/*! For license information please see createSimplePolylineGeometry.js.LICENSE.txt */
import{a as r}from"./chunk-LL4PRXXO.js";import{a as S}from"./chunk-3FGVTQZT.js";import{a as E}from"./chunk-T52RL3ZJ.js";import"./chunk-O7LU3SZT.js";import"./chunk-Q6IZOLLM.js";import"./chunk-WZ52TQTL.js";import"./chunk-5KPQNVA2.js";import{a as X}from"./chunk-DBOVA5XH.js";import{a as W}from"./chunk-RHEGXTJ5.js";import{b as K,c as Q,d as Y}from"./chunk-CWBIOT2C.js";import{d as j}from"./chunk-PPN6SLYU.js";import"./chunk-SOWUYSYI.js";import{a as H}from"./chunk-I36V6CKP.js";import{a as k,d as b}from"./chunk-WG62ICZK.js";import{a as q}from"./chunk-EEN7GMYN.js";import"./chunk-SXYTVHGU.js";import"./chunk-RAWIUDJR.js";import{a as w}from"./chunk-KGKDCW56.js";import{a as L}from"./chunk-G4IO3CPJ.js";import{e as u}from"./chunk-GBRF7ES3.js";function Z(e,t,o,a,n,i,l){let s,u=E.numberOfPoints(e,t,n),p=o.red,c=o.green,h=o.blue,f=o.alpha,y=a.red,m=a.green,k=a.blue,d=a.alpha;if(r.equals(o,a)){for(s=0;s<u;s++)i[l++]=r.floatToByte(p),i[l++]=r.floatToByte(c),i[l++]=r.floatToByte(h),i[l++]=r.floatToByte(f);return l}let g=(y-p)/u,T=(m-c)/u,w=(k-h)/u,_=(d-f)/u,B=l;for(s=0;s<u;s++)i[B++]=r.floatToByte(p+s*g),i[B++]=r.floatToByte(c+s*T),i[B++]=r.floatToByte(h+s*w),i[B++]=r.floatToByte(f+s*_);return B}function R(e){let t=(e=w(e,w.EMPTY_OBJECT)).positions,o=e.colors,a=w(e.colorsPerVertex,!1);if(!u(t)||t.length<2)throw new L("At least two positions are required.");if(u(o)&&(a&&o.length<t.length||!a&&o.length<t.length-1))throw new L("colors has an invalid length.");this._positions=t,this._colors=o,this._colorsPerVertex=a,this._arcType=w(e.arcType,S.GEODESIC),this._granularity=w(e.granularity,q.RADIANS_PER_DEGREE),this._ellipsoid=w(e.ellipsoid,b.default),this._workerName="createSimplePolylineGeometry";let n=1+t.length*k.packedLength;n+=u(o)?1+o.length*r.packedLength:1,this.packedLength=n+b.packedLength+3}R.pack=function(e,t,o){if(!u(e))throw new L("value is required");if(!u(t))throw new L("array is required");o=w(o,0);let a,n=e._positions,i=n.length;for(t[o++]=i,a=0;a<i;++a,o+=k.packedLength)k.pack(n[a],t,o);let l=e._colors;for(i=u(l)?l.length:0,t[o++]=i,a=0;a<i;++a,o+=r.packedLength)r.pack(l[a],t,o);return b.pack(e._ellipsoid,t,o),o+=b.packedLength,t[o++]=e._colorsPerVertex?1:0,t[o++]=e._arcType,t[o]=e._granularity,t},R.unpack=function(e,t,o){if(!u(e))throw new L("array is required");t=w(t,0);let a,n=e[t++],i=new Array(n);for(a=0;a<n;++a,t+=k.packedLength)i[a]=k.unpack(e,t);n=e[t++];let l=n>0?new Array(n):void 0;for(a=0;a<n;++a,t+=r.packedLength)l[a]=r.unpack(e,t);let s=b.unpack(e,t);t+=b.packedLength;let p=1===e[t++],c=e[t++],h=e[t];return u(o)?(o._positions=i,o._colors=l,o._ellipsoid=s,o._colorsPerVertex=p,o._arcType=c,o._granularity=h,o):new R({positions:i,colors:l,ellipsoid:s,colorsPerVertex:p,arcType:c,granularity:h})};var F=new Array(2),N=new Array(2),$={positions:F,height:N,ellipsoid:void 0,minDistance:void 0,granularity:void 0};R.createGeometry=function(e){let t,o,a,n,i,l=e._positions,s=e._colors,p=e._colorsPerVertex,c=e._arcType,h=e._granularity,f=e._ellipsoid,y=q.chordLength(h,f.maximumRadius),m=u(s)&&!p,d=l.length,g=0;if(c===S.GEODESIC||c===S.RHUMB){let e,a,p;c===S.GEODESIC?(e=q.chordLength(h,f.maximumRadius),a=E.numberOfPoints,p=E.generateArc):(e=h,a=E.numberOfPointsRhumbLine,p=E.generateRhumbArc);let k=E.extractHeights(l,f),T=$;if(c===S.GEODESIC?T.minDistance=y:T.granularity=h,T.ellipsoid=f,m){let c=0;for(t=0;t<d-1;t++)c+=a(l[t],l[t+1],e)+1;o=new Float64Array(3*c),n=new Uint8Array(4*c),T.positions=F,T.height=N;let h=0;for(t=0;t<d-1;++t){F[0]=l[t],F[1]=l[t+1],N[0]=k[t],N[1]=k[t+1];let e=p(T);if(u(s)){let o=e.length/3;i=s[t];for(let e=0;e<o;++e)n[h++]=r.floatToByte(i.red),n[h++]=r.floatToByte(i.green),n[h++]=r.floatToByte(i.blue),n[h++]=r.floatToByte(i.alpha)}o.set(e,g),g+=e.length}}else if(T.positions=l,T.height=k,o=new Float64Array(p(T)),u(s)){for(n=new Uint8Array(o.length/3*4),t=0;t<d-1;++t){g=Z(l[t],l[t+1],s[t],s[t+1],y,n,g)}let e=s[d-1];n[g++]=r.floatToByte(e.red),n[g++]=r.floatToByte(e.green),n[g++]=r.floatToByte(e.blue),n[g++]=r.floatToByte(e.alpha)}}else{a=m?2*d-2:d,o=new Float64Array(3*a),n=u(s)?new Uint8Array(4*a):void 0;let e=0,p=0;for(t=0;t<d;++t){let a=l[t];if(m&&t>0&&(k.pack(a,o,e),e+=3,i=s[t-1],n[p++]=r.floatToByte(i.red),n[p++]=r.floatToByte(i.green),n[p++]=r.floatToByte(i.blue),n[p++]=r.floatToByte(i.alpha)),m&&t===d-1)break;k.pack(a,o,e),e+=3,u(s)&&(i=s[t],n[p++]=r.floatToByte(i.red),n[p++]=r.floatToByte(i.green),n[p++]=r.floatToByte(i.blue),n[p++]=r.floatToByte(i.alpha))}}let T=new W;T.position=new Y({componentDatatype:H.DOUBLE,componentsPerAttribute:3,values:o}),u(s)&&(T.color=new Y({componentDatatype:H.UNSIGNED_BYTE,componentsPerAttribute:4,values:n,normalize:!0})),a=o.length/3;let w=2*(a-1),_=X.createTypedArray(a,w),B=0;for(t=0;t<a-1;++t)_[B++]=t,_[B++]=t+1;return new Q({attributes:T,indices:_,primitiveType:K.LINES,boundingSphere:j.fromPoints(l)})};var J=R;function x(e,r){return u(r)&&(e=J.unpack(e,r)),e._ellipsoid=b.clone(e._ellipsoid),J.createGeometry(e)}var _e=x;export{_e as default};