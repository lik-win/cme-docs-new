/*! For license information please see chunk-T52RL3ZJ.js.LICENSE.txt */
import{a as _}from"./chunk-O7LU3SZT.js";import{a as M}from"./chunk-Q6IZOLLM.js";import{b as G}from"./chunk-WZ52TQTL.js";import{a as b}from"./chunk-5KPQNVA2.js";import{b as R}from"./chunk-SOWUYSYI.js";import{a,b as L,d as z}from"./chunk-WG62ICZK.js";import{a as E}from"./chunk-EEN7GMYN.js";import{a as C}from"./chunk-KGKDCW56.js";import{a as I}from"./chunk-G4IO3CPJ.js";import{e as T}from"./chunk-GBRF7ES3.js";var p={numberOfPoints:function(e,t,r){let n=a.distance(e,t);return Math.ceil(n/r)},numberOfPointsRhumbLine:function(e,t,a){let r=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(r/(a*a))))}},V=new L;p.extractHeights=function(e,t){let a=e.length,r=new Array(a);for(let n=0;n<a;n++){let a=e[n];r[n]=t.cartesianToCartographic(a,V).height}return r};var Y=new R,F=new a,v=new a,j=new b(a.UNIT_X,0),H=new a,J=new b(a.UNIT_X,0),K=new a,Q=new a,k=[];function q(e,t,a){let r,n=k;if(n.length=e,t===a){for(r=0;r<e;r++)n[r]=t;return n}let i=(a-t)/e;for(r=0;r<e;r++){let e=t+r*i;n[r]=e}return n}var x=new L,N=new L,D=new a,B=new a,W=new a,O=new _,S=new M;function $(e,t,r,n,i,o,l,c){let s=n.scaleToGeodeticSurface(e,B),u=n.scaleToGeodeticSurface(t,W),h=p.numberOfPoints(e,t,r),f=n.cartesianToCartographic(s,x),g=n.cartesianToCartographic(u,N),m=q(h,i,o);O.setEndPoints(f,g);let T=O.surfaceDistance/h,d=c;f.height=i;let w=n.cartographicToCartesian(f,D);a.pack(w,l,d),d+=3;for(let e=1;e<h;e++){let t=O.interpolateUsingSurfaceDistance(e*T,N);t.height=m[e],w=n.cartographicToCartesian(t,D),a.pack(w,l,d),d+=3}return d}function tt(e,t,r,n,i,o,l,c){let s=n.cartesianToCartographic(e,x),u=n.cartesianToCartographic(t,N),h=p.numberOfPointsRhumbLine(s,u,r);s.height=0,u.height=0;let f=q(h,i,o);S.ellipsoid.equals(n)||(S=new M(void 0,void 0,n)),S.setEndPoints(s,u);let g=S.surfaceDistance/h,m=c;s.height=i;let T=n.cartographicToCartesian(s,D);a.pack(T,l,m),m+=3;for(let e=1;e<h;e++){let t=S.interpolateUsingSurfaceDistance(e*g,N);t.height=f[e],T=n.cartographicToCartesian(t,D),a.pack(T,l,m),m+=3}return m}p.wrapLongitude=function(e,t){let r=[],n=[];if(T(e)&&e.length>0){t=C(t,R.IDENTITY);let i=R.inverseTransformation(t,Y),o=R.multiplyByPoint(i,a.ZERO,F),l=a.normalize(R.multiplyByPointAsVector(i,a.UNIT_Y,v),v),c=b.fromPointNormal(o,l,j),s=a.normalize(R.multiplyByPointAsVector(i,a.UNIT_X,H),H),u=b.fromPointNormal(o,s,J),h=1;r.push(a.clone(e[0]));let p=r[0],f=e.length;for(let t=1;t<f;++t){let i=e[t];if(b.getPointDistance(u,p)<0||b.getPointDistance(u,i)<0){let e=G.lineSegmentPlane(p,i,c,K);if(T(e)){let t=a.multiplyByScalar(l,5e-9,Q);b.getPointDistance(c,p)<0&&a.negate(t,t),r.push(a.add(e,t,new a)),n.push(h+1),a.negate(t,t),r.push(a.add(e,t,new a)),h=1}}r.push(a.clone(e[t])),h++,p=i}n.push(h)}return{positions:r,lengths:n}},p.generateArc=function(e){T(e)||(e={});let t=e.positions;if(!T(t))throw new I("options.positions is required.");let r=t.length,n=C(e.ellipsoid,z.default),i=C(e.height,0),o=Array.isArray(i);if(r<1)return[];if(1===r){let e=n.scaleToGeodeticSurface(t[0],B);if(i=o?i[0]:i,0!==i){let t=n.geodeticSurfaceNormal(e,D);a.multiplyByScalar(t,i,t),a.add(e,t,e)}return[e.x,e.y,e.z]}let l=e.minDistance;if(!T(l)){let t=C(e.granularity,E.RADIANS_PER_DEGREE);l=E.chordLength(t,n.maximumRadius)}let c,s=0;for(c=0;c<r-1;c++)s+=p.numberOfPoints(t[c],t[c+1],l);let u=3*(s+1),h=new Array(u),f=0;for(c=0;c<r-1;c++){f=$(t[c],t[c+1],l,n,o?i[c]:i,o?i[c+1]:i,h,f)}k.length=0;let g=t[r-1],m=n.cartesianToCartographic(g,x);m.height=o?i[r-1]:i;let d=n.cartographicToCartesian(m,D);return a.pack(d,h,u-3),h};var U=new L,et=new L;p.generateRhumbArc=function(e){T(e)||(e={});let t=e.positions;if(!T(t))throw new I("options.positions is required.");let r=t.length,n=C(e.ellipsoid,z.default),i=C(e.height,0),o=Array.isArray(i);if(r<1)return[];if(1===r){let e=n.scaleToGeodeticSurface(t[0],B);if(i=o?i[0]:i,0!==i){let t=n.geodeticSurfaceNormal(e,D);a.multiplyByScalar(t,i,t),a.add(e,t,e)}return[e.x,e.y,e.z]}let l,c,s=C(e.granularity,E.RADIANS_PER_DEGREE),u=0,h=n.cartesianToCartographic(t[0],U);for(l=0;l<r-1;l++)c=n.cartesianToCartographic(t[l+1],et),u+=p.numberOfPointsRhumbLine(h,c,s),h=L.clone(c,U);let f=3*(u+1),g=new Array(f),m=0;for(l=0;l<r-1;l++){m=tt(t[l],t[l+1],s,n,o?i[l]:i,o?i[l+1]:i,g,m)}k.length=0;let d=t[r-1],w=n.cartesianToCartographic(d,x);w.height=o?i[r-1]:i;let y=n.cartographicToCartesian(w,D);return a.pack(y,g,f-3),g},p.generateCartesianArc=function(e){let t=p.generateArc(e),r=t.length/3,n=new Array(r);for(let e=0;e<r;e++)n[e]=a.unpack(t,3*e);return n},p.generateCartesianRhumbArc=function(e){let t=p.generateRhumbArc(e),r=t.length/3,n=new Array(r);for(let e=0;e<r;e++)n[e]=a.unpack(t,3*e);return n};var mt=p;export{mt as a};