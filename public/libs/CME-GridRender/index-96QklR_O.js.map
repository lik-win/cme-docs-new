{"version":3,"file":"index-96QklR_O.js","sources":["../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Disposable.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/events/Event.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/array.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/functions.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/obj.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/events/Target.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/events/EventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/TileState.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/util.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/easing.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Tile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/has.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/dom.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/DataTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/common.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/extent/Relationship.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/extent.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/Units.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/Projection.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/epsg3857.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/epsg4326.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/projections.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/transforms.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/math.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/coordinate.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/sphere.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/console.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/Triangulation.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/events.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/DataTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/asserts.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/structs/LRUCache.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/tilecoord.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/TileCache.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/TileEventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ObjectEventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Observable.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Object.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/Source.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/TileRange.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/tilegrid/common.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/segments.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/contains.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/intersectsextent.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/size.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/tilegrid/TileGrid.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/tilegrid.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/Tile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/DataTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/@petamoriken/float16/src/_util/primordials.mjs","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/@petamoriken/float16/src/_util/converter.mjs","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/@petamoriken/float16/src/DataView.mjs","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/get-attribute.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/index-of-match.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/index-of-match-end.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/count-substring.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/find-tag-by-name.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/find-tags-by-name.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/globals.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/rgb.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/compression/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/resample.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/geotiffimage.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/dataview64.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/dataslice.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/pool.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/httputils.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/basesource.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/quick-lru/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/utils.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/blockedsource.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/client/base.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/client/fetch.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/client/xhr.js","../../__vite-browser-external","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/client/http.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/remote.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/filereader.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/geotiff.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/GeoTIFF.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/Property.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/Base.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/render/EventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ViewHint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ViewProperty.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/centerconstraint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/resolutionconstraint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/rotationconstraint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/transform.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/transform.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/Geometry.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/SimpleGeometry.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/closest.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/deflate.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/simplify.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/inflate.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/area.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/LinearRing.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/Point.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/interiorpoint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/reverse.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/orient.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/Polygon.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/View.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/Layer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/TileProperty.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/BaseTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/Tile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ImageState.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Image.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ImageTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/BaseTileRepresentation.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/Buffer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/TileTexture.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/Layer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/render/Event.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/ContextEventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/PostProcessingPass.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/vec/mat4.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/Helper.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/webgl/Layer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/webgl/TileLayerBase.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/webgl/TileLayer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/rgb.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/xyz.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/luv.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/lchuv.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-name/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-parse/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/hsl.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-rgba/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/color.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/expr/expression.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/PaletteTexture.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/expr/gpu.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/styleparser.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/WebGLTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/common/commonLayerUnit.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/source/GeoTIFF.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/cme_cogtifLayer/cme_cogtifLayer2.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/render/canvas/ZIndexContext.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/canvas/Layer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/resolution.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/Image.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/common.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/Image.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ImageCanvas.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/ImageCanvas.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/BaseImage.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/canvas/ImageLayer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/Image.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/cme_gridArrowLayer/gridHelper.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/cme_gridValueLayer/gridNumberSource.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/cme_gridValueLayer/cme_gridValueLayer.js","../../src/components/cme-application/GridRender/index.vue","../../src/components/cme-application/GridRender/index.js"],"sourcesContent":["/**\r\n * @module CME2D/Disposable\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Objects that need to clean up after themselves.\r\n */\r\nclass Disposable {\r\n  constructor() {\r\n    /**\r\n     * The object has already been disposed.\r\n     * @type {boolean}\r\n     * @protected\r\n     */\r\n    this.disposed = false;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   */\r\n  dispose() {\r\n    if (!this.disposed) {\r\n      this.disposed = true;\r\n      this.disposeInternal();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extension point for disposable objects.\r\n   * @protected\r\n   */\r\n  disposeInternal() {}\r\n}\r\n\r\nexport default Disposable;\r\n","/**\r\n * @module CME2D/events/Event\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Stripped down implementation of the W3C DOM Level 2 Event interface.\r\n * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.\r\n *\r\n * This implementation only provides `type` and `target` properties, and\r\n * `stopPropagation` and `preventDefault` methods. It is meant as base class\r\n * for higher level events defined in the library, and works with\r\n * {@link module:ol/events/Target~Target}.\r\n */\r\nclass BaseEvent {\r\n  /**\r\n   * @param {string} type Type.\r\n   */\r\n  constructor(type) {\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.propagationStopped;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.defaultPrevented;\r\n\r\n    /**\r\n     * The event type.\r\n     * @type {string}\r\n     * @api\r\n     */\r\n    this.type = type;\r\n\r\n    /**\r\n     * The event target.\r\n     * @type {Object}\r\n     * @api\r\n     */\r\n    this.target = null;\r\n  }\r\n\r\n  /**\r\n   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events\r\n   * will be fired.\r\n   * @api\r\n   */\r\n  preventDefault() {\r\n    this.defaultPrevented = true;\r\n  }\r\n\r\n  /**\r\n   * Stop event propagation.\r\n   * @api\r\n   */\r\n  stopPropagation() {\r\n    this.propagationStopped = true;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Event|import(\"./Event.js\").default} evt Event\r\n */\r\nexport function stopPropagation(evt) {\r\n  evt.stopPropagation();\r\n}\r\n\r\n/**\r\n * @param {Event|import(\"./Event.js\").default} evt Event\r\n */\r\nexport function preventDefault(evt) {\r\n  evt.preventDefault();\r\n}\r\n\r\nexport default BaseEvent;\r\n","/**\r\n * @module CME2D/array\r\n */\r\n\r\n/**\r\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\r\n * https://github.com/darkskyapp/binary-search\r\n *\r\n * @param {Array<*>} haystack Items to search through.\r\n * @param {*} needle The item to look for.\r\n * @param {Function} [comparator] Comparator function.\r\n * @return {number} The index of the item if found, -1 if not.\r\n */\r\nexport function binarySearch(haystack, needle, comparator) {\r\n  let mid, cmp;\r\n  comparator = comparator || ascending;\r\n  let low = 0;\r\n  let high = haystack.length;\r\n  let found = false;\r\n\r\n  while (low < high) {\r\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\r\n     * to double (which gives the wrong results). */\r\n    mid = low + ((high - low) >> 1);\r\n    cmp = +comparator(haystack[mid], needle);\r\n\r\n    if (cmp < 0.0) {\r\n      /* Too low. */\r\n      low = mid + 1;\r\n    } else {\r\n      /* Key found or too high */\r\n      high = mid;\r\n      found = !cmp;\r\n    }\r\n  }\r\n\r\n  /* Key not found. */\r\n  return found ? low : ~low;\r\n}\r\n\r\n/**\r\n * Compare function sorting arrays in ascending order.  Safe to use for numeric values.\r\n * @param {*} a The first object to be compared.\r\n * @param {*} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is less than, equal to, or greater than the second.\r\n */\r\nexport function ascending(a, b) {\r\n  return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n\r\n/**\r\n * Compare function sorting arrays in descending order.  Safe to use for numeric values.\r\n * @param {*} a The first object to be compared.\r\n * @param {*} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is greater than, equal to, or less than the second.\r\n */\r\nexport function descending(a, b) {\r\n  return a < b ? 1 : a > b ? -1 : 0;\r\n}\r\n\r\n/**\r\n * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function\r\n * of this type to determine which nearest resolution to use.\r\n *\r\n * This function takes a `{number}` representing a value between two array entries,\r\n * a `{number}` representing the value of the nearest higher entry and\r\n * a `{number}` representing the value of the nearest lower entry\r\n * as arguments and returns a `{number}`. If a negative number or zero is returned\r\n * the lower value will be used, if a positive number is returned the higher value\r\n * will be used.\r\n * @typedef {function(number, number, number): number} NearestDirectionFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @param {Array<number>} arr Array in descending order.\r\n * @param {number} target Target.\r\n * @param {number|NearestDirectionFunction} direction\r\n *    0 means return the nearest,\r\n *    > 0 means return the largest nearest,\r\n *    < 0 means return the smallest nearest.\r\n * @return {number} Index.\r\n */\r\nexport function linearFindNearest(arr, target, direction) {\r\n  if (arr[0] <= target) {\r\n    return 0;\r\n  }\r\n\r\n  const n = arr.length;\r\n  if (target <= arr[n - 1]) {\r\n    return n - 1;\r\n  }\r\n\r\n  if (typeof direction === 'function') {\r\n    for (let i = 1; i < n; ++i) {\r\n      const candidate = arr[i];\r\n      if (candidate === target) {\r\n        return i;\r\n      }\r\n      if (candidate < target) {\r\n        if (direction(target, arr[i - 1], candidate) > 0) {\r\n          return i - 1;\r\n        }\r\n        return i;\r\n      }\r\n    }\r\n    return n - 1;\r\n  }\r\n\r\n  if (direction > 0) {\r\n    for (let i = 1; i < n; ++i) {\r\n      if (arr[i] < target) {\r\n        return i - 1;\r\n      }\r\n    }\r\n    return n - 1;\r\n  }\r\n\r\n  if (direction < 0) {\r\n    for (let i = 1; i < n; ++i) {\r\n      if (arr[i] <= target) {\r\n        return i;\r\n      }\r\n    }\r\n    return n - 1;\r\n  }\r\n\r\n  for (let i = 1; i < n; ++i) {\r\n    if (arr[i] == target) {\r\n      return i;\r\n    }\r\n    if (arr[i] < target) {\r\n      if (arr[i - 1] - target < target - arr[i]) {\r\n        return i - 1;\r\n      }\r\n      return i;\r\n    }\r\n  }\r\n  return n - 1;\r\n}\r\n\r\n/**\r\n * @param {Array<*>} arr Array.\r\n * @param {number} begin Begin index.\r\n * @param {number} end End index.\r\n */\r\nexport function reverseSubArray(arr, begin, end) {\r\n  while (begin < end) {\r\n    const tmp = arr[begin];\r\n    arr[begin] = arr[end];\r\n    arr[end] = tmp;\r\n    ++begin;\r\n    --end;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<VALUE>} arr The array to modify.\r\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\r\n * @template VALUE\r\n */\r\nexport function extend(arr, data) {\r\n  const extension = Array.isArray(data) ? data : [data];\r\n  const length = extension.length;\r\n  for (let i = 0; i < length; i++) {\r\n    arr[arr.length] = extension[i];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<VALUE>} arr The array to modify.\r\n * @param {VALUE} obj The element to remove.\r\n * @template VALUE\r\n * @return {boolean} If the element was removed.\r\n */\r\nexport function remove(arr, obj) {\r\n  const i = arr.indexOf(obj);\r\n  const found = i > -1;\r\n  if (found) {\r\n    arr.splice(i, 1);\r\n  }\r\n  return found;\r\n}\r\n\r\n/**\r\n * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.\r\n * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.\r\n * @return {boolean} Whether the two arrays are equal.\r\n */\r\nexport function equals(arr1, arr2) {\r\n  const len1 = arr1.length;\r\n  if (len1 !== arr2.length) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < len1; i++) {\r\n    if (arr1[i] !== arr2[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Sort the passed array such that the relative order of equal elements is preserved.\r\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\r\n * @param {Array<*>} arr The array to sort (modifies original).\r\n * @param {!function(*, *): number} compareFnc Comparison function.\r\n * @api\r\n */\r\nexport function stableSort(arr, compareFnc) {\r\n  const length = arr.length;\r\n  const tmp = Array(arr.length);\r\n  let i;\r\n  for (i = 0; i < length; i++) {\r\n    tmp[i] = {index: i, value: arr[i]};\r\n  }\r\n  tmp.sort(function (a, b) {\r\n    return compareFnc(a.value, b.value) || a.index - b.index;\r\n  });\r\n  for (i = 0; i < arr.length; i++) {\r\n    arr[i] = tmp[i].value;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<*>} arr The array to test.\r\n * @param {Function} [func] Comparison function.\r\n * @param {boolean} [strict] Strictly sorted (default false).\r\n * @return {boolean} Return index.\r\n */\r\nexport function isSorted(arr, func, strict) {\r\n  const compare = func || ascending;\r\n  return arr.every(function (currentVal, index) {\r\n    if (index === 0) {\r\n      return true;\r\n    }\r\n    const res = compare(arr[index - 1], currentVal);\r\n    return !(res > 0 || (strict && res === 0));\r\n  });\r\n}\r\n","/**\r\n * @module CME2D/functions\r\n */\r\n\r\nimport {equals as arrayEquals} from './array.js';\r\n\r\n/**\r\n * Always returns true.\r\n * @return {boolean} true.\r\n */\r\nexport function TRUE() {\r\n  return true;\r\n}\r\n\r\n/**\r\n * Always returns false.\r\n * @return {boolean} false.\r\n */\r\nexport function FALSE() {\r\n  return false;\r\n}\r\n\r\n/**\r\n * A reusable function, used e.g. as a default for callbacks.\r\n *\r\n * @return {void} Nothing.\r\n */\r\nexport function VOID() {}\r\n\r\n/**\r\n * Wrap a function in another function that remembers the last return.  If the\r\n * returned function is called twice in a row with the same arguments and the same\r\n * this object, it will return the value from the first call in the second call.\r\n *\r\n * @param {function(...any): ReturnType} fn The function to memoize.\r\n * @return {function(...any): ReturnType} The memoized function.\r\n * @template ReturnType\r\n */\r\nexport function memoizeOne(fn) {\r\n  /** @type {ReturnType} */\r\n  let lastResult;\r\n\r\n  /** @type {Array<any>|undefined} */\r\n  let lastArgs;\r\n\r\n  let lastThis;\r\n\r\n  /**\r\n   * @this {*} Only need to know if `this` changed, don't care what type\r\n   * @return {ReturnType} Memoized value\r\n   */\r\n  return function () {\r\n    const nextArgs = Array.prototype.slice.call(arguments);\r\n    if (!lastArgs || this !== lastThis || !arrayEquals(nextArgs, lastArgs)) {\r\n      lastThis = this;\r\n      lastArgs = nextArgs;\r\n      lastResult = fn.apply(this, arguments);\r\n    }\r\n    return lastResult;\r\n  };\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.\r\n * @return {Promise<T>} A promise for the value.\r\n */\r\nexport function toPromise(getter) {\r\n  function promiseGetter() {\r\n    let value;\r\n    try {\r\n      value = getter();\r\n    } catch (err) {\r\n      return Promise.reject(err);\r\n    }\r\n    if (value instanceof Promise) {\r\n      return value;\r\n    }\r\n    return Promise.resolve(value);\r\n  }\r\n  return promiseGetter();\r\n}\r\n","/**\r\n * @module CME2D/obj\r\n */\r\n\r\n/**\r\n * Removes all properties from an object.\r\n * @param {Object<string, unknown>} object The object to clear.\r\n */\r\nexport function clear(object) {\r\n  for (const property in object) {\r\n    delete object[property];\r\n  }\r\n}\r\n\r\n/**\r\n * Determine if an object has any properties.\r\n * @param {Object} object The object to check.\r\n * @return {boolean} The object is empty.\r\n */\r\nexport function isEmpty(object) {\r\n  let property;\r\n  for (property in object) {\r\n    return false;\r\n  }\r\n  return !property;\r\n}\r\n","/**\r\n * @module CME2D/events/Target\r\n */\r\nimport Disposable from '../Disposable.js';\r\nimport Event from './Event.js';\r\nimport {VOID} from '../functions.js';\r\nimport {clear} from '../obj.js';\r\n\r\n/**\r\n * @typedef {EventTarget|Target} EventTargetLike\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\r\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\r\n *\r\n * There are two important simplifications compared to the specification:\r\n *\r\n * 1. The handling of `useCapture` in `addEventListener` and\r\n *    `removeEventListener`. There is no real capture model.\r\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\r\n *    There is no event target hierarchy. When a listener calls\r\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\r\n *    more listeners after this one will be called. Same as when the listener\r\n *    returns false.\r\n */\r\nclass Target extends Disposable {\r\n  /**\r\n   * @param {*} [target] Default event target for dispatched events.\r\n   */\r\n  constructor(target) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {*}\r\n     */\r\n    this.eventTarget_ = target;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, number>|null}\r\n     */\r\n    this.pendingRemovals_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, number>|null}\r\n     */\r\n    this.dispatching_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>|null}\r\n     */\r\n    this.listeners_ = null;\r\n  }\r\n\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../events.js\").Listener} listener Listener.\r\n   */\r\n  addEventListener(type, listener) {\r\n    if (!type || !listener) {\r\n      return;\r\n    }\r\n    const listeners = this.listeners_ || (this.listeners_ = {});\r\n    const listenersForType = listeners[type] || (listeners[type] = []);\r\n    if (!listenersForType.includes(listener)) {\r\n      listenersForType.push(listener);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispatches an event and calls all listeners listening for events\r\n   * of this type. The event parameter can either be a string or an\r\n   * Object with a `type` property.\r\n   *\r\n   * @param {import(\"./Event.js\").default|string} event Event object.\r\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\r\n   *     event object or if any of the listeners returned false.\r\n   * @api\r\n   */\r\n  dispatchEvent(event) {\r\n    const isString = typeof event === 'string';\r\n    const type = isString ? event : event.type;\r\n    const listeners = this.listeners_ && this.listeners_[type];\r\n    if (!listeners) {\r\n      return;\r\n    }\r\n\r\n    const evt = isString ? new Event(event) : /** @type {Event} */ (event);\r\n    if (!evt.target) {\r\n      evt.target = this.eventTarget_ || this;\r\n    }\r\n    const dispatching = this.dispatching_ || (this.dispatching_ = {});\r\n    const pendingRemovals =\r\n      this.pendingRemovals_ || (this.pendingRemovals_ = {});\r\n    if (!(type in dispatching)) {\r\n      dispatching[type] = 0;\r\n      pendingRemovals[type] = 0;\r\n    }\r\n    ++dispatching[type];\r\n    let propagate;\r\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\r\n      if ('handleEvent' in listeners[i]) {\r\n        propagate = /** @type {import(\"../events.js\").ListenerObject} */ (\r\n          listeners[i]\r\n        ).handleEvent(evt);\r\n      } else {\r\n        propagate = /** @type {import(\"../events.js\").ListenerFunction} */ (\r\n          listeners[i]\r\n        ).call(this, evt);\r\n      }\r\n      if (propagate === false || evt.propagationStopped) {\r\n        propagate = false;\r\n        break;\r\n      }\r\n    }\r\n    if (--dispatching[type] === 0) {\r\n      let pr = pendingRemovals[type];\r\n      delete pendingRemovals[type];\r\n      while (pr--) {\r\n        this.removeEventListener(type, VOID);\r\n      }\r\n      delete dispatching[type];\r\n    }\r\n    return propagate;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    this.listeners_ && clear(this.listeners_);\r\n  }\r\n\r\n  /**\r\n   * Get the listeners for a specified event type. Listeners are returned in the\r\n   * order that they will be called in.\r\n   *\r\n   * @param {string} type Type.\r\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\r\n   */\r\n  getListeners(type) {\r\n    return (this.listeners_ && this.listeners_[type]) || undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {string} [type] Type. If not provided,\r\n   *     `true` will be returned if this event target has any listeners.\r\n   * @return {boolean} Has listeners.\r\n   */\r\n  hasListener(type) {\r\n    if (!this.listeners_) {\r\n      return false;\r\n    }\r\n    return type\r\n      ? type in this.listeners_\r\n      : Object.keys(this.listeners_).length > 0;\r\n  }\r\n\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../events.js\").Listener} listener Listener.\r\n   */\r\n  removeEventListener(type, listener) {\r\n    if (!this.listeners_) {\r\n      return;\r\n    }\r\n    const listeners = this.listeners_[type];\r\n    if (!listeners) {\r\n      return;\r\n    }\r\n    const index = listeners.indexOf(listener);\r\n    if (index !== -1) {\r\n      if (this.pendingRemovals_ && type in this.pendingRemovals_) {\r\n        // make listener a no-op, and remove later in #dispatchEvent()\r\n        listeners[index] = VOID;\r\n        ++this.pendingRemovals_[type];\r\n      } else {\r\n        listeners.splice(index, 1);\r\n        if (listeners.length === 0) {\r\n          delete this.listeners_[type];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Target;\r\n","/**\r\n * @module CME2D/events/EventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n * @const\r\n */\r\nexport default {\r\n  /**\r\n   * Generic change event. Triggered when the revision counter is increased.\r\n   * @event module:ol/events/Event~BaseEvent#change\r\n   * @api\r\n   */\r\n  CHANGE: 'change',\r\n\r\n  /**\r\n   * Generic error event. Triggered when an error occurs.\r\n   * @event module:ol/events/Event~BaseEvent#error\r\n   * @api\r\n   */\r\n  ERROR: 'error',\r\n\r\n  BLUR: 'blur',\r\n  CLEAR: 'clear',\r\n  CONTEXTMENU: 'contextmenu',\r\n  CLICK: 'click',\r\n  DBLCLICK: 'dblclick',\r\n  DRAGENTER: 'dragenter',\r\n  DRAGOVER: 'dragover',\r\n  DROP: 'drop',\r\n  FOCUS: 'focus',\r\n  KEYDOWN: 'keydown',\r\n  KEYPRESS: 'keypress',\r\n  LOAD: 'load',\r\n  RESIZE: 'resize',\r\n  TOUCHMOVE: 'touchmove',\r\n  WHEEL: 'wheel',\r\n};\r\n","/**\r\n * @module CME2D/TileState\r\n */\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nexport default {\r\n  IDLE: 0,\r\n  LOADING: 1,\r\n  LOADED: 2,\r\n  /**\r\n   * Indicates that tile loading failed\r\n   * @type {number}\r\n   */\r\n  ERROR: 3,\r\n  EMPTY: 4,\r\n};\r\n","/**\r\n * @module CME2D/util\r\n */\r\n\r\n/**\r\n * @return {never} Any return.\r\n */\r\nexport function abstract() {\r\n  throw new Error('Unimplemented abstract method.');\r\n}\r\n\r\n/**\r\n * Counter for getUid.\r\n * @type {number}\r\n * @private\r\n */\r\nlet uidCounter_ = 0;\r\n\r\n/**\r\n * Gets a unique ID for an object. This mutates the object so that further calls\r\n * with the same object as a parameter returns the same value. Unique IDs are generated\r\n * as a strictly increasing sequence. Adapted from goog.getUid.\r\n *\r\n * @param {Object} obj The object to get the unique ID for.\r\n * @return {string} The unique ID for the object.\r\n * @api\r\n */\r\nexport function getUid(obj) {\r\n  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\r\n}\r\n\r\n/**\r\n * OpenLayers version.\r\n * @type {string}\r\n */\r\nexport const VERSION = 'latest';\r\n","/**\r\n * @module CME2D/easing\r\n */\r\n\r\n/**\r\n * Start slow and speed up.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function easeIn(t) {\r\n  return Math.pow(t, 3);\r\n}\r\n\r\n/**\r\n * Start fast and slow down.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function easeOut(t) {\r\n  return 1 - easeIn(1 - t);\r\n}\r\n\r\n/**\r\n * Start slow, speed up, and then slow down again.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function inAndOut(t) {\r\n  return 3 * t * t - 2 * t * t * t;\r\n}\r\n\r\n/**\r\n * Maintain a constant speed over time.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function linear(t) {\r\n  return t;\r\n}\r\n\r\n/**\r\n * Start slow, speed up, and at the very end slow down again.  This has the\r\n * same general behavior as {@link module:ol/easing.inAndOut}, but the final\r\n * slowdown is delayed.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function upAndDown(t) {\r\n  if (t < 0.5) {\r\n    return inAndOut(2 * t);\r\n  }\r\n  return 1 - inAndOut(2 * (t - 0.5));\r\n}\r\n","/**\r\n * @module CME2D/Tile\r\n */\r\nimport EventTarget from './events/Target.js';\r\nimport EventType from './events/EventType.js';\r\nimport TileState from './TileState.js';\r\nimport {abstract} from './util.js';\r\nimport {easeIn} from './easing.js';\r\n\r\n/**\r\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\r\n * `{string}` for the url as arguments. The default is\r\n * ```js\r\n * source.setTileLoadFunction(function(tile, src) {\r\n *   tile.getImage().src = src;\r\n * });\r\n * ```\r\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\r\n * error handling:\r\n *\r\n * ```js\r\n * import TileState from 'ol/TileState.js';\r\n *\r\n * source.setTileLoadFunction(function(tile, src) {\r\n *   const xhr = new XMLHttpRequest();\r\n *   xhr.responseType = 'blob';\r\n *   xhr.addEventListener('loadend', function (evt) {\r\n *     const data = this.response;\r\n *     if (data !== undefined) {\r\n *       tile.getImage().src = URL.createObjectURL(data);\r\n *     } else {\r\n *       tile.setState(TileState.ERROR);\r\n *     }\r\n *   });\r\n *   xhr.addEventListener('error', function () {\r\n *     tile.setState(TileState.ERROR);\r\n *   });\r\n *   xhr.open('GET', src);\r\n *   xhr.send();\r\n * });\r\n * ```\r\n *\r\n * @typedef {function(Tile, string): void} LoadFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\r\n * the url that provides a tile for a given tile coordinate.\r\n *\r\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\r\n * coordinate, a `{number}` representing the pixel ratio and a\r\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\r\n * and returns a `{string}` representing the tile URL, or undefined if no tile\r\n * should be requested for the passed tile coordinate.\r\n *\r\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\r\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @api\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for tiles.\r\n *\r\n * @abstract\r\n */\r\nclass Tile extends EventTarget {\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {Options} [options] Tile options.\r\n   */\r\n  constructor(tileCoord, state, options) {\r\n    super();\r\n\r\n    options = options ? options : {};\r\n\r\n    /**\r\n     * @type {import(\"./tilecoord.js\").TileCoord}\r\n     */\r\n    this.tileCoord = tileCoord;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./TileState.js\").default}\r\n     */\r\n    this.state = state;\r\n\r\n    /**\r\n     * A key assigned to the tile. This is used in conjunction with a source key\r\n     * to determine if a cached version of this tile may be used by the renderer.\r\n     * @type {string}\r\n     */\r\n    this.key = '';\r\n\r\n    /**\r\n     * The duration for the opacity transition.\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.transition_ =\r\n      options.transition === undefined ? 250 : options.transition;\r\n\r\n    /**\r\n     * Lookup of start times for rendering transitions.  If the start time is\r\n     * equal to -1, the transition is complete.\r\n     * @private\r\n     * @type {Object<string, number>}\r\n     */\r\n    this.transitionStarts_ = {};\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.interpolate = !!options.interpolate;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  changed() {\r\n    this.dispatchEvent(EventType.CHANGE);\r\n  }\r\n\r\n  /**\r\n   * Called by the tile cache when the tile is removed from the cache due to expiry\r\n   */\r\n  release() {\r\n    if (this.state === TileState.ERROR) {\r\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\r\n      this.setState(TileState.EMPTY);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {string} Key.\r\n   */\r\n  getKey() {\r\n    return this.key + '/' + this.tileCoord;\r\n  }\r\n\r\n  /**\r\n   * Get the tile coordinate for this tile.\r\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoord() {\r\n    return this.tileCoord;\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./TileState.js\").default} State.\r\n   */\r\n  getState() {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\r\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\r\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\r\n   * the tile queue and will block other requests.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @api\r\n   */\r\n  setState(state) {\r\n    if (this.state !== TileState.ERROR && this.state > state) {\r\n      throw new Error('Tile load sequence violation');\r\n    }\r\n    this.state = state;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load the image or retry if loading previously failed.\r\n   * Loading is taken care of by the tile queue, and calling this method is\r\n   * only needed for preloading or for reloading in case of an error.\r\n   * @abstract\r\n   * @api\r\n   */\r\n  load() {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Get the alpha value for rendering.\r\n   * @param {string} id An id for the renderer.\r\n   * @param {number} time The render frame time.\r\n   * @return {number} A number between 0 and 1.\r\n   */\r\n  getAlpha(id, time) {\r\n    if (!this.transition_) {\r\n      return 1;\r\n    }\r\n\r\n    let start = this.transitionStarts_[id];\r\n    if (!start) {\r\n      start = time;\r\n      this.transitionStarts_[id] = start;\r\n    } else if (start === -1) {\r\n      return 1;\r\n    }\r\n\r\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\r\n    if (delta >= this.transition_) {\r\n      return 1;\r\n    }\r\n    return easeIn(delta / this.transition_);\r\n  }\r\n\r\n  /**\r\n   * Determine if a tile is in an alpha transition.  A tile is considered in\r\n   * transition if tile.getAlpha() has not yet been called or has been called\r\n   * and returned 1.\r\n   * @param {string} id An id for the renderer.\r\n   * @return {boolean} The tile is in transition.\r\n   */\r\n  inTransition(id) {\r\n    if (!this.transition_) {\r\n      return false;\r\n    }\r\n    return this.transitionStarts_[id] !== -1;\r\n  }\r\n\r\n  /**\r\n   * Mark a transition as complete.\r\n   * @param {string} id An id for the renderer.\r\n   */\r\n  endTransition(id) {\r\n    if (this.transition_) {\r\n      this.transitionStarts_[id] = -1;\r\n    }\r\n  }\r\n}\r\n\r\nexport default Tile;\r\n","/**\r\n * @module CME2D/has\r\n */\r\n\r\nconst ua =\r\n  typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'\r\n    ? navigator.userAgent.toLowerCase()\r\n    : '';\r\n\r\n/**\r\n * User agent string says we are dealing with Firefox as browser.\r\n * @type {boolean}\r\n */\r\nexport const FIREFOX = ua.includes('firefox');\r\n\r\n/**\r\n * User agent string says we are dealing with Safari as browser.\r\n * @type {boolean}\r\n */\r\nexport const SAFARI = ua.includes('safari') && !ua.includes('chrom');\r\n\r\n/**\r\n * https://bugs.webkit.org/show_bug.cgi?id=237906\r\n * @type {boolean}\r\n */\r\nexport const SAFARI_BUG_237906 =\r\n  SAFARI &&\r\n  (ua.includes('version/15.4') ||\r\n    /cpu (os|iphone os) 15_4 like mac os x/.test(ua));\r\n\r\n/**\r\n * User agent string says we are dealing with a WebKit engine.\r\n * @type {boolean}\r\n */\r\nexport const WEBKIT = ua.includes('webkit') && !ua.includes('edge');\r\n\r\n/**\r\n * User agent string says we are dealing with a Mac as platform.\r\n * @type {boolean}\r\n */\r\nexport const MAC = ua.includes('macintosh');\r\n\r\n/**\r\n * The ratio between physical pixels and device-independent pixels\r\n * (dips) on the device (`window.devicePixelRatio`).\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const DEVICE_PIXEL_RATIO =\r\n  typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;\r\n\r\n/**\r\n * The execution context is a worker with OffscreenCanvas available.\r\n * @const\r\n * @type {boolean}\r\n */\r\nexport const WORKER_OFFSCREEN_CANVAS =\r\n  typeof WorkerGlobalScope !== 'undefined' &&\r\n  typeof OffscreenCanvas !== 'undefined' &&\r\n  self instanceof WorkerGlobalScope; //eslint-disable-line\r\n\r\n/**\r\n * Image.prototype.decode() is supported.\r\n * @type {boolean}\r\n */\r\nexport const IMAGE_DECODE =\r\n  typeof Image !== 'undefined' && Image.prototype.decode;\r\n\r\n/**\r\n * createImageBitmap() is supported.\r\n * @type {boolean}\r\n */\r\nexport const CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';\r\n\r\n/**\r\n * @type {boolean}\r\n */\r\nexport const PASSIVE_EVENT_LISTENERS = (function () {\r\n  let passive = false;\r\n  try {\r\n    const options = Object.defineProperty({}, 'passive', {\r\n      get: function () {\r\n        passive = true;\r\n      },\r\n    });\r\n\r\n    // @ts-ignore Ignore invalid event type '_'\r\n    window.addEventListener('_', null, options);\r\n    // @ts-ignore Ignore invalid event type '_'\r\n    window.removeEventListener('_', null, options);\r\n  } catch (error) {\r\n    // passive not supported\r\n  }\r\n  return passive;\r\n})();\r\n","import {WORKER_OFFSCREEN_CANVAS} from './has.js';\r\n\r\n/**\r\n * @module CME2D/dom\r\n */\r\n\r\n//FIXME Move this function to the canvas module\r\n/**\r\n * Create an html canvas element and returns its 2d context.\r\n * @param {number} [width] Canvas width.\r\n * @param {number} [height] Canvas height.\r\n * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.\r\n * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings\r\n * @return {CanvasRenderingContext2D} The context.\r\n */\r\nexport function createCanvasContext2D(width, height, canvasPool, settings) {\r\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\r\n  let canvas;\r\n  if (canvasPool && canvasPool.length) {\r\n    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());\r\n  } else if (WORKER_OFFSCREEN_CANVAS) {\r\n    canvas = new OffscreenCanvas(width || 300, height || 300);\r\n  } else {\r\n    canvas = document.createElement('canvas');\r\n  }\r\n  if (width) {\r\n    canvas.width = width;\r\n  }\r\n  if (height) {\r\n    canvas.height = height;\r\n  }\r\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\r\n  return /** @type {CanvasRenderingContext2D} */ (\r\n    canvas.getContext('2d', settings)\r\n  );\r\n}\r\n\r\n/** @type {CanvasRenderingContext2D} */\r\nlet sharedCanvasContext;\r\n\r\n/**\r\n * @return {CanvasRenderingContext2D} Shared canvas context.\r\n */\r\nexport function getSharedCanvasContext2D() {\r\n  if (!sharedCanvasContext) {\r\n    sharedCanvasContext = createCanvasContext2D(1, 1);\r\n  }\r\n  return sharedCanvasContext;\r\n}\r\n\r\n/**\r\n * Releases canvas memory to avoid exceeding memory limits in Safari.\r\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\r\n * @param {CanvasRenderingContext2D} context Context.\r\n */\r\nexport function releaseCanvas(context) {\r\n  const canvas = context.canvas;\r\n  canvas.width = 1;\r\n  canvas.height = 1;\r\n  context.clearRect(0, 0, 1, 1);\r\n}\r\n\r\n/**\r\n * Get the current computed width for the given element including margin,\r\n * padding and border.\r\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\r\n * @param {!HTMLElement} element Element.\r\n * @return {number} The width.\r\n */\r\nexport function outerWidth(element) {\r\n  let width = element.offsetWidth;\r\n  const style = getComputedStyle(element);\r\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\r\n\r\n  return width;\r\n}\r\n\r\n/**\r\n * Get the current computed height for the given element including margin,\r\n * padding and border.\r\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\r\n * @param {!HTMLElement} element Element.\r\n * @return {number} The height.\r\n */\r\nexport function outerHeight(element) {\r\n  let height = element.offsetHeight;\r\n  const style = getComputedStyle(element);\r\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\r\n\r\n  return height;\r\n}\r\n\r\n/**\r\n * @param {Node} newNode Node to replace old node\r\n * @param {Node} oldNode The node to be replaced\r\n */\r\nexport function replaceNode(newNode, oldNode) {\r\n  const parent = oldNode.parentNode;\r\n  if (parent) {\r\n    parent.replaceChild(newNode, oldNode);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node The node to remove the children from.\r\n */\r\nexport function removeChildren(node) {\r\n  while (node.lastChild) {\r\n    node.lastChild.remove();\r\n  }\r\n}\r\n\r\n/**\r\n * Transform the children of a parent node so they match the\r\n * provided list of children.  This function aims to efficiently\r\n * remove, add, and reorder child nodes while maintaining a simple\r\n * implementation (it is not guaranteed to minimize DOM operations).\r\n * @param {Node} node The parent node whose children need reworking.\r\n * @param {Array<Node>} children The desired children.\r\n */\r\nexport function replaceChildren(node, children) {\r\n  const oldChildren = node.childNodes;\r\n\r\n  for (let i = 0; true; ++i) {\r\n    const oldChild = oldChildren[i];\r\n    const newChild = children[i];\r\n\r\n    // check if our work is done\r\n    if (!oldChild && !newChild) {\r\n      break;\r\n    }\r\n\r\n    // check if children match\r\n    if (oldChild === newChild) {\r\n      continue;\r\n    }\r\n\r\n    // check if a new child needs to be added\r\n    if (!oldChild) {\r\n      node.appendChild(newChild);\r\n      continue;\r\n    }\r\n\r\n    // check if an old child needs to be removed\r\n    if (!newChild) {\r\n      node.removeChild(oldChild);\r\n      --i;\r\n      continue;\r\n    }\r\n\r\n    // reorder\r\n    node.insertBefore(newChild, oldChild);\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/DataTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport TileState from './TileState.js';\r\nimport {createCanvasContext2D} from './dom.js';\r\n\r\n/**\r\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\r\n */\r\n\r\n/**\r\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\r\n */\r\n\r\n/**\r\n * Data that can be used with a DataTile.\r\n * @typedef {ArrayLike|ImageLike} Data\r\n */\r\n\r\n/**\r\n * @param {Data} data Tile data.\r\n * @return {ImageLike|null} The image-like data.\r\n */\r\nexport function asImageLike(data) {\r\n  return data instanceof Image ||\r\n    data instanceof HTMLCanvasElement ||\r\n    data instanceof HTMLVideoElement ||\r\n    data instanceof ImageBitmap\r\n    ? data\r\n    : null;\r\n}\r\n\r\n/**\r\n * @param {Data} data Tile data.\r\n * @return {ArrayLike|null} The array-like data.\r\n */\r\nexport function asArrayLike(data) {\r\n  return data instanceof Uint8Array ||\r\n    data instanceof Uint8ClampedArray ||\r\n    data instanceof Float32Array ||\r\n    data instanceof DataView\r\n    ? data\r\n    : null;\r\n}\r\n\r\n/**\r\n * This is set as the cancellation reason when a tile is disposed.\r\n */\r\nexport const disposedError = new Error('disposed');\r\n\r\n/**\r\n * @type {CanvasRenderingContext2D|null}\r\n */\r\nlet sharedContext = null;\r\n\r\n/**\r\n * @param {ImageLike} image The image.\r\n * @return {Uint8ClampedArray} The data.\r\n */\r\nexport function toArray(image) {\r\n  if (!sharedContext) {\r\n    sharedContext = createCanvasContext2D(\r\n      image.width,\r\n      image.height,\r\n      undefined,\r\n      {willReadFrequently: true},\r\n    );\r\n  }\r\n  const canvas = sharedContext.canvas;\r\n  const width = image.width;\r\n  if (canvas.width !== width) {\r\n    canvas.width = width;\r\n  }\r\n  const height = image.height;\r\n  if (canvas.height !== height) {\r\n    canvas.height = height;\r\n  }\r\n  sharedContext.clearRect(0, 0, width, height);\r\n  sharedContext.drawImage(image, 0, 0);\r\n  return sharedContext.getImageData(0, 0, width, height).data;\r\n}\r\n\r\n/**\r\n * @type {import('./size.js').Size}\r\n */\r\nconst defaultSize = [256, 256];\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\r\n * the promise should not resolve until the image is loaded.\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\r\n * @property {AbortController} [controller] An abort controller.\r\n * @api\r\n */\r\n\r\nclass DataTile extends Tile {\r\n  /**\r\n   * @param {Options} options Tile options.\r\n   */\r\n  constructor(options) {\r\n    const state = TileState.IDLE;\r\n\r\n    super(options.tileCoord, state, {\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n    });\r\n\r\n    /**\r\n     * @type {function(): Promise<Data>}\r\n     * @private\r\n     */\r\n    this.loader_ = options.loader;\r\n\r\n    /**\r\n     * @type {Data}\r\n     * @private\r\n     */\r\n    this.data_ = null;\r\n\r\n    /**\r\n     * @type {Error}\r\n     * @private\r\n     */\r\n    this.error_ = null;\r\n\r\n    /**\r\n     * @type {import('./size.js').Size|null}\r\n     * @private\r\n     */\r\n    this.size_ = options.size || null;\r\n\r\n    /**\r\n     * @type {AbortController|null}\r\n     * @private\r\n     */\r\n    this.controller_ = options.controller || null;\r\n  }\r\n\r\n  /**\r\n   * Get the tile size.\r\n   * @return {import('./size.js').Size} Tile size.\r\n   */\r\n  getSize() {\r\n    if (this.size_) {\r\n      return this.size_;\r\n    }\r\n    const imageData = asImageLike(this.data_);\r\n    if (imageData) {\r\n      return [imageData.width, imageData.height];\r\n    }\r\n    return defaultSize;\r\n  }\r\n\r\n  /**\r\n   * Get the data for the tile.\r\n   * @return {Data} Tile data.\r\n   * @api\r\n   */\r\n  getData() {\r\n    return this.data_;\r\n  }\r\n\r\n  /**\r\n   * Get any loading error.\r\n   * @return {Error} Loading error.\r\n   * @api\r\n   */\r\n  getError() {\r\n    return this.error_;\r\n  }\r\n\r\n  /**\r\n   * Load the tile data.\r\n   * @api\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\r\n      return;\r\n    }\r\n    this.state = TileState.LOADING;\r\n    this.changed();\r\n\r\n    const self = this;\r\n    this.loader_()\r\n      .then(function (data) {\r\n        self.data_ = data;\r\n        self.state = TileState.LOADED;\r\n        self.changed();\r\n      })\r\n      .catch(function (error) {\r\n        self.error_ = error;\r\n        self.state = TileState.ERROR;\r\n        self.changed();\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    if (this.controller_) {\r\n      this.controller_.abort(disposedError);\r\n      this.controller_ = null;\r\n    }\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default DataTile;\r\n","/**\r\n * @module CME2D/reproj/common\r\n */\r\n\r\n/**\r\n * Default maximum allowed threshold  (in pixels) for reprojection\r\n * triangulation.\r\n * @type {number}\r\n */\r\nexport const ERROR_THRESHOLD = 0.5;\r\n","/**\r\n * @module CME2D/extent/Relationship\r\n */\r\n\r\n/**\r\n * Relationship to an extent.\r\n * @enum {number}\r\n */\r\nexport default {\r\n  UNKNOWN: 0,\r\n  INTERSECTING: 1,\r\n  ABOVE: 2,\r\n  RIGHT: 4,\r\n  BELOW: 8,\r\n  LEFT: 16,\r\n};\r\n","/**\r\n * @module CME2D/extent\r\n */\r\nimport Relationship from './extent/Relationship.js';\r\n\r\n/**\r\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\r\n * @typedef {Array<number>} Extent\r\n * @api\r\n */\r\n\r\n/**\r\n * Extent corner.\r\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\r\n */\r\n\r\n/**\r\n * Build an extent that includes all given coordinates.\r\n *\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @return {Extent} Bounding extent.\r\n * @api\r\n */\r\nexport function boundingExtent(coordinates) {\r\n  const extent = createEmpty();\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    extendCoordinate(extent, coordinates[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} xs Xs.\r\n * @param {Array<number>} ys Ys.\r\n * @param {Extent} [dest] Destination extent.\r\n * @private\r\n * @return {Extent} Extent.\r\n */\r\nfunction _boundingExtentXYs(xs, ys, dest) {\r\n  const minX = Math.min.apply(null, xs);\r\n  const minY = Math.min.apply(null, ys);\r\n  const maxX = Math.max.apply(null, xs);\r\n  const maxY = Math.max.apply(null, ys);\r\n  return createOrUpdate(minX, minY, maxX, maxY, dest);\r\n}\r\n\r\n/**\r\n * Return extent increased by the provided value.\r\n * @param {Extent} extent Extent.\r\n * @param {number} value The amount by which the extent should be buffered.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n * @api\r\n */\r\nexport function buffer(extent, value, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0] - value;\r\n    dest[1] = extent[1] - value;\r\n    dest[2] = extent[2] + value;\r\n    dest[3] = extent[3] + value;\r\n    return dest;\r\n  }\r\n  return [\r\n    extent[0] - value,\r\n    extent[1] - value,\r\n    extent[2] + value,\r\n    extent[3] + value,\r\n  ];\r\n}\r\n\r\n/**\r\n * Creates a clone of an extent.\r\n *\r\n * @param {Extent} extent Extent to clone.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} The clone.\r\n */\r\nexport function clone(extent, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0];\r\n    dest[1] = extent[1];\r\n    dest[2] = extent[2];\r\n    dest[3] = extent[3];\r\n    return dest;\r\n  }\r\n  return extent.slice();\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {number} Closest squared distance.\r\n */\r\nexport function closestSquaredDistanceXY(extent, x, y) {\r\n  let dx, dy;\r\n  if (x < extent[0]) {\r\n    dx = extent[0] - x;\r\n  } else if (extent[2] < x) {\r\n    dx = x - extent[2];\r\n  } else {\r\n    dx = 0;\r\n  }\r\n  if (y < extent[1]) {\r\n    dy = extent[1] - y;\r\n  } else if (extent[3] < y) {\r\n    dy = y - extent[3];\r\n  } else {\r\n    dy = 0;\r\n  }\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Check if the passed coordinate is contained or on the edge of the extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @return {boolean} The coordinate is contained in the extent.\r\n * @api\r\n */\r\nexport function containsCoordinate(extent, coordinate) {\r\n  return containsXY(extent, coordinate[0], coordinate[1]);\r\n}\r\n\r\n/**\r\n * Check if one extent contains another.\r\n *\r\n * An extent is deemed contained if it lies completely within the other extent,\r\n * including if they share one or more edges.\r\n *\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {boolean} The second extent is contained by or on the edge of the\r\n *     first.\r\n * @api\r\n */\r\nexport function containsExtent(extent1, extent2) {\r\n  return (\r\n    extent1[0] <= extent2[0] &&\r\n    extent2[2] <= extent1[2] &&\r\n    extent1[1] <= extent2[1] &&\r\n    extent2[3] <= extent1[3]\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the passed coordinate is contained or on the edge of the extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X coordinate.\r\n * @param {number} y Y coordinate.\r\n * @return {boolean} The x, y values are contained in the extent.\r\n * @api\r\n */\r\nexport function containsXY(extent, x, y) {\r\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\r\n}\r\n\r\n/**\r\n * Get the relationship between a coordinate and extent.\r\n * @param {Extent} extent The extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\r\n *     import(\"./extent/Relationship.js\").Relationship).\r\n */\r\nexport function coordinateRelationship(extent, coordinate) {\r\n  const minX = extent[0];\r\n  const minY = extent[1];\r\n  const maxX = extent[2];\r\n  const maxY = extent[3];\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  let relationship = Relationship.UNKNOWN;\r\n  if (x < minX) {\r\n    relationship = relationship | Relationship.LEFT;\r\n  } else if (x > maxX) {\r\n    relationship = relationship | Relationship.RIGHT;\r\n  }\r\n  if (y < minY) {\r\n    relationship = relationship | Relationship.BELOW;\r\n  } else if (y > maxY) {\r\n    relationship = relationship | Relationship.ABOVE;\r\n  }\r\n  if (relationship === Relationship.UNKNOWN) {\r\n    relationship = Relationship.INTERSECTING;\r\n  }\r\n  return relationship;\r\n}\r\n\r\n/**\r\n * Create an empty extent.\r\n * @return {Extent} Empty extent.\r\n * @api\r\n */\r\nexport function createEmpty() {\r\n  return [Infinity, Infinity, -Infinity, -Infinity];\r\n}\r\n\r\n/**\r\n * Create a new extent or update the provided extent.\r\n * @param {number} minX Minimum X.\r\n * @param {number} minY Minimum Y.\r\n * @param {number} maxX Maximum X.\r\n * @param {number} maxY Maximum Y.\r\n * @param {Extent} [dest] Destination extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdate(minX, minY, maxX, maxY, dest) {\r\n  if (dest) {\r\n    dest[0] = minX;\r\n    dest[1] = minY;\r\n    dest[2] = maxX;\r\n    dest[3] = maxY;\r\n    return dest;\r\n  }\r\n  return [minX, minY, maxX, maxY];\r\n}\r\n\r\n/**\r\n * Create a new empty extent or make the provided one empty.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateEmpty(dest) {\r\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromCoordinate(coordinate, dest) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  return createOrUpdate(x, y, x, y, dest);\r\n}\r\n\r\n/**\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromCoordinates(coordinates, dest) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendCoordinates(extent, coordinates);\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromFlatCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  dest,\r\n) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\r\n}\r\n\r\n/**\r\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromRings(rings, dest) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendRings(extent, rings);\r\n}\r\n\r\n/**\r\n * Determine if two extents are equivalent.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {boolean} The two extents are equivalent.\r\n * @api\r\n */\r\nexport function equals(extent1, extent2) {\r\n  return (\r\n    extent1[0] == extent2[0] &&\r\n    extent1[2] == extent2[2] &&\r\n    extent1[1] == extent2[1] &&\r\n    extent1[3] == extent2[3]\r\n  );\r\n}\r\n\r\n/**\r\n * Determine if two extents are approximately equivalent.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @param {number} tolerance Tolerance in extent coordinate units.\r\n * @return {boolean} The two extents differ by less than the tolerance.\r\n */\r\nexport function approximatelyEquals(extent1, extent2, tolerance) {\r\n  return (\r\n    Math.abs(extent1[0] - extent2[0]) < tolerance &&\r\n    Math.abs(extent1[2] - extent2[2]) < tolerance &&\r\n    Math.abs(extent1[1] - extent2[1]) < tolerance &&\r\n    Math.abs(extent1[3] - extent2[3]) < tolerance\r\n  );\r\n}\r\n\r\n/**\r\n * Modify an extent to include another extent.\r\n * @param {Extent} extent1 The extent to be modified.\r\n * @param {Extent} extent2 The extent that will be included in the first.\r\n * @return {Extent} A reference to the first (extended) extent.\r\n * @api\r\n */\r\nexport function extend(extent1, extent2) {\r\n  if (extent2[0] < extent1[0]) {\r\n    extent1[0] = extent2[0];\r\n  }\r\n  if (extent2[2] > extent1[2]) {\r\n    extent1[2] = extent2[2];\r\n  }\r\n  if (extent2[1] < extent1[1]) {\r\n    extent1[1] = extent2[1];\r\n  }\r\n  if (extent2[3] > extent1[3]) {\r\n    extent1[3] = extent2[3];\r\n  }\r\n  return extent1;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n */\r\nexport function extendCoordinate(extent, coordinate) {\r\n  if (coordinate[0] < extent[0]) {\r\n    extent[0] = coordinate[0];\r\n  }\r\n  if (coordinate[0] > extent[2]) {\r\n    extent[2] = coordinate[0];\r\n  }\r\n  if (coordinate[1] < extent[1]) {\r\n    extent[1] = coordinate[1];\r\n  }\r\n  if (coordinate[1] > extent[3]) {\r\n    extent[3] = coordinate[1];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendCoordinates(extent, coordinates) {\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    extendCoordinate(extent, coordinates[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendFlatCoordinates(\r\n  extent,\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n) {\r\n  for (; offset < end; offset += stride) {\r\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendRings(extent, rings) {\r\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\r\n    extendCoordinates(extent, rings[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n */\r\nexport function extendXY(extent, x, y) {\r\n  extent[0] = Math.min(extent[0], x);\r\n  extent[1] = Math.min(extent[1], y);\r\n  extent[2] = Math.max(extent[2], x);\r\n  extent[3] = Math.max(extent[3], y);\r\n}\r\n\r\n/**\r\n * This function calls `callback` for each corner of the extent. If the\r\n * callback returns a truthy value the function returns that value\r\n * immediately. Otherwise the function returns `false`.\r\n * @param {Extent} extent Extent.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\r\n * @return {S|boolean} Value.\r\n * @template S\r\n */\r\nexport function forEachCorner(extent, callback) {\r\n  let val;\r\n  val = callback(getBottomLeft(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getBottomRight(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getTopRight(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getTopLeft(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get the size of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Area.\r\n * @api\r\n */\r\nexport function getArea(extent) {\r\n  let area = 0;\r\n  if (!isEmpty(extent)) {\r\n    area = getWidth(extent) * getHeight(extent);\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * Get the bottom left coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\r\n * @api\r\n */\r\nexport function getBottomLeft(extent) {\r\n  return [extent[0], extent[1]];\r\n}\r\n\r\n/**\r\n * Get the bottom right coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\r\n * @api\r\n */\r\nexport function getBottomRight(extent) {\r\n  return [extent[2], extent[1]];\r\n}\r\n\r\n/**\r\n * Get the center coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Center.\r\n * @api\r\n */\r\nexport function getCenter(extent) {\r\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\r\n}\r\n\r\n/**\r\n * Get a corner coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @param {Corner} corner Corner.\r\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\r\n */\r\nexport function getCorner(extent, corner) {\r\n  let coordinate;\r\n  if (corner === 'bottom-left') {\r\n    coordinate = getBottomLeft(extent);\r\n  } else if (corner === 'bottom-right') {\r\n    coordinate = getBottomRight(extent);\r\n  } else if (corner === 'top-left') {\r\n    coordinate = getTopLeft(extent);\r\n  } else if (corner === 'top-right') {\r\n    coordinate = getTopRight(extent);\r\n  } else {\r\n    throw new Error('Invalid corner');\r\n  }\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {number} Enlarged area.\r\n */\r\nexport function getEnlargedArea(extent1, extent2) {\r\n  const minX = Math.min(extent1[0], extent2[0]);\r\n  const minY = Math.min(extent1[1], extent2[1]);\r\n  const maxX = Math.max(extent1[2], extent2[2]);\r\n  const maxY = Math.max(extent1[3], extent2[3]);\r\n  return (maxX - minX) * (maxY - minY);\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @param {import(\"./size.js\").Size} size Size.\r\n * @param {Extent} [dest] Destination extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function getForViewAndSize(center, resolution, rotation, size, dest) {\r\n  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(\r\n    center,\r\n    resolution,\r\n    rotation,\r\n    size,\r\n  );\r\n  return createOrUpdate(\r\n    Math.min(x0, x1, x2, x3),\r\n    Math.min(y0, y1, y2, y3),\r\n    Math.max(x0, x1, x2, x3),\r\n    Math.max(y0, y1, y2, y3),\r\n    dest,\r\n  );\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @param {import(\"./size.js\").Size} size Size.\r\n * @return {Array<number>} Linear ring representing the viewport.\r\n */\r\nexport function getRotatedViewport(center, resolution, rotation, size) {\r\n  const dx = (resolution * size[0]) / 2;\r\n  const dy = (resolution * size[1]) / 2;\r\n  const cosRotation = Math.cos(rotation);\r\n  const sinRotation = Math.sin(rotation);\r\n  const xCos = dx * cosRotation;\r\n  const xSin = dx * sinRotation;\r\n  const yCos = dy * cosRotation;\r\n  const ySin = dy * sinRotation;\r\n  const x = center[0];\r\n  const y = center[1];\r\n  return [\r\n    x - xCos + ySin,\r\n    y - xSin - yCos,\r\n    x - xCos - ySin,\r\n    y - xSin + yCos,\r\n    x + xCos - ySin,\r\n    y + xSin + yCos,\r\n    x + xCos + ySin,\r\n    y + xSin - yCos,\r\n    x - xCos + ySin,\r\n    y - xSin - yCos,\r\n  ];\r\n}\r\n\r\n/**\r\n * Get the height of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Height.\r\n * @api\r\n */\r\nexport function getHeight(extent) {\r\n  return extent[3] - extent[1];\r\n}\r\n\r\n/**\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {number} Intersection area.\r\n */\r\nexport function getIntersectionArea(extent1, extent2) {\r\n  const intersection = getIntersection(extent1, extent2);\r\n  return getArea(intersection);\r\n}\r\n\r\n/**\r\n * Get the intersection of two extents.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @param {Extent} [dest] Optional extent to populate with intersection.\r\n * @return {Extent} Intersecting extent.\r\n * @api\r\n */\r\nexport function getIntersection(extent1, extent2, dest) {\r\n  const intersection = dest ? dest : createEmpty();\r\n  if (intersects(extent1, extent2)) {\r\n    if (extent1[0] > extent2[0]) {\r\n      intersection[0] = extent1[0];\r\n    } else {\r\n      intersection[0] = extent2[0];\r\n    }\r\n    if (extent1[1] > extent2[1]) {\r\n      intersection[1] = extent1[1];\r\n    } else {\r\n      intersection[1] = extent2[1];\r\n    }\r\n    if (extent1[2] < extent2[2]) {\r\n      intersection[2] = extent1[2];\r\n    } else {\r\n      intersection[2] = extent2[2];\r\n    }\r\n    if (extent1[3] < extent2[3]) {\r\n      intersection[3] = extent1[3];\r\n    } else {\r\n      intersection[3] = extent2[3];\r\n    }\r\n  } else {\r\n    createOrUpdateEmpty(intersection);\r\n  }\r\n  return intersection;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @return {number} Margin.\r\n */\r\nexport function getMargin(extent) {\r\n  return getWidth(extent) + getHeight(extent);\r\n}\r\n\r\n/**\r\n * Get the size (width, height) of an extent.\r\n * @param {Extent} extent The extent.\r\n * @return {import(\"./size.js\").Size} The extent size.\r\n * @api\r\n */\r\nexport function getSize(extent) {\r\n  return [extent[2] - extent[0], extent[3] - extent[1]];\r\n}\r\n\r\n/**\r\n * Get the top left coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\r\n * @api\r\n */\r\nexport function getTopLeft(extent) {\r\n  return [extent[0], extent[3]];\r\n}\r\n\r\n/**\r\n * Get the top right coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\r\n * @api\r\n */\r\nexport function getTopRight(extent) {\r\n  return [extent[2], extent[3]];\r\n}\r\n\r\n/**\r\n * Get the width of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Width.\r\n * @api\r\n */\r\nexport function getWidth(extent) {\r\n  return extent[2] - extent[0];\r\n}\r\n\r\n/**\r\n * Determine if one extent intersects another.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent.\r\n * @return {boolean} The two extents intersect.\r\n * @api\r\n */\r\nexport function intersects(extent1, extent2) {\r\n  return (\r\n    extent1[0] <= extent2[2] &&\r\n    extent1[2] >= extent2[0] &&\r\n    extent1[1] <= extent2[3] &&\r\n    extent1[3] >= extent2[1]\r\n  );\r\n}\r\n\r\n/**\r\n * Determine if an extent is empty.\r\n * @param {Extent} extent Extent.\r\n * @return {boolean} Is empty.\r\n * @api\r\n */\r\nexport function isEmpty(extent) {\r\n  return extent[2] < extent[0] || extent[3] < extent[1];\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function returnOrUpdate(extent, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0];\r\n    dest[1] = extent[1];\r\n    dest[2] = extent[2];\r\n    dest[3] = extent[3];\r\n    return dest;\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} value Value.\r\n */\r\nexport function scaleFromCenter(extent, value) {\r\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\r\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\r\n  extent[0] -= deltaX;\r\n  extent[2] += deltaX;\r\n  extent[1] -= deltaY;\r\n  extent[3] += deltaY;\r\n}\r\n\r\n/**\r\n * Determine if the segment between two coordinates intersects (crosses,\r\n * touches, or is contained by) the provided extent.\r\n * @param {Extent} extent The extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\r\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\r\n * @return {boolean} The segment intersects the extent.\r\n */\r\nexport function intersectsSegment(extent, start, end) {\r\n  let intersects = false;\r\n  const startRel = coordinateRelationship(extent, start);\r\n  const endRel = coordinateRelationship(extent, end);\r\n  if (\r\n    startRel === Relationship.INTERSECTING ||\r\n    endRel === Relationship.INTERSECTING\r\n  ) {\r\n    intersects = true;\r\n  } else {\r\n    const minX = extent[0];\r\n    const minY = extent[1];\r\n    const maxX = extent[2];\r\n    const maxY = extent[3];\r\n    const startX = start[0];\r\n    const startY = start[1];\r\n    const endX = end[0];\r\n    const endY = end[1];\r\n    const slope = (endY - startY) / (endX - startX);\r\n    let x, y;\r\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\r\n      // potentially intersects top\r\n      x = endX - (endY - maxY) / slope;\r\n      intersects = x >= minX && x <= maxX;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.RIGHT) &&\r\n      !(startRel & Relationship.RIGHT)\r\n    ) {\r\n      // potentially intersects right\r\n      y = endY - (endX - maxX) * slope;\r\n      intersects = y >= minY && y <= maxY;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.BELOW) &&\r\n      !(startRel & Relationship.BELOW)\r\n    ) {\r\n      // potentially intersects bottom\r\n      x = endX - (endY - minY) / slope;\r\n      intersects = x >= minX && x <= maxX;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.LEFT) &&\r\n      !(startRel & Relationship.LEFT)\r\n    ) {\r\n      // potentially intersects left\r\n      y = endY - (endX - minX) * slope;\r\n      intersects = y >= minY && y <= maxY;\r\n    }\r\n  }\r\n  return intersects;\r\n}\r\n\r\n/**\r\n * Apply a transform function to the extent.\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\r\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\r\n * @param {Extent} [dest] Destination extent.\r\n * @param {number} [stops] Number of stops per side used for the transform.\r\n * By default only the corners are used.\r\n * @return {Extent} Extent.\r\n * @api\r\n */\r\nexport function applyTransform(extent, transformFn, dest, stops) {\r\n  if (isEmpty(extent)) {\r\n    return createOrUpdateEmpty(dest);\r\n  }\r\n  let coordinates = [];\r\n  if (stops > 1) {\r\n    const width = extent[2] - extent[0];\r\n    const height = extent[3] - extent[1];\r\n    for (let i = 0; i < stops; ++i) {\r\n      coordinates.push(\r\n        extent[0] + (width * i) / stops,\r\n        extent[1],\r\n        extent[2],\r\n        extent[1] + (height * i) / stops,\r\n        extent[2] - (width * i) / stops,\r\n        extent[3],\r\n        extent[0],\r\n        extent[3] - (height * i) / stops,\r\n      );\r\n    }\r\n  } else {\r\n    coordinates = [\r\n      extent[0],\r\n      extent[1],\r\n      extent[2],\r\n      extent[1],\r\n      extent[2],\r\n      extent[3],\r\n      extent[0],\r\n      extent[3],\r\n    ];\r\n  }\r\n  transformFn(coordinates, coordinates, 2);\r\n  const xs = [];\r\n  const ys = [];\r\n  for (let i = 0, l = coordinates.length; i < l; i += 2) {\r\n    xs.push(coordinates[i]);\r\n    ys.push(coordinates[i + 1]);\r\n  }\r\n  return _boundingExtentXYs(xs, ys, dest);\r\n}\r\n\r\n/**\r\n * Modifies the provided extent in-place to be within the real world\r\n * extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection\r\n * @return {Extent} The extent within the real world extent.\r\n */\r\nexport function wrapX(extent, projection) {\r\n  const projectionExtent = projection.getExtent();\r\n  const center = getCenter(extent);\r\n  if (\r\n    projection.canWrapX() &&\r\n    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])\r\n  ) {\r\n    const worldWidth = getWidth(projectionExtent);\r\n    const worldsAway = Math.floor(\r\n      (center[0] - projectionExtent[0]) / worldWidth,\r\n    );\r\n    const offset = worldsAway * worldWidth;\r\n    extent[0] -= offset;\r\n    extent[2] -= offset;\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * Fits the extent to the real world\r\n *\r\n * If the extent does not cross the anti meridian, this will return the extent in an array\r\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\r\n * real world\r\n *\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection\r\n * @param {boolean} [multiWorld] Return all worlds\r\n * @return {Array<Extent>} The extent within the real world extent.\r\n */\r\nexport function wrapAndSliceX(extent, projection, multiWorld) {\r\n  if (projection.canWrapX()) {\r\n    const projectionExtent = projection.getExtent();\r\n\r\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\r\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\r\n    }\r\n\r\n    wrapX(extent, projection);\r\n    const worldWidth = getWidth(projectionExtent);\r\n\r\n    if (getWidth(extent) > worldWidth && !multiWorld) {\r\n      // the extent wraps around on itself\r\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\r\n    }\r\n    if (extent[0] < projectionExtent[0]) {\r\n      // the extent crosses the anti meridian, so it needs to be sliced\r\n      return [\r\n        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\r\n        [projectionExtent[0], extent[1], extent[2], extent[3]],\r\n      ];\r\n    }\r\n    if (extent[2] > projectionExtent[2]) {\r\n      // the extent crosses the anti meridian, so it needs to be sliced\r\n      return [\r\n        [extent[0], extent[1], projectionExtent[2], extent[3]],\r\n        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\r\n      ];\r\n    }\r\n  }\r\n\r\n  return [extent];\r\n}\r\n","/**\r\n * @module CME2D/proj/Units\r\n */\r\n\r\n/**\r\n * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units\r\n * Projection units.\r\n */\r\n\r\n/**\r\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\r\n * @type {Object<number, Units>}\r\n */\r\nconst unitByCode = {\r\n  '9001': 'm',\r\n  '9002': 'ft',\r\n  '9003': 'us-ft',\r\n  '9101': 'radians',\r\n  '9102': 'degrees',\r\n};\r\n\r\n/**\r\n * @param {number} code Unit code.\r\n * @return {Units} Units.\r\n */\r\nexport function fromCode(code) {\r\n  return unitByCode[code];\r\n}\r\n\r\n/**\r\n * @typedef {Object} MetersPerUnitLookup\r\n * @property {number} radians Radians\r\n * @property {number} degrees Degrees\r\n * @property {number} ft  Feet\r\n * @property {number} m Meters\r\n * @property {number} us-ft US feet\r\n */\r\n\r\n/**\r\n * Meters per unit lookup table.\r\n * @const\r\n * @type {MetersPerUnitLookup}\r\n * @api\r\n */\r\nexport const METERS_PER_UNIT = {\r\n  // use the radius of the Normal sphere\r\n  'radians': 6370997 / (2 * Math.PI),\r\n  'degrees': (2 * Math.PI * 6370997) / 360,\r\n  'ft': 0.3048,\r\n  'm': 1,\r\n  'us-ft': 1200 / 3937,\r\n};\r\n","/**\r\n * @module CME2D/proj/Projection\r\n */\r\nimport {METERS_PER_UNIT} from './Units.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\r\n * @property {import(\"./Units.js\").Units} [units] Units. Required unless a\r\n * proj4 projection is defined for `code`.\r\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\r\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\r\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\r\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\r\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\r\n * lookup table.\r\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\r\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\r\n * Function to determine resolution at a point. The function is called with a\r\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\r\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\r\n * the default {@link module:ol/proj.getPointResolution} function will be used.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Projection definition class. One of these is created for each projection\r\n * supported in the application and stored in the {@link module:ol/proj} namespace.\r\n * You can use these in applications, but this is not required, as API params\r\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\r\n * code will suffice.\r\n *\r\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\r\n * projection.\r\n *\r\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\r\n * with the following aliases:\r\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\r\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\r\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\r\n *     urn:x-ogc:def:crs:EPSG:4326\r\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\r\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\r\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\r\n *\r\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\r\n * be added using `proj4.defs()`. After all required projection definitions are\r\n * added, call the {@link module:ol/proj/proj4.register} function.\r\n *\r\n * @api\r\n */\r\nclass Projection {\r\n  /**\r\n   * @param {Options} options Projection options.\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.code_ = options.code;\r\n\r\n    /**\r\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\r\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\r\n     * tile.\r\n     * @private\r\n     * @type {import(\"./Units.js\").Units}\r\n     */\r\n    this.units_ = /** @type {import(\"./Units.js\").Units} */ (options.units);\r\n\r\n    /**\r\n     * Validity extent of the projection in projected coordinates. For projections\r\n     * with `TILE_PIXELS` units, this is the extent of the tile in\r\n     * tile pixel space.\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = options.extent !== undefined ? options.extent : null;\r\n\r\n    /**\r\n     * Extent of the world in EPSG:4326. For projections with\r\n     * `TILE_PIXELS` units, this is the extent of the tile in\r\n     * projected coordinate space.\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.worldExtent_ =\r\n      options.worldExtent !== undefined ? options.worldExtent : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.axisOrientation_ =\r\n      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.global_ = options.global !== undefined ? options.global : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.canWrapX_ = !!(this.global_ && this.extent_);\r\n\r\n    /**\r\n     * @private\r\n     * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\r\n     */\r\n    this.getPointResolutionFunc_ = options.getPointResolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.defaultTileGrid_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.metersPerUnit_ = options.metersPerUnit;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} The projection is suitable for wrapping the x-axis\r\n   */\r\n  canWrapX() {\r\n    return this.canWrapX_;\r\n  }\r\n\r\n  /**\r\n   * Get the code for this projection, e.g. 'EPSG:4326'.\r\n   * @return {string} Code.\r\n   * @api\r\n   */\r\n  getCode() {\r\n    return this.code_;\r\n  }\r\n\r\n  /**\r\n   * Get the validity extent for this projection.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return this.extent_;\r\n  }\r\n\r\n  /**\r\n   * Get the units of this projection.\r\n   * @return {import(\"./Units.js\").Units} Units.\r\n   * @api\r\n   */\r\n  getUnits() {\r\n    return this.units_;\r\n  }\r\n\r\n  /**\r\n   * Get the amount of meters per unit of this projection.  If the projection is\r\n   * not configured with `metersPerUnit` or a units identifier, the return is\r\n   * `undefined`.\r\n   * @return {number|undefined} Meters.\r\n   * @api\r\n   */\r\n  getMetersPerUnit() {\r\n    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\r\n  }\r\n\r\n  /**\r\n   * Get the world extent for this projection.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getWorldExtent() {\r\n    return this.worldExtent_;\r\n  }\r\n\r\n  /**\r\n   * Get the axis orientation of this projection.\r\n   * Example values are:\r\n   * enu - the default easting, northing, elevation.\r\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\r\n   *     or south orientated transverse mercator.\r\n   * wnu - westing, northing, up - some planetary coordinate systems have\r\n   *     \"west positive\" coordinate systems\r\n   * @return {string} Axis orientation.\r\n   * @api\r\n   */\r\n  getAxisOrientation() {\r\n    return this.axisOrientation_;\r\n  }\r\n\r\n  /**\r\n   * Is this projection a global projection which spans the whole world?\r\n   * @return {boolean} Whether the projection is global.\r\n   * @api\r\n   */\r\n  isGlobal() {\r\n    return this.global_;\r\n  }\r\n\r\n  /**\r\n   * Set if the projection is a global projection which spans the whole world\r\n   * @param {boolean} global Whether the projection is global.\r\n   * @api\r\n   */\r\n  setGlobal(global) {\r\n    this.global_ = global;\r\n    this.canWrapX_ = !!(global && this.extent_);\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\r\n   */\r\n  getDefaultTileGrid() {\r\n    return this.defaultTileGrid_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\r\n   */\r\n  setDefaultTileGrid(tileGrid) {\r\n    this.defaultTileGrid_ = tileGrid;\r\n  }\r\n\r\n  /**\r\n   * Set the validity extent for this projection.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @api\r\n   */\r\n  setExtent(extent) {\r\n    this.extent_ = extent;\r\n    this.canWrapX_ = !!(this.global_ && extent);\r\n  }\r\n\r\n  /**\r\n   * Set the world extent for this projection.\r\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\r\n   *     [minlon, minlat, maxlon, maxlat].\r\n   * @api\r\n   */\r\n  setWorldExtent(worldExtent) {\r\n    this.worldExtent_ = worldExtent;\r\n  }\r\n\r\n  /**\r\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\r\n   * for this projection.\r\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\r\n   * @api\r\n   */\r\n  setGetPointResolution(func) {\r\n    this.getPointResolutionFunc_ = func;\r\n  }\r\n\r\n  /**\r\n   * Get the custom point resolution function for this projection (if set).\r\n   * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\r\n   * resolution function (if set).\r\n   */\r\n  getPointResolutionFunc() {\r\n    return this.getPointResolutionFunc_;\r\n  }\r\n}\r\n\r\nexport default Projection;\r\n","/**\r\n * @module CME2D/proj/epsg3857\r\n */\r\nimport Projection from './Projection.js';\r\n\r\n/**\r\n * Radius of WGS84 sphere\r\n *\r\n * @const\r\n * @type {number}\r\n */\r\nexport const RADIUS = 6378137;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const HALF_SIZE = Math.PI * RADIUS;\r\n\r\n/**\r\n * @const\r\n * @type {import(\"../extent.js\").Extent}\r\n */\r\nexport const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\r\n\r\n/**\r\n * @const\r\n * @type {import(\"../extent.js\").Extent}\r\n */\r\nexport const WORLD_EXTENT = [-180, -85, 180, 85];\r\n\r\n/**\r\n * Maximum safe value in y direction\r\n * @const\r\n * @type {number}\r\n */\r\nexport const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\r\n\r\n/**\r\n * @classdesc\r\n * Projection object for web/spherical Mercator (EPSG:3857).\r\n */\r\nclass EPSG3857Projection extends Projection {\r\n  /**\r\n   * @param {string} code Code.\r\n   */\r\n  constructor(code) {\r\n    super({\r\n      code: code,\r\n      units: 'm',\r\n      extent: EXTENT,\r\n      global: true,\r\n      worldExtent: WORLD_EXTENT,\r\n      getPointResolution: function (resolution, point) {\r\n        return resolution / Math.cosh(point[1] / RADIUS);\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Projections equal to EPSG:3857.\r\n *\r\n * @const\r\n * @type {Array<import(\"./Projection.js\").default>}\r\n */\r\nexport const PROJECTIONS = [\r\n  new EPSG3857Projection('EPSG:3857'),\r\n  new EPSG3857Projection('EPSG:102100'),\r\n  new EPSG3857Projection('EPSG:102113'),\r\n  new EPSG3857Projection('EPSG:900913'),\r\n  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),\r\n  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),\r\n];\r\n\r\n/**\r\n * Transformation from EPSG:4326 to EPSG:3857.\r\n *\r\n * @param {Array<number>} input Input array of coordinate values.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @param {number} [dimension] Dimension (default is `2`).\r\n * @param {number} [stride] Stride (default is `dimension`).\r\n * @return {Array<number>} Output array of coordinate values.\r\n */\r\nexport function fromEPSG4326(input, output, dimension, stride) {\r\n  const length = input.length;\r\n  dimension = dimension > 1 ? dimension : 2;\r\n  stride = stride ?? dimension;\r\n  if (output === undefined) {\r\n    if (dimension > 2) {\r\n      // preserve values beyond second dimension\r\n      output = input.slice();\r\n    } else {\r\n      output = new Array(length);\r\n    }\r\n  }\r\n  for (let i = 0; i < length; i += stride) {\r\n    output[i] = (HALF_SIZE * input[i]) / 180;\r\n    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\r\n    if (y > MAX_SAFE_Y) {\r\n      y = MAX_SAFE_Y;\r\n    } else if (y < -MAX_SAFE_Y) {\r\n      y = -MAX_SAFE_Y;\r\n    }\r\n    output[i + 1] = y;\r\n  }\r\n  return output;\r\n}\r\n\r\n/**\r\n * Transformation from EPSG:3857 to EPSG:4326.\r\n *\r\n * @param {Array<number>} input Input array of coordinate values.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @param {number} [dimension] Dimension (default is `2`).\r\n * @param {number} [stride] Stride (default is `dimension`).\r\n * @return {Array<number>} Output array of coordinate values.\r\n */\r\nexport function toEPSG4326(input, output, dimension, stride) {\r\n  const length = input.length;\r\n  dimension = dimension > 1 ? dimension : 2;\r\n  stride = stride ?? dimension;\r\n  if (output === undefined) {\r\n    if (dimension > 2) {\r\n      // preserve values beyond second dimension\r\n      output = input.slice();\r\n    } else {\r\n      output = new Array(length);\r\n    }\r\n  }\r\n  for (let i = 0; i < length; i += stride) {\r\n    output[i] = (180 * input[i]) / HALF_SIZE;\r\n    output[i + 1] =\r\n      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\r\n  }\r\n  return output;\r\n}\r\n","/**\r\n * @module CME2D/proj/epsg4326\r\n */\r\nimport Projection from './Projection.js';\r\n\r\n/**\r\n * Semi-major radius of the WGS84 ellipsoid.\r\n *\r\n * @const\r\n * @type {number}\r\n */\r\nexport const RADIUS = 6378137;\r\n\r\n/**\r\n * Extent of the EPSG:4326 projection which is the whole world.\r\n *\r\n * @const\r\n * @type {import(\"../extent.js\").Extent}\r\n */\r\nexport const EXTENT = [-180, -90, 180, 90];\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;\r\n\r\n/**\r\n * @classdesc\r\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\r\n *\r\n * Note that OpenLayers does not strictly comply with the EPSG definition.\r\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\r\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\r\n */\r\nclass EPSG4326Projection extends Projection {\r\n  /**\r\n   * @param {string} code Code.\r\n   * @param {string} [axisOrientation] Axis orientation.\r\n   */\r\n  constructor(code, axisOrientation) {\r\n    super({\r\n      code: code,\r\n      units: 'degrees',\r\n      extent: EXTENT,\r\n      axisOrientation: axisOrientation,\r\n      global: true,\r\n      metersPerUnit: METERS_PER_UNIT,\r\n      worldExtent: EXTENT,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Projections equal to EPSG:4326.\r\n *\r\n * @const\r\n * @type {Array<import(\"./Projection.js\").default>}\r\n */\r\nexport const PROJECTIONS = [\r\n  new EPSG4326Projection('CRS:84'),\r\n  new EPSG4326Projection('EPSG:4326', 'neu'),\r\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\r\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\r\n  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),\r\n  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\r\n  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),\r\n];\r\n","/**\r\n * @module CME2D/proj/projections\r\n */\r\n\r\n/**\r\n * @type {Object<string, import(\"./Projection.js\").default>}\r\n */\r\nlet cache = {};\r\n\r\n/**\r\n * Clear the projections cache.\r\n */\r\nexport function clear() {\r\n  cache = {};\r\n}\r\n\r\n/**\r\n * Get a cached projection by code.\r\n * @param {string} code The code for the projection.\r\n * @return {import(\"./Projection.js\").default} The projection (if cached).\r\n */\r\nexport function get(code) {\r\n  return (\r\n    cache[code] ||\r\n    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] ||\r\n    null\r\n  );\r\n}\r\n\r\n/**\r\n * Add a projection to the cache.\r\n * @param {string} code The projection code.\r\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\r\n */\r\nexport function add(code, projection) {\r\n  cache[code] = projection;\r\n}\r\n","/**\r\n * @module CME2D/proj/transforms\r\n */\r\nimport {isEmpty} from '../obj.js';\r\n\r\n/**\r\n * @private\r\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\r\n */\r\nlet transforms = {};\r\n\r\n/**\r\n * Clear the transform cache.\r\n */\r\nexport function clear() {\r\n  transforms = {};\r\n}\r\n\r\n/**\r\n * Registers a conversion function to convert coordinates from the source\r\n * projection to the destination projection.\r\n *\r\n * @param {import(\"./Projection.js\").default} source Source.\r\n * @param {import(\"./Projection.js\").default} destination Destination.\r\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\r\n */\r\nexport function add(source, destination, transformFn) {\r\n  const sourceCode = source.getCode();\r\n  const destinationCode = destination.getCode();\r\n  if (!(sourceCode in transforms)) {\r\n    transforms[sourceCode] = {};\r\n  }\r\n  transforms[sourceCode][destinationCode] = transformFn;\r\n}\r\n\r\n/**\r\n * Unregisters the conversion function to convert coordinates from the source\r\n * projection to the destination projection.  This method is used to clean up\r\n * cached transforms during testing.\r\n *\r\n * @param {import(\"./Projection.js\").default} source Source projection.\r\n * @param {import(\"./Projection.js\").default} destination Destination projection.\r\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\r\n */\r\nexport function remove(source, destination) {\r\n  const sourceCode = source.getCode();\r\n  const destinationCode = destination.getCode();\r\n  const transform = transforms[sourceCode][destinationCode];\r\n  delete transforms[sourceCode][destinationCode];\r\n  if (isEmpty(transforms[sourceCode])) {\r\n    delete transforms[sourceCode];\r\n  }\r\n  return transform;\r\n}\r\n\r\n/**\r\n * Get a transform given a source code and a destination code.\r\n * @param {string} sourceCode The code for the source projection.\r\n * @param {string} destinationCode The code for the destination projection.\r\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\r\n */\r\nexport function get(sourceCode, destinationCode) {\r\n  let transform;\r\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\r\n    transform = transforms[sourceCode][destinationCode];\r\n  }\r\n  return transform;\r\n}\r\n","/**\r\n * @module CME2D/math\r\n */\r\n\r\n/**\r\n * Takes a number and clamps it to within the provided bounds.\r\n * @param {number} value The input number.\r\n * @param {number} min The minimum value to return.\r\n * @param {number} max The maximum value to return.\r\n * @return {number} The input number if it is within bounds, or the nearest\r\n *     number within the bounds.\r\n */\r\nexport function clamp(value, min, max) {\r\n  return Math.min(Math.max(value, min), max);\r\n}\r\n\r\n/**\r\n * Returns the square of the closest distance between the point (x, y) and the\r\n * line segment (x1, y1) to (x2, y2).\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {number} x1 X1.\r\n * @param {number} y1 Y1.\r\n * @param {number} x2 X2.\r\n * @param {number} y2 Y2.\r\n * @return {number} Squared distance.\r\n */\r\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  if (dx !== 0 || dy !== 0) {\r\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\r\n    if (t > 1) {\r\n      x1 = x2;\r\n      y1 = y2;\r\n    } else if (t > 0) {\r\n      x1 += dx * t;\r\n      y1 += dy * t;\r\n    }\r\n  }\r\n  return squaredDistance(x, y, x1, y1);\r\n}\r\n\r\n/**\r\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\r\n * @param {number} x1 X1.\r\n * @param {number} y1 Y1.\r\n * @param {number} x2 X2.\r\n * @param {number} y2 Y2.\r\n * @return {number} Squared distance.\r\n */\r\nexport function squaredDistance(x1, y1, x2, y2) {\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Solves system of linear equations using Gaussian elimination method.\r\n *\r\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\r\n *                                     in row-major order.\r\n * @return {Array<number>|null} The resulting vector.\r\n */\r\nexport function solveLinearSystem(mat) {\r\n  const n = mat.length;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    // Find max in the i-th column (ignoring i - 1 first rows)\r\n    let maxRow = i;\r\n    let maxEl = Math.abs(mat[i][i]);\r\n    for (let r = i + 1; r < n; r++) {\r\n      const absValue = Math.abs(mat[r][i]);\r\n      if (absValue > maxEl) {\r\n        maxEl = absValue;\r\n        maxRow = r;\r\n      }\r\n    }\r\n\r\n    if (maxEl === 0) {\r\n      return null; // matrix is singular\r\n    }\r\n\r\n    // Swap max row with i-th (current) row\r\n    const tmp = mat[maxRow];\r\n    mat[maxRow] = mat[i];\r\n    mat[i] = tmp;\r\n\r\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\r\n    for (let j = i + 1; j < n; j++) {\r\n      const coef = -mat[j][i] / mat[i][i];\r\n      for (let k = i; k < n + 1; k++) {\r\n        if (i == k) {\r\n          mat[j][k] = 0;\r\n        } else {\r\n          mat[j][k] += coef * mat[i][k];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Solve Ax=b for upper triangular matrix A (mat)\r\n  const x = new Array(n);\r\n  for (let l = n - 1; l >= 0; l--) {\r\n    x[l] = mat[l][n] / mat[l][l];\r\n    for (let m = l - 1; m >= 0; m--) {\r\n      mat[m][n] -= mat[m][l] * x[l];\r\n    }\r\n  }\r\n  return x;\r\n}\r\n\r\n/**\r\n * Converts radians to to degrees.\r\n *\r\n * @param {number} angleInRadians Angle in radians.\r\n * @return {number} Angle in degrees.\r\n */\r\nexport function toDegrees(angleInRadians) {\r\n  return (angleInRadians * 180) / Math.PI;\r\n}\r\n\r\n/**\r\n * Converts degrees to radians.\r\n *\r\n * @param {number} angleInDegrees Angle in degrees.\r\n * @return {number} Angle in radians.\r\n */\r\nexport function toRadians(angleInDegrees) {\r\n  return (angleInDegrees * Math.PI) / 180;\r\n}\r\n\r\n/**\r\n * Returns the modulo of a / b, depending on the sign of b.\r\n *\r\n * @param {number} a Dividend.\r\n * @param {number} b Divisor.\r\n * @return {number} Modulo.\r\n */\r\nexport function modulo(a, b) {\r\n  const r = a % b;\r\n  return r * b < 0 ? r + b : r;\r\n}\r\n\r\n/**\r\n * Calculates the linearly interpolated value of x between a and b.\r\n *\r\n * @param {number} a Number\r\n * @param {number} b Number\r\n * @param {number} x Value to be interpolated.\r\n * @return {number} Interpolated value.\r\n */\r\nexport function lerp(a, b, x) {\r\n  return a + x * (b - a);\r\n}\r\n\r\n/**\r\n * Returns a number with a limited number of decimal digits.\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The input number with a limited number of decimal digits.\r\n */\r\nexport function toFixed(n, decimals) {\r\n  const factor = Math.pow(10, decimals);\r\n  return Math.round(n * factor) / factor;\r\n}\r\n\r\n/**\r\n * Rounds a number to the nearest integer value considering only the given number\r\n * of decimal digits (with rounding on the final digit).\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The nearest integer.\r\n */\r\nexport function round(n, decimals) {\r\n  return Math.round(toFixed(n, decimals));\r\n}\r\n\r\n/**\r\n * Rounds a number to the next smaller integer considering only the given number\r\n * of decimal digits (with rounding on the final digit).\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The next smaller integer.\r\n */\r\nexport function floor(n, decimals) {\r\n  return Math.floor(toFixed(n, decimals));\r\n}\r\n\r\n/**\r\n * Rounds a number to the next bigger integer considering only the given number\r\n * of decimal digits (with rounding on the final digit).\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The next bigger integer.\r\n */\r\nexport function ceil(n, decimals) {\r\n  return Math.ceil(toFixed(n, decimals));\r\n}\r\n","/**\r\n * @module CME2D/coordinate\r\n */\r\nimport {getWidth} from './extent.js';\r\nimport {modulo, toFixed} from './math.js';\r\nimport {padNumber} from './string.js';\r\n\r\n/**\r\n * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.\r\n * Example: `[16, 48]`.\r\n * @typedef {Array<number>} Coordinate\r\n * @api\r\n */\r\n\r\n/**\r\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\r\n * transforms it into a `{string}`.\r\n *\r\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\r\n * @api\r\n */\r\n\r\n/**\r\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\r\n * by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {add} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     add(coord, [-2, 4]);\r\n *     // coord is now [5.85, 51.983333]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {Coordinate} delta Delta.\r\n * @return {Coordinate} The input coordinate adjusted by\r\n * the given delta.\r\n * @api\r\n */\r\nexport function add(coordinate, delta) {\r\n  coordinate[0] += +delta[0];\r\n  coordinate[1] += +delta[1];\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Calculates the point closest to the passed coordinate on the passed circle.\r\n *\r\n * @param {Coordinate} coordinate The coordinate.\r\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\r\n * @return {Coordinate} Closest point on the circumference.\r\n */\r\nexport function closestOnCircle(coordinate, circle) {\r\n  const r = circle.getRadius();\r\n  const center = circle.getCenter();\r\n  const x0 = center[0];\r\n  const y0 = center[1];\r\n  const x1 = coordinate[0];\r\n  const y1 = coordinate[1];\r\n\r\n  let dx = x1 - x0;\r\n  const dy = y1 - y0;\r\n  if (dx === 0 && dy === 0) {\r\n    dx = 1;\r\n  }\r\n  const d = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  const x = x0 + (r * dx) / d;\r\n  const y = y0 + (r * dy) / d;\r\n\r\n  return [x, y];\r\n}\r\n\r\n/**\r\n * Calculates the point closest to the passed coordinate on the passed segment.\r\n * This is the foot of the perpendicular of the coordinate to the segment when\r\n * the foot is on the segment, or the closest segment coordinate when the foot\r\n * is outside the segment.\r\n *\r\n * @param {Coordinate} coordinate The coordinate.\r\n * @param {Array<Coordinate>} segment The two coordinates\r\n * of the segment.\r\n * @return {Coordinate} The foot of the perpendicular of\r\n * the coordinate to the segment.\r\n */\r\nexport function closestOnSegment(coordinate, segment) {\r\n  const x0 = coordinate[0];\r\n  const y0 = coordinate[1];\r\n  const start = segment[0];\r\n  const end = segment[1];\r\n  const x1 = start[0];\r\n  const y1 = start[1];\r\n  const x2 = end[0];\r\n  const y2 = end[1];\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  const along =\r\n    dx === 0 && dy === 0\r\n      ? 0\r\n      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\r\n  let x, y;\r\n  if (along <= 0) {\r\n    x = x1;\r\n    y = y1;\r\n  } else if (along >= 1) {\r\n    x = x2;\r\n    y = y2;\r\n  } else {\r\n    x = x1 + along * dx;\r\n    y = y1 + along * dy;\r\n  }\r\n  return [x, y];\r\n}\r\n\r\n/**\r\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\r\n * used to format\r\n * a {Coordinate} to a string.\r\n *\r\n * Example without specifying the fractional digits:\r\n *\r\n *     import {createStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const stringifyFunc = createStringXY();\r\n *     const out = stringifyFunc(coord);\r\n *     // out is now '8, 48'\r\n *\r\n * Example with explicitly specifying 2 fractional digits:\r\n *\r\n *     import {createStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const stringifyFunc = createStringXY(2);\r\n *     const out = stringifyFunc(coord);\r\n *     // out is now '7.85, 47.98'\r\n *\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {CoordinateFormat} Coordinate format.\r\n * @api\r\n */\r\nexport function createStringXY(fractionDigits) {\r\n  return (\r\n    /**\r\n     * @param {Coordinate} coordinate Coordinate.\r\n     * @return {string} String XY.\r\n     */\r\n    function (coordinate) {\r\n      return toStringXY(coordinate, fractionDigits);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {string} hemispheres Hemispheres.\r\n * @param {number} degrees Degrees.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} String.\r\n */\r\nexport function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\r\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\r\n  const x = Math.abs(3600 * normalizedDegrees);\r\n  const decimals = fractionDigits || 0;\r\n\r\n  let deg = Math.floor(x / 3600);\r\n  let min = Math.floor((x - deg * 3600) / 60);\r\n  let sec = toFixed(x - deg * 3600 - min * 60, decimals);\r\n\r\n  if (sec >= 60) {\r\n    sec = 0;\r\n    min += 1;\r\n  }\r\n\r\n  if (min >= 60) {\r\n    min = 0;\r\n    deg += 1;\r\n  }\r\n\r\n  let hdms = deg + '\\u00b0';\r\n  if (min !== 0 || sec !== 0) {\r\n    hdms += ' ' + padNumber(min, 2) + '\\u2032';\r\n  }\r\n  if (sec !== 0) {\r\n    hdms += ' ' + padNumber(sec, 2, decimals) + '\\u2033';\r\n  }\r\n  if (normalizedDegrees !== 0) {\r\n    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\r\n  }\r\n\r\n  return hdms;\r\n}\r\n\r\n/**\r\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\r\n * using the given string template. The strings `{x}` and `{y}` in the template\r\n * will be replaced with the first and second coordinate values respectively.\r\n *\r\n * Example without specifying the fractional digits:\r\n *\r\n *     import {format} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const template = 'Coordinate is ({x}|{y}).';\r\n *     const out = format(coord, template);\r\n *     // out is now 'Coordinate is (8|48).'\r\n *\r\n * Example explicitly specifying the fractional digits:\r\n *\r\n *     import {format} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const template = 'Coordinate is ({x}|{y}).';\r\n *     const out = format(coord, template, 2);\r\n *     // out is now 'Coordinate is (7.85|47.98).'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {string} template A template string with `{x}` and `{y}` placeholders\r\n *     that will be replaced by first and second coordinate values.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} Formatted coordinate.\r\n * @api\r\n */\r\nexport function format(coordinate, template, fractionDigits) {\r\n  if (coordinate) {\r\n    return template\r\n      .replace('{x}', coordinate[0].toFixed(fractionDigits))\r\n      .replace('{y}', coordinate[1].toFixed(fractionDigits));\r\n  }\r\n  return '';\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coordinate1 First coordinate.\r\n * @param {Coordinate} coordinate2 Second coordinate.\r\n * @return {boolean} The two coordinates are equal.\r\n */\r\nexport function equals(coordinate1, coordinate2) {\r\n  let equals = true;\r\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\r\n    if (coordinate1[i] != coordinate2[i]) {\r\n      equals = false;\r\n      break;\r\n    }\r\n  }\r\n  return equals;\r\n}\r\n\r\n/**\r\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\r\n * returned by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {rotate} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const rotateRadians = Math.PI / 2; // 90 degrees\r\n *     rotate(coord, rotateRadians);\r\n *     // coord is now [-47.983333, 7.85]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} angle Angle in radian.\r\n * @return {Coordinate} Coordinate.\r\n * @api\r\n */\r\nexport function rotate(coordinate, angle) {\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\r\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\r\n  coordinate[0] = x;\r\n  coordinate[1] = y;\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\r\n * by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {scale as scaleCoordinate} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const scale = 1.2;\r\n *     scaleCoordinate(coord, scale);\r\n *     // coord is now [9.42, 57.5799996]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} scale Scale factor.\r\n * @return {Coordinate} Coordinate.\r\n */\r\nexport function scale(coordinate, scale) {\r\n  coordinate[0] *= scale;\r\n  coordinate[1] *= scale;\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coord1 First coordinate.\r\n * @param {Coordinate} coord2 Second coordinate.\r\n * @return {number} Squared distance between coord1 and coord2.\r\n */\r\nexport function squaredDistance(coord1, coord2) {\r\n  const dx = coord1[0] - coord2[0];\r\n  const dy = coord1[1] - coord2[1];\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coord1 First coordinate.\r\n * @param {Coordinate} coord2 Second coordinate.\r\n * @return {number} Distance between coord1 and coord2.\r\n */\r\nexport function distance(coord1, coord2) {\r\n  return Math.sqrt(squaredDistance(coord1, coord2));\r\n}\r\n\r\n/**\r\n * Calculate the squared distance from a coordinate to a line segment.\r\n *\r\n * @param {Coordinate} coordinate Coordinate of the point.\r\n * @param {Array<Coordinate>} segment Line segment (2\r\n * coordinates).\r\n * @return {number} Squared distance from the point to the line segment.\r\n */\r\nexport function squaredDistanceToSegment(coordinate, segment) {\r\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\r\n}\r\n\r\n/**\r\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\r\n * seconds.\r\n *\r\n * Example without specifying fractional digits:\r\n *\r\n *     import {toStringHDMS} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringHDMS(coord);\r\n *     // out is now '47 58 60 N 7 50 60 E'\r\n *\r\n * Example explicitly specifying 1 fractional digit:\r\n *\r\n *     import {toStringHDMS} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringHDMS(coord, 1);\r\n *     // out is now '47 58 60.0 N 7 50 60.0 E'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} Hemisphere, degrees, minutes and seconds.\r\n * @api\r\n */\r\nexport function toStringHDMS(coordinate, fractionDigits) {\r\n  if (coordinate) {\r\n    return (\r\n      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +\r\n      ' ' +\r\n      degreesToStringHDMS('EW', coordinate[0], fractionDigits)\r\n    );\r\n  }\r\n  return '';\r\n}\r\n\r\n/**\r\n * Format a coordinate as a comma delimited string.\r\n *\r\n * Example without specifying fractional digits:\r\n *\r\n *     import {toStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringXY(coord);\r\n *     // out is now '8, 48'\r\n *\r\n * Example explicitly specifying 1 fractional digit:\r\n *\r\n *     import {toStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringXY(coord, 1);\r\n *     // out is now '7.8, 48.0'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} XY.\r\n * @api\r\n */\r\nexport function toStringXY(coordinate, fractionDigits) {\r\n  return format(coordinate, '{x}, {y}', fractionDigits);\r\n}\r\n\r\n/**\r\n * Modifies the provided coordinate in-place to be within the real world\r\n * extent. The lower projection extent boundary is inclusive, the upper one\r\n * exclusive.\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {Coordinate} The coordinate within the real world extent.\r\n */\r\nexport function wrapX(coordinate, projection) {\r\n  if (projection.canWrapX()) {\r\n    const worldWidth = getWidth(projection.getExtent());\r\n    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\r\n    if (worldsAway) {\r\n      coordinate[0] -= worldsAway * worldWidth;\r\n    }\r\n  }\r\n  return coordinate;\r\n}\r\n/**\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @param {number} [sourceExtentWidth] Width of the source extent.\r\n * @return {number} Offset in world widths.\r\n */\r\nexport function getWorldsAway(coordinate, projection, sourceExtentWidth) {\r\n  const projectionExtent = projection.getExtent();\r\n  let worldsAway = 0;\r\n  if (\r\n    projection.canWrapX() &&\r\n    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])\r\n  ) {\r\n    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);\r\n    worldsAway = Math.floor(\r\n      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth,\r\n    );\r\n  }\r\n  return worldsAway;\r\n}\r\n","/**\r\n * @module CME2D/sphere\r\n */\r\nimport {toDegrees, toRadians} from './math.js';\r\n\r\n/**\r\n * Object literal with options for the {@link getLength} or {@link getArea}\r\n * functions.\r\n * @typedef {Object} SphereMetricOptions\r\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\r\n * Projection of the  geometry.  By default, the geometry is assumed to be in\r\n * Web Mercator.\r\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\r\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\r\n * for the WGS84 ellipsoid is used.\r\n */\r\n\r\n/**\r\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\r\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\r\n * @type {number}\r\n */\r\nexport const DEFAULT_RADIUS = 6371008.8;\r\n\r\n/**\r\n * Get the great circle distance (in meters) between two geographic coordinates.\r\n * @param {Array} c1 Starting coordinate.\r\n * @param {Array} c2 Ending coordinate.\r\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\r\n *     mean radius using the WGS84 ellipsoid.\r\n * @return {number} The great circle distance between the points (in meters).\r\n * @api\r\n */\r\nexport function getDistance(c1, c2, radius) {\r\n  radius = radius || DEFAULT_RADIUS;\r\n  const lat1 = toRadians(c1[1]);\r\n  const lat2 = toRadians(c2[1]);\r\n  const deltaLatBy2 = (lat2 - lat1) / 2;\r\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\r\n  const a =\r\n    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\r\n    Math.sin(deltaLonBy2) *\r\n      Math.sin(deltaLonBy2) *\r\n      Math.cos(lat1) *\r\n      Math.cos(lat2);\r\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n}\r\n\r\n/**\r\n * Get the cumulative great circle length of linestring coordinates (geographic).\r\n * @param {Array} coordinates Linestring coordinates.\r\n * @param {number} radius The sphere radius to use.\r\n * @return {number} The length (in meters).\r\n */\r\nfunction getLengthInternal(coordinates, radius) {\r\n  let length = 0;\r\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\r\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\r\n  }\r\n  return length;\r\n}\r\n\r\n/**\r\n * Get the spherical length of a geometry.  This length is the sum of the\r\n * great circle distances between coordinates.  For polygons, the length is\r\n * the sum of all rings.  For points, the length is zero.  For multi-part\r\n * geometries, the length is the sum of the length of each part.\r\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\r\n * @param {SphereMetricOptions} [options] Options for the\r\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\r\n * You can change this by providing a `projection` option.\r\n * @return {number} The spherical length (in meters).\r\n * @api\r\n */\r\nexport function getLength(geometry, options) {\r\n  options = options || {};\r\n  const radius = options.radius || DEFAULT_RADIUS;\r\n  const projection = options.projection || 'EPSG:3857';\r\n  const type = geometry.getType();\r\n  if (type !== 'GeometryCollection') {\r\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\r\n  }\r\n  let length = 0;\r\n  let coordinates, coords, i, ii, j, jj;\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint': {\r\n      break;\r\n    }\r\n    case 'LineString':\r\n    case 'LinearRing': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      length = getLengthInternal(coordinates, radius);\r\n      break;\r\n    }\r\n    case 'MultiLineString':\r\n    case 'Polygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        length += getLengthInternal(coordinates[i], radius);\r\n      }\r\n      break;\r\n    }\r\n    case 'MultiPolygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coords = coordinates[i];\r\n        for (j = 0, jj = coords.length; j < jj; ++j) {\r\n          length += getLengthInternal(coords[j], radius);\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 'GeometryCollection': {\r\n      const geometries =\r\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries();\r\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\r\n        length += getLength(geometries[i], options);\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error('Unsupported geometry type: ' + type);\r\n    }\r\n  }\r\n  return length;\r\n}\r\n\r\n/**\r\n * Returns the spherical area for a list of coordinates.\r\n *\r\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\r\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\r\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\r\n * Laboratory, Pasadena, CA, June 2007\r\n *\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\r\n * ring. If the ring is oriented clockwise, the area will be positive,\r\n * otherwise it will be negative.\r\n * @param {number} radius The sphere radius.\r\n * @return {number} Area (in square meters).\r\n */\r\nfunction getAreaInternal(coordinates, radius) {\r\n  let area = 0;\r\n  const len = coordinates.length;\r\n  let x1 = coordinates[len - 1][0];\r\n  let y1 = coordinates[len - 1][1];\r\n  for (let i = 0; i < len; i++) {\r\n    const x2 = coordinates[i][0];\r\n    const y2 = coordinates[i][1];\r\n    area +=\r\n      toRadians(x2 - x1) *\r\n      (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return (area * radius * radius) / 2.0;\r\n}\r\n\r\n/**\r\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\r\n * that polygon edges are segments of great circles on a sphere.\r\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\r\n * @param {SphereMetricOptions} [options] Options for the area\r\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\r\n *     You can change this by providing a `projection` option.\r\n * @return {number} The spherical area (in square meters).\r\n * @api\r\n */\r\nexport function getArea(geometry, options) {\r\n  options = options || {};\r\n  const radius = options.radius || DEFAULT_RADIUS;\r\n  const projection = options.projection || 'EPSG:3857';\r\n  const type = geometry.getType();\r\n  if (type !== 'GeometryCollection') {\r\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\r\n  }\r\n  let area = 0;\r\n  let coordinates, coords, i, ii, j, jj;\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n    case 'LineString':\r\n    case 'MultiLineString':\r\n    case 'LinearRing': {\r\n      break;\r\n    }\r\n    case 'Polygon': {\r\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\r\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\r\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\r\n      }\r\n      break;\r\n    }\r\n    case 'MultiPolygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coords = coordinates[i];\r\n        area += Math.abs(getAreaInternal(coords[0], radius));\r\n        for (j = 1, jj = coords.length; j < jj; ++j) {\r\n          area -= Math.abs(getAreaInternal(coords[j], radius));\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 'GeometryCollection': {\r\n      const geometries =\r\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries();\r\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\r\n        area += getArea(geometries[i], options);\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error('Unsupported geometry type: ' + type);\r\n    }\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * Returns the coordinate at the given distance and bearing from `c1`.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\r\n * @param {number} distance The great-circle distance between the origin\r\n *     point and the target point.\r\n * @param {number} bearing The bearing (in radians).\r\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\r\n *     mean radius using the WGS84 ellipsoid.\r\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\r\n */\r\nexport function offset(c1, distance, bearing, radius) {\r\n  radius = radius || DEFAULT_RADIUS;\r\n  const lat1 = toRadians(c1[1]);\r\n  const lon1 = toRadians(c1[0]);\r\n  const dByR = distance / radius;\r\n  const lat = Math.asin(\r\n    Math.sin(lat1) * Math.cos(dByR) +\r\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing),\r\n  );\r\n  const lon =\r\n    lon1 +\r\n    Math.atan2(\r\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\r\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat),\r\n    );\r\n  return [toDegrees(lon), toDegrees(lat)];\r\n}\r\n","/**\r\n * @module CME2D/console\r\n */\r\n\r\n/**\r\n * @typedef {'info'|'warn'|'error'|'none'} Level\r\n */\r\n\r\n/**\r\n * @type {Object<Level, number>}\r\n */\r\nconst levels = {\r\n  info: 1,\r\n  warn: 2,\r\n  error: 3,\r\n  none: 4,\r\n};\r\n\r\n/**\r\n * @type {number}\r\n */\r\nlet level = levels.info;\r\n\r\n/**\r\n * Set the logging level.  By default, the level is set to 'info' and all\r\n * messages will be logged.  Set to 'warn' to only display warnings and errors.\r\n * Set to 'error' to only display errors.  Set to 'none' to silence all messages.\r\n *\r\n * @param {Level} l The new level.\r\n */\r\nexport function setLevel(l) {\r\n  level = levels[l];\r\n}\r\n\r\n/**\r\n * @param  {...any} args Arguments to log\r\n */\r\nexport function log(...args) {\r\n  if (level > levels.info) {\r\n    return;\r\n  }\r\n  console.log(...args); // eslint-disable-line no-console\r\n}\r\n\r\n/**\r\n * @param  {...any} args Arguments to log\r\n */\r\nexport function warn(...args) {\r\n  if (level > levels.warn) {\r\n    return;\r\n  }\r\n  console.warn(...args); // eslint-disable-line no-console\r\n}\r\n\r\n/**\r\n * @param  {...any} args Arguments to log\r\n */\r\nexport function error(...args) {\r\n  if (level > levels.error) {\r\n    return;\r\n  }\r\n  console.error(...args); // eslint-disable-line no-console\r\n}\r\n","/**\r\n * @module CME2D/proj\r\n */\r\n\r\n/**\r\n * The ol/proj module stores:\r\n * * a list of {@link module:ol/proj/Projection~Projection}\r\n * objects, one for each projection supported by the application\r\n * * a list of transform functions needed to convert coordinates in one projection\r\n * into another.\r\n *\r\n * The static functions are the methods used to maintain these.\r\n * Each transform function can handle not only simple coordinate pairs, but also\r\n * large arrays of coordinates such as vector geometries.\r\n *\r\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\r\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\r\n * for example by Bing Maps or OpenStreetMap), together with the relevant\r\n * transform functions.\r\n *\r\n * Additional transforms may be added by using the http://proj4js.org/\r\n * library (version 2.2 or later). You can use the full build supplied by\r\n * Proj4js, or create a custom build to support those projections you need; see\r\n * the Proj4js website for how to do this. You also need the Proj4js definitions\r\n * for the required projections. These definitions can be obtained from\r\n * https://epsg.io/, and are a JS function, so can be loaded in a script\r\n * tag (as in the examples) or pasted into your application.\r\n *\r\n * After all required projection definitions are added to proj4's registry (by\r\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\r\n * package. Existing transforms are not changed by this function. See\r\n * examples/wms-image-custom-proj for an example of this.\r\n *\r\n * Additional projection definitions can be registered with `proj4.defs()` any\r\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\r\n * know in advance what projections are needed, you can initially load minimal\r\n * support and then load whichever are requested.\r\n *\r\n * Note that Proj4js does not support projection extents. If you want to add\r\n * one for creating default tile grids, you can add it after the Projection\r\n * object has been created with `setExtent`, for example,\r\n * `get('EPSG:1234').setExtent(extent)`.\r\n *\r\n * In addition to Proj4js support, any transform functions can be added with\r\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\r\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\r\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\r\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\r\n * examples/wms-custom-proj for an example of this.\r\n *\r\n * Note that if no transforms are needed and you only need to define the\r\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\r\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\r\n * this.\r\n */\r\nimport Projection from './proj/Projection.js';\r\nimport {\r\n  PROJECTIONS as EPSG3857_PROJECTIONS,\r\n  fromEPSG4326,\r\n  toEPSG4326,\r\n} from './proj/epsg3857.js';\r\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\r\nimport {METERS_PER_UNIT} from './proj/Units.js';\r\nimport {\r\n  add as addProj,\r\n  clear as clearProj,\r\n  get as getProj,\r\n} from './proj/projections.js';\r\nimport {\r\n  add as addTransformFunc,\r\n  clear as clearTransformFuncs,\r\n  get as getTransformFunc,\r\n} from './proj/transforms.js';\r\nimport {applyTransform, getWidth} from './extent.js';\r\nimport {clamp, modulo} from './math.js';\r\nimport {equals, getWorldsAway} from './coordinate.js';\r\nimport {getDistance} from './sphere.js';\r\nimport {warn} from './console.js';\r\n\r\n/**\r\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\r\n * string or undefined.\r\n * @typedef {Projection|string|undefined} ProjectionLike\r\n * @api\r\n */\r\n\r\n/**\r\n * A transform function accepts an array of input coordinate values, an optional\r\n * output array, and an optional dimension (default should be 2).  The function\r\n * transforms the input coordinate values, populates the output array, and\r\n * returns the output array.\r\n *\r\n * @typedef {function(Array<number>, Array<number>=, number=, number=): Array<number>} TransformFunction\r\n * @api\r\n */\r\n\r\nexport {METERS_PER_UNIT};\r\n\r\nexport {Projection};\r\n\r\nlet showCoordinateWarning = true;\r\n\r\n/**\r\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\r\n */\r\nexport function disableCoordinateWarning(disable) {\r\n  const hide = disable === undefined ? true : disable;\r\n  showCoordinateWarning = !hide;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} input Input coordinate array.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @return {Array<number>} Output coordinate array (new array, same coordinate\r\n *     values).\r\n */\r\nexport function cloneTransform(input, output) {\r\n  if (output !== undefined) {\r\n    for (let i = 0, ii = input.length; i < ii; ++i) {\r\n      output[i] = input[i];\r\n    }\r\n    output = output;\r\n  } else {\r\n    output = input.slice();\r\n  }\r\n  return output;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} input Input coordinate array.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @return {Array<number>} Input coordinate array (same array as input).\r\n */\r\nexport function identityTransform(input, output) {\r\n  if (output !== undefined && input !== output) {\r\n    for (let i = 0, ii = input.length; i < ii; ++i) {\r\n      output[i] = input[i];\r\n    }\r\n    input = output;\r\n  }\r\n  return input;\r\n}\r\n\r\n/**\r\n * Add a Projection object to the list of supported projections that can be\r\n * looked up by their code.\r\n *\r\n * @param {Projection} projection Projection instance.\r\n * @api\r\n */\r\nexport function addProjection(projection) {\r\n  addProj(projection.getCode(), projection);\r\n  addTransformFunc(projection, projection, cloneTransform);\r\n}\r\n\r\n/**\r\n * @param {Array<Projection>} projections Projections.\r\n */\r\nexport function addProjections(projections) {\r\n  projections.forEach(addProjection);\r\n}\r\n\r\n/**\r\n * Fetches a Projection object for the code specified.\r\n *\r\n * @param {ProjectionLike} projectionLike Either a code string which is\r\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\r\n *     existing projection object, or undefined.\r\n * @return {Projection|null} Projection object, or null if not in list.\r\n * @api\r\n */\r\nexport function get(projectionLike) {\r\n  return typeof projectionLike === 'string'\r\n    ? getProj(/** @type {string} */ (projectionLike))\r\n    : /** @type {Projection} */ (projectionLike) || null;\r\n}\r\n\r\n/**\r\n * Get the resolution of the point in degrees or distance units.\r\n * For projections with degrees as the unit this will simply return the\r\n * provided resolution. For other projections the point resolution is\r\n * by default estimated by transforming the `point` pixel to EPSG:4326,\r\n * measuring its width and height on the normal sphere,\r\n * and taking the average of the width and height.\r\n * A custom function can be provided for a specific projection, either\r\n * by setting the `getPointResolution` option in the\r\n * {@link module:ol/proj/Projection~Projection} constructor or by using\r\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\r\n * projection object.\r\n * @param {ProjectionLike} projection The projection.\r\n * @param {number} resolution Nominal resolution in projection units.\r\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\r\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\r\n * Default is the projection's units.\r\n * @return {number} Point resolution.\r\n * @api\r\n */\r\nexport function getPointResolution(projection, resolution, point, units) {\r\n  projection = get(projection);\r\n  let pointResolution;\r\n  const getter = projection.getPointResolutionFunc();\r\n  if (getter) {\r\n    pointResolution = getter(resolution, point);\r\n    if (units && units !== projection.getUnits()) {\r\n      const metersPerUnit = projection.getMetersPerUnit();\r\n      if (metersPerUnit) {\r\n        pointResolution =\r\n          (pointResolution * metersPerUnit) / METERS_PER_UNIT[units];\r\n      }\r\n    }\r\n  } else {\r\n    const projUnits = projection.getUnits();\r\n    if ((projUnits == 'degrees' && !units) || units == 'degrees') {\r\n      pointResolution = resolution;\r\n    } else {\r\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\r\n      // measuring its width and height on the normal sphere, and taking the\r\n      // average of the width and height.\r\n      const toEPSG4326 = getTransformFromProjections(\r\n        projection,\r\n        get('EPSG:4326'),\r\n      );\r\n      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {\r\n        // no transform is available\r\n        pointResolution = resolution * projection.getMetersPerUnit();\r\n      } else {\r\n        let vertices = [\r\n          point[0] - resolution / 2,\r\n          point[1],\r\n          point[0] + resolution / 2,\r\n          point[1],\r\n          point[0],\r\n          point[1] - resolution / 2,\r\n          point[0],\r\n          point[1] + resolution / 2,\r\n        ];\r\n        vertices = toEPSG4326(vertices, vertices, 2);\r\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\r\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\r\n        pointResolution = (width + height) / 2;\r\n      }\r\n      const metersPerUnit = units\r\n        ? METERS_PER_UNIT[units]\r\n        : projection.getMetersPerUnit();\r\n      if (metersPerUnit !== undefined) {\r\n        pointResolution /= metersPerUnit;\r\n      }\r\n    }\r\n  }\r\n  return pointResolution;\r\n}\r\n\r\n/**\r\n * Registers transformation functions that don't alter coordinates. Those allow\r\n * to transform between projections with equal meaning.\r\n *\r\n * @param {Array<Projection>} projections Projections.\r\n * @api\r\n */\r\nexport function addEquivalentProjections(projections) {\r\n  addProjections(projections);\r\n  projections.forEach(function (source) {\r\n    projections.forEach(function (destination) {\r\n      if (source !== destination) {\r\n        addTransformFunc(source, destination, cloneTransform);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Registers transformation functions to convert coordinates in any projection\r\n * in projection1 to any projection in projection2.\r\n *\r\n * @param {Array<Projection>} projections1 Projections with equal\r\n *     meaning.\r\n * @param {Array<Projection>} projections2 Projections with equal\r\n *     meaning.\r\n * @param {TransformFunction} forwardTransform Transformation from any\r\n *   projection in projection1 to any projection in projection2.\r\n * @param {TransformFunction} inverseTransform Transform from any projection\r\n *   in projection2 to any projection in projection1..\r\n */\r\nexport function addEquivalentTransforms(\r\n  projections1,\r\n  projections2,\r\n  forwardTransform,\r\n  inverseTransform,\r\n) {\r\n  projections1.forEach(function (projection1) {\r\n    projections2.forEach(function (projection2) {\r\n      addTransformFunc(projection1, projection2, forwardTransform);\r\n      addTransformFunc(projection2, projection1, inverseTransform);\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Clear all cached projections and transforms.\r\n */\r\nexport function clearAllProjections() {\r\n  clearProj();\r\n  clearTransformFuncs();\r\n}\r\n\r\n/**\r\n * @param {Projection|string|undefined} projection Projection.\r\n * @param {string} defaultCode Default code.\r\n * @return {Projection} Projection.\r\n */\r\nexport function createProjection(projection, defaultCode) {\r\n  if (!projection) {\r\n    return get(defaultCode);\r\n  }\r\n  if (typeof projection === 'string') {\r\n    return get(projection);\r\n  }\r\n  return /** @type {Projection} */ (projection);\r\n}\r\n\r\n/**\r\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\r\n * function.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\r\n *     transform.\r\n * @return {TransformFunction} Transform function.\r\n */\r\nexport function createTransformFromCoordinateTransform(coordTransform) {\r\n  return (\r\n    /**\r\n     * @param {Array<number>} input Input.\r\n     * @param {Array<number>} [output] Output.\r\n     * @param {number} [dimension] Dimensions that should be transformed.\r\n     * @param {number} [stride] Stride.\r\n     * @return {Array<number>} Output.\r\n     */\r\n    function (input, output, dimension, stride) {\r\n      const length = input.length;\r\n      dimension = dimension !== undefined ? dimension : 2;\r\n      stride = stride ?? dimension;\r\n      output = output !== undefined ? output : new Array(length);\r\n      for (let i = 0; i < length; i += stride) {\r\n        const point = coordTransform(input.slice(i, i + dimension));\r\n        const pointLength = point.length;\r\n        for (let j = 0, jj = stride; j < jj; ++j) {\r\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\r\n        }\r\n      }\r\n      return output;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Registers coordinate transform functions to convert coordinates between the\r\n * source projection and the destination projection.\r\n * The forward and inverse functions convert coordinate pairs; this function\r\n * converts these into the functions used internally which also handle\r\n * extents and coordinate arrays.\r\n *\r\n * @param {ProjectionLike} source Source projection.\r\n * @param {ProjectionLike} destination Destination projection.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\r\n *     function (that is, from the source projection to the destination\r\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\r\n *     the transformed {@link module:ol/coordinate~Coordinate}.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\r\n *     function (that is, from the destination projection to the source\r\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\r\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\r\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\r\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\r\n *     source.\r\n * @api\r\n */\r\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\r\n  const sourceProj = get(source);\r\n  const destProj = get(destination);\r\n  addTransformFunc(\r\n    sourceProj,\r\n    destProj,\r\n    createTransformFromCoordinateTransform(forward),\r\n  );\r\n  addTransformFunc(\r\n    destProj,\r\n    sourceProj,\r\n    createTransformFromCoordinateTransform(inverse),\r\n  );\r\n}\r\n\r\n/**\r\n * Transforms a coordinate from longitude/latitude to a different projection.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\r\n *     an array with longitude as 1st and latitude as 2nd element.\r\n * @param {ProjectionLike} [projection] Target projection. The\r\n *     default is Web Mercator, i.e. 'EPSG:3857'.\r\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\r\n * @api\r\n */\r\nexport function fromLonLat(coordinate, projection) {\r\n  disableCoordinateWarning();\r\n  return transform(\r\n    coordinate,\r\n    'EPSG:4326',\r\n    projection !== undefined ? projection : 'EPSG:3857',\r\n  );\r\n}\r\n\r\n/**\r\n * Transforms a coordinate to longitude/latitude.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\r\n * @param {ProjectionLike} [projection] Projection of the coordinate.\r\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\r\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\r\n *     with longitude as 1st and latitude as 2nd element.\r\n * @api\r\n */\r\nexport function toLonLat(coordinate, projection) {\r\n  const lonLat = transform(\r\n    coordinate,\r\n    projection !== undefined ? projection : 'EPSG:3857',\r\n    'EPSG:4326',\r\n  );\r\n  const lon = lonLat[0];\r\n  if (lon < -180 || lon > 180) {\r\n    lonLat[0] = modulo(lon + 180, 360) - 180;\r\n  }\r\n  return lonLat;\r\n}\r\n\r\n/**\r\n * Checks if two projections are the same, that is every coordinate in one\r\n * projection does represent the same geographic point as the same coordinate in\r\n * the other projection.\r\n *\r\n * @param {Projection} projection1 Projection 1.\r\n * @param {Projection} projection2 Projection 2.\r\n * @return {boolean} Equivalent.\r\n * @api\r\n */\r\nexport function equivalent(projection1, projection2) {\r\n  if (projection1 === projection2) {\r\n    return true;\r\n  }\r\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\r\n  if (projection1.getCode() === projection2.getCode()) {\r\n    return equalUnits;\r\n  }\r\n  const transformFunc = getTransformFromProjections(projection1, projection2);\r\n  return transformFunc === cloneTransform && equalUnits;\r\n}\r\n\r\n/**\r\n * Searches in the list of transform functions for the function for converting\r\n * coordinates from the source projection to the destination projection.\r\n *\r\n * @param {Projection} sourceProjection Source Projection object.\r\n * @param {Projection} destinationProjection Destination Projection\r\n *     object.\r\n * @return {TransformFunction} Transform function.\r\n */\r\nexport function getTransformFromProjections(\r\n  sourceProjection,\r\n  destinationProjection,\r\n) {\r\n  const sourceCode = sourceProjection.getCode();\r\n  const destinationCode = destinationProjection.getCode();\r\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\r\n  if (!transformFunc) {\r\n    transformFunc = identityTransform;\r\n  }\r\n  return transformFunc;\r\n}\r\n\r\n/**\r\n * Given the projection-like objects, searches for a transformation\r\n * function to convert a coordinates array from the source projection to the\r\n * destination projection.\r\n *\r\n * @param {ProjectionLike} source Source.\r\n * @param {ProjectionLike} destination Destination.\r\n * @return {TransformFunction} Transform function.\r\n * @api\r\n */\r\nexport function getTransform(source, destination) {\r\n  const sourceProjection = get(source);\r\n  const destinationProjection = get(destination);\r\n  return getTransformFromProjections(sourceProjection, destinationProjection);\r\n}\r\n\r\n/**\r\n * Transforms a coordinate from source projection to destination projection.\r\n * This returns a new coordinate (and does not modify the original).\r\n *\r\n * See {@link module:ol/proj.transformExtent} for extent transformation.\r\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\r\n * subclasses for geometry transforms.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {ProjectionLike} source Source projection-like.\r\n * @param {ProjectionLike} destination Destination projection-like.\r\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\r\n * @api\r\n */\r\nexport function transform(coordinate, source, destination) {\r\n  const transformFunc = getTransform(source, destination);\r\n  return transformFunc(coordinate, undefined, coordinate.length);\r\n}\r\n\r\n/**\r\n * Transforms an extent from source projection to destination projection.  This\r\n * returns a new extent (and does not modify the original).\r\n *\r\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\r\n * @param {ProjectionLike} source Source projection-like.\r\n * @param {ProjectionLike} destination Destination projection-like.\r\n * @param {number} [stops] Number of stops per side used for the transform.\r\n * By default only the corners are used.\r\n * @return {import(\"./extent.js\").Extent} The transformed extent.\r\n * @api\r\n */\r\nexport function transformExtent(extent, source, destination, stops) {\r\n  const transformFunc = getTransform(source, destination);\r\n  return applyTransform(extent, transformFunc, undefined, stops);\r\n}\r\n\r\n/**\r\n * Transforms the given point to the destination projection.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\r\n * @param {Projection} sourceProjection Source projection.\r\n * @param {Projection} destinationProjection Destination projection.\r\n * @return {import(\"./coordinate.js\").Coordinate} Point.\r\n */\r\nexport function transformWithProjections(\r\n  point,\r\n  sourceProjection,\r\n  destinationProjection,\r\n) {\r\n  const transformFunc = getTransformFromProjections(\r\n    sourceProjection,\r\n    destinationProjection,\r\n  );\r\n  return transformFunc(point);\r\n}\r\n\r\n/**\r\n * @type {Projection|null}\r\n */\r\nlet userProjection = null;\r\n\r\n/**\r\n * Set the projection for coordinates supplied from and returned by API methods.\r\n * This includes all API methods except for those interacting with tile grids,\r\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\r\n * @param {ProjectionLike} projection The user projection.\r\n * @api\r\n */\r\nexport function setUserProjection(projection) {\r\n  userProjection = get(projection);\r\n}\r\n\r\n/**\r\n * Clear the user projection if set.\r\n * @api\r\n */\r\nexport function clearUserProjection() {\r\n  userProjection = null;\r\n}\r\n\r\n/**\r\n * Get the projection for coordinates supplied from and returned by API methods.\r\n * @return {Projection|null} The user projection (or null if not set).\r\n * @api\r\n */\r\nexport function getUserProjection() {\r\n  return userProjection;\r\n}\r\n\r\n/**\r\n * Use geographic coordinates (WGS-84 datum) in API methods.\r\n * This includes all API methods except for those interacting with tile grids,\r\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\r\n * @api\r\n */\r\nexport function useGeographic() {\r\n  setUserProjection('EPSG:4326');\r\n}\r\n\r\n/**\r\n * Return a coordinate transformed into the user projection.  If no user projection\r\n * is set, the original coordinate is returned.\r\n * @param {Array<number>} coordinate Input coordinate.\r\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\r\n * @return {Array<number>} The input coordinate in the user projection.\r\n */\r\nexport function toUserCoordinate(coordinate, sourceProjection) {\r\n  if (!userProjection) {\r\n    return coordinate;\r\n  }\r\n  return transform(coordinate, sourceProjection, userProjection);\r\n}\r\n\r\n/**\r\n * Return a coordinate transformed from the user projection.  If no user projection\r\n * is set, the original coordinate is returned.\r\n * @param {Array<number>} coordinate Input coordinate.\r\n * @param {ProjectionLike} destProjection The destination projection.\r\n * @return {Array<number>} The input coordinate transformed.\r\n */\r\nexport function fromUserCoordinate(coordinate, destProjection) {\r\n  if (!userProjection) {\r\n    if (\r\n      showCoordinateWarning &&\r\n      !equals(coordinate, [0, 0]) &&\r\n      coordinate[0] >= -180 &&\r\n      coordinate[0] <= 180 &&\r\n      coordinate[1] >= -90 &&\r\n      coordinate[1] <= 90\r\n    ) {\r\n      showCoordinateWarning = false;\r\n      warn(\r\n        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.',\r\n      );\r\n    }\r\n    return coordinate;\r\n  }\r\n  return transform(coordinate, userProjection, destProjection);\r\n}\r\n\r\n/**\r\n * Return an extent transformed into the user projection.  If no user projection\r\n * is set, the original extent is returned.\r\n * @param {import(\"./extent.js\").Extent} extent Input extent.\r\n * @param {ProjectionLike} sourceProjection The input extent projection.\r\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\r\n */\r\nexport function toUserExtent(extent, sourceProjection) {\r\n  if (!userProjection) {\r\n    return extent;\r\n  }\r\n  return transformExtent(extent, sourceProjection, userProjection);\r\n}\r\n\r\n/**\r\n * Return an extent transformed from the user projection.  If no user projection\r\n * is set, the original extent is returned.\r\n * @param {import(\"./extent.js\").Extent} extent Input extent.\r\n * @param {ProjectionLike} destProjection The destination projection.\r\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\r\n */\r\nexport function fromUserExtent(extent, destProjection) {\r\n  if (!userProjection) {\r\n    return extent;\r\n  }\r\n  return transformExtent(extent, userProjection, destProjection);\r\n}\r\n\r\n/**\r\n * Return the resolution in user projection units per pixel. If no user projection\r\n * is set, or source or user projection are missing units, the original resolution\r\n * is returned.\r\n * @param {number} resolution Resolution in input projection units per pixel.\r\n * @param {ProjectionLike} sourceProjection The input projection.\r\n * @return {number} Resolution in user projection units per pixel.\r\n */\r\nexport function toUserResolution(resolution, sourceProjection) {\r\n  if (!userProjection) {\r\n    return resolution;\r\n  }\r\n  const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();\r\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\r\n  return sourceMetersPerUnit && userMetersPerUnit\r\n    ? (resolution * sourceMetersPerUnit) / userMetersPerUnit\r\n    : resolution;\r\n}\r\n\r\n/**\r\n * Return the resolution in user projection units per pixel. If no user projection\r\n * is set, or source or user projection are missing units, the original resolution\r\n * is returned.\r\n * @param {number} resolution Resolution in user projection units per pixel.\r\n * @param {ProjectionLike} destProjection The destination projection.\r\n * @return {number} Resolution in destination projection units per pixel.\r\n */\r\nexport function fromUserResolution(resolution, destProjection) {\r\n  if (!userProjection) {\r\n    return resolution;\r\n  }\r\n  const destMetersPerUnit = get(destProjection).getMetersPerUnit();\r\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\r\n  return destMetersPerUnit && userMetersPerUnit\r\n    ? (resolution * userMetersPerUnit) / destMetersPerUnit\r\n    : resolution;\r\n}\r\n\r\n/**\r\n * Creates a safe coordinate transform function from a coordinate transform function.\r\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\r\n * and that coordinates exceeding the source projection validity extent's range will be\r\n * clamped to the validity range.\r\n * @param {Projection} sourceProj Source projection.\r\n * @param {Projection} destProj Destination projection.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destination).\r\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destination).\r\n */\r\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\r\n  return function (coord) {\r\n    let transformed, worldsAway;\r\n    if (sourceProj.canWrapX()) {\r\n      const sourceExtent = sourceProj.getExtent();\r\n      const sourceExtentWidth = getWidth(sourceExtent);\r\n      coord = coord.slice(0);\r\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\r\n      if (worldsAway) {\r\n        // Move x to the real world\r\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\r\n      }\r\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\r\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\r\n      transformed = transform(coord);\r\n    } else {\r\n      transformed = transform(coord);\r\n    }\r\n    if (worldsAway && destProj.canWrapX()) {\r\n      // Move transformed coordinate back to the offset world\r\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\r\n    }\r\n    return transformed;\r\n  };\r\n}\r\n\r\n/**\r\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\r\n * by when this module is executed and should only need to be called again after\r\n * `clearAllProjections()` is called (e.g. in tests).\r\n */\r\nexport function addCommon() {\r\n  // Add transformations that don't alter coordinates to convert within set of\r\n  // projections with equal meaning.\r\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\r\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\r\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\r\n  // coordinates and back.\r\n  addEquivalentTransforms(\r\n    EPSG4326_PROJECTIONS,\r\n    EPSG3857_PROJECTIONS,\r\n    fromEPSG4326,\r\n    toEPSG4326,\r\n  );\r\n}\r\n\r\naddCommon();\r\n","/**\r\n * @module CME2D/reproj/Triangulation\r\n */\r\nimport {\r\n  boundingExtent,\r\n  createEmpty,\r\n  extendCoordinate,\r\n  getArea,\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getTopLeft,\r\n  getTopRight,\r\n  getWidth,\r\n  intersects,\r\n} from '../extent.js';\r\nimport {getTransform} from '../proj.js';\r\nimport {modulo} from '../math.js';\r\n\r\n/**\r\n * Single triangle; consists of 3 source points and 3 target points.\r\n * @typedef {Object} Triangle\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\r\n */\r\n\r\n/**\r\n * Maximum number of subdivision steps during raster reprojection triangulation.\r\n * Prevents high memory usage and large number of proj4 calls (for certain\r\n * transformations and areas). At most `2*(2^this)` triangles are created for\r\n * each triangulated extent (tile/image).\r\n * @type {number}\r\n */\r\nconst MAX_SUBDIVISION = 10;\r\n\r\n/**\r\n * Maximum allowed size of triangle relative to world width. When transforming\r\n * corners of world extent between certain projections, the resulting\r\n * triangulation seems to have zero error and no subdivision is performed. If\r\n * the triangle width is more than this (relative to world width; 0-1),\r\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\r\n * @type {number}\r\n */\r\nconst MAX_TRIANGLE_WIDTH = 0.25;\r\n\r\n/**\r\n * @classdesc\r\n * Class containing triangulation of the given target extent.\r\n * Used for determining source data and the reprojection itself.\r\n */\r\nclass Triangulation {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\r\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\r\n   * @param {number} errorThreshold Acceptable error (in source units).\r\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    targetProj,\r\n    targetExtent,\r\n    maxSourceExtent,\r\n    errorThreshold,\r\n    destinationResolution,\r\n  ) {\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.sourceProj_ = sourceProj;\r\n\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.targetProj_ = targetProj;\r\n\r\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\r\n    let transformInvCache = {};\r\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\r\n\r\n    /**\r\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\r\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\r\n     * @private\r\n     */\r\n    this.transformInv_ = function (c) {\r\n      const key = c[0] + '/' + c[1];\r\n      if (!transformInvCache[key]) {\r\n        transformInvCache[key] = transformInv(c);\r\n      }\r\n      return transformInvCache[key];\r\n    };\r\n\r\n    /**\r\n     * @type {import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\r\n    this.maxSourceExtent_ = maxSourceExtent;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\r\n\r\n    /**\r\n     * @type {Array<Triangle>}\r\n     * @private\r\n     */\r\n    this.triangles_ = [];\r\n\r\n    /**\r\n     * Indicates that the triangulation crosses edge of the source projection.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.wrapsXInSource_ = false;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.canWrapXInSource_ =\r\n      this.sourceProj_.canWrapX() &&\r\n      !!maxSourceExtent &&\r\n      !!this.sourceProj_.getExtent() &&\r\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\r\n      ? getWidth(this.sourceProj_.getExtent())\r\n      : null;\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\r\n      ? getWidth(this.targetProj_.getExtent())\r\n      : null;\r\n\r\n    const destinationTopLeft = getTopLeft(targetExtent);\r\n    const destinationTopRight = getTopRight(targetExtent);\r\n    const destinationBottomRight = getBottomRight(targetExtent);\r\n    const destinationBottomLeft = getBottomLeft(targetExtent);\r\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\r\n    const sourceTopRight = this.transformInv_(destinationTopRight);\r\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\r\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\r\n\r\n    /*\r\n     * The maxSubdivision controls how many splittings of the target area can\r\n     * be done. The idea here is to do a linear mapping of the target areas\r\n     * but the actual overall reprojection (can be) extremely non-linear. The\r\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\r\n     * tile size. However this function is also called to remap canvas rendered\r\n     * layers which can be much larger. This calculation increases the maxSubdivision\r\n     * value by the right factor so that each 256x256 pixel area has\r\n     * MAX_SUBDIVISION divisions.\r\n     */\r\n    const maxSubdivision =\r\n      MAX_SUBDIVISION +\r\n      (destinationResolution\r\n        ? Math.max(\r\n            0,\r\n            Math.ceil(\r\n              Math.log2(\r\n                getArea(targetExtent) /\r\n                  (destinationResolution * destinationResolution * 256 * 256),\r\n              ),\r\n            ),\r\n          )\r\n        : 0);\r\n\r\n    this.addQuad_(\r\n      destinationTopLeft,\r\n      destinationTopRight,\r\n      destinationBottomRight,\r\n      destinationBottomLeft,\r\n      sourceTopLeft,\r\n      sourceTopRight,\r\n      sourceBottomRight,\r\n      sourceBottomLeft,\r\n      maxSubdivision,\r\n    );\r\n\r\n    if (this.wrapsXInSource_) {\r\n      let leftBound = Infinity;\r\n      this.triangles_.forEach(function (triangle, i, arr) {\r\n        leftBound = Math.min(\r\n          leftBound,\r\n          triangle.source[0][0],\r\n          triangle.source[1][0],\r\n          triangle.source[2][0],\r\n        );\r\n      });\r\n\r\n      // Shift triangles to be as close to `leftBound` as possible\r\n      // (if the distance is more than `worldWidth / 2` it can be closer.\r\n      this.triangles_.forEach((triangle) => {\r\n        if (\r\n          Math.max(\r\n            triangle.source[0][0],\r\n            triangle.source[1][0],\r\n            triangle.source[2][0],\r\n          ) -\r\n            leftBound >\r\n          this.sourceWorldWidth_ / 2\r\n        ) {\r\n          const newTriangle = [\r\n            [triangle.source[0][0], triangle.source[0][1]],\r\n            [triangle.source[1][0], triangle.source[1][1]],\r\n            [triangle.source[2][0], triangle.source[2][1]],\r\n          ];\r\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[0][0] -= this.sourceWorldWidth_;\r\n          }\r\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[1][0] -= this.sourceWorldWidth_;\r\n          }\r\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[2][0] -= this.sourceWorldWidth_;\r\n          }\r\n\r\n          // Rarely (if the extent contains both the dateline and prime meridian)\r\n          // the shift can in turn break some triangles.\r\n          // Detect this here and don't shift in such cases.\r\n          const minX = Math.min(\r\n            newTriangle[0][0],\r\n            newTriangle[1][0],\r\n            newTriangle[2][0],\r\n          );\r\n          const maxX = Math.max(\r\n            newTriangle[0][0],\r\n            newTriangle[1][0],\r\n            newTriangle[2][0],\r\n          );\r\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\r\n            triangle.source = newTriangle;\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    transformInvCache = {};\r\n  }\r\n\r\n  /**\r\n   * Adds triangle to the triangulation.\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @private\r\n   */\r\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\r\n    this.triangles_.push({\r\n      source: [aSrc, bSrc, cSrc],\r\n      target: [a, b, c],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds quad (points in clock-wise order) to the triangulation\r\n   * (and reprojects the vertices) if valid.\r\n   * Performs quad subdivision if needed to increase precision.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\r\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\r\n   * @private\r\n   */\r\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\r\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\r\n    const sourceCoverageX = this.sourceWorldWidth_\r\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\r\n      : null;\r\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\r\n\r\n    // when the quad is wrapped in the source projection\r\n    // it covers most of the projection extent, but not fully\r\n    const wrapsX =\r\n      this.sourceProj_.canWrapX() &&\r\n      sourceCoverageX > 0.5 &&\r\n      sourceCoverageX < 1;\r\n\r\n    let needsSubdivision = false;\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\r\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\r\n        const targetCoverageX =\r\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\r\n        needsSubdivision =\r\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\r\n        needsSubdivision =\r\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n    }\r\n\r\n    if (!needsSubdivision && this.maxSourceExtent_) {\r\n      if (\r\n        isFinite(sourceQuadExtent[0]) &&\r\n        isFinite(sourceQuadExtent[1]) &&\r\n        isFinite(sourceQuadExtent[2]) &&\r\n        isFinite(sourceQuadExtent[3])\r\n      ) {\r\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\r\n          // whole quad outside source projection extent -> ignore\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    let isNotFinite = 0;\r\n\r\n    if (!needsSubdivision) {\r\n      if (\r\n        !isFinite(aSrc[0]) ||\r\n        !isFinite(aSrc[1]) ||\r\n        !isFinite(bSrc[0]) ||\r\n        !isFinite(bSrc[1]) ||\r\n        !isFinite(cSrc[0]) ||\r\n        !isFinite(cSrc[1]) ||\r\n        !isFinite(dSrc[0]) ||\r\n        !isFinite(dSrc[1])\r\n      ) {\r\n        if (maxSubdivision > 0) {\r\n          needsSubdivision = true;\r\n        } else {\r\n          // It might be the case that only 1 of the points is infinite. In this case\r\n          // we can draw a single triangle with the other three points\r\n          isNotFinite =\r\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\r\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\r\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\r\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\r\n          if (\r\n            isNotFinite != 1 &&\r\n            isNotFinite != 2 &&\r\n            isNotFinite != 4 &&\r\n            isNotFinite != 8\r\n          ) {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (!needsSubdivision) {\r\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\r\n        const centerSrc = this.transformInv_(center);\r\n\r\n        let dx;\r\n        if (wrapsX) {\r\n          const centerSrcEstimX =\r\n            (modulo(aSrc[0], sourceWorldWidth) +\r\n              modulo(cSrc[0], sourceWorldWidth)) /\r\n            2;\r\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\r\n        } else {\r\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\r\n        }\r\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\r\n        const centerSrcErrorSquared = dx * dx + dy * dy;\r\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\r\n      }\r\n      if (needsSubdivision) {\r\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\r\n          // split horizontally (top & bottom)\r\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\r\n          const bcSrc = this.transformInv_(bc);\r\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\r\n          const daSrc = this.transformInv_(da);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            b,\r\n            bc,\r\n            da,\r\n            aSrc,\r\n            bSrc,\r\n            bcSrc,\r\n            daSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n          this.addQuad_(\r\n            da,\r\n            bc,\r\n            c,\r\n            d,\r\n            daSrc,\r\n            bcSrc,\r\n            cSrc,\r\n            dSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n        } else {\r\n          // split vertically (left & right)\r\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\r\n          const abSrc = this.transformInv_(ab);\r\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\r\n          const cdSrc = this.transformInv_(cd);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            ab,\r\n            cd,\r\n            d,\r\n            aSrc,\r\n            abSrc,\r\n            cdSrc,\r\n            dSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n          this.addQuad_(\r\n            ab,\r\n            b,\r\n            c,\r\n            cd,\r\n            abSrc,\r\n            bSrc,\r\n            cSrc,\r\n            cdSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n        }\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (wrapsX) {\r\n      if (!this.canWrapXInSource_) {\r\n        return;\r\n      }\r\n      this.wrapsXInSource_ = true;\r\n    }\r\n\r\n    // Exactly zero or one of *Src is not finite\r\n    // The triangles must have the diagonal line as the first side\r\n    // This is to allow easy code in reproj.s to make it straight for broken\r\n    // browsers that can't handle diagonal clipping\r\n    if ((isNotFinite & 0xb) == 0) {\r\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\r\n    }\r\n    if ((isNotFinite & 0xe) == 0) {\r\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\r\n    }\r\n    if (isNotFinite) {\r\n      // Try the other two triangles\r\n      if ((isNotFinite & 0xd) == 0) {\r\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\r\n      }\r\n      if ((isNotFinite & 0x7) == 0) {\r\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates extent of the `source` coordinates from all the triangles.\r\n   *\r\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\r\n   */\r\n  calculateSourceExtent() {\r\n    const extent = createEmpty();\r\n\r\n    this.triangles_.forEach(function (triangle, i, arr) {\r\n      const src = triangle.source;\r\n      extendCoordinate(extent, src[0]);\r\n      extendCoordinate(extent, src[1]);\r\n      extendCoordinate(extent, src[2]);\r\n    });\r\n\r\n    return extent;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Triangle>} Array of the calculated triangles.\r\n   */\r\n  getTriangles() {\r\n    return this.triangles_;\r\n  }\r\n}\r\n\r\nexport default Triangulation;\r\n","/**\r\n * @module CME2D/reproj\r\n */\r\nimport {\r\n  containsCoordinate,\r\n  createEmpty,\r\n  extend,\r\n  forEachCorner,\r\n  getCenter,\r\n  getHeight,\r\n  getTopLeft,\r\n  getWidth,\r\n} from './extent.js';\r\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\r\nimport {getPointResolution, transform} from './proj.js';\r\nimport {solveLinearSystem} from './math.js';\r\n\r\nlet brokenDiagonalRendering_;\r\n\r\n/**\r\n * @type {Array<HTMLCanvasElement>}\r\n */\r\nexport const canvasPool = [];\r\n\r\n/**\r\n * This draws a small triangle into a canvas by setting the triangle as the clip region\r\n * and then drawing a (too large) rectangle\r\n *\r\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\r\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\r\n * @param {number} v1 The y-coordinate of the second point.\r\n * @param {number} u2 The x-coordinate of the third point.\r\n * @param {number} v2 The y-coordinate of the third point.\r\n */\r\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(0, 0);\r\n  ctx.lineTo(u1, v1);\r\n  ctx.lineTo(u2, v2);\r\n  ctx.closePath();\r\n  ctx.save();\r\n  ctx.clip();\r\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\r\n  ctx.restore();\r\n}\r\n\r\n/**\r\n * Given the data from getImageData, see if the right values appear at the provided offset.\r\n * Returns true if either the color or transparency is off\r\n *\r\n * @param {Uint8ClampedArray} data The data returned from getImageData\r\n * @param {number} offset The pixel offset from the start of data.\r\n * @return {boolean} true if the diagonal rendering is broken\r\n */\r\nfunction verifyBrokenDiagonalRendering(data, offset) {\r\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\r\n  return (\r\n    Math.abs(data[offset * 4] - 210) > 2 ||\r\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\r\n  );\r\n}\r\n\r\n/**\r\n * Determines if the current browser configuration can render triangular clip regions correctly.\r\n * This value is cached so the function is only expensive the first time called.\r\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\r\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\r\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\r\n * running, but lets hope not.\r\n *\r\n * @return {boolean} true if the Diagonal Rendering is broken.\r\n */\r\nfunction isBrokenDiagonalRendering() {\r\n  if (brokenDiagonalRendering_ === undefined) {\r\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\r\n    ctx.globalCompositeOperation = 'lighter';\r\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\r\n    drawTestTriangle(ctx, 4, 5, 4, 0);\r\n    drawTestTriangle(ctx, 4, 5, 0, 5);\r\n    const data = ctx.getImageData(0, 0, 3, 3).data;\r\n    brokenDiagonalRendering_ =\r\n      verifyBrokenDiagonalRendering(data, 0) ||\r\n      verifyBrokenDiagonalRendering(data, 4) ||\r\n      verifyBrokenDiagonalRendering(data, 8);\r\n    releaseCanvas(ctx);\r\n    canvasPool.push(ctx.canvas);\r\n  }\r\n\r\n  return brokenDiagonalRendering_;\r\n}\r\n\r\n/**\r\n * Calculates ideal resolution to use from the source in order to achieve\r\n * pixel mapping as close as possible to 1:1 during reprojection.\r\n * The resolution is calculated regardless of what resolutions\r\n * are actually available in the dataset (TileGrid, Image, ...).\r\n *\r\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\r\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\r\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\r\n * @param {number} targetResolution Target resolution.\r\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\r\n */\r\nexport function calculateSourceResolution(\r\n  sourceProj,\r\n  targetProj,\r\n  targetCenter,\r\n  targetResolution,\r\n) {\r\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\r\n\r\n  // calculate the ideal resolution of the source data\r\n  let sourceResolution = getPointResolution(\r\n    targetProj,\r\n    targetResolution,\r\n    targetCenter,\r\n  );\r\n\r\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\r\n  if (targetMetersPerUnit !== undefined) {\r\n    sourceResolution *= targetMetersPerUnit;\r\n  }\r\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\r\n  if (sourceMetersPerUnit !== undefined) {\r\n    sourceResolution /= sourceMetersPerUnit;\r\n  }\r\n\r\n  // Based on the projection properties, the point resolution at the specified\r\n  // coordinates may be slightly different. We need to reverse-compensate this\r\n  // in order to achieve optimal results.\r\n\r\n  const sourceExtent = sourceProj.getExtent();\r\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\r\n    const compensationFactor =\r\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\r\n      sourceResolution;\r\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\r\n      sourceResolution /= compensationFactor;\r\n    }\r\n  }\r\n\r\n  return sourceResolution;\r\n}\r\n\r\n/**\r\n * Calculates ideal resolution to use from the source in order to achieve\r\n * pixel mapping as close as possible to 1:1 during reprojection.\r\n * The resolution is calculated regardless of what resolutions\r\n * are actually available in the dataset (TileGrid, Image, ...).\r\n *\r\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\r\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\r\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\r\n * @param {number} targetResolution Target resolution.\r\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\r\n */\r\nexport function calculateSourceExtentResolution(\r\n  sourceProj,\r\n  targetProj,\r\n  targetExtent,\r\n  targetResolution,\r\n) {\r\n  const targetCenter = getCenter(targetExtent);\r\n  let sourceResolution = calculateSourceResolution(\r\n    sourceProj,\r\n    targetProj,\r\n    targetCenter,\r\n    targetResolution,\r\n  );\r\n\r\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n    forEachCorner(targetExtent, function (corner) {\r\n      sourceResolution = calculateSourceResolution(\r\n        sourceProj,\r\n        targetProj,\r\n        corner,\r\n        targetResolution,\r\n      );\r\n      return isFinite(sourceResolution) && sourceResolution > 0;\r\n    });\r\n  }\r\n\r\n  return sourceResolution;\r\n}\r\n\r\n/**\r\n * @typedef {Object} ImageExtent\r\n * @property {import(\"./extent.js\").Extent} extent Extent.\r\n * @property {import(\"./extent.js\").Extent} [clipExtent] Clip extent.\r\n * @property {import('./DataTile.js').ImageLike} image Image.\r\n */\r\n\r\n/**\r\n * Renders the source data into new canvas based on the triangulation.\r\n *\r\n * @param {number} width Width of the canvas.\r\n * @param {number} height Height of the canvas.\r\n * @param {number} pixelRatio Pixel ratio.\r\n * @param {number} sourceResolution Source resolution.\r\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\r\n * @param {number} targetResolution Target resolution.\r\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\r\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\r\n * @param {Array<ImageExtent>} sources Array of sources.\r\n * @param {number} gutter Gutter of the sources.\r\n * @param {boolean} [renderEdges] Render reprojection edges.\r\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\r\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\r\n * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.\r\n * @return {HTMLCanvasElement} Canvas with reprojected data.\r\n */\r\nexport function render(\r\n  width,\r\n  height,\r\n  pixelRatio,\r\n  sourceResolution,\r\n  sourceExtent,\r\n  targetResolution,\r\n  targetExtent,\r\n  triangulation,\r\n  sources,\r\n  gutter,\r\n  renderEdges,\r\n  interpolate,\r\n  drawSingle,\r\n  clipExtent,\r\n) {\r\n  const context = createCanvasContext2D(\r\n    Math.round(pixelRatio * width),\r\n    Math.round(pixelRatio * height),\r\n    canvasPool,\r\n  );\r\n\r\n  if (!interpolate) {\r\n    context.imageSmoothingEnabled = false;\r\n  }\r\n\r\n  if (sources.length === 0) {\r\n    return context.canvas;\r\n  }\r\n\r\n  context.scale(pixelRatio, pixelRatio);\r\n\r\n  function pixelRound(value) {\r\n    return Math.round(value * pixelRatio) / pixelRatio;\r\n  }\r\n\r\n  context.globalCompositeOperation = 'lighter';\r\n\r\n  const sourceDataExtent = createEmpty();\r\n  sources.forEach(function (src, i, arr) {\r\n    extend(sourceDataExtent, src.extent);\r\n  });\r\n\r\n  let stitchContext;\r\n  const stitchScale = pixelRatio / sourceResolution;\r\n  // Round up Float32 scale values to prevent interpolation in Firefox.\r\n  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;\r\n\r\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\r\n    stitchContext = createCanvasContext2D(\r\n      Math.round(getWidth(sourceDataExtent) * stitchScale),\r\n      Math.round(getHeight(sourceDataExtent) * stitchScale),\r\n      canvasPool,\r\n    );\r\n\r\n    if (!interpolate) {\r\n      stitchContext.imageSmoothingEnabled = false;\r\n    }\r\n    if (sourceExtent && clipExtent) {\r\n      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;\r\n      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;\r\n      const width = getWidth(sourceExtent) * stitchScale;\r\n      const height = getHeight(sourceExtent) * stitchScale;\r\n      stitchContext.rect(xPos, yPos, width, height);\r\n      stitchContext.clip();\r\n    }\r\n\r\n    sources.forEach(function (src, i, arr) {\r\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\r\n      if (src.image.width > 0 && src.image.height > 0) {\r\n        if (src.clipExtent) {\r\n          stitchContext.save();\r\n          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;\r\n          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;\r\n          const width = getWidth(src.clipExtent) * stitchScale;\r\n          const height = getHeight(src.clipExtent) * stitchScale;\r\n          stitchContext.rect(\r\n            interpolate ? xPos : Math.round(xPos),\r\n            interpolate ? yPos : Math.round(yPos),\r\n            interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\r\n            interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\r\n          );\r\n          stitchContext.clip();\r\n        }\r\n\r\n        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;\r\n        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;\r\n        const srcWidth = getWidth(src.extent) * stitchScale;\r\n        const srcHeight = getHeight(src.extent) * stitchScale;\r\n        stitchContext.drawImage(\r\n          src.image,\r\n          gutter,\r\n          gutter,\r\n          src.image.width - 2 * gutter,\r\n          src.image.height - 2 * gutter,\r\n          interpolate ? xPos : Math.round(xPos),\r\n          interpolate ? yPos : Math.round(yPos),\r\n          interpolate\r\n            ? srcWidth\r\n            : Math.round(xPos + srcWidth) - Math.round(xPos),\r\n          interpolate\r\n            ? srcHeight\r\n            : Math.round(yPos + srcHeight) - Math.round(yPos),\r\n        );\r\n\r\n        if (src.clipExtent) {\r\n          stitchContext.restore();\r\n        }\r\n      }\r\n    });\r\n  }\r\n  const targetTopLeft = getTopLeft(targetExtent);\r\n\r\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\r\n    /* Calculate affine transform (src -> dst)\r\n     * Resulting matrix can be used to transform coordinate\r\n     * from `sourceProjection` to destination pixels.\r\n     *\r\n     * To optimize number of context calls and increase numerical stability,\r\n     * we also do the following operations:\r\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\r\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\r\n     *\r\n     * Src points: xi, yi\r\n     * Dst points: ui, vi\r\n     * Affine coefficients: aij\r\n     *\r\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\r\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\r\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\r\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\r\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\r\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\r\n     */\r\n    const source = triangle.source;\r\n    const target = triangle.target;\r\n    let x0 = source[0][0],\r\n      y0 = source[0][1];\r\n    let x1 = source[1][0],\r\n      y1 = source[1][1];\r\n    let x2 = source[2][0],\r\n      y2 = source[2][1];\r\n    // Make sure that everything is on pixel boundaries\r\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\r\n    const v0 = pixelRound(\r\n      -(target[0][1] - targetTopLeft[1]) / targetResolution,\r\n    );\r\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\r\n    const v1 = pixelRound(\r\n      -(target[1][1] - targetTopLeft[1]) / targetResolution,\r\n    );\r\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\r\n    const v2 = pixelRound(\r\n      -(target[2][1] - targetTopLeft[1]) / targetResolution,\r\n    );\r\n\r\n    // Shift all the source points to improve numerical stability\r\n    // of all the subsequent calculations. The [x0, y0] is used here.\r\n    // This is also used to simplify the linear system.\r\n    const sourceNumericalShiftX = x0;\r\n    const sourceNumericalShiftY = y0;\r\n    x0 = 0;\r\n    y0 = 0;\r\n    x1 -= sourceNumericalShiftX;\r\n    y1 -= sourceNumericalShiftY;\r\n    x2 -= sourceNumericalShiftX;\r\n    y2 -= sourceNumericalShiftY;\r\n\r\n    const augmentedMatrix = [\r\n      [x1, y1, 0, 0, u1 - u0],\r\n      [x2, y2, 0, 0, u2 - u0],\r\n      [0, 0, x1, y1, v1 - v0],\r\n      [0, 0, x2, y2, v2 - v0],\r\n    ];\r\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\r\n    if (!affineCoefs) {\r\n      return;\r\n    }\r\n\r\n    context.save();\r\n    context.beginPath();\r\n\r\n    if (isBrokenDiagonalRendering() || !interpolate) {\r\n      // Make sure that all lines are horizontal or vertical\r\n      context.moveTo(u1, v1);\r\n      // This is the diagonal line. Do it in 4 steps\r\n      const steps = 4;\r\n      const ud = u0 - u1;\r\n      const vd = v0 - v1;\r\n      for (let step = 0; step < steps; step++) {\r\n        // Go horizontally\r\n        context.lineTo(\r\n          u1 + pixelRound(((step + 1) * ud) / steps),\r\n          v1 + pixelRound((step * vd) / (steps - 1)),\r\n        );\r\n        // Go vertically\r\n        if (step != steps - 1) {\r\n          context.lineTo(\r\n            u1 + pixelRound(((step + 1) * ud) / steps),\r\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1)),\r\n          );\r\n        }\r\n      }\r\n      // We are almost at u0r, v0r\r\n      context.lineTo(u2, v2);\r\n    } else {\r\n      context.moveTo(u1, v1);\r\n      context.lineTo(u0, v0);\r\n      context.lineTo(u2, v2);\r\n    }\r\n\r\n    context.clip();\r\n\r\n    context.transform(\r\n      affineCoefs[0],\r\n      affineCoefs[2],\r\n      affineCoefs[1],\r\n      affineCoefs[3],\r\n      u0,\r\n      v0,\r\n    );\r\n\r\n    context.translate(\r\n      sourceDataExtent[0] - sourceNumericalShiftX,\r\n      sourceDataExtent[3] - sourceNumericalShiftY,\r\n    );\r\n\r\n    let image;\r\n    if (stitchContext) {\r\n      image = stitchContext.canvas;\r\n      context.scale(inverseScale, -inverseScale);\r\n    } else {\r\n      const source = sources[0];\r\n      const extent = source.extent;\r\n      image = source.image;\r\n      context.scale(\r\n        getWidth(extent) / image.width,\r\n        -getHeight(extent) / image.height,\r\n      );\r\n    }\r\n\r\n    context.drawImage(image, 0, 0);\r\n    context.restore();\r\n  });\r\n\r\n  if (stitchContext) {\r\n    releaseCanvas(stitchContext);\r\n    canvasPool.push(stitchContext.canvas);\r\n  }\r\n\r\n  if (renderEdges) {\r\n    context.save();\r\n\r\n    context.globalCompositeOperation = 'source-over';\r\n    context.strokeStyle = 'black';\r\n    context.lineWidth = 1;\r\n\r\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\r\n      const target = triangle.target;\r\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\r\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\r\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\r\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\r\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\r\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\r\n\r\n      context.beginPath();\r\n      context.moveTo(u1, v1);\r\n      context.lineTo(u0, v0);\r\n      context.lineTo(u2, v2);\r\n      context.closePath();\r\n      context.stroke();\r\n    });\r\n\r\n    context.restore();\r\n  }\r\n  return context.canvas;\r\n}\r\n","/**\r\n * @module CME2D/events\r\n */\r\nimport {clear} from './obj.js';\r\n\r\n/**\r\n * Key to use with {@link module:ol/Observable.unByKey}.\r\n * @typedef {Object} EventsKey\r\n * @property {ListenerFunction} listener Listener.\r\n * @property {import(\"./events/Target.js\").EventTargetLike} target Target.\r\n * @property {string} type Type.\r\n * @api\r\n */\r\n\r\n/**\r\n * Listener function. This function is called with an event object as argument.\r\n * When the function returns `false`, event propagation will stop.\r\n *\r\n * @typedef {function((Event|import(\"./events/Event.js\").default)): (void|boolean)} ListenerFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {Object} ListenerObject\r\n * @property {ListenerFunction} handleEvent HandleEvent listener function.\r\n */\r\n\r\n/**\r\n * @typedef {ListenerFunction|ListenerObject} Listener\r\n */\r\n\r\n/**\r\n * Registers an event listener on an event target. Inspired by\r\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\r\n *\r\n * This function efficiently binds a `listener` to a `this` object, and returns\r\n * a key for use with {@link module:ol/events.unlistenByKey}.\r\n *\r\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\r\n * @param {string} type Event type.\r\n * @param {ListenerFunction} listener Listener.\r\n * @param {Object} [thisArg] Object referenced by the `this` keyword in the\r\n *     listener. Default is the `target`.\r\n * @param {boolean} [once] If true, add the listener as one-off listener.\r\n * @return {EventsKey} Unique key for the listener.\r\n */\r\nexport function listen(target, type, listener, thisArg, once) {\r\n  if (once) {\r\n    const originalListener = listener;\r\n    /**\r\n     * @this {typeof target}\r\n     */\r\n    listener = function () {\r\n      target.removeEventListener(type, listener);\r\n      originalListener.apply(thisArg ?? this, arguments);\r\n    };\r\n  } else if (thisArg && thisArg !== target) {\r\n    listener = listener.bind(thisArg);\r\n  }\r\n  const eventsKey = {\r\n    target: target,\r\n    type: type,\r\n    listener: listener,\r\n  };\r\n  target.addEventListener(type, listener);\r\n  return eventsKey;\r\n}\r\n\r\n/**\r\n * Registers a one-off event listener on an event target. Inspired by\r\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\r\n *\r\n * This function efficiently binds a `listener` as self-unregistering listener\r\n * to a `this` object, and returns a key for use with\r\n * {@link module:ol/events.unlistenByKey} in case the listener needs to be\r\n * unregistered before it is called.\r\n *\r\n * When {@link module:ol/events.listen} is called with the same arguments after this\r\n * function, the self-unregistering listener will be turned into a permanent\r\n * listener.\r\n *\r\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\r\n * @param {string} type Event type.\r\n * @param {ListenerFunction} listener Listener.\r\n * @param {Object} [thisArg] Object referenced by the `this` keyword in the\r\n *     listener. Default is the `target`.\r\n * @return {EventsKey} Key for unlistenByKey.\r\n */\r\nexport function listenOnce(target, type, listener, thisArg) {\r\n  return listen(target, type, listener, thisArg, true);\r\n}\r\n\r\n/**\r\n * Unregisters event listeners on an event target. Inspired by\r\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\r\n *\r\n * The argument passed to this function is the key returned from\r\n * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.\r\n *\r\n * @param {EventsKey} key The key.\r\n */\r\nexport function unlistenByKey(key) {\r\n  if (key && key.target) {\r\n    key.target.removeEventListener(key.type, key.listener);\r\n    clear(key);\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/reproj/DataTile\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\r\nimport EventType from '../events/EventType.js';\r\nimport TileState from '../TileState.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {\r\n  calculateSourceExtentResolution,\r\n  canvasPool,\r\n  render as renderReprojected,\r\n} from '../reproj.js';\r\nimport {clamp} from '../math.js';\r\nimport {createCanvasContext2D, releaseCanvas} from '../dom.js';\r\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\r\n */\r\n\r\n/**\r\n * @typedef {Object} TileOffset\r\n * @property {DataTile} tile Tile.\r\n * @property {number} offset Offset.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\r\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\r\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\r\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\r\n * @property {number} pixelRatio Pixel ratio.\r\n * @property {number} gutter Gutter of the source tiles.\r\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected data tile.\r\n * See {@link module:ol/source/DataTile~DataTileSource}.\r\n *\r\n */\r\nclass ReprojDataTile extends DataTile {\r\n  /**\r\n   * @param {Options} options Tile options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      tileCoord: options.tileCoord,\r\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\r\n      interpolate: options.interpolate,\r\n      transition: options.transition,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = options.pixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = options.gutter;\r\n\r\n    /**\r\n     * @type {import(\"../DataTile.js\").Data}\r\n     * @private\r\n     */\r\n    this.reprojData_ = null;\r\n\r\n    /**\r\n     * @type {Error}\r\n     * @private\r\n     */\r\n    this.reprojError_ = null;\r\n\r\n    /**\r\n     * @type {import('../size.js').Size}\r\n     * @private\r\n     */\r\n    this.reprojSize_ = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.sourceTileGrid_ = options.sourceTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.targetTileGrid_ = options.targetTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilecoord.js\").TileCoord}\r\n     */\r\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<TileOffset>}\r\n     */\r\n    this.sourceTiles_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.sourcesListenerKeys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourceZ_ = 0;\r\n\r\n    const sourceProj = options.sourceProj;\r\n    const sourceProjExtent = sourceProj.getExtent();\r\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.clipExtent_ = sourceProj.canWrapX()\r\n      ? sourceTileGridExtent\r\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\r\n        : sourceProjExtent\r\n      : sourceTileGridExtent;\r\n\r\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n      this.wrappedTileCoord_,\r\n    );\r\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\r\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    if (getArea(limitedTargetExtent) === 0) {\r\n      // Tile is completely outside range -> EMPTY\r\n      // TODO: is it actually correct that the source even creates the tile ?\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    if (sourceProjExtent) {\r\n      if (!maxSourceExtent) {\r\n        maxSourceExtent = sourceProjExtent;\r\n      } else {\r\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\r\n      }\r\n    }\r\n\r\n    const targetResolution = this.targetTileGrid_.getResolution(\r\n      this.wrappedTileCoord_[0],\r\n    );\r\n\r\n    const targetProj = options.targetProj;\r\n    const sourceResolution = calculateSourceExtentResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      targetResolution,\r\n    );\r\n\r\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n      // invalid sourceResolution -> EMPTY\r\n      // probably edges of the projections when no extent is defined\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const errorThresholdInPixels =\r\n      options.errorThreshold !== undefined\r\n        ? options.errorThreshold\r\n        : ERROR_THRESHOLD;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution,\r\n    );\r\n\r\n    if (this.triangulation_.getTriangles().length === 0) {\r\n      // no valid triangles -> EMPTY\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\r\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\r\n\r\n    if (maxSourceExtent) {\r\n      if (sourceProj.canWrapX()) {\r\n        sourceExtent[1] = clamp(\r\n          sourceExtent[1],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n        sourceExtent[3] = clamp(\r\n          sourceExtent[3],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n      } else {\r\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\r\n      }\r\n    }\r\n\r\n    if (!getArea(sourceExtent)) {\r\n      this.state = TileState.EMPTY;\r\n    } else {\r\n      let worldWidth = 0;\r\n      let worldsAway = 0;\r\n      if (sourceProj.canWrapX()) {\r\n        worldWidth = getWidth(sourceProjExtent);\r\n        worldsAway = Math.floor(\r\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\r\n        );\r\n      }\r\n\r\n      const sourceExtents = wrapAndSliceX(\r\n        sourceExtent.slice(),\r\n        sourceProj,\r\n        true,\r\n      );\r\n      sourceExtents.forEach((extent) => {\r\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\r\n          extent,\r\n          this.sourceZ_,\r\n        );\r\n        const getTile = options.getTileFunction;\r\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\r\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\r\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\r\n            if (tile) {\r\n              const offset = worldsAway * worldWidth;\r\n              this.sourceTiles_.push({tile, offset});\r\n            }\r\n          }\r\n        }\r\n        ++worldsAway;\r\n      });\r\n\r\n      if (this.sourceTiles_.length === 0) {\r\n        this.state = TileState.EMPTY;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the tile size.\r\n   * @return {import('../size.js').Size} Tile size.\r\n   * @override\r\n   */\r\n  getSize() {\r\n    return this.reprojSize_;\r\n  }\r\n\r\n  /**\r\n   * Get the data for the tile.\r\n   * @return {import(\"../DataTile.js\").Data} Tile data.\r\n   * @override\r\n   */\r\n  getData() {\r\n    return this.reprojData_;\r\n  }\r\n\r\n  /**\r\n   * Get any loading error.\r\n   * @return {Error} Loading error.\r\n   * @override\r\n   */\r\n  getError() {\r\n    return this.reprojError_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const dataSources = [];\r\n    let imageLike = false;\r\n    this.sourceTiles_.forEach((source) => {\r\n      const tile = source.tile;\r\n      if (!tile || tile.getState() !== TileState.LOADED) {\r\n        return;\r\n      }\r\n      const size = tile.getSize();\r\n      const gutter = this.gutter_;\r\n      /**\r\n       * @type {import(\"../DataTile.js\").ArrayLike}\r\n       */\r\n      let tileData;\r\n      const arrayData = asArrayLike(tile.getData());\r\n      if (arrayData) {\r\n        tileData = arrayData;\r\n      } else {\r\n        imageLike = true;\r\n        tileData = toArray(asImageLike(tile.getData()));\r\n      }\r\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\r\n      const isFloat = tileData instanceof Float32Array;\r\n      const pixelCount = pixelSize[0] * pixelSize[1];\r\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\r\n      const tileDataR = new DataType(tileData.buffer);\r\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\r\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\r\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\r\n      const bandCount = Math.floor(\r\n        bytesPerRow / bytesPerElement / pixelSize[0],\r\n      );\r\n      const packedLength = pixelCount * bandCount;\r\n      let packedData = tileDataR;\r\n      if (tileDataR.length !== packedLength) {\r\n        packedData = new DataType(packedLength);\r\n        let dataIndex = 0;\r\n        let rowOffset = 0;\r\n        const colCount = pixelSize[0] * bandCount;\r\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\r\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\r\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\r\n          }\r\n          rowOffset += bytesPerRow / bytesPerElement;\r\n        }\r\n      }\r\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\r\n      extent[0] += source.offset;\r\n      extent[2] += source.offset;\r\n      const clipExtent = this.clipExtent_?.slice();\r\n      if (clipExtent) {\r\n        clipExtent[0] += source.offset;\r\n        clipExtent[2] += source.offset;\r\n      }\r\n      dataSources.push({\r\n        extent: extent,\r\n        clipExtent: clipExtent,\r\n        data: new Uint8ClampedArray(packedData.buffer),\r\n        dataType: DataType,\r\n        bytesPerPixel: bytesPerPixel,\r\n        pixelSize: pixelSize,\r\n      });\r\n    });\r\n    this.sourceTiles_.length = 0;\r\n\r\n    if (dataSources.length === 0) {\r\n      this.state = TileState.ERROR;\r\n      this.changed();\r\n      return;\r\n    }\r\n\r\n    const z = this.wrappedTileCoord_[0];\r\n    const size = this.targetTileGrid_.getTileSize(z);\r\n    const targetWidth = typeof size === 'number' ? size : size[0];\r\n    const targetHeight = typeof size === 'number' ? size : size[1];\r\n    const targetResolution = this.targetTileGrid_.getResolution(z);\r\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\r\n\r\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n      this.wrappedTileCoord_,\r\n    );\r\n\r\n    let dataR, dataU;\r\n\r\n    const bytesPerPixel = dataSources[0].bytesPerPixel;\r\n\r\n    const reprojs = Math.ceil(bytesPerPixel / 3);\r\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\r\n      const sources = [];\r\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\r\n        const dataSource = dataSources[i];\r\n        const buffer = dataSource.data;\r\n        const pixelSize = dataSource.pixelSize;\r\n        const width = pixelSize[0];\r\n        const height = pixelSize[1];\r\n        const context = createCanvasContext2D(width, height, canvasPool);\r\n        const imageData = context.createImageData(width, height);\r\n        const data = imageData.data;\r\n        let offset = reproj * 3;\r\n        for (let j = 0, len = data.length; j < len; j += 4) {\r\n          data[j] = buffer[offset];\r\n          data[j + 1] = buffer[offset + 1];\r\n          data[j + 2] = buffer[offset + 2];\r\n          data[j + 3] = 255;\r\n          offset += bytesPerPixel;\r\n        }\r\n        context.putImageData(imageData, 0, 0);\r\n        sources.push({\r\n          extent: dataSource.extent,\r\n          clipExtent: dataSource.clipExtent,\r\n          image: context.canvas,\r\n        });\r\n      }\r\n\r\n      const canvas = renderReprojected(\r\n        targetWidth,\r\n        targetHeight,\r\n        this.pixelRatio_,\r\n        sourceResolution,\r\n        this.sourceTileGrid_.getExtent(),\r\n        targetResolution,\r\n        targetExtent,\r\n        this.triangulation_,\r\n        sources,\r\n        this.gutter_,\r\n        false,\r\n        false,\r\n        false,\r\n      );\r\n\r\n      for (let i = 0, len = sources.length; i < len; ++i) {\r\n        const canvas = sources[i].image;\r\n        const context = canvas.getContext('2d');\r\n        releaseCanvas(context);\r\n        canvasPool.push(context.canvas);\r\n      }\r\n\r\n      const context = canvas.getContext('2d');\r\n      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n      releaseCanvas(context);\r\n      canvasPool.push(canvas);\r\n\r\n      if (!dataR) {\r\n        dataU = new Uint8ClampedArray(\r\n          bytesPerPixel * imageData.width * imageData.height,\r\n        );\r\n        dataR = new dataSources[0].dataType(dataU.buffer);\r\n      }\r\n\r\n      const data = imageData.data;\r\n      let offset = reproj * 3;\r\n      for (let i = 0, len = data.length; i < len; i += 4) {\r\n        if (data[i + 3] === 255) {\r\n          dataU[offset] = data[i];\r\n          dataU[offset + 1] = data[i + 1];\r\n          dataU[offset + 2] = data[i + 2];\r\n        } else {\r\n          dataU[offset] = 0;\r\n          dataU[offset + 1] = 0;\r\n          dataU[offset + 2] = 0;\r\n        }\r\n        offset += bytesPerPixel;\r\n      }\r\n    }\r\n\r\n    if (imageLike) {\r\n      const context = createCanvasContext2D(targetWidth, targetHeight);\r\n      const imageData = new ImageData(dataR, targetWidth);\r\n      context.putImageData(imageData, 0, 0);\r\n      this.reprojData_ = context.canvas;\r\n    } else {\r\n      this.reprojData_ = dataR;\r\n    }\r\n    this.reprojSize_ = [\r\n      Math.round(targetWidth * this.pixelRatio_),\r\n      Math.round(targetHeight * this.pixelRatio_),\r\n    ];\r\n    this.state = TileState.LOADED;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\r\n      return;\r\n    }\r\n    this.state = TileState.LOADING;\r\n    this.changed();\r\n\r\n    let leftToLoad = 0;\r\n\r\n    this.sourcesListenerKeys_ = [];\r\n    this.sourceTiles_.forEach(({tile}) => {\r\n      const state = tile.getState();\r\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\r\n        return;\r\n      }\r\n      leftToLoad++;\r\n\r\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\r\n        const state = tile.getState();\r\n        if (\r\n          state == TileState.LOADED ||\r\n          state == TileState.ERROR ||\r\n          state == TileState.EMPTY\r\n        ) {\r\n          unlistenByKey(sourceListenKey);\r\n          leftToLoad--;\r\n          if (leftToLoad === 0) {\r\n            this.unlistenSources_();\r\n            this.reproject_();\r\n          }\r\n        }\r\n      });\r\n      this.sourcesListenerKeys_.push(sourceListenKey);\r\n    });\r\n\r\n    if (leftToLoad === 0) {\r\n      setTimeout(this.reproject_.bind(this), 0);\r\n    } else {\r\n      this.sourceTiles_.forEach(function ({tile}) {\r\n        const state = tile.getState();\r\n        if (state == TileState.IDLE) {\r\n          tile.load();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSources_() {\r\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\r\n    this.sourcesListenerKeys_ = null;\r\n  }\r\n}\r\n\r\nexport default ReprojDataTile;\r\n","/**\r\n * @module CME2D/asserts\r\n */\r\n\r\n/**\r\n * @param {*} assertion Assertion we expected to be truthy.\r\n * @param {string} errorMessage Error message.\r\n */\r\nexport function assert(assertion, errorMessage) {\r\n  if (!assertion) {\r\n    throw new Error(errorMessage);\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/structs/LRUCache\r\n */\r\n\r\nimport {assert} from '../asserts.js';\r\n\r\n/**\r\n * @typedef {Object} Entry\r\n * @property {string} key_ Key.\r\n * @property {Entry|null} newer Newer.\r\n * @property {Entry|null} older Older.\r\n * @property {*} value_ Value.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Implements a Least-Recently-Used cache where the keys do not conflict with\r\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\r\n * items from the cache is the responsibility of the user.\r\n *\r\n * @fires import(\"../events/Event.js\").default\r\n * @template T\r\n */\r\nclass LRUCache {\r\n  /**\r\n   * @param {number} [highWaterMark] High water mark.\r\n   */\r\n  constructor(highWaterMark) {\r\n    /**\r\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\r\n     * will be pruned at all.\r\n     * @type {number}\r\n     */\r\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.count_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, Entry>}\r\n     */\r\n    this.entries_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\r\n    this.oldest_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\r\n    this.newest_ = null;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\r\n  }\r\n\r\n  /**\r\n   * Expire the cache.\r\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\r\n   */\r\n  expireCache(keep) {\r\n    while (this.canExpireCache()) {\r\n      this.pop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * FIXME empty description for jsdoc\r\n   */\r\n  clear() {\r\n    this.count_ = 0;\r\n    this.entries_ = {};\r\n    this.oldest_ = null;\r\n    this.newest_ = null;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @return {boolean} Contains key.\r\n   */\r\n  containsKey(key) {\r\n    return this.entries_.hasOwnProperty(key);\r\n  }\r\n\r\n  /**\r\n   * @param {function(T, string, LRUCache<T>): ?} f The function\r\n   *     to call for every entry from the oldest to the newer. This function takes\r\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\r\n   *     The return value is ignored.\r\n   */\r\n  forEach(f) {\r\n    let entry = this.oldest_;\r\n    while (entry) {\r\n      f(entry.value_, entry.key_, this);\r\n      entry = entry.newer;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {*} [options] Options (reserved for subclasses).\r\n   * @return {T} Value.\r\n   */\r\n  get(key, options) {\r\n    const entry = this.entries_[key];\r\n    assert(\r\n      entry !== undefined,\r\n      'Tried to get a value for a key that does not exist in the cache',\r\n    );\r\n    if (entry === this.newest_) {\r\n      return entry.value_;\r\n    }\r\n    if (entry === this.oldest_) {\r\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\r\n      this.oldest_.older = null;\r\n    } else {\r\n      entry.newer.older = entry.older;\r\n      entry.older.newer = entry.newer;\r\n    }\r\n    entry.newer = null;\r\n    entry.older = this.newest_;\r\n    this.newest_.newer = entry;\r\n    this.newest_ = entry;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * Remove an entry from the cache.\r\n   * @param {string} key The entry key.\r\n   * @return {T} The removed entry.\r\n   */\r\n  remove(key) {\r\n    const entry = this.entries_[key];\r\n    assert(\r\n      entry !== undefined,\r\n      'Tried to get a value for a key that does not exist in the cache',\r\n    );\r\n    if (entry === this.newest_) {\r\n      this.newest_ = /** @type {Entry} */ (entry.older);\r\n      if (this.newest_) {\r\n        this.newest_.newer = null;\r\n      }\r\n    } else if (entry === this.oldest_) {\r\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\r\n      if (this.oldest_) {\r\n        this.oldest_.older = null;\r\n      }\r\n    } else {\r\n      entry.newer.older = entry.older;\r\n      entry.older.newer = entry.newer;\r\n    }\r\n    delete this.entries_[key];\r\n    --this.count_;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Count.\r\n   */\r\n  getCount() {\r\n    return this.count_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<string>} Keys.\r\n   */\r\n  getKeys() {\r\n    const keys = new Array(this.count_);\r\n    let i = 0;\r\n    let entry;\r\n    for (entry = this.newest_; entry; entry = entry.older) {\r\n      keys[i++] = entry.key_;\r\n    }\r\n    return keys;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<T>} Values.\r\n   */\r\n  getValues() {\r\n    const values = new Array(this.count_);\r\n    let i = 0;\r\n    let entry;\r\n    for (entry = this.newest_; entry; entry = entry.older) {\r\n      values[i++] = entry.value_;\r\n    }\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * @return {T} Last value.\r\n   */\r\n  peekLast() {\r\n    return this.oldest_.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {string} Last key.\r\n   */\r\n  peekLastKey() {\r\n    return this.oldest_.key_;\r\n  }\r\n\r\n  /**\r\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\r\n   * @return {string} The newest key.\r\n   */\r\n  peekFirstKey() {\r\n    return this.newest_.key_;\r\n  }\r\n\r\n  /**\r\n   * Return an entry without updating least recently used time.\r\n   * @param {string} key Key.\r\n   * @return {T|undefined} Value.\r\n   */\r\n  peek(key) {\r\n    return this.entries_[key]?.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {T} value Value.\r\n   */\r\n  pop() {\r\n    const entry = this.oldest_;\r\n    delete this.entries_[entry.key_];\r\n    if (entry.newer) {\r\n      entry.newer.older = null;\r\n    }\r\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\r\n    if (!this.oldest_) {\r\n      this.newest_ = null;\r\n    }\r\n    --this.count_;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\r\n  replace(key, value) {\r\n    this.get(key); // update `newest_`\r\n    this.entries_[key].value_ = value;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\r\n  set(key, value) {\r\n    assert(\r\n      !(key in this.entries_),\r\n      'Tried to set a value for a key that is used already',\r\n    );\r\n    const entry = {\r\n      key_: key,\r\n      newer: null,\r\n      older: this.newest_,\r\n      value_: value,\r\n    };\r\n    if (!this.newest_) {\r\n      this.oldest_ = entry;\r\n    } else {\r\n      this.newest_.newer = entry;\r\n    }\r\n    this.newest_ = entry;\r\n    this.entries_[key] = entry;\r\n    ++this.count_;\r\n  }\r\n\r\n  /**\r\n   * Set a maximum number of entries for the cache.\r\n   * @param {number} size Cache size.\r\n   * @api\r\n   */\r\n  setSize(size) {\r\n    this.highWaterMark = size;\r\n  }\r\n}\r\n\r\nexport default LRUCache;\r\n","/**\r\n * @module CME2D/tilecoord\r\n */\r\n\r\n/**\r\n * An array of three numbers representing the location of a tile in a tile\r\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\r\n * @typedef {Array<number>} TileCoord\r\n * @api\r\n */\r\n\r\n/**\r\n * @param {number} z Z.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {TileCoord} [tileCoord] Tile coordinate.\r\n * @return {TileCoord} Tile coordinate.\r\n */\r\nexport function createOrUpdate(z, x, y, tileCoord) {\r\n  if (tileCoord !== undefined) {\r\n    tileCoord[0] = z;\r\n    tileCoord[1] = x;\r\n    tileCoord[2] = y;\r\n    return tileCoord;\r\n  }\r\n  return [z, x, y];\r\n}\r\n\r\n/**\r\n * @param {number} z Z.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {string} Key.\r\n */\r\nexport function getKeyZXY(z, x, y) {\r\n  return z + '/' + x + '/' + y;\r\n}\r\n\r\n/**\r\n * Get the key for a tile coord.\r\n * @param {TileCoord} tileCoord The tile coord.\r\n * @return {string} Key.\r\n */\r\nexport function getKey(tileCoord) {\r\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\r\n}\r\n\r\n/**\r\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\r\n * @param {string} tileKey The tile key.\r\n * @return {string} The cache key.\r\n */\r\nexport function getCacheKeyForTileKey(tileKey) {\r\n  const [z, x, y] = tileKey\r\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\r\n    .split(',')\r\n    .map(Number);\r\n  return getKeyZXY(z, x, y);\r\n}\r\n\r\n/**\r\n * Get a tile coord given a key.\r\n * @param {string} key The tile coord key.\r\n * @return {TileCoord} The tile coord.\r\n */\r\nexport function fromKey(key) {\r\n  return key.split('/').map(Number);\r\n}\r\n\r\n/**\r\n * @param {TileCoord} tileCoord Tile coord.\r\n * @return {number} Hash.\r\n */\r\nexport function hash(tileCoord) {\r\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\r\n}\r\n\r\n/**\r\n * @param {number} z The tile z coordinate.\r\n * @param {number} x The tile x coordinate.\r\n * @param {number} y The tile y coordinate.\r\n * @return {number} Hash.\r\n */\r\nexport function hashZXY(z, x, y) {\r\n  return (x << z) + y;\r\n}\r\n\r\n/**\r\n * @param {TileCoord} tileCoord Tile coordinate.\r\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\r\n * @return {boolean} Tile coordinate is within extent and zoom level range.\r\n */\r\nexport function withinExtentAndZ(tileCoord, tileGrid) {\r\n  const z = tileCoord[0];\r\n  const x = tileCoord[1];\r\n  const y = tileCoord[2];\r\n\r\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\r\n    return false;\r\n  }\r\n  const tileRange = tileGrid.getFullTileRange(z);\r\n  if (!tileRange) {\r\n    return true;\r\n  }\r\n  return tileRange.containsXY(x, y);\r\n}\r\n","/**\r\n * @module CME2D/TileCache\r\n */\r\nimport LRUCache from './structs/LRUCache.js';\r\nimport {fromKey, getKey} from './tilecoord.js';\r\n\r\nclass TileCache extends LRUCache {\r\n  /**\r\n   * @override\r\n   */\r\n  clear() {\r\n    while (this.getCount() > 0) {\r\n      this.pop().release();\r\n    }\r\n    super.clear();\r\n  }\r\n\r\n  /**\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   * @override\r\n   */\r\n  expireCache(usedTiles) {\r\n    while (this.canExpireCache()) {\r\n      const tile = this.peekLast();\r\n      if (tile.getKey() in usedTiles) {\r\n        break;\r\n      } else {\r\n        this.pop().release();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\r\n   */\r\n  pruneExceptNewestZ() {\r\n    if (this.getCount() === 0) {\r\n      return;\r\n    }\r\n    const key = this.peekFirstKey();\r\n    const tileCoord = fromKey(key);\r\n    const z = tileCoord[0];\r\n    this.forEach((tile) => {\r\n      if (tile.tileCoord[0] !== z) {\r\n        this.remove(getKey(tile.tileCoord));\r\n        tile.release();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default TileCache;\r\n","/**\r\n * @module CME2D/source/TileEventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * Triggered when a tile starts loading.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\r\n   * @api\r\n   */\r\n  TILELOADSTART: 'tileloadstart',\r\n\r\n  /**\r\n   * Triggered when a tile finishes loading, either when its data is loaded,\r\n   * or when loading was aborted because the tile is no longer needed.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\r\n   * @api\r\n   */\r\n  TILELOADEND: 'tileloadend',\r\n\r\n  /**\r\n   * Triggered if tile loading results in an error. Note that this is not the\r\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\r\n   * for details.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\r\n   * @api\r\n   */\r\n  TILELOADERROR: 'tileloaderror',\r\n};\r\n\r\n/**\r\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\r\n */\r\n","/**\r\n * @module CME2D/ObjectEventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * Triggered when a property is changed.\r\n   * @event module:ol/Object.ObjectEvent#propertychange\r\n   * @api\r\n   */\r\n  PROPERTYCHANGE: 'propertychange',\r\n};\r\n\r\n/**\r\n * @typedef {'propertychange'} Types\r\n */\r\n","/**\r\n * @module CME2D/Observable\r\n */\r\nimport EventTarget from './events/Target.js';\r\nimport EventType from './events/EventType.js';\r\nimport {listen, listenOnce, unlistenByKey} from './events.js';\r\n\r\n/***\r\n * @template {string} Type\r\n * @template {Event|import(\"./events/Event.js\").default} EventClass\r\n * @template Return\r\n * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature\r\n */\r\n\r\n/***\r\n * @template {string} Type\r\n * @template Return\r\n * @typedef {(type: Type[], listener: (event: Event|import(\"./events/Event\").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {'change'|'error'} EventTypes\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {OnSignature<EventTypes, import(\"./events/Event.js\").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * An event target providing convenient methods for listener registration\r\n * and unregistration. A generic `change` event is always available through\r\n * {@link module:ol/Observable~Observable#changed}.\r\n *\r\n * @fires import(\"./events/Event.js\").default\r\n * @api\r\n */\r\nclass Observable extends EventTarget {\r\n  constructor() {\r\n    super();\r\n\r\n    this.on =\r\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\r\n        this.onInternal\r\n      );\r\n\r\n    this.once =\r\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\r\n        this.onceInternal\r\n      );\r\n\r\n    this.un = /** @type {ObservableOnSignature<void>} */ (this.unInternal);\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.revision_ = 0;\r\n  }\r\n\r\n  /**\r\n   * Increases the revision counter and dispatches a 'change' event.\r\n   * @api\r\n   */\r\n  changed() {\r\n    ++this.revision_;\r\n    this.dispatchEvent(EventType.CHANGE);\r\n  }\r\n\r\n  /**\r\n   * Get the version number for this object.  Each time the object is modified,\r\n   * its version number will be incremented.\r\n   * @return {number} Revision.\r\n   * @api\r\n   */\r\n  getRevision() {\r\n    return this.revision_;\r\n  }\r\n\r\n  /**\r\n   * @param {string|Array<string>} type Type.\r\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\r\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\r\n   * @protected\r\n   */\r\n  onInternal(type, listener) {\r\n    if (Array.isArray(type)) {\r\n      const len = type.length;\r\n      const keys = new Array(len);\r\n      for (let i = 0; i < len; ++i) {\r\n        keys[i] = listen(this, type[i], listener);\r\n      }\r\n      return keys;\r\n    }\r\n    return listen(this, /** @type {string} */ (type), listener);\r\n  }\r\n\r\n  /**\r\n   * @param {string|Array<string>} type Type.\r\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\r\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\r\n   * @protected\r\n   */\r\n  onceInternal(type, listener) {\r\n    let key;\r\n    if (Array.isArray(type)) {\r\n      const len = type.length;\r\n      key = new Array(len);\r\n      for (let i = 0; i < len; ++i) {\r\n        key[i] = listenOnce(this, type[i], listener);\r\n      }\r\n    } else {\r\n      key = listenOnce(this, /** @type {string} */ (type), listener);\r\n    }\r\n    /** @type {Object} */ (listener).ol_key = key;\r\n    return key;\r\n  }\r\n\r\n  /**\r\n   * Unlisten for a certain type of event.\r\n   * @param {string|Array<string>} type Type.\r\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\r\n   * @protected\r\n   */\r\n  unInternal(type, listener) {\r\n    const key = /** @type {Object} */ (listener).ol_key;\r\n    if (key) {\r\n      unByKey(key);\r\n    } else if (Array.isArray(type)) {\r\n      for (let i = 0, ii = type.length; i < ii; ++i) {\r\n        this.removeEventListener(type[i], listener);\r\n      }\r\n    } else {\r\n      this.removeEventListener(type, listener);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Listen for a certain type of event.\r\n * @function\r\n * @param {string|Array<string>} type The event type or array of event types.\r\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\r\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\r\n *     called with an array of event types as the first argument, the return\r\n *     will be an array of keys.\r\n * @api\r\n */\r\nObservable.prototype.on;\r\n\r\n/**\r\n * Listen once for a certain type of event.\r\n * @function\r\n * @param {string|Array<string>} type The event type or array of event types.\r\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\r\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\r\n *     called with an array of event types as the first argument, the return\r\n *     will be an array of keys.\r\n * @api\r\n */\r\nObservable.prototype.once;\r\n\r\n/**\r\n * Unlisten for a certain type of event.\r\n * @function\r\n * @param {string|Array<string>} type The event type or array of event types.\r\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\r\n * @api\r\n */\r\nObservable.prototype.un;\r\n\r\n/**\r\n * Removes an event listener using the key returned by `on()` or `once()`.\r\n * @param {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} key The key returned by `on()`\r\n *     or `once()` (or an array of keys).\r\n * @api\r\n */\r\nexport function unByKey(key) {\r\n  if (Array.isArray(key)) {\r\n    for (let i = 0, ii = key.length; i < ii; ++i) {\r\n      unlistenByKey(key[i]);\r\n    }\r\n  } else {\r\n    unlistenByKey(/** @type {import(\"./events.js\").EventsKey} */ (key));\r\n  }\r\n}\r\n\r\nexport default Observable;\r\n","/**\r\n * @module CME2D/Object\r\n */\r\nimport Event from './events/Event.js';\r\nimport ObjectEventType from './ObjectEventType.js';\r\nimport Observable from './Observable.js';\r\nimport {getUid} from './util.js';\r\nimport {isEmpty} from './obj.js';\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.\r\n */\r\nexport class ObjectEvent extends Event {\r\n  /**\r\n   * @param {string} type The event type.\r\n   * @param {string} key The property name.\r\n   * @param {*} oldValue The old value for `key`.\r\n   */\r\n  constructor(type, key, oldValue) {\r\n    super(type);\r\n\r\n    /**\r\n     * The name of the property whose value is changing.\r\n     * @type {string}\r\n     * @api\r\n     */\r\n    this.key = key;\r\n\r\n    /**\r\n     * The old value. To get the new value use `e.target.get(e.key)` where\r\n     * `e` is the event object.\r\n     * @type {*}\r\n     * @api\r\n     */\r\n    this.oldValue = oldValue;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\r\n *    import(\"./Observable\").OnSignature<import(\"./ObjectEventType\").Types, ObjectEvent, Return> &\r\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|import(\"./ObjectEventType\").Types, Return>} ObjectOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Most non-trivial classes inherit from this.\r\n *\r\n * This extends {@link module:ol/Observable~Observable} with observable\r\n * properties, where each property is observable as well as the object as a\r\n * whole.\r\n *\r\n * Classes that inherit from this have pre-defined properties, to which you can\r\n * add your owns. The pre-defined properties are listed in this documentation as\r\n * 'Observable Properties', and have their own accessors; for example,\r\n * {@link module:ol/Map~Map} has a `target` property, accessed with\r\n * `getTarget()` and changed with `setTarget()`. Not all properties are however\r\n * settable. There are also general-purpose accessors `get()` and `set()`. For\r\n * example, `get('target')` is equivalent to `getTarget()`.\r\n *\r\n * The `set` accessors trigger a change event, and you can monitor this by\r\n * registering a listener. For example, {@link module:ol/View~View} has a\r\n * `center` property, so `view.on('change:center', function(evt) {...});` would\r\n * call the function whenever the value of the center property changes. Within\r\n * the function, `evt.target` would be the view, so `evt.target.getCenter()`\r\n * would return the new center.\r\n *\r\n * You can add your own observable properties with\r\n * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\r\n * You can listen for changes on that property value with\r\n * `object.on('change:prop', listener)`. You can get a list of all\r\n * properties with {@link module:ol/Object~BaseObject#getProperties}.\r\n *\r\n * Note that the observable properties are separate from standard JS properties.\r\n * You can, for example, give your map object a title with\r\n * `map.title='New title'` and with `map.set('title', 'Another title')`. The\r\n * first will be a `hasOwnProperty`; the second will appear in\r\n * `getProperties()`. Only the second is observable.\r\n *\r\n * Properties can be deleted by using the unset method. E.g.\r\n * object.unset('foo').\r\n *\r\n * @fires ObjectEvent\r\n * @api\r\n */\r\nclass BaseObject extends Observable {\r\n  /**\r\n   * @param {Object<string, *>} [values] An object with key-value pairs.\r\n   */\r\n  constructor(values) {\r\n    super();\r\n\r\n    /***\r\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {ObjectOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is\r\n    // the same as the order in which they were created.  This also helps to\r\n    // ensure that object properties are always added in the same order, which\r\n    // helps many JavaScript engines generate faster code.\r\n    getUid(this);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, *>|null}\r\n     */\r\n    this.values_ = null;\r\n\r\n    if (values !== undefined) {\r\n      this.setProperties(values);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets a value.\r\n   * @param {string} key Key name.\r\n   * @return {*} Value.\r\n   * @api\r\n   */\r\n  get(key) {\r\n    let value;\r\n    if (this.values_ && this.values_.hasOwnProperty(key)) {\r\n      value = this.values_[key];\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Get a list of object property names.\r\n   * @return {Array<string>} List of property names.\r\n   * @api\r\n   */\r\n  getKeys() {\r\n    return (this.values_ && Object.keys(this.values_)) || [];\r\n  }\r\n\r\n  /**\r\n   * Get an object of all property names and values.\r\n   * @return {Object<string, *>} Object.\r\n   * @api\r\n   */\r\n  getProperties() {\r\n    return (this.values_ && Object.assign({}, this.values_)) || {};\r\n  }\r\n\r\n  /**\r\n   * Get an object of all property names and values.\r\n   * @return {Object<string, *>?} Object.\r\n   */\r\n  getPropertiesInternal() {\r\n    return this.values_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} The object has properties.\r\n   */\r\n  hasProperties() {\r\n    return !!this.values_;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key name.\r\n   * @param {*} oldValue Old value.\r\n   */\r\n  notify(key, oldValue) {\r\n    let eventType;\r\n    eventType = `change:${key}`;\r\n    if (this.hasListener(eventType)) {\r\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\r\n    }\r\n    eventType = ObjectEventType.PROPERTYCHANGE;\r\n    if (this.hasListener(eventType)) {\r\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key name.\r\n   * @param {import(\"./events.js\").Listener} listener Listener.\r\n   */\r\n  addChangeListener(key, listener) {\r\n    this.addEventListener(`change:${key}`, listener);\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key name.\r\n   * @param {import(\"./events.js\").Listener} listener Listener.\r\n   */\r\n  removeChangeListener(key, listener) {\r\n    this.removeEventListener(`change:${key}`, listener);\r\n  }\r\n\r\n  /**\r\n   * Sets a value.\r\n   * @param {string} key Key name.\r\n   * @param {*} value Value.\r\n   * @param {boolean} [silent] Update without triggering an event.\r\n   * @api\r\n   */\r\n  set(key, value, silent) {\r\n    const values = this.values_ || (this.values_ = {});\r\n    if (silent) {\r\n      values[key] = value;\r\n    } else {\r\n      const oldValue = values[key];\r\n      values[key] = value;\r\n      if (oldValue !== value) {\r\n        this.notify(key, oldValue);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets a collection of key-value pairs.  Note that this changes any existing\r\n   * properties and adds new ones (it does not remove any existing properties).\r\n   * @param {Object<string, *>} values Values.\r\n   * @param {boolean} [silent] Update without triggering an event.\r\n   * @api\r\n   */\r\n  setProperties(values, silent) {\r\n    for (const key in values) {\r\n      this.set(key, values[key], silent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply any properties from another object without triggering events.\r\n   * @param {BaseObject} source The source object.\r\n   * @protected\r\n   */\r\n  applyProperties(source) {\r\n    if (!source.values_) {\r\n      return;\r\n    }\r\n    Object.assign(this.values_ || (this.values_ = {}), source.values_);\r\n  }\r\n\r\n  /**\r\n   * Unsets a property.\r\n   * @param {string} key Key name.\r\n   * @param {boolean} [silent] Unset without triggering an event.\r\n   * @api\r\n   */\r\n  unset(key, silent) {\r\n    if (this.values_ && key in this.values_) {\r\n      const oldValue = this.values_[key];\r\n      delete this.values_[key];\r\n      if (isEmpty(this.values_)) {\r\n        this.values_ = null;\r\n      }\r\n      if (!silent) {\r\n        this.notify(key, oldValue);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default BaseObject;\r\n","/**\r\n * @module CME2D/source/Source\r\n */\r\nimport BaseObject from '../Object.js';\r\nimport {get as getProjection} from '../proj.js';\r\n\r\n/**\r\n * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State\r\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\r\n */\r\n\r\n/**\r\n * A function that takes a {@link import(\"../View.js\").ViewStateLayerStateExtent} and returns a string or\r\n * an array of strings representing source attributions.\r\n *\r\n * @typedef {function(import(\"../View.js\").ViewStateLayerStateExtent): (string|Array<string>)} Attribution\r\n */\r\n\r\n/**\r\n * A type that can be used to provide attribution information for data sources.\r\n *\r\n * It represents either\r\n * * a simple string (e.g. `' Acme Inc.'`)\r\n * * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)\r\n * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})\r\n *\r\n * @typedef {string|Array<string>|Attribution} AttributionLike\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\r\n * @property {import(\"./Source.js\").State} [state='ready'] State.\r\n * @property {boolean} [wrapX=false] WrapX.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\r\n *\r\n * A generic `change` event is triggered when the state of the source changes.\r\n * @abstract\r\n * @api\r\n */\r\nclass Source extends BaseObject {\r\n  /**\r\n   * @param {Options} options Source options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../proj/Projection.js\").default|null}\r\n     */\r\n    this.projection = getProjection(options.projection);\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Attribution}\r\n     */\r\n    this.attributions_ = adaptAttributions(options.attributions);\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;\r\n\r\n    /**\r\n     * This source is currently loading data. Sources that defer loading to the\r\n     * map's tile queue never set this to `true`.\r\n     * @type {boolean}\r\n     */\r\n    this.loading = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./Source.js\").State}\r\n     */\r\n    this.state_ = options.state !== undefined ? options.state : 'ready';\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.interpolate_ = !!options.interpolate;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {function(import(\"../View.js\").ViewOptions):void}\r\n     */\r\n    this.viewResolver = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {function(Error):void}\r\n     */\r\n    this.viewRejector = null;\r\n\r\n    const self = this;\r\n    /**\r\n     * @private\r\n     * @type {Promise<import(\"../View.js\").ViewOptions>}\r\n     */\r\n    this.viewPromise_ = new Promise(function (resolve, reject) {\r\n      self.viewResolver = resolve;\r\n      self.viewRejector = reject;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the attribution function for the source.\r\n   * @return {?Attribution} Attribution function.\r\n   * @api\r\n   */\r\n  getAttributions() {\r\n    return this.attributions_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Attributions are collapsible.\r\n   * @api\r\n   */\r\n  getAttributionsCollapsible() {\r\n    return this.attributionsCollapsible_;\r\n  }\r\n\r\n  /**\r\n   * Get the projection of the source.\r\n   * @return {import(\"../proj/Projection.js\").default|null} Projection.\r\n   * @api\r\n   */\r\n  getProjection() {\r\n    return this.projection;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\r\n   * @return {Array<number>|null} Resolutions.\r\n   */\r\n  getResolutions(projection) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\r\n   */\r\n  getView() {\r\n    return this.viewPromise_;\r\n  }\r\n\r\n  /**\r\n   * Get the state of the source, see {@link import(\"./Source.js\").State} for possible states.\r\n   * @return {import(\"./Source.js\").State} State.\r\n   * @api\r\n   */\r\n  getState() {\r\n    return this.state_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean|undefined} Wrap X.\r\n   */\r\n  getWrapX() {\r\n    return this.wrapX_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Use linear interpolation when resampling.\r\n   */\r\n  getInterpolate() {\r\n    return this.interpolate_;\r\n  }\r\n\r\n  /**\r\n   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.\r\n   * @api\r\n   */\r\n  refresh() {\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the attributions of the source.\r\n   * @param {AttributionLike|undefined} attributions Attributions.\r\n   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},\r\n   *     or `undefined`.\r\n   * @api\r\n   */\r\n  setAttributions(attributions) {\r\n    this.attributions_ = adaptAttributions(attributions);\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the state of the source.\r\n   * @param {import(\"./Source.js\").State} state State.\r\n   */\r\n  setState(state) {\r\n    this.state_ = state;\r\n    this.changed();\r\n  }\r\n}\r\n\r\n/**\r\n * Turns the attributions option into an attributions function.\r\n * @param {AttributionLike|undefined} attributionLike The attribution option.\r\n * @return {Attribution|null} An attribution function (or null).\r\n */\r\nfunction adaptAttributions(attributionLike) {\r\n  if (!attributionLike) {\r\n    return null;\r\n  }\r\n  if (typeof attributionLike === 'function') {\r\n    return attributionLike;\r\n  }\r\n  if (!Array.isArray(attributionLike)) {\r\n    attributionLike = [attributionLike];\r\n  }\r\n  return (frameState) => attributionLike;\r\n}\r\n\r\nexport default Source;\r\n","/**\r\n * @module CME2D/TileRange\r\n */\r\n\r\n/**\r\n * A representation of a contiguous block of tiles.  A tile range is specified\r\n * by its min/max tile coordinates and is inclusive of coordinates.\r\n */\r\nclass TileRange {\r\n  /**\r\n   * @param {number} minX Minimum X.\r\n   * @param {number} maxX Maximum X.\r\n   * @param {number} minY Minimum Y.\r\n   * @param {number} maxY Maximum Y.\r\n   */\r\n  constructor(minX, maxX, minY, maxY) {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.minX = minX;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.maxX = maxX;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.minY = minY;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.maxY = maxY;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {boolean} Contains tile coordinate.\r\n   */\r\n  contains(tileCoord) {\r\n    return this.containsXY(tileCoord[1], tileCoord[2]);\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   * @return {boolean} Contains.\r\n   */\r\n  containsTileRange(tileRange) {\r\n    return (\r\n      this.minX <= tileRange.minX &&\r\n      tileRange.maxX <= this.maxX &&\r\n      this.minY <= tileRange.minY &&\r\n      tileRange.maxY <= this.maxY\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @return {boolean} Contains coordinate.\r\n   */\r\n  containsXY(x, y) {\r\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   * @return {boolean} Equals.\r\n   */\r\n  equals(tileRange) {\r\n    return (\r\n      this.minX == tileRange.minX &&\r\n      this.minY == tileRange.minY &&\r\n      this.maxX == tileRange.maxX &&\r\n      this.maxY == tileRange.maxY\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   */\r\n  extend(tileRange) {\r\n    if (tileRange.minX < this.minX) {\r\n      this.minX = tileRange.minX;\r\n    }\r\n    if (tileRange.maxX > this.maxX) {\r\n      this.maxX = tileRange.maxX;\r\n    }\r\n    if (tileRange.minY < this.minY) {\r\n      this.minY = tileRange.minY;\r\n    }\r\n    if (tileRange.maxY > this.maxY) {\r\n      this.maxY = tileRange.maxY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {number} Height.\r\n   */\r\n  getHeight() {\r\n    return this.maxY - this.minY + 1;\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./size.js\").Size} Size.\r\n   */\r\n  getSize() {\r\n    return [this.getWidth(), this.getHeight()];\r\n  }\r\n\r\n  /**\r\n   * @return {number} Width.\r\n   */\r\n  getWidth() {\r\n    return this.maxX - this.minX + 1;\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   * @return {boolean} Intersects.\r\n   */\r\n  intersects(tileRange) {\r\n    return (\r\n      this.minX <= tileRange.maxX &&\r\n      this.maxX >= tileRange.minX &&\r\n      this.minY <= tileRange.maxY &&\r\n      this.maxY >= tileRange.minY\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} minX Minimum X.\r\n * @param {number} maxX Maximum X.\r\n * @param {number} minY Minimum Y.\r\n * @param {number} maxY Maximum Y.\r\n * @param {TileRange} [tileRange] TileRange.\r\n * @return {TileRange} Tile range.\r\n */\r\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\r\n  if (tileRange !== undefined) {\r\n    tileRange.minX = minX;\r\n    tileRange.maxX = maxX;\r\n    tileRange.minY = minY;\r\n    tileRange.maxY = maxY;\r\n    return tileRange;\r\n  }\r\n  return new TileRange(minX, maxX, minY, maxY);\r\n}\r\n\r\nexport default TileRange;\r\n","/**\r\n * @module CME2D/tilegrid/common\r\n */\r\n\r\n/**\r\n * Default maximum zoom for default tile grids.\r\n * @type {number}\r\n */\r\nexport const DEFAULT_MAX_ZOOM = 42;\r\n\r\n/**\r\n * Default tile size.\r\n * @type {number}\r\n */\r\nexport const DEFAULT_TILE_SIZE = 256;\r\n","/**\r\n * @module CME2D/geom/flat/segments\r\n */\r\n\r\n/**\r\n * This function calls `callback` for each segment of the flat coordinates\r\n * array. If the callback returns a truthy value the function returns that\r\n * value immediately. Otherwise the function returns `false`.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\r\n *     called for each segment.\r\n * @return {T|boolean} Value.\r\n * @template T\r\n */\r\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\r\n  let ret;\r\n  offset += stride;\r\n  for (; offset < end; offset += stride) {\r\n    ret = callback(\r\n      flatCoordinates.slice(offset - stride, offset),\r\n      flatCoordinates.slice(offset, offset + stride),\r\n    );\r\n    if (ret) {\r\n      return ret;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/contains\r\n */\r\nimport {forEachCorner} from '../../extent.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} Contains extent.\r\n */\r\nexport function linearRingContainsExtent(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  extent,\r\n) {\r\n  const outside = forEachCorner(\r\n    extent,\r\n    /**\r\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\r\n     * @return {boolean} Contains (x, y).\r\n     */\r\n    function (coordinate) {\r\n      return !linearRingContainsXY(\r\n        flatCoordinates,\r\n        offset,\r\n        end,\r\n        stride,\r\n        coordinate[0],\r\n        coordinate[1],\r\n      );\r\n    },\r\n  );\r\n  return !outside;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {boolean} Contains (x, y).\r\n */\r\nexport function linearRingContainsXY(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  x,\r\n  y,\r\n) {\r\n  // https://geomalgorithms.com/a03-_inclusion.html\r\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\r\n  // This code may be freely used and modified for any purpose\r\n  // providing that this copyright notice is included with it.\r\n  // SoftSurfer makes no warranty for this code, and cannot be held\r\n  // liable for any real or imagined damage resulting from its use.\r\n  // Users of this code must verify correctness for their application.\r\n  let wn = 0;\r\n  let x1 = flatCoordinates[end - stride];\r\n  let y1 = flatCoordinates[end - stride + 1];\r\n  for (; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    if (y1 <= y) {\r\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\r\n        wn++;\r\n      }\r\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\r\n      wn--;\r\n    }\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return wn !== 0;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {boolean} Contains (x, y).\r\n */\r\nexport function linearRingsContainsXY(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  x,\r\n  y,\r\n) {\r\n  if (ends.length === 0) {\r\n    return false;\r\n  }\r\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\r\n    return false;\r\n  }\r\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\r\n    if (\r\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\r\n    ) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {boolean} Contains (x, y).\r\n */\r\nexport function linearRingssContainsXY(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  x,\r\n  y,\r\n) {\r\n  if (endss.length === 0) {\r\n    return false;\r\n  }\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\r\n      return true;\r\n    }\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return false;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/intersectsextent\r\n */\r\nimport {\r\n  containsExtent,\r\n  createEmpty,\r\n  extendFlatCoordinates,\r\n  intersects,\r\n  intersectsSegment,\r\n} from '../../extent.js';\r\nimport {forEach as forEachSegment} from './segments.js';\r\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLineString(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  extent,\r\n) {\r\n  const coordinatesExtent = extendFlatCoordinates(\r\n    createEmpty(),\r\n    flatCoordinates,\r\n    offset,\r\n    end,\r\n    stride,\r\n  );\r\n  if (!intersects(extent, coordinatesExtent)) {\r\n    return false;\r\n  }\r\n  if (containsExtent(extent, coordinatesExtent)) {\r\n    return true;\r\n  }\r\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\r\n    return true;\r\n  }\r\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\r\n    return true;\r\n  }\r\n  return forEachSegment(\r\n    flatCoordinates,\r\n    offset,\r\n    end,\r\n    stride,\r\n    /**\r\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\r\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\r\n     * @return {boolean} `true` if the segment and the extent intersect,\r\n     *     `false` otherwise.\r\n     */\r\n    function (point1, point2) {\r\n      return intersectsSegment(extent, point1, point2);\r\n    },\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLineStringArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  extent,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    if (\r\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\r\n    ) {\r\n      return true;\r\n    }\r\n    offset = ends[i];\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLinearRing(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  extent,\r\n) {\r\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\r\n    return true;\r\n  }\r\n  if (\r\n    linearRingContainsXY(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      extent[0],\r\n      extent[1],\r\n    )\r\n  ) {\r\n    return true;\r\n  }\r\n  if (\r\n    linearRingContainsXY(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      extent[0],\r\n      extent[3],\r\n    )\r\n  ) {\r\n    return true;\r\n  }\r\n  if (\r\n    linearRingContainsXY(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      extent[2],\r\n      extent[1],\r\n    )\r\n  ) {\r\n    return true;\r\n  }\r\n  if (\r\n    linearRingContainsXY(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      extent[2],\r\n      extent[3],\r\n    )\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLinearRingArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  extent,\r\n) {\r\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\r\n    return false;\r\n  }\r\n  if (ends.length === 1) {\r\n    return true;\r\n  }\r\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\r\n    if (\r\n      linearRingContainsExtent(\r\n        flatCoordinates,\r\n        ends[i - 1],\r\n        ends[i],\r\n        stride,\r\n        extent,\r\n      )\r\n    ) {\r\n      if (\r\n        !intersectsLineString(\r\n          flatCoordinates,\r\n          ends[i - 1],\r\n          ends[i],\r\n          stride,\r\n          extent,\r\n        )\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLinearRingMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  extent,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    if (\r\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\r\n    ) {\r\n      return true;\r\n    }\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return false;\r\n}\r\n","/**\r\n * @module CME2D/size\r\n */\r\n\r\n/**\r\n * An array of numbers representing a size: `[width, height]`.\r\n * @typedef {Array<number>} Size\r\n * @api\r\n */\r\n\r\n/**\r\n * Returns a buffered size.\r\n * @param {Size} size Size.\r\n * @param {number} num The amount by which to buffer.\r\n * @param {Size} [dest] Optional reusable size array.\r\n * @return {Size} The buffered size.\r\n */\r\nexport function buffer(size, num, dest) {\r\n  if (dest === undefined) {\r\n    dest = [0, 0];\r\n  }\r\n  dest[0] = size[0] + 2 * num;\r\n  dest[1] = size[1] + 2 * num;\r\n  return dest;\r\n}\r\n\r\n/**\r\n * Determines if a size has a positive area.\r\n * @param {Size} size The size to test.\r\n * @return {boolean} The size has a positive area.\r\n */\r\nexport function hasArea(size) {\r\n  return size[0] > 0 && size[1] > 0;\r\n}\r\n\r\n/**\r\n * Returns a size scaled by a ratio. The result will be an array of integers.\r\n * @param {Size} size Size.\r\n * @param {number} ratio Ratio.\r\n * @param {Size} [dest] Optional reusable size array.\r\n * @return {Size} The scaled size.\r\n */\r\nexport function scale(size, ratio, dest) {\r\n  if (dest === undefined) {\r\n    dest = [0, 0];\r\n  }\r\n  dest[0] = (size[0] * ratio + 0.5) | 0;\r\n  dest[1] = (size[1] * ratio + 0.5) | 0;\r\n  return dest;\r\n}\r\n\r\n/**\r\n * Returns an `Size` array for the passed in number (meaning: square) or\r\n * `Size` array.\r\n * (meaning: non-square),\r\n * @param {number|Size} size Width and height.\r\n * @param {Size} [dest] Optional reusable size array.\r\n * @return {Size} Size.\r\n * @api\r\n */\r\nexport function toSize(size, dest) {\r\n  if (Array.isArray(size)) {\r\n    return size;\r\n  }\r\n  if (dest === undefined) {\r\n    dest = [size, size];\r\n  } else {\r\n    dest[0] = size;\r\n    dest[1] = size;\r\n  }\r\n  return dest;\r\n}\r\n","/**\r\n * @module CME2D/tilegrid/TileGrid\r\n */\r\nimport TileRange, {\r\n  createOrUpdate as createOrUpdateTileRange,\r\n} from '../TileRange.js';\r\nimport {DEFAULT_TILE_SIZE} from './common.js';\r\nimport {assert} from '../asserts.js';\r\nimport {ceil, clamp, floor} from '../math.js';\r\nimport {createOrUpdate, getTopLeft} from '../extent.js';\r\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\r\nimport {intersectsLinearRing} from '../geom/flat/intersectsextent.js';\r\nimport {isSorted, linearFindNearest} from '../array.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @private\r\n * @type {import(\"../tilecoord.js\").TileCoord}\r\n */\r\nconst tmpTileCoord = [0, 0, 0];\r\n\r\n/**\r\n * Number of decimal digits to consider in integer values when rounding.\r\n * @type {number}\r\n */\r\nconst DECIMALS = 5;\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\r\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\r\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\r\n * @property {number} [minZoom=0] Minimum zoom.\r\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\r\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\r\n * specified, `extent` or `origins` must be provided.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\r\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\r\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\r\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\r\n * `origin` must be provided.\r\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\r\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\r\n * array will have a length of `maxZoom + 1`.\r\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\r\n * of the grid for each zoom level. If specified the values\r\n * define each zoom level's extent together with the `origin` or `origins`.\r\n * A grid `extent` can be configured in addition, and will further limit the extent\r\n * for which tile requests are made by sources. If the bottom-left corner of\r\n * an extent is used as `origin` or `origins`, then the `y` value must be\r\n * negative because OpenLayers tile coordinates use the top left as the origin.\r\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\r\n * Default is `[256, 256]`.\r\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\r\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\r\n * tile size.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for setting the grid pattern for sources accessing tiled-image\r\n * servers.\r\n * @api\r\n */\r\nclass TileGrid {\r\n  /**\r\n   * @param {Options} options Tile grid options.\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<number>}\r\n     */\r\n    this.resolutions_ = options.resolutions;\r\n    assert(\r\n      isSorted(\r\n        this.resolutions_,\r\n        /**\r\n         * @param {number} a First resolution\r\n         * @param {number} b Second resolution\r\n         * @return {number} Comparison result\r\n         */\r\n        (a, b) => b - a,\r\n        true,\r\n      ),\r\n      '`resolutions` must be sorted in descending order',\r\n    );\r\n\r\n    // check if we've got a consistent zoom factor and origin\r\n    let zoomFactor;\r\n    if (!options.origins) {\r\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\r\n        if (!zoomFactor) {\r\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\r\n        } else {\r\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\r\n            zoomFactor = undefined;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.zoomFactor_ = zoomFactor;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.maxZoom = this.resolutions_.length - 1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate|null}\r\n     */\r\n    this.origin_ = options.origin !== undefined ? options.origin : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\r\n     */\r\n    this.origins_ = null;\r\n    if (options.origins !== undefined) {\r\n      this.origins_ = options.origins;\r\n      assert(\r\n        this.origins_.length == this.resolutions_.length,\r\n        'Number of `origins` and `resolutions` must be equal',\r\n      );\r\n    }\r\n\r\n    const extent = options.extent;\r\n\r\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\r\n      this.origin_ = getTopLeft(extent);\r\n    }\r\n\r\n    assert(\r\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\r\n      'Either `origin` or `origins` must be configured, never both',\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number|import(\"../size.js\").Size>}\r\n     */\r\n    this.tileSizes_ = null;\r\n    if (options.tileSizes !== undefined) {\r\n      this.tileSizes_ = options.tileSizes;\r\n      assert(\r\n        this.tileSizes_.length == this.resolutions_.length,\r\n        'Number of `tileSizes` and `resolutions` must be equal',\r\n      );\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|import(\"../size.js\").Size}\r\n     */\r\n    this.tileSize_ =\r\n      options.tileSize !== undefined\r\n        ? options.tileSize\r\n        : !this.tileSizes_\r\n          ? DEFAULT_TILE_SIZE\r\n          : null;\r\n    assert(\r\n      (!this.tileSize_ && this.tileSizes_) ||\r\n        (this.tileSize_ && !this.tileSizes_),\r\n      'Either `tileSize` or `tileSizes` must be configured, never both',\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = extent !== undefined ? extent : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../TileRange.js\").default>}\r\n     */\r\n    this.fullTileRanges_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../size.js\").Size}\r\n     */\r\n    this.tmpSize_ = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.tmpExtent_ = [0, 0, 0, 0];\r\n\r\n    if (options.sizes !== undefined) {\r\n      this.fullTileRanges_ = options.sizes.map((size, z) => {\r\n        const tileRange = new TileRange(\r\n          Math.min(0, size[0]),\r\n          Math.max(size[0] - 1, -1),\r\n          Math.min(0, size[1]),\r\n          Math.max(size[1] - 1, -1),\r\n        );\r\n        if (extent) {\r\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\r\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\r\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\r\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\r\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\r\n        }\r\n        return tileRange;\r\n      });\r\n    } else if (extent) {\r\n      this.calculateTileRanges_(extent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call a function with each tile coordinate for a given extent and zoom level.\r\n   *\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} zoom Integer zoom level.\r\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\r\n   * @api\r\n   */\r\n  forEachTileCoord(extent, zoom, callback) {\r\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\r\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\r\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\r\n        callback([zoom, i, j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {boolean} Callback succeeded.\r\n   */\r\n  forEachTileCoordParentTileRange(\r\n    tileCoord,\r\n    callback,\r\n    tempTileRange,\r\n    tempExtent,\r\n  ) {\r\n    let tileRange, x, y;\r\n    let tileCoordExtent = null;\r\n    let z = tileCoord[0] - 1;\r\n    if (this.zoomFactor_ === 2) {\r\n      x = tileCoord[1];\r\n      y = tileCoord[2];\r\n    } else {\r\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\r\n    }\r\n    while (z >= this.minZoom) {\r\n      if (x !== undefined && y !== undefined) {\r\n        x = Math.floor(x / 2);\r\n        y = Math.floor(y / 2);\r\n        tileRange = createOrUpdateTileRange(x, x, y, y, tempTileRange);\r\n      } else {\r\n        tileRange = this.getTileRangeForExtentAndZ(\r\n          tileCoordExtent,\r\n          z,\r\n          tempTileRange,\r\n        );\r\n      }\r\n      if (callback(z, tileRange)) {\r\n        return true;\r\n      }\r\n      --z;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get the extent for this tile grid, if it was configured.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return this.extent_;\r\n  }\r\n\r\n  /**\r\n   * Get the maximum zoom level for the grid.\r\n   * @return {number} Max zoom.\r\n   * @api\r\n   */\r\n  getMaxZoom() {\r\n    return this.maxZoom;\r\n  }\r\n\r\n  /**\r\n   * Get the minimum zoom level for the grid.\r\n   * @return {number} Min zoom.\r\n   * @api\r\n   */\r\n  getMinZoom() {\r\n    return this.minZoom;\r\n  }\r\n\r\n  /**\r\n   * Get the origin for the grid at the given zoom level.\r\n   * @param {number} z Integer zoom level.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\r\n   * @api\r\n   */\r\n  getOrigin(z) {\r\n    if (this.origin_) {\r\n      return this.origin_;\r\n    }\r\n    return this.origins_[z];\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for the given zoom level.\r\n   * @param {number} z Integer zoom level.\r\n   * @return {number} Resolution.\r\n   * @api\r\n   */\r\n  getResolution(z) {\r\n    return this.resolutions_[z];\r\n  }\r\n\r\n  /**\r\n   * Get the list of resolutions for the tile grid.\r\n   * @return {Array<number>} Resolutions.\r\n   * @api\r\n   */\r\n  getResolutions() {\r\n    return this.resolutions_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\r\n   */\r\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\r\n    if (tileCoord[0] < this.maxZoom) {\r\n      if (this.zoomFactor_ === 2) {\r\n        const minX = tileCoord[1] * 2;\r\n        const minY = tileCoord[2] * 2;\r\n        return createOrUpdateTileRange(\r\n          minX,\r\n          minX + 1,\r\n          minY,\r\n          minY + 1,\r\n          tempTileRange,\r\n        );\r\n      }\r\n      const tileCoordExtent = this.getTileCoordExtent(\r\n        tileCoord,\r\n        tempExtent || this.tmpExtent_,\r\n      );\r\n      return this.getTileRangeForExtentAndZ(\r\n        tileCoordExtent,\r\n        tileCoord[0] + 1,\r\n        tempTileRange,\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\r\n   */\r\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\r\n    if (z > this.maxZoom || z < this.minZoom) {\r\n      return null;\r\n    }\r\n\r\n    const tileCoordZ = tileCoord[0];\r\n    const tileCoordX = tileCoord[1];\r\n    const tileCoordY = tileCoord[2];\r\n\r\n    if (z === tileCoordZ) {\r\n      return createOrUpdateTileRange(\r\n        tileCoordX,\r\n        tileCoordY,\r\n        tileCoordX,\r\n        tileCoordY,\r\n        tempTileRange,\r\n      );\r\n    }\r\n\r\n    if (this.zoomFactor_) {\r\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\r\n      const minX = Math.floor(tileCoordX * factor);\r\n      const minY = Math.floor(tileCoordY * factor);\r\n      if (z < tileCoordZ) {\r\n        return createOrUpdateTileRange(minX, minX, minY, minY, tempTileRange);\r\n      }\r\n\r\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\r\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\r\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\r\n    }\r\n\r\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\r\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\r\n  }\r\n\r\n  /**\r\n   * Get a tile range for the given extent and integer zoom level.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary tile range object.\r\n   * @return {import(\"../TileRange.js\").default} Tile range.\r\n   */\r\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\r\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);\r\n    const minX = tmpTileCoord[1];\r\n    const minY = tmpTileCoord[2];\r\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);\r\n    const maxX = tmpTileCoord[1];\r\n    const maxY = tmpTileCoord[2];\r\n    return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\r\n   */\r\n  getTileCoordCenter(tileCoord) {\r\n    const origin = this.getOrigin(tileCoord[0]);\r\n    const resolution = this.getResolution(tileCoord[0]);\r\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\r\n    return [\r\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\r\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Get the extent of a tile coordinate.\r\n   *\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary extent object.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getTileCoordExtent(tileCoord, tempExtent) {\r\n    const origin = this.getOrigin(tileCoord[0]);\r\n    const resolution = this.getResolution(tileCoord[0]);\r\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\r\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\r\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\r\n    const maxX = minX + tileSize[0] * resolution;\r\n    const maxY = minY + tileSize[1] * resolution;\r\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\r\n  }\r\n\r\n  /**\r\n   * Get the tile coordinate for the given map coordinate and resolution.  This\r\n   * method considers that coordinates that intersect tile boundaries should be\r\n   * assigned the higher tile coordinate.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} resolution Resolution.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\r\n    return this.getTileCoordForXYAndResolution_(\r\n      coordinate[0],\r\n      coordinate[1],\r\n      resolution,\r\n      false,\r\n      opt_tileCoord,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Note that this method should not be called for resolutions that correspond\r\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {number} resolution Resolution (for a non-integer zoom level).\r\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\r\n   *     intersections go to the higher tile coordinate, let edge intersections\r\n   *     go to the lower tile coordinate.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @private\r\n   */\r\n  getTileCoordForXYAndResolution_(\r\n    x,\r\n    y,\r\n    resolution,\r\n    reverseIntersectionPolicy,\r\n    opt_tileCoord,\r\n  ) {\r\n    const z = this.getZForResolution(resolution);\r\n    const scale = resolution / this.getResolution(z);\r\n    const origin = this.getOrigin(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n\r\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\r\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\r\n\r\n    if (reverseIntersectionPolicy) {\r\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\r\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\r\n    } else {\r\n      tileCoordX = floor(tileCoordX, DECIMALS);\r\n      tileCoordY = floor(tileCoordY, DECIMALS);\r\n    }\r\n\r\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\r\n  }\r\n\r\n  /**\r\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\r\n   * they should have separate implementations.  This method is for integer zoom\r\n   * levels.  The other method should only be called for resolutions corresponding\r\n   * to non-integer zoom levels.\r\n   * @param {number} x Map x coordinate.\r\n   * @param {number} y Map y coordinate.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\r\n   *     intersections go to the higher tile coordinate, let edge intersections\r\n   *     go to the lower tile coordinate.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @private\r\n   */\r\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\r\n    const origin = this.getOrigin(z);\r\n    const resolution = this.getResolution(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n\r\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\r\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\r\n\r\n    if (reverseIntersectionPolicy) {\r\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\r\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\r\n    } else {\r\n      tileCoordX = floor(tileCoordX, DECIMALS);\r\n      tileCoordY = floor(tileCoordY, DECIMALS);\r\n    }\r\n\r\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\r\n  }\r\n\r\n  /**\r\n   * Get a tile coordinate given a map coordinate and zoom level.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\r\n    return this.getTileCoordForXYAndZ_(\r\n      coordinate[0],\r\n      coordinate[1],\r\n      z,\r\n      false,\r\n      opt_tileCoord,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {number} Tile resolution.\r\n   */\r\n  getTileCoordResolution(tileCoord) {\r\n    return this.resolutions_[tileCoord[0]];\r\n  }\r\n\r\n  /**\r\n   * Get the tile size for a zoom level. The type of the return value matches the\r\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\r\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\r\n   * @param {number} z Z.\r\n   * @return {number|import(\"../size.js\").Size} Tile size.\r\n   * @api\r\n   */\r\n  getTileSize(z) {\r\n    if (this.tileSize_) {\r\n      return this.tileSize_;\r\n    }\r\n    return this.tileSizes_[z];\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Zoom level.\r\n   * @return {import(\"../TileRange.js\").default|null} Extent tile range for the specified zoom level.\r\n   */\r\n  getFullTileRange(z) {\r\n    if (!this.fullTileRanges_) {\r\n      return this.extent_\r\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\r\n        : null;\r\n    }\r\n    return this.fullTileRanges_[z];\r\n  }\r\n\r\n  /**\r\n   * @param {number} resolution Resolution.\r\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\r\n   *     If 0, the nearest resolution will be used.\r\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\r\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\r\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\r\n   *\r\n   * For example to change tile Z at the midpoint of zoom levels\r\n   * ```js\r\n   * function(value, high, low) {\r\n   *   return value - low * Math.sqrt(high / low);\r\n   * }\r\n   * ```\r\n   * @return {number} Z.\r\n   * @api\r\n   */\r\n  getZForResolution(resolution, opt_direction) {\r\n    const z = linearFindNearest(\r\n      this.resolutions_,\r\n      resolution,\r\n      opt_direction || 0,\r\n    );\r\n    return clamp(z, this.minZoom, this.maxZoom);\r\n  }\r\n\r\n  /**\r\n   * The tile with the provided tile coordinate intersects the given viewport.\r\n   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\r\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\r\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\r\n   */\r\n  tileCoordIntersectsViewport(tileCoord, viewport) {\r\n    return intersectsLinearRing(\r\n      viewport,\r\n      0,\r\n      viewport.length,\r\n      2,\r\n      this.getTileCoordExtent(tileCoord),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\r\n   * @private\r\n   */\r\n  calculateTileRanges_(extent) {\r\n    const length = this.resolutions_.length;\r\n    const fullTileRanges = new Array(length);\r\n    for (let z = this.minZoom; z < length; ++z) {\r\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\r\n    }\r\n    this.fullTileRanges_ = fullTileRanges;\r\n  }\r\n}\r\n\r\nexport default TileGrid;\r\n","/**\r\n * @module CME2D/tilegrid\r\n */\r\nimport TileGrid from './tilegrid/TileGrid.js';\r\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\r\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\r\nimport {\r\n  containsCoordinate,\r\n  createOrUpdate,\r\n  getCorner,\r\n  getHeight,\r\n  getWidth,\r\n} from './extent.js';\r\nimport {toSize} from './size.js';\r\n\r\nexport {TileGrid};\r\nexport {default as WMTS} from './tilegrid/WMTS.js';\r\n\r\n/**\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {!TileGrid} Default tile grid for the\r\n * passed projection.\r\n */\r\nexport function getForProjection(projection) {\r\n  let tileGrid = projection.getDefaultTileGrid();\r\n  if (!tileGrid) {\r\n    tileGrid = createForProjection(projection);\r\n    projection.setDefaultTileGrid(tileGrid);\r\n  }\r\n  return tileGrid;\r\n}\r\n\r\n/**\r\n * @param {TileGrid} tileGrid Tile grid.\r\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\r\n */\r\nexport function wrapX(tileGrid, tileCoord, projection) {\r\n  const z = tileCoord[0];\r\n  const center = tileGrid.getTileCoordCenter(tileCoord);\r\n  const projectionExtent = extentFromProjection(projection);\r\n  if (!containsCoordinate(projectionExtent, center)) {\r\n    const worldWidth = getWidth(projectionExtent);\r\n    const worldsAway = Math.ceil(\r\n      (projectionExtent[0] - center[0]) / worldWidth,\r\n    );\r\n    center[0] += worldWidth * worldsAway;\r\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\r\n  }\r\n  return tileCoord;\r\n}\r\n\r\n/**\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {number} [maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\r\n * @return {!TileGrid} TileGrid instance.\r\n */\r\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\r\n  corner = corner !== undefined ? corner : 'top-left';\r\n\r\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\r\n\r\n  return new TileGrid({\r\n    extent: extent,\r\n    origin: getCorner(extent, corner),\r\n    resolutions: resolutions,\r\n    tileSize: tileSize,\r\n  });\r\n}\r\n\r\n/**\r\n * @typedef {Object} XYZOptions\r\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\r\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\r\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\r\n * @property {number} [maxResolution] Resolution at level zero.\r\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\r\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\r\n * @property {number} [minZoom=0] Minimum zoom.\r\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\r\n */\r\n\r\n/**\r\n * Creates a tile grid with a standard XYZ tiling scheme.\r\n * @param {XYZOptions} [options] Tile grid options.\r\n * @return {!TileGrid} Tile grid instance.\r\n * @api\r\n */\r\nexport function createXYZ(options) {\r\n  const xyzOptions = options || {};\r\n\r\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\r\n\r\n  const gridOptions = {\r\n    extent: extent,\r\n    minZoom: xyzOptions.minZoom,\r\n    tileSize: xyzOptions.tileSize,\r\n    resolutions: resolutionsFromExtent(\r\n      extent,\r\n      xyzOptions.maxZoom,\r\n      xyzOptions.tileSize,\r\n      xyzOptions.maxResolution,\r\n    ),\r\n  };\r\n  return new TileGrid(gridOptions);\r\n}\r\n\r\n/**\r\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {number} [maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {number} [maxResolution] Resolution at level zero.\r\n * @return {!Array<number>} Resolutions array.\r\n */\r\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\r\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\r\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\r\n\r\n  const height = getHeight(extent);\r\n  const width = getWidth(extent);\r\n\r\n  maxResolution =\r\n    maxResolution > 0\r\n      ? maxResolution\r\n      : Math.max(width / tileSize[0], height / tileSize[1]);\r\n\r\n  const length = maxZoom + 1;\r\n  const resolutions = new Array(length);\r\n  for (let z = 0; z < length; ++z) {\r\n    resolutions[z] = maxResolution / Math.pow(2, z);\r\n  }\r\n  return resolutions;\r\n}\r\n\r\n/**\r\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\r\n * @param {number} [maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\r\n * @return {!TileGrid} TileGrid instance.\r\n */\r\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\r\n  const extent = extentFromProjection(projection);\r\n  return createForExtent(extent, maxZoom, tileSize, corner);\r\n}\r\n\r\n/**\r\n * Generate a tile grid extent from a projection.  If the projection has an\r\n * extent, it is used.  If not, a global extent is assumed.\r\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\r\n * @return {import(\"./extent.js\").Extent} Extent.\r\n */\r\nexport function extentFromProjection(projection) {\r\n  projection = getProjection(projection);\r\n  let extent = projection.getExtent();\r\n  if (!extent) {\r\n    const half =\r\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\r\n    extent = createOrUpdate(-half, -half, half, half);\r\n  }\r\n  return extent;\r\n}\r\n","/**\r\n * @module CME2D/source/Tile\r\n */\r\nimport Event from '../events/Event.js';\r\nimport Source from './Source.js';\r\nimport TileCache from '../TileCache.js';\r\nimport {abstract} from '../util.js';\r\nimport {assert} from '../asserts.js';\r\nimport {equivalent} from '../proj.js';\r\nimport {\r\n  getForProjection as getTileGridForProjection,\r\n  wrapX,\r\n} from '../tilegrid.js';\r\nimport {scale as scaleSize, toSize} from '../size.js';\r\nimport {withinExtentAndZ} from '../tilecoord.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\r\n * @property {number} [tilePixelRatio] TilePixelRatio.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\r\n * @property {import(\"./Source.js\").State} [state] State.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\r\n * @property {boolean} [wrapX=false] WrapX.\r\n * @property {number} [transition] Transition.\r\n * @property {string} [key] Key.\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for sources providing images divided into a tile grid.\r\n *\r\n * @template {import(\"../Tile.js\").default} [TileType=import(\"../Tile.js\").default]\r\n * @abstract\r\n * @api\r\n */\r\nclass TileSource extends Source {\r\n  /**\r\n   * @param {Options} options SourceTile source options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      wrapX: options.wrapX,\r\n      interpolate: options.interpolate,\r\n    });\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.tilePixelRatio_ =\r\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\r\n\r\n    /**\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\r\n     */\r\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\r\n\r\n    const tileSize = [256, 256];\r\n    if (this.tileGrid) {\r\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\r\n    }\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../TileCache.js\").default}\r\n     */\r\n    this.tileCache = new TileCache(options.cacheSize || 0);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../size.js\").Size}\r\n     */\r\n    this.tmpSize = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.key_ = options.key || '';\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Tile.js\").Options}\r\n     */\r\n    this.tileOptions = {\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n    };\r\n\r\n    /**\r\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\r\n     * by a renderer if the views resolution does not match any resolution of the tile source.\r\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\r\n     * will be used. If -1, the nearest higher resolution will be used.\r\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\r\n     */\r\n    this.zDirection = options.zDirection ? options.zDirection : 0;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    return this.tileCache.canExpireCache();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   */\r\n  expireCache(projection, usedTiles) {\r\n    const tileCache = this.getTileCacheForProjection(projection);\r\n    if (tileCache) {\r\n      tileCache.expireCache(usedTiles);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {number} Gutter.\r\n   */\r\n  getGutterForProjection(projection) {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Return the key to be used for all tiles in the source.\r\n   * @return {string} The key for all tiles.\r\n   */\r\n  getKey() {\r\n    return this.key_;\r\n  }\r\n\r\n  /**\r\n   * Set the value to be used as the key for all tiles in the source.\r\n   * @param {string} key The key for tiles.\r\n   * @protected\r\n   */\r\n  setKey(key) {\r\n    if (this.key_ !== key) {\r\n      this.key_ = key;\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\r\n   * @return {Array<number>|null} Resolutions.\r\n   * @override\r\n   */\r\n  getResolutions(projection) {\r\n    const tileGrid = projection\r\n      ? this.getTileGridForProjection(projection)\r\n      : this.tileGrid;\r\n    if (!tileGrid) {\r\n      return null;\r\n    }\r\n    return tileGrid.getResolutions();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {TileType|null} Tile.\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the tile grid of the tile source.\r\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\r\n   * @api\r\n   */\r\n  getTileGrid() {\r\n    return this.tileGrid;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\r\n   */\r\n  getTileGridForProjection(projection) {\r\n    if (!this.tileGrid) {\r\n      return getTileGridForProjection(projection);\r\n    }\r\n    return this.tileGrid;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../TileCache.js\").default} Tile cache.\r\n   * @protected\r\n   */\r\n  getTileCacheForProjection(projection) {\r\n    const sourceProjection = this.getProjection();\r\n    assert(\r\n      sourceProjection === null || equivalent(sourceProjection, projection),\r\n      'A VectorTile source can only be rendered if it has a projection compatible with the view projection.',\r\n    );\r\n    return this.tileCache;\r\n  }\r\n\r\n  /**\r\n   * Get the tile pixel ratio for this source. Subclasses may override this\r\n   * method, which is meant to return a supported pixel ratio that matches the\r\n   * provided `pixelRatio` as close as possible.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @return {number} Tile pixel ratio.\r\n   */\r\n  getTilePixelRatio(pixelRatio) {\r\n    return this.tilePixelRatio_;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Z.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../size.js\").Size} Tile size.\r\n   */\r\n  getTilePixelSize(z, pixelRatio, projection) {\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\r\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\r\n    if (tilePixelRatio == 1) {\r\n      return tileSize;\r\n    }\r\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\r\n  }\r\n\r\n  /**\r\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\r\n   * is outside the resolution and extent range of the tile grid, `null` will be\r\n   * returned.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\r\n   *     null if no tile URL should be created for the passed `tileCoord`.\r\n   */\r\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\r\n    projection = projection !== undefined ? projection : this.getProjection();\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    if (this.getWrapX() && projection.isGlobal()) {\r\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\r\n    }\r\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\r\n  }\r\n\r\n  /**\r\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\r\n   * @api\r\n   */\r\n  clear() {\r\n    this.tileCache.clear();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  refresh() {\r\n    this.clear();\r\n    super.refresh();\r\n  }\r\n\r\n  /**\r\n   * Marks a tile coord as being used, without triggering a load.\r\n   * @abstract\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   */\r\n  useTile(z, x, y, projection) {}\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\r\n * type.\r\n */\r\nexport class TileSourceEvent extends Event {\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../Tile.js\").default} tile The tile.\r\n   */\r\n  constructor(type, tile) {\r\n    super(type);\r\n\r\n    /**\r\n     * The tile related to the event.\r\n     * @type {import(\"../Tile.js\").default}\r\n     * @api\r\n     */\r\n    this.tile = tile;\r\n  }\r\n}\r\n\r\nexport default TileSource;\r\n","/**\r\n * @module CME2D/source/DataTile\r\n */\r\nimport DataTile from '../DataTile.js';\r\nimport EventType from '../events/EventType.js';\r\nimport ReprojDataTile from '../reproj/DataTile.js';\r\nimport TileCache from '../TileCache.js';\r\nimport TileEventType from './TileEventType.js';\r\nimport TileSource, {TileSourceEvent} from './Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport {\r\n  createXYZ,\r\n  extentFromProjection,\r\n  getForProjection as getTileGridForProjection,\r\n} from '../tilegrid.js';\r\nimport {equivalent, get as getProjection} from '../proj.js';\r\nimport {getKeyZXY} from '../tilecoord.js';\r\nimport {getUid} from '../util.js';\r\nimport {toPromise} from '../functions.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute\r\n */\r\n\r\n/**\r\n * @typedef {Object} LoaderOptions\r\n * @property {AbortSignal} signal An abort controller signal.\r\n * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.\r\n * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the\r\n * underlying tile grid does not have a known extent.\r\n */\r\n\r\n/**\r\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\r\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\r\n * @typedef {function(number, number, number, LoaderOptions) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\r\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\r\n * For loaders that generate images, the promise should not resolve until the image is loaded.\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\r\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\r\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\r\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\r\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\r\n * This allows artifacts of rendering at tile edges to be ignored.\r\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\r\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\r\n * @property {import(\"./Source.js\").State} [state] The source state.\r\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\r\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\r\n * @property {number} [bandCount=4] Number of bands represented in the data.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\r\n * @property {string} [key] Key for use in caching tiles.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A source for typed array data tiles.\r\n *\r\n * @fires import(\"./Tile.js\").TileSourceEvent\r\n * @template {import(\"../Tile.js\").default} [TileType=DataTile]\r\n * @extends TileSource<TileType>\r\n * @api\r\n */\r\nclass DataTileSource extends TileSource {\r\n  /**\r\n   * @param {Options} options DataTile source options.\r\n   */\r\n  constructor(options) {\r\n    const projection =\r\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\r\n\r\n    let tileGrid = options.tileGrid;\r\n    if (tileGrid === undefined && projection) {\r\n      tileGrid = createXYZ({\r\n        extent: extentFromProjection(projection),\r\n        maxResolution: options.maxResolution,\r\n        maxZoom: options.maxZoom,\r\n        minZoom: options.minZoom,\r\n        tileSize: options.tileSize,\r\n      });\r\n    }\r\n\r\n    super({\r\n      cacheSize: 0.1, // don't cache on the source\r\n      attributions: options.attributions,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      projection: projection,\r\n      tileGrid: tileGrid,\r\n      state: options.state,\r\n      wrapX: options.wrapX,\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n      key: options.key,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import('../size.js').Size|null}\r\n     */\r\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import('../size.js').Size>|null}\r\n     */\r\n    this.tileSizes_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, boolean>}\r\n     */\r\n    this.tileLoadingKeys_ = {};\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.loader_ = options.loader;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\r\n     */\r\n    this.tileGridForProjection_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, import(\"../TileCache.js\").default>}\r\n     */\r\n    this.tileCacheForProjection_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {CrossOriginAttribute}\r\n     */\r\n    this.crossOrigin_ = options.crossOrigin || 'anonymous';\r\n  }\r\n\r\n  /**\r\n   * Set the source tile sizes.  The length of the array is expected to match the number of\r\n   * levels in the tile grid.\r\n   * @protected\r\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\r\n   */\r\n  setTileSizes(tileSizes) {\r\n    this.tileSizes_ = tileSizes;\r\n  }\r\n\r\n  /**\r\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\r\n   * size.\r\n   * @protected\r\n   * @param {number} z Tile zoom level.\r\n   * @return {import('../size.js').Size} The source tile size.\r\n   */\r\n  getTileSize(z) {\r\n    if (this.tileSizes_) {\r\n      return this.tileSizes_[z];\r\n    }\r\n    if (this.tileSize_) {\r\n      return this.tileSize_;\r\n    }\r\n    const tileGrid = this.getTileGrid();\r\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {number} Gutter.\r\n   * @override\r\n   */\r\n  getGutterForProjection(projection) {\r\n    const thisProj = this.getProjection();\r\n    if (!thisProj || equivalent(thisProj, projection)) {\r\n      return this.gutter_;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @param {Loader} loader The data loader.\r\n   * @protected\r\n   */\r\n  setLoader(loader) {\r\n    this.loader_ = loader;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\r\n   * @return {!TileType} Tile.\r\n   */\r\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\r\n    const cache = this.getTileCacheForProjection(targetProj);\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    if (cache.containsKey(tileCoordKey)) {\r\n      const tile = cache.get(tileCoordKey);\r\n      if (tile && tile.key == this.getKey()) {\r\n        return tile;\r\n      }\r\n    }\r\n\r\n    const tileGrid = this.getTileGrid();\r\n    const reprojTilePixelRatio = Math.max.apply(\r\n      null,\r\n      tileGrid.getResolutions().map((r, z) => {\r\n        const tileSize = toSize(tileGrid.getTileSize(z));\r\n        const textureSize = this.getTileSize(z);\r\n        return Math.max(\r\n          textureSize[0] / tileSize[0],\r\n          textureSize[1] / tileSize[1],\r\n        );\r\n      }),\r\n    );\r\n\r\n    const sourceTileGrid = this.getTileGridForProjection(sourceProj);\r\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\r\n    const tileCoord = [z, x, y];\r\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\r\n      tileCoord,\r\n      targetProj,\r\n    );\r\n\r\n    const options = Object.assign(\r\n      {\r\n        sourceProj,\r\n        sourceTileGrid,\r\n        targetProj,\r\n        targetTileGrid,\r\n        tileCoord,\r\n        wrappedTileCoord,\r\n        pixelRatio: reprojTilePixelRatio,\r\n        gutter: this.getGutterForProjection(sourceProj),\r\n        getTileFunction: (z, x, y, pixelRatio) =>\r\n          this.getTile(z, x, y, pixelRatio, sourceProj),\r\n      },\r\n      /** @type {import(\"../reproj/DataTile.js\").Options} */ (this.tileOptions),\r\n    );\r\n    const newTile = /** @type {TileType} */ (\r\n      /** @type {*} */ (new ReprojDataTile(options))\r\n    );\r\n    newTile.key = this.getKey();\r\n    return newTile;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {TileType|null} Tile (or null if outside source extent).\r\n   * @override\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    const sourceProjection = this.getProjection();\r\n    if (\r\n      sourceProjection &&\r\n      projection &&\r\n      !equivalent(sourceProjection, projection)\r\n    ) {\r\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\r\n    }\r\n\r\n    const size = this.getTileSize(z);\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    if (this.tileCache.containsKey(tileCoordKey)) {\r\n      return this.tileCache.get(tileCoordKey);\r\n    }\r\n\r\n    const sourceLoader = this.loader_;\r\n    const controller = new AbortController();\r\n    /**\r\n     * @type {LoaderOptions}\r\n     */\r\n    const loaderOptions = {\r\n      signal: controller.signal,\r\n      crossOrigin: this.crossOrigin_,\r\n    };\r\n\r\n    const tileCoord = this.getTileCoordForTileUrlFunction([z, x, y]);\r\n    if (!tileCoord) {\r\n      return null;\r\n    }\r\n\r\n    const requestZ = tileCoord[0];\r\n    const requestX = tileCoord[1];\r\n    const requestY = tileCoord[2];\r\n    function loader() {\r\n      return toPromise(function () {\r\n        return sourceLoader(requestZ, requestX, requestY, loaderOptions);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * @type {import(\"../DataTile.js\").Options}\r\n     */\r\n    const options = Object.assign(\r\n      {\r\n        tileCoord: [z, x, y],\r\n        loader: loader,\r\n        size: size,\r\n        controller: controller,\r\n      },\r\n      this.tileOptions,\r\n    );\r\n\r\n    const tile = /** @type {TileType} */ (\r\n      /** @type {*} */ (new DataTile(options))\r\n    );\r\n    tile.key = this.getKey();\r\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\r\n\r\n    this.tileCache.set(tileCoordKey, tile);\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * Handle tile change events.\r\n   * @param {import(\"../events/Event.js\").default} event Event.\r\n   */\r\n  handleTileChange_(event) {\r\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\r\n    const uid = getUid(tile);\r\n    const tileState = tile.getState();\r\n    let type;\r\n    if (tileState == TileState.LOADING) {\r\n      this.tileLoadingKeys_[uid] = true;\r\n      type = TileEventType.TILELOADSTART;\r\n    } else if (uid in this.tileLoadingKeys_) {\r\n      delete this.tileLoadingKeys_[uid];\r\n      type =\r\n        tileState == TileState.ERROR\r\n          ? TileEventType.TILELOADERROR\r\n          : tileState == TileState.LOADED\r\n            ? TileEventType.TILELOADEND\r\n            : undefined;\r\n    }\r\n    if (type) {\r\n      this.dispatchEvent(new TileSourceEvent(type, tile));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\r\n   * @override\r\n   */\r\n  getTileGridForProjection(projection) {\r\n    const thisProj = this.getProjection();\r\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\r\n      return this.tileGrid;\r\n    }\r\n    const projKey = getUid(projection);\r\n    if (!(projKey in this.tileGridForProjection_)) {\r\n      this.tileGridForProjection_[projKey] =\r\n        getTileGridForProjection(projection);\r\n    }\r\n    return this.tileGridForProjection_[projKey];\r\n  }\r\n\r\n  /**\r\n   * Sets the tile grid to use when reprojecting the tiles to the given\r\n   * projection instead of the default tile grid for the projection.\r\n   *\r\n   * This can be useful when the default tile grid cannot be created\r\n   * (e.g. projection has no extent defined) or\r\n   * for optimization reasons (custom tile size, resolutions, ...).\r\n   *\r\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\r\n   * @api\r\n   */\r\n  setTileGridForProjection(projection, tilegrid) {\r\n    const proj = getProjection(projection);\r\n    if (proj) {\r\n      const projKey = getUid(proj);\r\n      if (!(projKey in this.tileGridForProjection_)) {\r\n        this.tileGridForProjection_[projKey] = tilegrid;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../TileCache.js\").default} Tile cache.\r\n   * @override\r\n   */\r\n  getTileCacheForProjection(projection) {\r\n    const thisProj = this.getProjection();\r\n    if (!thisProj || equivalent(thisProj, projection)) {\r\n      return this.tileCache;\r\n    }\r\n\r\n    const projKey = getUid(projection);\r\n    if (!(projKey in this.tileCacheForProjection_)) {\r\n      this.tileCacheForProjection_[projKey] = new TileCache(0.1); // don't cache\r\n    }\r\n    return this.tileCacheForProjection_[projKey];\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   * @override\r\n   */\r\n  expireCache(projection, usedTiles) {\r\n    const usedTileCache = this.getTileCacheForProjection(projection);\r\n\r\n    this.tileCache.expireCache(\r\n      this.tileCache == usedTileCache ? usedTiles : {},\r\n    );\r\n    for (const id in this.tileCacheForProjection_) {\r\n      const tileCache = this.tileCacheForProjection_[id];\r\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  clear() {\r\n    super.clear();\r\n    for (const id in this.tileCacheForProjection_) {\r\n      this.tileCacheForProjection_[id].clear();\r\n    }\r\n  }\r\n}\r\n\r\nexport default DataTileSource;\r\n","/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\nimport { CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT } from \"./messages.mjs\";\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nexport const {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nexport const NativeProxy = Proxy;\n\n// Number\nexport const {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nexport const {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nexport const NativeObject = Object;\nexport const {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nexport const ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nexport const ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nexport const ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nexport const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nexport const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nexport const ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nexport const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nexport const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nexport const {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nexport const NativeArrayBuffer = ArrayBuffer;\nexport const ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nexport const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nexport const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nexport const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nexport const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nexport const TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nexport const TypedArrayPrototype = TypedArray.prototype;\nexport const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nexport const TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nexport const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nexport const TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nexport const TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nexport const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nexport const TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nexport const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nexport const NativeUint8Array = Uint8Array;\n\n// Uint16Array\nexport const NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nexport const Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nexport const NativeUint32Array = Uint32Array;\n\n// Float32Array\nexport const NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nexport const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nexport const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nexport const GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nexport const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nexport const DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nexport const DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nexport const NativeTypeError = TypeError;\nexport const NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nexport const NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nexport const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nexport const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nexport const NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nexport const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nexport const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nexport const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n","import {\n  ArrayIteratorPrototype,\n  ArrayIteratorPrototypeNext,\n  ArrayPrototypeSymbolIterator,\n  GeneratorPrototypeNext,\n  IteratorPrototype,\n  NativeArrayPrototypeSymbolIterator,\n  NativeWeakMap,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  SymbolIterator,\n  WeakMapPrototypeGet,\n  WeakMapPrototypeSet,\n} from \"./primordials.mjs\";\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new NativeWeakMap();\n\nconst SafeIteratorPrototype = ObjectCreate(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n      return ArrayIteratorPrototypeNext(arrayIterator);\n    },\n  },\n\n  [SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nexport function safeIfNeeded(array) {\n  if (\n    array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n    ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = ObjectCreate(SafeIteratorPrototype);\n  WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = WeakMapPrototypeGet(generators, this);\n      return GeneratorPrototypeNext(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nexport function wrap(generator) {\n  const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n  WeakMapPrototypeSet(generators, dummy, generator);\n  return dummy;\n}\n","import {\n  EPSILON,\n  MathAbs,\n  NativeArrayBuffer,\n  NativeFloat32Array,\n  NativeUint16Array,\n  NativeUint32Array,\n  NativeUint8Array,\n  NumberIsFinite,\n  NumberIsNaN,\n} from \"./primordials.mjs\";\n\nconst INVERSE_OF_EPSILON = 1 / EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number\n */\nexport function roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!NumberIsFinite(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = MathAbs(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new NativeArrayBuffer(4);\nconst floatView = new NativeFloat32Array(buffer);\nconst uint32View = new NativeUint32Array(buffer);\n\nconst baseTable = new NativeUint16Array(512);\nconst shiftTable = new NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -24) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n","import { safeIfNeeded } from \"./_util/arrayIterator.mjs\";\nimport { convertToNumber, roundToFloat16Bits } from \"./_util/converter.mjs\";\nimport {\n  DataViewPrototypeGetUint16,\n  DataViewPrototypeSetUint16,\n} from \"./_util/primordials.mjs\";\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nexport function getFloat16(dataView, byteOffset, ...opts) {\n  return convertToNumber(\n    DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nexport function setFloat16(dataView, byteOffset, value, ...opts) {\n  return DataViewPrototypeSetUint16(\n    dataView,\n    byteOffset,\n    roundToFloat16Bits(value),\n    ...safeIfNeeded(opts)\n  );\n}\n","function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports.default = getAttribute;\n","function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports.default = indexOfMatch;\n","function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports.default = indexOfMatchEnd;\n","function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports.default = countSubstring;\n","const indexOfMatch = require(\"./index-of-match.js\");\nconst indexOfMatchEnd = require(\"./index-of-match-end.js\");\nconst countSubstring = require(\"./count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;\n","const findTagByName = require(\"./find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports.default = findTagsByName;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export default class QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n\n\n    debugger\n    console.log(\"headers-signal---------------------------\")\n    console.log(headers)\n    let _cmeUrl = this.url;\n    if (headers.Range) {\n      debugger\n      _cmeUrl = this.url + '?Range=' + headers.Range.match(/=([^=]*)$/)[1]\n    }\n\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","export default {}","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n","/**\r\n * @module CME2D/source/GeoTIFF\r\n */\r\nimport DataTile from './DataTile.js';\r\nimport TileGrid from '../tilegrid/TileGrid.js';\r\nimport {\r\n  Pool,\r\n  globals as geotiffGlobals,\r\n  fromBlob as tiffFromBlob,\r\n  fromUrl as tiffFromUrl,\r\n  fromUrls as tiffFromUrls,\r\n} from 'geotiff';\r\nimport {\r\n  Projection,\r\n  get as getCachedProjection,\r\n  toUserCoordinate,\r\n  toUserExtent,\r\n} from '../proj.js';\r\nimport {clamp} from '../math.js';\r\nimport {getCenter, getIntersection} from '../extent.js';\r\nimport {error as logError} from '../console.js';\r\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\r\n\r\n/**\r\n * Determine if an image type is a mask.\r\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\r\n * @param {GeoTIFFImage} image The image.\r\n * @return {boolean} The image is a mask.\r\n */\r\nfunction isMask(image) {\r\n  const fileDirectory = image.fileDirectory;\r\n  const type = fileDirectory.NewSubfileType || 0;\r\n  return (type & 4) === 4;\r\n}\r\n\r\n/**\r\n * @param {true|false|'auto'} preference The convertToRGB option.\r\n * @param {GeoTIFFImage} image The image.\r\n * @return {boolean} Use the `image.readRGB()` method.\r\n */\r\nfunction readRGB(preference, image) {\r\n  if (!preference) {\r\n    return false;\r\n  }\r\n  if (preference === true) {\r\n    return true;\r\n  }\r\n  if (image.getSamplesPerPixel() !== 3) {\r\n    return false;\r\n  }\r\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\r\n  const interpretations = geotiffGlobals.photometricInterpretations;\r\n  return (\r\n    interpretation === interpretations.CMYK ||\r\n    interpretation === interpretations.YCbCr ||\r\n    interpretation === interpretations.CIELab ||\r\n    interpretation === interpretations.ICCLab\r\n  );\r\n}\r\n\r\n/**\r\n * @typedef {Object} SourceInfo\r\n * @property {string} [url] URL for the source GeoTIFF.\r\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\r\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\r\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\r\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\r\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\r\n * the `normalize` option to `false` in the constructor.\r\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\r\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\r\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\r\n * the `normalize` option to `false` in the constructor.\r\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\r\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\r\n * will include information about nodata values, so you should only need to set this property if\r\n * you find that it is not already extracted from the metadata.\r\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\r\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\r\n * near-infrared band, configure `bands: [4]`.\r\n */\r\n\r\n/**\r\n * @typedef {Object} GeoKeys\r\n * @property {number} GTModelTypeGeoKey Model type.\r\n * @property {number} GTRasterTypeGeoKey Raster type.\r\n * @property {number} GeogAngularUnitsGeoKey Angular units.\r\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\r\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\r\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\r\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\r\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\r\n */\r\n\r\n/**\r\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\r\n */\r\n\r\n/**\r\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\r\n */\r\n\r\n/**\r\n * @typedef {Object} GDALMetadata\r\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\r\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\r\n */\r\n\r\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\r\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\r\n\r\nconst defaultTileSize = 256;\r\n\r\n/**\r\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\r\n */\r\n\r\nlet workerPool;\r\nfunction getWorkerPool() {\r\n  if (!workerPool) {\r\n    workerPool = new Pool();\r\n  }\r\n  return workerPool;\r\n}\r\n\r\n/**\r\n * Get the bounding box of an image.  If the image does not have an affine transform,\r\n * the pixel bounds are returned.\r\n * @param {GeoTIFFImage} image The image.\r\n * @return {Array<number>} The image bounding box.\r\n */\r\nfunction getBoundingBox(image) {\r\n  try {\r\n    return image.getBoundingBox();\r\n  } catch (_) {\r\n    return [0, 0, image.getWidth(), image.getHeight()];\r\n  }\r\n}\r\n\r\n/**\r\n * Get the origin of an image.  If the image does not have an affine transform,\r\n * the top-left corner of the pixel bounds is returned.\r\n * @param {GeoTIFFImage} image The image.\r\n * @return {Array<number>} The image origin.\r\n */\r\nfunction getOrigin(image) {\r\n  try {\r\n    return image.getOrigin().slice(0, 2);\r\n  } catch (_) {\r\n    return [0, image.getHeight()];\r\n  }\r\n}\r\n\r\n/**\r\n * Get the resolution of an image.  If the image does not have an affine transform,\r\n * the width of the image is compared with the reference image.\r\n * @param {GeoTIFFImage} image The image.\r\n * @param {GeoTIFFImage} referenceImage The reference image.\r\n * @return {Array<number>} The map x and y units per pixel.\r\n */\r\nfunction getResolutions(image, referenceImage) {\r\n  try {\r\n    return image.getResolution(referenceImage);\r\n  } catch (_) {\r\n    return [\r\n      referenceImage.getWidth() / image.getWidth(),\r\n      referenceImage.getHeight() / image.getHeight(),\r\n    ];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {GeoTIFFImage} image A GeoTIFF.\r\n * @return {import(\"../proj/Projection.js\").default} The image projection.\r\n */\r\nfunction getProjection(image) {\r\n  const geoKeys = image.geoKeys;\r\n  if (!geoKeys) {\r\n    return null;\r\n  }\r\n\r\n  if (\r\n    geoKeys.ProjectedCSTypeGeoKey &&\r\n    geoKeys.ProjectedCSTypeGeoKey !== 32767\r\n  ) {\r\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\r\n    let projection = getCachedProjection(code);\r\n    if (!projection) {\r\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\r\n      if (units) {\r\n        projection = new Projection({\r\n          code: code,\r\n          units: units,\r\n        });\r\n      }\r\n    }\r\n    return projection;\r\n  }\r\n\r\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\r\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\r\n    let projection = getCachedProjection(code);\r\n    if (!projection) {\r\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\r\n      if (units) {\r\n        projection = new Projection({\r\n          code: code,\r\n          units: units,\r\n        });\r\n      }\r\n    }\r\n    return projection;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\r\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\r\n */\r\nfunction getImagesForTIFF(tiff) {\r\n  return tiff.getImageCount().then(function (count) {\r\n    const requests = new Array(count);\r\n    for (let i = 0; i < count; ++i) {\r\n      requests[i] = tiff.getImage(i);\r\n    }\r\n    return Promise.all(requests);\r\n  });\r\n}\r\n\r\n/**\r\n * @param {SourceInfo} source The GeoTIFF source.\r\n * @param {Object} options Options for the GeoTIFF source.\r\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\r\n */\r\nfunction getImagesForSource(source, options) {\r\n  let request;\r\n  if (source.blob) {\r\n    request = tiffFromBlob(source.blob);\r\n  } else if (source.overviews) {\r\n    request = tiffFromUrls(source.url, source.overviews, options);\r\n  } else {\r\n    request = tiffFromUrl(source.url, options);\r\n  }\r\n  return request.then(getImagesForTIFF);\r\n}\r\n\r\n/**\r\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\r\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\r\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\r\n * @param {string} message The error message.\r\n * @param {function(Error):void} rejector A function to be called with any error.\r\n */\r\nfunction assertEqual(expected, got, tolerance, message, rejector) {\r\n  if (Array.isArray(expected)) {\r\n    const length = expected.length;\r\n    if (!Array.isArray(got) || length != got.length) {\r\n      const error = new Error(message);\r\n      rejector(error);\r\n      throw error;\r\n    }\r\n    for (let i = 0; i < length; ++i) {\r\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\r\n    }\r\n    return;\r\n  }\r\n\r\n  got = /** @type {number} */ (got);\r\n  if (Math.abs(expected - got) > tolerance * expected) {\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array} array The data array.\r\n * @return {number} The minimum value.\r\n */\r\nfunction getMinForDataType(array) {\r\n  if (array instanceof Int8Array) {\r\n    return -128;\r\n  }\r\n  if (array instanceof Int16Array) {\r\n    return -32768;\r\n  }\r\n  if (array instanceof Int32Array) {\r\n    return -2147483648;\r\n  }\r\n  if (array instanceof Float32Array) {\r\n    return 1.2e-38;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/**\r\n * @param {Array} array The data array.\r\n * @return {number} The maximum value.\r\n */\r\nfunction getMaxForDataType(array) {\r\n  if (array instanceof Int8Array) {\r\n    return 127;\r\n  }\r\n  if (array instanceof Uint8Array) {\r\n    return 255;\r\n  }\r\n  if (array instanceof Uint8ClampedArray) {\r\n    return 255;\r\n  }\r\n  if (array instanceof Int16Array) {\r\n    return 32767;\r\n  }\r\n  if (array instanceof Uint16Array) {\r\n    return 65535;\r\n  }\r\n  if (array instanceof Int32Array) {\r\n    return 2147483647;\r\n  }\r\n  if (array instanceof Uint32Array) {\r\n    return 4294967295;\r\n  }\r\n  if (array instanceof Float32Array) {\r\n    return 3.4e38;\r\n  }\r\n  return 255;\r\n}\r\n\r\n/**\r\n * @typedef {Object} GeoTIFFSourceOptions\r\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\r\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\r\n * @property {string} [credentials] How credentials shall be handled. See\r\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\r\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\r\n * By default only a single range is used.\r\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\r\n * requested. Only use this when you know the source image to be small enough to fit in memory.\r\n * @property {number} [blockSize=65536] The block size to use.\r\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\r\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\r\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\r\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\r\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\r\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\r\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\r\n * band from the first source, and 1 band from the second source.\r\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\r\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\r\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\r\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\r\n * CIELab, and ICCLab images will automatically be converted to RGB.\r\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\r\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\r\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\r\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\r\n * will be read for projection information.\r\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\r\n * To disable the opacity transition, pass `transition: 0`.\r\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A source for working with GeoTIFF data.\r\n * **Note for users of the full build**: The `GeoTIFF` source requires the\r\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\r\n *\r\n * @api\r\n */\r\nclass GeoTIFFSource extends DataTile {\r\n  /**\r\n   * @param {Options} options Data tile options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      state: 'loading',\r\n      tileGrid: null,\r\n      projection: options.projection || null,\r\n      transition: options.transition,\r\n      interpolate: options.interpolate !== false,\r\n      wrapX: options.wrapX,\r\n    });\r\n\r\n    /**\r\n     * @type {Array<SourceInfo>}\r\n     * @private\r\n     */\r\n    this.sourceInfo_ = options.sources;\r\n\r\n    const numSources = this.sourceInfo_.length;\r\n\r\n    /**\r\n     * @type {Object}\r\n     * @private\r\n     */\r\n    this.sourceOptions_ = options.sourceOptions;\r\n\r\n    /**\r\n     * @type {Array<Array<GeoTIFFImage>>}\r\n     * @private\r\n     */\r\n    this.sourceImagery_ = new Array(numSources);\r\n\r\n    /**\r\n     * @type {Array<Array<GeoTIFFImage>>}\r\n     * @private\r\n     */\r\n    this.sourceMasks_ = new Array(numSources);\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.resolutionFactors_ = new Array(numSources);\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.samplesPerPixel_;\r\n\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     * @private\r\n     */\r\n    this.nodataValues_;\r\n\r\n    /**\r\n     * @type {Array<Array<GDALMetadata>>}\r\n     * @private\r\n     */\r\n    this.metadata_;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.normalize_ = options.normalize !== false;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.addAlpha_ = false;\r\n\r\n    /**\r\n     * @type {Error}\r\n     * @private\r\n     */\r\n    this.error_ = null;\r\n\r\n    /**\r\n     * @type {true|false|'auto'}\r\n     * @private\r\n     */\r\n    this.convertToRGB_ = options.convertToRGB || false;\r\n\r\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\r\n\r\n    const self = this;\r\n    const requests = new Array(numSources);\r\n    for (let i = 0; i < numSources; ++i) {\r\n      requests[i] = getImagesForSource(\r\n        this.sourceInfo_[i],\r\n        this.sourceOptions_,\r\n      );\r\n    }\r\n    Promise.all(requests)\r\n      .then(function (sources) {\r\n        self.configure_(sources);\r\n      })\r\n      .catch(function (error) {\r\n        logError(error);\r\n        self.error_ = error;\r\n        self.setState('error');\r\n      });\r\n  }\r\n\r\n  /**\r\n   * @return {Error} A source loading error. When the source state is `error`, use this function\r\n   * to get more information about the error. To debug a faulty configuration, you may want to use\r\n   * a listener like\r\n   * ```js\r\n   * geotiffSource.on('change', () => {\r\n   *   if (geotiffSource.getState() === 'error') {\r\n   *     console.error(geotiffSource.getError());\r\n   *   }\r\n   * });\r\n   * ```\r\n   */\r\n  getError() {\r\n    return this.error_;\r\n  }\r\n\r\n  /**\r\n   * Determine the projection of the images in this GeoTIFF.\r\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\r\n   * of each image in turn.\r\n   * You can override this method in a subclass to support more projections.\r\n   *\r\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\r\n   * from a single GeoTIFF.\r\n   */\r\n  determineProjection(sources) {\r\n    const firstSource = sources[0];\r\n    for (let i = firstSource.length - 1; i >= 0; --i) {\r\n      const image = firstSource[i];\r\n      const projection = getProjection(image);\r\n      if (projection) {\r\n        this.projection = projection;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\r\n   * must have the same internal tiled structure.\r\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\r\n   * from a single GeoTIFF.\r\n   * @private\r\n   */\r\n  configure_(sources) {\r\n    let extent;\r\n    let origin;\r\n    let commonRenderTileSizes;\r\n    let commonSourceTileSizes;\r\n    let resolutions;\r\n    const samplesPerPixel = new Array(sources.length);\r\n    const nodataValues = new Array(sources.length);\r\n    const metadata = new Array(sources.length);\r\n    let minZoom = 0;\r\n\r\n    const sourceCount = sources.length;\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      const images = [];\r\n      const masks = [];\r\n      sources[sourceIndex].forEach((item) => {\r\n        if (isMask(item)) {\r\n          masks.push(item);\r\n        } else {\r\n          images.push(item);\r\n        }\r\n      });\r\n\r\n      const imageCount = images.length;\r\n      if (masks.length > 0 && masks.length !== imageCount) {\r\n        throw new Error(\r\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`,\r\n        );\r\n      }\r\n\r\n      let sourceExtent;\r\n      let sourceOrigin;\r\n      const sourceTileSizes = new Array(imageCount);\r\n      const renderTileSizes = new Array(imageCount);\r\n      const sourceResolutions = new Array(imageCount);\r\n\r\n      nodataValues[sourceIndex] = new Array(imageCount);\r\n      metadata[sourceIndex] = new Array(imageCount);\r\n\r\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\r\n        const image = images[imageIndex];\r\n        const nodataValue = image.getGDALNoData();\r\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\r\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\r\n\r\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\r\n        samplesPerPixel[sourceIndex] = wantedSamples\r\n          ? wantedSamples.length\r\n          : image.getSamplesPerPixel();\r\n        const level = imageCount - (imageIndex + 1);\r\n\r\n        if (!sourceExtent) {\r\n          sourceExtent = getBoundingBox(image);\r\n        }\r\n\r\n        if (!sourceOrigin) {\r\n          sourceOrigin = getOrigin(image);\r\n        }\r\n\r\n        const imageResolutions = getResolutions(image, images[0]);\r\n        sourceResolutions[level] = imageResolutions[0];\r\n\r\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\r\n\r\n        // request larger blocks for untiled layouts\r\n        if (\r\n          sourceTileSize[0] !== sourceTileSize[1] &&\r\n          sourceTileSize[1] < defaultTileSize\r\n        ) {\r\n          sourceTileSize[0] = defaultTileSize;\r\n          sourceTileSize[1] = defaultTileSize;\r\n        }\r\n\r\n        sourceTileSizes[level] = sourceTileSize;\r\n\r\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\r\n        renderTileSizes[level] = [\r\n          sourceTileSize[0],\r\n          sourceTileSize[1] / aspectRatio,\r\n        ];\r\n      }\r\n\r\n      if (!extent) {\r\n        extent = sourceExtent;\r\n      } else {\r\n        getIntersection(extent, sourceExtent, extent);\r\n      }\r\n\r\n      if (!origin) {\r\n        origin = sourceOrigin;\r\n      } else {\r\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\r\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\r\n      }\r\n\r\n      if (!resolutions) {\r\n        resolutions = sourceResolutions;\r\n        this.resolutionFactors_[sourceIndex] = 1;\r\n      } else {\r\n        if (resolutions.length - minZoom > sourceResolutions.length) {\r\n          minZoom = resolutions.length - sourceResolutions.length;\r\n        }\r\n        const resolutionFactor =\r\n          resolutions[resolutions.length - 1] /\r\n          sourceResolutions[sourceResolutions.length - 1];\r\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\r\n        const scaledSourceResolutions = sourceResolutions.map(\r\n          (resolution) => (resolution *= resolutionFactor),\r\n        );\r\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\r\n        assertEqual(\r\n          resolutions.slice(minZoom, resolutions.length),\r\n          scaledSourceResolutions,\r\n          0.02,\r\n          message,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      if (!commonRenderTileSizes) {\r\n        commonRenderTileSizes = renderTileSizes;\r\n      } else {\r\n        assertEqual(\r\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\r\n          renderTileSizes,\r\n          0.01,\r\n          `Tile size mismatch for source ${sourceIndex}`,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      if (!commonSourceTileSizes) {\r\n        commonSourceTileSizes = sourceTileSizes;\r\n      } else {\r\n        assertEqual(\r\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\r\n          sourceTileSizes,\r\n          0,\r\n          `Tile size mismatch for source ${sourceIndex}`,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      this.sourceImagery_[sourceIndex] = images.reverse();\r\n      this.sourceMasks_[sourceIndex] = masks.reverse();\r\n    }\r\n\r\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\r\n      const sourceImagery = this.sourceImagery_[i];\r\n      while (sourceImagery.length < resolutions.length) {\r\n        sourceImagery.unshift(undefined);\r\n      }\r\n    }\r\n\r\n    if (!this.getProjection()) {\r\n      this.determineProjection(sources);\r\n    }\r\n\r\n    this.samplesPerPixel_ = samplesPerPixel;\r\n    this.nodataValues_ = nodataValues;\r\n    this.metadata_ = metadata;\r\n\r\n    // decide if we need to add an alpha band to handle nodata\r\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      // option 1: source is configured with a nodata value\r\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\r\n        this.addAlpha_ = true;\r\n        break;\r\n      }\r\n      if (this.sourceMasks_[sourceIndex].length) {\r\n        this.addAlpha_ = true;\r\n        break;\r\n      }\r\n\r\n      const values = nodataValues[sourceIndex];\r\n\r\n      // option 2: check image metadata for limited bands\r\n      const bands = this.sourceInfo_[sourceIndex].bands;\r\n      if (bands) {\r\n        for (let i = 0; i < bands.length; ++i) {\r\n          if (values[bands[i] - 1] !== null) {\r\n            this.addAlpha_ = true;\r\n            break outer;\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // option 3: check image metadata for all bands\r\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\r\n        if (values[imageIndex] !== null) {\r\n          this.addAlpha_ = true;\r\n          break outer;\r\n        }\r\n      }\r\n    }\r\n\r\n    let bandCount = this.addAlpha_ ? 1 : 0;\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      bandCount += samplesPerPixel[sourceIndex];\r\n    }\r\n    this.bandCount = bandCount;\r\n\r\n    const tileGrid = new TileGrid({\r\n      extent: extent,\r\n      minZoom: minZoom,\r\n      origin: origin,\r\n      resolutions: resolutions,\r\n      tileSizes: commonRenderTileSizes,\r\n    });\r\n\r\n    this.tileGrid = tileGrid;\r\n    this.setTileSizes(commonSourceTileSizes);\r\n\r\n    this.setLoader(this.loadTile_.bind(this));\r\n    this.setState('ready');\r\n\r\n    const zoom = 1;\r\n    if (resolutions.length === 2) {\r\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\r\n    } else if (resolutions.length === 1) {\r\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\r\n    }\r\n\r\n    this.viewResolver({\r\n      showFullExtent: true,\r\n      projection: this.projection,\r\n      resolutions: resolutions,\r\n      center: toUserCoordinate(getCenter(extent), this.projection),\r\n      extent: toUserExtent(extent, this.projection),\r\n      zoom: zoom,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {number} z The z tile index.\r\n   * @param {number} x The x tile index.\r\n   * @param {number} y The y tile index.\r\n   * @param {import('./DataTile.js').LoaderOptions} options The loader options.\r\n   * @return {Promise} The composed tile data.\r\n   * @private\r\n   */\r\n  loadTile_(z, x, y, options) {\r\n    const sourceTileSize = this.getTileSize(z);\r\n    const sourceCount = this.sourceImagery_.length;\r\n    const requests = new Array(sourceCount * 2);\r\n    const nodataValues = this.nodataValues_;\r\n    const sourceInfo = this.sourceInfo_;\r\n    const pool = getWorkerPool();\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      const source = sourceInfo[sourceIndex];\r\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\r\n      const pixelBounds = [\r\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\r\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\r\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\r\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\r\n      ];\r\n      const image = this.sourceImagery_[sourceIndex][z];\r\n      let samples;\r\n      if (source.bands) {\r\n        samples = source.bands.map(function (bandNumber) {\r\n          return bandNumber - 1;\r\n        });\r\n      }\r\n\r\n      /** @type {number|Array<number>} */\r\n      let fillValue;\r\n      if ('nodata' in source && source.nodata !== null) {\r\n        fillValue = source.nodata;\r\n      } else {\r\n        if (!samples) {\r\n          fillValue = nodataValues[sourceIndex];\r\n        } else {\r\n          fillValue = samples.map(function (sampleIndex) {\r\n            return nodataValues[sourceIndex][sampleIndex];\r\n          });\r\n        }\r\n      }\r\n\r\n      const readOptions = {\r\n        window: pixelBounds,\r\n        width: sourceTileSize[0],\r\n        height: sourceTileSize[1],\r\n        samples: samples,\r\n        fillValue: fillValue,\r\n        pool: pool,\r\n        interleave: false,\r\n        signal: options.signal,\r\n      };\r\n      if (readRGB(this.convertToRGB_, image)) {\r\n        requests[sourceIndex] = image.readRGB(readOptions);\r\n      } else {\r\n        requests[sourceIndex] = image.readRasters(readOptions);\r\n      }\r\n\r\n      // requests after `sourceCount` are for mask data (if any)\r\n      const maskIndex = sourceCount + sourceIndex;\r\n      const mask = this.sourceMasks_[sourceIndex][z];\r\n      if (!mask) {\r\n        requests[maskIndex] = Promise.resolve(null);\r\n        continue;\r\n      }\r\n\r\n      requests[maskIndex] = mask.readRasters({\r\n        window: pixelBounds,\r\n        width: sourceTileSize[0],\r\n        height: sourceTileSize[1],\r\n        samples: [0],\r\n        pool: pool,\r\n        interleave: false,\r\n      });\r\n    }\r\n\r\n    return Promise.all(requests)\r\n      .then(this.composeTile_.bind(this, sourceTileSize))\r\n      .catch(function (error) {\r\n        logError(error);\r\n        throw error;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\r\n   * @param {Array} sourceSamples The source samples.\r\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\r\n   * @private\r\n   */\r\n  composeTile_(sourceTileSize, sourceSamples) {\r\n    const metadata = this.metadata_;\r\n    const sourceInfo = this.sourceInfo_;\r\n    const sourceCount = this.sourceImagery_.length;\r\n    const bandCount = this.bandCount;\r\n    const samplesPerPixel = this.samplesPerPixel_;\r\n    const nodataValues = this.nodataValues_;\r\n    const normalize = this.normalize_;\r\n    const addAlpha = this.addAlpha_;\r\n\r\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\r\n    const dataLength = pixelCount * bandCount;\r\n\r\n    /** @type {Uint8Array|Float32Array} */\r\n    let data;\r\n    if (normalize) {\r\n      data = new Uint8Array(dataLength);\r\n    } else {\r\n      data = new Float32Array(dataLength);\r\n    }\r\n\r\n    let dataIndex = 0;\r\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\r\n      let transparent = addAlpha;\r\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n        const source = sourceInfo[sourceIndex];\r\n\r\n        let min = source.min;\r\n        let max = source.max;\r\n        let gain, bias;\r\n        if (normalize) {\r\n          const stats = metadata[sourceIndex][0];\r\n          if (min === undefined) {\r\n            if (stats && STATISTICS_MINIMUM in stats) {\r\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\r\n            } else {\r\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\r\n            }\r\n          }\r\n          if (max === undefined) {\r\n            if (stats && STATISTICS_MAXIMUM in stats) {\r\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\r\n            } else {\r\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\r\n            }\r\n          }\r\n\r\n          gain = 255 / (max - min);\r\n          bias = -min * gain;\r\n        }\r\n\r\n        for (\r\n          let sampleIndex = 0;\r\n          sampleIndex < samplesPerPixel[sourceIndex];\r\n          ++sampleIndex\r\n        ) {\r\n          const sourceValue =\r\n            sourceSamples[sourceIndex][sampleIndex][pixelIndex];\r\n\r\n          let value;\r\n          if (normalize) {\r\n            value = clamp(gain * sourceValue + bias, 0, 255);\r\n          } else {\r\n            value = sourceValue;\r\n          }\r\n\r\n          if (!addAlpha) {\r\n            data[dataIndex] = value;\r\n          } else {\r\n            let nodata = source.nodata;\r\n            if (nodata === undefined) {\r\n              let bandIndex;\r\n              if (source.bands) {\r\n                bandIndex = source.bands[sampleIndex] - 1;\r\n              } else {\r\n                bandIndex = sampleIndex;\r\n              }\r\n              nodata = nodataValues[sourceIndex][bandIndex];\r\n            }\r\n\r\n            const nodataIsNaN = isNaN(nodata);\r\n            if (\r\n              (!nodataIsNaN && sourceValue !== nodata) ||\r\n              (nodataIsNaN && !isNaN(sourceValue))\r\n            ) {\r\n              transparent = false;\r\n              data[dataIndex] = value;\r\n            }\r\n          }\r\n          dataIndex++;\r\n        }\r\n        if (!transparent) {\r\n          const maskIndex = sourceCount + sourceIndex;\r\n          const mask = sourceSamples[maskIndex];\r\n          if (mask && !mask[0][pixelIndex]) {\r\n            transparent = true;\r\n          }\r\n        }\r\n      }\r\n      if (addAlpha) {\r\n        if (!transparent) {\r\n          data[dataIndex] = 255;\r\n        }\r\n        dataIndex++;\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n}\r\n\r\n/**\r\n * Get a promise for view properties based on the source.  Use the result of this function\r\n * as the `view` option in a map constructor.\r\n *\r\n *     const source = new GeoTIFF(options);\r\n *\r\n *     const map = new Map({\r\n *       target: 'map',\r\n *       layers: [\r\n *         new TileLayer({\r\n *           source: source,\r\n *         }),\r\n *       ],\r\n *       view: source.getView(),\r\n *     });\r\n *\r\n * @function\r\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\r\n * @api\r\n *\r\n */\r\nGeoTIFFSource.prototype.getView;\r\n\r\nexport default GeoTIFFSource;\r\n","/**\r\n * @module CME2D/layer/Property\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  OPACITY: 'opacity',\r\n  VISIBLE: 'visible',\r\n  EXTENT: 'extent',\r\n  Z_INDEX: 'zIndex',\r\n  MAX_RESOLUTION: 'maxResolution',\r\n  MIN_RESOLUTION: 'minResolution',\r\n  MAX_ZOOM: 'maxZoom',\r\n  MIN_ZOOM: 'minZoom',\r\n  SOURCE: 'source',\r\n  MAP: 'map',\r\n};\r\n","/**\r\n * @module CME2D/layer/Base\r\n */\r\nimport BaseObject from '../Object.js';\r\nimport LayerProperty from './Property.js';\r\nimport {abstract} from '../util.js';\r\nimport {assert} from '../asserts.js';\r\nimport {clamp} from '../math.js';\r\n\r\n/**\r\n * A css color, or a function called with a view resolution returning a css color.\r\n *\r\n * @typedef {string|function(number):string} BackgroundColor\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../ObjectEventType\").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|\r\n *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<BaseLayerObjectEventTypes, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background\r\n * will be rendered.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in\r\n * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so\r\n * is observable, and has get/set accessors.\r\n *\r\n * @api\r\n */\r\nclass BaseLayer extends BaseObject {\r\n  /**\r\n   * @param {Options} options Layer options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /***\r\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {BaseLayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @type {BackgroundColor|false}\r\n     * @private\r\n     */\r\n    this.background_ = options.background;\r\n\r\n    /**\r\n     * @type {Object<string, *>}\r\n     */\r\n    const properties = Object.assign({}, options);\r\n    if (typeof options.properties === 'object') {\r\n      delete properties.properties;\r\n      Object.assign(properties, options.properties);\r\n    }\r\n\r\n    properties[LayerProperty.OPACITY] =\r\n      options.opacity !== undefined ? options.opacity : 1;\r\n    assert(\r\n      typeof properties[LayerProperty.OPACITY] === 'number',\r\n      'Layer opacity must be a number',\r\n    );\r\n\r\n    properties[LayerProperty.VISIBLE] =\r\n      options.visible !== undefined ? options.visible : true;\r\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\r\n    properties[LayerProperty.MAX_RESOLUTION] =\r\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\r\n    properties[LayerProperty.MIN_RESOLUTION] =\r\n      options.minResolution !== undefined ? options.minResolution : 0;\r\n    properties[LayerProperty.MIN_ZOOM] =\r\n      options.minZoom !== undefined ? options.minZoom : -Infinity;\r\n    properties[LayerProperty.MAX_ZOOM] =\r\n      options.maxZoom !== undefined ? options.maxZoom : Infinity;\r\n\r\n    /**\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.className_ =\r\n      properties.className !== undefined ? properties.className : 'ol-layer';\r\n    delete properties.className;\r\n\r\n    this.setProperties(properties);\r\n\r\n    /**\r\n     * @type {import(\"./Layer.js\").State}\r\n     * @private\r\n     */\r\n    this.state_ = null;\r\n  }\r\n\r\n  /**\r\n   * Get the background for this layer.\r\n   * @return {BackgroundColor|false} Layer background.\r\n   */\r\n  getBackground() {\r\n    return this.background_;\r\n  }\r\n\r\n  /**\r\n   * @return {string} CSS class name.\r\n   */\r\n  getClassName() {\r\n    return this.className_;\r\n  }\r\n\r\n  /**\r\n   * This method is not meant to be called by layers or layer renderers because the state\r\n   * is incorrect if the layer is included in a layer group.\r\n   *\r\n   * @param {boolean} [managed] Layer is managed.\r\n   * @return {import(\"./Layer.js\").State} Layer state.\r\n   */\r\n  getLayerState(managed) {\r\n    /** @type {import(\"./Layer.js\").State} */\r\n    const state =\r\n      this.state_ ||\r\n      /** @type {?} */ ({\r\n        layer: this,\r\n        managed: managed === undefined ? true : managed,\r\n      });\r\n    const zIndex = this.getZIndex();\r\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\r\n    state.visible = this.getVisible();\r\n    state.extent = this.getExtent();\r\n    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;\r\n    state.maxResolution = this.getMaxResolution();\r\n    state.minResolution = Math.max(this.getMinResolution(), 0);\r\n    state.minZoom = this.getMinZoom();\r\n    state.maxZoom = this.getMaxZoom();\r\n    this.state_ = state;\r\n\r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be\r\n   *     modified in place).\r\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\r\n   */\r\n  getLayersArray(array) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer\r\n   *     states (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\r\n   */\r\n  getLayerStatesArray(states) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\r\n   * will be visible regardless of extent.\r\n   * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return /** @type {import(\"../extent.js\").Extent|undefined} */ (\r\n      this.get(LayerProperty.EXTENT)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the maximum resolution of the layer. Returns Infinity if\r\n   * the layer has no maximum resolution set.\r\n   * @return {number} The maximum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMaxResolution() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\r\n  }\r\n\r\n  /**\r\n   * Return the minimum resolution of the layer. Returns 0 if\r\n   * the layer has no minimum resolution set.\r\n   * @return {number} The minimum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMinResolution() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\r\n  }\r\n\r\n  /**\r\n   * Return the minimum zoom level of the layer. Returns -Infinity if\r\n   * the layer has no minimum zoom set.\r\n   * @return {number} The minimum zoom level of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMinZoom() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));\r\n  }\r\n\r\n  /**\r\n   * Return the maximum zoom level of the layer. Returns Infinity if\r\n   * the layer has no maximum zoom set.\r\n   * @return {number} The maximum zoom level of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMaxZoom() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));\r\n  }\r\n\r\n  /**\r\n   * Return the opacity of the layer (between 0 and 1).\r\n   * @return {number} The opacity of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getOpacity() {\r\n    return /** @type {number} */ (this.get(LayerProperty.OPACITY));\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @return {import(\"../source/Source.js\").State} Source state.\r\n   */\r\n  getSourceState() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the value of this layer's `visible` property. To find out whether the layer\r\n   * is visible on a map, use `isVisible()` instead.\r\n   * @return {boolean} The value of the `visible` property of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getVisible() {\r\n    return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\r\n  }\r\n\r\n  /**\r\n   * Return the Z-index of the layer, which is used to order layers before\r\n   * rendering. Returns undefined if the layer is unmanaged.\r\n   * @return {number|undefined} The Z-index of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getZIndex() {\r\n    return /** @type {number|undefined} */ (this.get(LayerProperty.Z_INDEX));\r\n  }\r\n\r\n  /**\r\n   * Sets the background color.\r\n   * @param {BackgroundColor} [background] Background color.\r\n   */\r\n  setBackground(background) {\r\n    this.background_ = background;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\r\n   * will be visible at all extents.\r\n   * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setExtent(extent) {\r\n    this.set(LayerProperty.EXTENT, extent);\r\n  }\r\n\r\n  /**\r\n   * Set the maximum resolution at which the layer is visible.\r\n   * @param {number} maxResolution The maximum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMaxResolution(maxResolution) {\r\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\r\n  }\r\n\r\n  /**\r\n   * Set the minimum resolution at which the layer is visible.\r\n   * @param {number} minResolution The minimum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMinResolution(minResolution) {\r\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\r\n  }\r\n\r\n  /**\r\n   * Set the maximum zoom (exclusive) at which the layer is visible.\r\n   * Note that the zoom levels for layer visibility are based on the\r\n   * view zoom level, which may be different from a tile source zoom level.\r\n   * @param {number} maxZoom The maximum zoom of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMaxZoom(maxZoom) {\r\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\r\n  }\r\n\r\n  /**\r\n   * Set the minimum zoom (inclusive) at which the layer is visible.\r\n   * Note that the zoom levels for layer visibility are based on the\r\n   * view zoom level, which may be different from a tile source zoom level.\r\n   * @param {number} minZoom The minimum zoom of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMinZoom(minZoom) {\r\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\r\n  }\r\n\r\n  /**\r\n   * Set the opacity of the layer, allowed values range from 0 to 1.\r\n   * @param {number} opacity The opacity of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setOpacity(opacity) {\r\n    assert(typeof opacity === 'number', 'Layer opacity must be a number');\r\n    this.set(LayerProperty.OPACITY, opacity);\r\n  }\r\n\r\n  /**\r\n   * Set the visibility of the layer (`true` or `false`).\r\n   * @param {boolean} visible The visibility of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setVisible(visible) {\r\n    this.set(LayerProperty.VISIBLE, visible);\r\n  }\r\n\r\n  /**\r\n   * Set Z-index of the layer, which is used to order layers before rendering.\r\n   * The default Z-index is 0.\r\n   * @param {number} zindex The z-index of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setZIndex(zindex) {\r\n    this.set(LayerProperty.Z_INDEX, zindex);\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    if (this.state_) {\r\n      this.state_.layer = null;\r\n      this.state_ = null;\r\n    }\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default BaseLayer;\r\n","/**\r\n * @module CME2D/render/EventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * Triggered before a layer is rendered.\r\n   * @event module:ol/render/Event~RenderEvent#prerender\r\n   * @api\r\n   */\r\n  PRERENDER: 'prerender',\r\n\r\n  /**\r\n   * Triggered after a layer is rendered.\r\n   * @event module:ol/render/Event~RenderEvent#postrender\r\n   * @api\r\n   */\r\n  POSTRENDER: 'postrender',\r\n\r\n  /**\r\n   * Triggered before layers are composed.  When dispatched by the map, the event object will not have\r\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\r\n   * WebGL layers currently dispatch this event.\r\n   * @event module:ol/render/Event~RenderEvent#precompose\r\n   * @api\r\n   */\r\n  PRECOMPOSE: 'precompose',\r\n\r\n  /**\r\n   * Triggered after layers are composed.  When dispatched by the map, the event object will not have\r\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\r\n   * WebGL layers currently dispatch this event.\r\n   * @event module:ol/render/Event~RenderEvent#postcompose\r\n   * @api\r\n   */\r\n  POSTCOMPOSE: 'postcompose',\r\n\r\n  /**\r\n   * Triggered when rendering is complete, i.e. all sources and tiles have\r\n   * finished loading for the current viewport, and all tiles are faded in.\r\n   * The event object will not have a `context` set.\r\n   * @event module:ol/render/Event~RenderEvent#rendercomplete\r\n   * @api\r\n   */\r\n  RENDERCOMPLETE: 'rendercomplete',\r\n};\r\n\r\n/**\r\n * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes\r\n */\r\n\r\n/**\r\n * @typedef {'postrender'|'prerender'} LayerRenderEventTypes\r\n */\r\n","/**\r\n * @module CME2D/ViewHint\r\n */\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nexport default {\r\n  ANIMATING: 0,\r\n  INTERACTING: 1,\r\n};\r\n","/**\r\n * @module CME2D/ViewProperty\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  CENTER: 'center',\r\n  RESOLUTION: 'resolution',\r\n  ROTATION: 'rotation',\r\n};\r\n","/**\r\n * @module CME2D/centerconstraint\r\n */\r\nimport {clamp} from './math.js';\r\n\r\n/**\r\n * @typedef {function((import(\"./coordinate.js\").Coordinate|undefined), number, import(\"./size.js\").Size, boolean=, Array<number>=): (import(\"./coordinate.js\").Coordinate|undefined)} Type\r\n */\r\n\r\n/**\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.\r\n * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent\r\n * (only during interaction and animation).\r\n * @return {Type} The constraint.\r\n */\r\nexport function createExtent(extent, onlyCenter, smooth) {\r\n  return (\r\n    /**\r\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center Center.\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {import(\"./size.js\").Size} size Viewport size; unused if `onlyCenter` was specified.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @param {Array<number>} [centerShift] Shift between map center and viewport center.\r\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\r\n     */\r\n    function (center, resolution, size, isMoving, centerShift) {\r\n      if (!center) {\r\n        return undefined;\r\n      }\r\n      if (!resolution && !onlyCenter) {\r\n        return center;\r\n      }\r\n      const viewWidth = onlyCenter ? 0 : size[0] * resolution;\r\n      const viewHeight = onlyCenter ? 0 : size[1] * resolution;\r\n      const shiftX = centerShift ? centerShift[0] : 0;\r\n      const shiftY = centerShift ? centerShift[1] : 0;\r\n      let minX = extent[0] + viewWidth / 2 + shiftX;\r\n      let maxX = extent[2] - viewWidth / 2 + shiftX;\r\n      let minY = extent[1] + viewHeight / 2 + shiftY;\r\n      let maxY = extent[3] - viewHeight / 2 + shiftY;\r\n\r\n      // note: when zooming out of bounds, min and max values for x and y may\r\n      // end up inverted (min > max); this has to be accounted for\r\n      if (minX > maxX) {\r\n        minX = (maxX + minX) / 2;\r\n        maxX = minX;\r\n      }\r\n      if (minY > maxY) {\r\n        minY = (maxY + minY) / 2;\r\n        maxY = minY;\r\n      }\r\n\r\n      let x = clamp(center[0], minX, maxX);\r\n      let y = clamp(center[1], minY, maxY);\r\n\r\n      // during an interaction, allow some overscroll\r\n      if (isMoving && smooth && resolution) {\r\n        const ratio = 30 * resolution;\r\n        x +=\r\n          -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +\r\n          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);\r\n        y +=\r\n          -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +\r\n          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);\r\n      }\r\n\r\n      return [x, y];\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} [center] Center.\r\n * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\r\n */\r\nexport function none(center) {\r\n  return center;\r\n}\r\n","/**\r\n * @module CME2D/resolutionconstraint\r\n */\r\nimport {clamp} from './math.js';\r\nimport {getHeight, getWidth} from './extent.js';\r\nimport {linearFindNearest} from './array.js';\r\n\r\n/**\r\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\r\n */\r\n\r\n/**\r\n * Returns a modified resolution taking into account the viewport size and maximum\r\n * allowed extent.\r\n * @param {number} resolution Resolution\r\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\r\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\r\n * @param {boolean} showFullExtent Whether to show the full extent.\r\n * @return {number} Capped resolution.\r\n */\r\nfunction getViewportClampedResolution(\r\n  resolution,\r\n  maxExtent,\r\n  viewportSize,\r\n  showFullExtent,\r\n) {\r\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\r\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\r\n\r\n  if (showFullExtent) {\r\n    return Math.min(resolution, Math.max(xResolution, yResolution));\r\n  }\r\n  return Math.min(resolution, Math.min(xResolution, yResolution));\r\n}\r\n\r\n/**\r\n * Returns a modified resolution to be between maxResolution and minResolution while\r\n * still allowing the value to be slightly out of bounds.\r\n * Note: the computation is based on the logarithm function (ln):\r\n *  - at 1, ln(x) is 0\r\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\r\n * The final result is clamped to prevent getting too far away from bounds.\r\n * @param {number} resolution Resolution.\r\n * @param {number} maxResolution Max resolution.\r\n * @param {number} minResolution Min resolution.\r\n * @return {number} Smoothed resolution.\r\n */\r\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\r\n  let result = Math.min(resolution, maxResolution);\r\n  const ratio = 50;\r\n\r\n  result *=\r\n    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\r\n    1;\r\n  if (minResolution) {\r\n    result = Math.max(result, minResolution);\r\n    result /=\r\n      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\r\n        ratio +\r\n      1;\r\n  }\r\n  return clamp(result, minResolution / 2, maxResolution * 2);\r\n}\r\n\r\n/**\r\n * @param {Array<number>} resolutions Resolutions.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\r\nexport function createSnapToResolutions(\r\n  resolutions,\r\n  smooth,\r\n  maxExtent,\r\n  showFullExtent,\r\n) {\r\n  smooth = smooth !== undefined ? smooth : true;\r\n  return (\r\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\r\n    function (resolution, direction, size, isMoving) {\r\n      if (resolution !== undefined) {\r\n        const maxResolution = resolutions[0];\r\n        const minResolution = resolutions[resolutions.length - 1];\r\n        const cappedMaxRes = maxExtent\r\n          ? getViewportClampedResolution(\r\n              maxResolution,\r\n              maxExtent,\r\n              size,\r\n              showFullExtent,\r\n            )\r\n          : maxResolution;\r\n\r\n        // during interacting or animating, allow intermediary values\r\n        if (isMoving) {\r\n          if (!smooth) {\r\n            return clamp(resolution, minResolution, cappedMaxRes);\r\n          }\r\n          return getSmoothClampedResolution(\r\n            resolution,\r\n            cappedMaxRes,\r\n            minResolution,\r\n          );\r\n        }\r\n\r\n        const capped = Math.min(cappedMaxRes, resolution);\r\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\r\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\r\n          return resolutions[z + 1];\r\n        }\r\n        return resolutions[z];\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {number} power Power.\r\n * @param {number} maxResolution Maximum resolution.\r\n * @param {number} [minResolution] Minimum resolution.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\r\nexport function createSnapToPower(\r\n  power,\r\n  maxResolution,\r\n  minResolution,\r\n  smooth,\r\n  maxExtent,\r\n  showFullExtent,\r\n) {\r\n  smooth = smooth !== undefined ? smooth : true;\r\n  minResolution = minResolution !== undefined ? minResolution : 0;\r\n\r\n  return (\r\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\r\n    function (resolution, direction, size, isMoving) {\r\n      if (resolution !== undefined) {\r\n        const cappedMaxRes = maxExtent\r\n          ? getViewportClampedResolution(\r\n              maxResolution,\r\n              maxExtent,\r\n              size,\r\n              showFullExtent,\r\n            )\r\n          : maxResolution;\r\n\r\n        // during interacting or animating, allow intermediary values\r\n        if (isMoving) {\r\n          if (!smooth) {\r\n            return clamp(resolution, minResolution, cappedMaxRes);\r\n          }\r\n          return getSmoothClampedResolution(\r\n            resolution,\r\n            cappedMaxRes,\r\n            minResolution,\r\n          );\r\n        }\r\n\r\n        const tolerance = 1e-9;\r\n        const minZoomLevel = Math.ceil(\r\n          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance,\r\n        );\r\n        const offset = -direction * (0.5 - tolerance) + 0.5;\r\n        const capped = Math.min(cappedMaxRes, resolution);\r\n        const cappedZoomLevel = Math.floor(\r\n          Math.log(maxResolution / capped) / Math.log(power) + offset,\r\n        );\r\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\r\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\r\n        return clamp(newResolution, minResolution, cappedMaxRes);\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {number} maxResolution Max resolution.\r\n * @param {number} minResolution Min resolution.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\r\nexport function createMinMaxResolution(\r\n  maxResolution,\r\n  minResolution,\r\n  smooth,\r\n  maxExtent,\r\n  showFullExtent,\r\n) {\r\n  smooth = smooth !== undefined ? smooth : true;\r\n\r\n  return (\r\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\r\n    function (resolution, direction, size, isMoving) {\r\n      if (resolution !== undefined) {\r\n        const cappedMaxRes = maxExtent\r\n          ? getViewportClampedResolution(\r\n              maxResolution,\r\n              maxExtent,\r\n              size,\r\n              showFullExtent,\r\n            )\r\n          : maxResolution;\r\n\r\n        if (!smooth || !isMoving) {\r\n          return clamp(resolution, minResolution, cappedMaxRes);\r\n        }\r\n        return getSmoothClampedResolution(\r\n          resolution,\r\n          cappedMaxRes,\r\n          minResolution,\r\n        );\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n","/**\r\n * @module CME2D/rotationconstraint\r\n */\r\nimport {toRadians} from './math.js';\r\n\r\n/**\r\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\r\n */\r\n\r\n/**\r\n * @param {number|undefined} rotation Rotation.\r\n * @return {number|undefined} Rotation.\r\n */\r\nexport function disable(rotation) {\r\n  if (rotation !== undefined) {\r\n    return 0;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * @param {number|undefined} rotation Rotation.\r\n * @return {number|undefined} Rotation.\r\n */\r\nexport function none(rotation) {\r\n  if (rotation !== undefined) {\r\n    return rotation;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * @param {number} n N.\r\n * @return {Type} Rotation constraint.\r\n */\r\nexport function createSnapToN(n) {\r\n  const theta = (2 * Math.PI) / n;\r\n  return (\r\n    /**\r\n     * @param {number|undefined} rotation Rotation.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Rotation.\r\n     */\r\n    function (rotation, isMoving) {\r\n      if (isMoving) {\r\n        return rotation;\r\n      }\r\n\r\n      if (rotation !== undefined) {\r\n        rotation = Math.floor(rotation / theta + 0.5) * theta;\r\n        return rotation;\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {number} [tolerance] Tolerance.\r\n * @return {Type} Rotation constraint.\r\n */\r\nexport function createSnapToZero(tolerance) {\r\n  const t = tolerance === undefined ? toRadians(5) : tolerance;\r\n  return (\r\n    /**\r\n     * @param {number|undefined} rotation Rotation.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Rotation.\r\n     */\r\n    function (rotation, isMoving) {\r\n      if (isMoving || rotation === undefined) {\r\n        return rotation;\r\n      }\r\n\r\n      if (Math.abs(rotation) <= t) {\r\n        return 0;\r\n      }\r\n      return rotation;\r\n    }\r\n  );\r\n}\r\n","/**\r\n * @module CME2D/transform\r\n */\r\nimport {assert} from './asserts.js';\r\n\r\n/**\r\n * An array representing an affine 2d transformation for use with\r\n * {@link module:ol/transform} functions. The array has 6 elements.\r\n * @typedef {!Array<number>} Transform\r\n * @api\r\n */\r\n\r\n/**\r\n * Collection of affine 2d transformation functions. The functions work on an\r\n * array of 6 elements. The element order is compatible with the [SVGMatrix\r\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\r\n * a subset (elements a to f) of a 33 matrix:\r\n * ```\r\n * [ a c e ]\r\n * [ b d f ]\r\n * [ 0 0 1 ]\r\n * ```\r\n */\r\n\r\n/**\r\n * @private\r\n * @type {Transform}\r\n */\r\nconst tmp_ = new Array(6);\r\n\r\n/**\r\n * Create an identity transform.\r\n * @return {!Transform} Identity transform.\r\n */\r\nexport function create() {\r\n  return [1, 0, 0, 1, 0, 0];\r\n}\r\n\r\n/**\r\n * Resets the given transform to an identity transform.\r\n * @param {!Transform} transform Transform.\r\n * @return {!Transform} Transform.\r\n */\r\nexport function reset(transform) {\r\n  return set(transform, 1, 0, 0, 1, 0, 0);\r\n}\r\n\r\n/**\r\n * Multiply the underlying matrices of two transforms and return the result in\r\n * the first transform.\r\n * @param {!Transform} transform1 Transform parameters of matrix 1.\r\n * @param {!Transform} transform2 Transform parameters of matrix 2.\r\n * @return {!Transform} transform1 multiplied with transform2.\r\n */\r\nexport function multiply(transform1, transform2) {\r\n  const a1 = transform1[0];\r\n  const b1 = transform1[1];\r\n  const c1 = transform1[2];\r\n  const d1 = transform1[3];\r\n  const e1 = transform1[4];\r\n  const f1 = transform1[5];\r\n  const a2 = transform2[0];\r\n  const b2 = transform2[1];\r\n  const c2 = transform2[2];\r\n  const d2 = transform2[3];\r\n  const e2 = transform2[4];\r\n  const f2 = transform2[5];\r\n\r\n  transform1[0] = a1 * a2 + c1 * b2;\r\n  transform1[1] = b1 * a2 + d1 * b2;\r\n  transform1[2] = a1 * c2 + c1 * d2;\r\n  transform1[3] = b1 * c2 + d1 * d2;\r\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\r\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\r\n\r\n  return transform1;\r\n}\r\n\r\n/**\r\n * Set the transform components a-f on a given transform.\r\n * @param {!Transform} transform Transform.\r\n * @param {number} a The a component of the transform.\r\n * @param {number} b The b component of the transform.\r\n * @param {number} c The c component of the transform.\r\n * @param {number} d The d component of the transform.\r\n * @param {number} e The e component of the transform.\r\n * @param {number} f The f component of the transform.\r\n * @return {!Transform} Matrix with transform applied.\r\n */\r\nexport function set(transform, a, b, c, d, e, f) {\r\n  transform[0] = a;\r\n  transform[1] = b;\r\n  transform[2] = c;\r\n  transform[3] = d;\r\n  transform[4] = e;\r\n  transform[5] = f;\r\n  return transform;\r\n}\r\n\r\n/**\r\n * Set transform on one matrix from another matrix.\r\n * @param {!Transform} transform1 Matrix to set transform to.\r\n * @param {!Transform} transform2 Matrix to set transform from.\r\n * @return {!Transform} transform1 with transform from transform2 applied.\r\n */\r\nexport function setFromArray(transform1, transform2) {\r\n  transform1[0] = transform2[0];\r\n  transform1[1] = transform2[1];\r\n  transform1[2] = transform2[2];\r\n  transform1[3] = transform2[3];\r\n  transform1[4] = transform2[4];\r\n  transform1[5] = transform2[5];\r\n  return transform1;\r\n}\r\n\r\n/**\r\n * Transforms the given coordinate with the given transform returning the\r\n * resulting, transformed coordinate. The coordinate will be modified in-place.\r\n *\r\n * @param {Transform} transform The transformation.\r\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\r\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\r\n *     chained together.\r\n */\r\nexport function apply(transform, coordinate) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\r\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Applies rotation to the given transform.\r\n * @param {!Transform} transform Transform.\r\n * @param {number} angle Angle in radians.\r\n * @return {!Transform} The rotated transform.\r\n */\r\nexport function rotate(transform, angle) {\r\n  const cos = Math.cos(angle);\r\n  const sin = Math.sin(angle);\r\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\r\n}\r\n\r\n/**\r\n * Applies scale to a given transform.\r\n * @param {!Transform} transform Transform.\r\n * @param {number} x Scale factor x.\r\n * @param {number} y Scale factor y.\r\n * @return {!Transform} The scaled transform.\r\n */\r\nexport function scale(transform, x, y) {\r\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\r\n}\r\n\r\n/**\r\n * Creates a scale transform.\r\n * @param {!Transform} target Transform to overwrite.\r\n * @param {number} x Scale factor x.\r\n * @param {number} y Scale factor y.\r\n * @return {!Transform} The scale transform.\r\n */\r\nexport function makeScale(target, x, y) {\r\n  return set(target, x, 0, 0, y, 0, 0);\r\n}\r\n\r\n/**\r\n * Applies translation to the given transform.\r\n * @param {!Transform} transform Transform.\r\n * @param {number} dx Translation x.\r\n * @param {number} dy Translation y.\r\n * @return {!Transform} The translated transform.\r\n */\r\nexport function translate(transform, dx, dy) {\r\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\r\n}\r\n\r\n/**\r\n * Creates a composite transform given an initial translation, scale, rotation, and\r\n * final translation (in that order only, not commutative).\r\n * @param {!Transform} transform The transform (will be modified in place).\r\n * @param {number} dx1 Initial translation x.\r\n * @param {number} dy1 Initial translation y.\r\n * @param {number} sx Scale factor x.\r\n * @param {number} sy Scale factor y.\r\n * @param {number} angle Rotation (in counter-clockwise radians).\r\n * @param {number} dx2 Final translation x.\r\n * @param {number} dy2 Final translation y.\r\n * @return {!Transform} The composite transform.\r\n */\r\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\r\n  const sin = Math.sin(angle);\r\n  const cos = Math.cos(angle);\r\n  transform[0] = sx * cos;\r\n  transform[1] = sy * sin;\r\n  transform[2] = -sx * sin;\r\n  transform[3] = sy * cos;\r\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\r\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\r\n  return transform;\r\n}\r\n\r\n/**\r\n * Creates a composite transform given an initial translation, scale, rotation, and\r\n * final translation (in that order only, not commutative). The resulting transform\r\n * string can be applied as `transform` property of an HTMLElement's style.\r\n * @param {number} dx1 Initial translation x.\r\n * @param {number} dy1 Initial translation y.\r\n * @param {number} sx Scale factor x.\r\n * @param {number} sy Scale factor y.\r\n * @param {number} angle Rotation (in counter-clockwise radians).\r\n * @param {number} dx2 Final translation x.\r\n * @param {number} dy2 Final translation y.\r\n * @return {string} The composite css transform.\r\n * @api\r\n */\r\nexport function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\r\n  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\r\n}\r\n\r\n/**\r\n * Invert the given transform.\r\n * @param {!Transform} source The source transform to invert.\r\n * @return {!Transform} The inverted (source) transform.\r\n */\r\nexport function invert(source) {\r\n  return makeInverse(source, source);\r\n}\r\n\r\n/**\r\n * Invert the given transform.\r\n * @param {!Transform} target Transform to be set as the inverse of\r\n *     the source transform.\r\n * @param {!Transform} source The source transform to invert.\r\n * @return {!Transform} The inverted (target) transform.\r\n */\r\nexport function makeInverse(target, source) {\r\n  const det = determinant(source);\r\n  assert(det !== 0, 'Transformation matrix cannot be inverted');\r\n\r\n  const a = source[0];\r\n  const b = source[1];\r\n  const c = source[2];\r\n  const d = source[3];\r\n  const e = source[4];\r\n  const f = source[5];\r\n\r\n  target[0] = d / det;\r\n  target[1] = -b / det;\r\n  target[2] = -c / det;\r\n  target[3] = a / det;\r\n  target[4] = (c * f - d * e) / det;\r\n  target[5] = -(a * f - b * e) / det;\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Returns the determinant of the given matrix.\r\n * @param {!Transform} mat Matrix.\r\n * @return {number} Determinant.\r\n */\r\nexport function determinant(mat) {\r\n  return mat[0] * mat[3] - mat[1] * mat[2];\r\n}\r\n\r\n/**\r\n * @type {Array}\r\n */\r\nconst matrixPrecision = [1e6, 1e6, 1e6, 1e6, 2, 2];\r\n\r\n/**\r\n * A rounded string version of the transform.  This can be used\r\n * for CSS transforms.\r\n * @param {!Transform} mat Matrix.\r\n * @return {string} The transform as a string.\r\n */\r\nexport function toString(mat) {\r\n  const transformString =\r\n    'matrix(' +\r\n    mat\r\n      .map(\r\n        (value, i) =>\r\n          Math.round(value * matrixPrecision[i]) / matrixPrecision[i],\r\n      )\r\n      .join(', ') +\r\n    ')';\r\n  return transformString;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/transform\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n * @param {Array<number>} [dest] Destination.\r\n * @param {number} [destinationStride] Stride of destination coordinates; if unspecified, assumed to be 2.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function transform2D(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  transform,\r\n  dest,\r\n  destinationStride,\r\n) {\r\n  dest = dest ? dest : [];\r\n  destinationStride = destinationStride ? destinationStride : 2;\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    const x = flatCoordinates[j];\r\n    const y = flatCoordinates[j + 1];\r\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\r\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\r\n\r\n    for (let k = 2; k < destinationStride; k++) {\r\n      dest[i++] = flatCoordinates[j + k];\r\n    }\r\n  }\r\n\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} angle Angle.\r\n * @param {Array<number>} anchor Rotation anchor point.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function rotate(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  angle,\r\n  anchor,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  const cos = Math.cos(angle);\r\n  const sin = Math.sin(angle);\r\n  const anchorX = anchor[0];\r\n  const anchorY = anchor[1];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    const deltaX = flatCoordinates[j] - anchorX;\r\n    const deltaY = flatCoordinates[j + 1] - anchorY;\r\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\r\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\r\n    for (let k = j + 2; k < j + stride; ++k) {\r\n      dest[i++] = flatCoordinates[k];\r\n    }\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * Scale the coordinates.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} sx Scale factor in the x-direction.\r\n * @param {number} sy Scale factor in the y-direction.\r\n * @param {Array<number>} anchor Scale anchor point.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function scale(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  sx,\r\n  sy,\r\n  anchor,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  const anchorX = anchor[0];\r\n  const anchorY = anchor[1];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    const deltaX = flatCoordinates[j] - anchorX;\r\n    const deltaY = flatCoordinates[j + 1] - anchorY;\r\n    dest[i++] = anchorX + sx * deltaX;\r\n    dest[i++] = anchorY + sy * deltaY;\r\n    for (let k = j + 2; k < j + stride; ++k) {\r\n      dest[i++] = flatCoordinates[k];\r\n    }\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} deltaX Delta X.\r\n * @param {number} deltaY Delta Y.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function translate(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  deltaX,\r\n  deltaY,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    dest[i++] = flatCoordinates[j] + deltaX;\r\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\r\n    for (let k = j + 2; k < j + stride; ++k) {\r\n      dest[i++] = flatCoordinates[k];\r\n    }\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n","/**\r\n * @module CME2D/geom/Geometry\r\n */\r\nimport BaseObject from '../Object.js';\r\nimport {abstract} from '../util.js';\r\nimport {\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n} from '../transform.js';\r\nimport {\r\n  createEmpty,\r\n  createOrUpdateEmpty,\r\n  getHeight,\r\n  returnOrUpdate,\r\n} from '../extent.js';\r\nimport {get as getProjection, getTransform} from '../proj.js';\r\nimport {memoizeOne} from '../functions.js';\r\nimport {transform2D} from './flat/transform.js';\r\n\r\n/**\r\n * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout\r\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\r\n * or measure ('M') coordinate is available.\r\n */\r\n\r\n/**\r\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type\r\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\r\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\r\n * `'GeometryCollection'`, or `'Circle'`.\r\n */\r\n\r\n/**\r\n * @type {import(\"../transform.js\").Transform}\r\n */\r\nconst tmpTransform = createTransform();\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for vector geometries.\r\n *\r\n * To get notified of changes to the geometry, register a listener for the\r\n * generic `change` event on your geometry instance.\r\n *\r\n * @abstract\r\n * @api\r\n */\r\nclass Geometry extends BaseObject {\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = createEmpty();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.extentRevision_ = -1;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.simplifiedGeometryRevision = 0;\r\n\r\n    /**\r\n     * Get a transformed and simplified version of the geometry.\r\n     * @abstract\r\n     * @param {number} revision The geometry revision.\r\n     * @param {number} squaredTolerance Squared tolerance.\r\n     * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\r\n     * @return {Geometry} Simplified geometry.\r\n     */\r\n    this.simplifyTransformedInternal = memoizeOne(\r\n      (revision, squaredTolerance, transform) => {\r\n        if (!transform) {\r\n          return this.getSimplifiedGeometry(squaredTolerance);\r\n        }\r\n        const clone = this.clone();\r\n        clone.applyTransform(transform);\r\n        return clone.getSimplifiedGeometry(squaredTolerance);\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get a transformed and simplified version of the geometry.\r\n   * @abstract\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\r\n   * @return {Geometry} Simplified geometry.\r\n   */\r\n  simplifyTransformed(squaredTolerance, transform) {\r\n    return this.simplifyTransformedInternal(\r\n      this.getRevision(),\r\n      squaredTolerance,\r\n      transform,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @abstract\r\n   * @return {!Geometry} Clone.\r\n   */\r\n  clone() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   */\r\n  containsXY(x, y) {\r\n    const coord = this.getClosestPoint([x, y]);\r\n    return coord[0] === x && coord[1] === y;\r\n  }\r\n\r\n  /**\r\n   * Return the closest point of the geometry to the passed point as\r\n   * {@link module:ol/coordinate~Coordinate coordinate}.\r\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\r\n   * @param {import(\"../coordinate.js\").Coordinate} [closestPoint] Closest point.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\r\n   * @api\r\n   */\r\n  getClosestPoint(point, closestPoint) {\r\n    closestPoint = closestPoint ? closestPoint : [NaN, NaN];\r\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\r\n    return closestPoint;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this geometry includes the specified coordinate. If the\r\n   * coordinate is on the boundary of the geometry, returns false.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @return {boolean} Contains coordinate.\r\n   * @api\r\n   */\r\n  intersectsCoordinate(coordinate) {\r\n    return this.containsXY(coordinate[0], coordinate[1]);\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @protected\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   */\r\n  computeExtent(extent) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Get the extent of the geometry.\r\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   * @api\r\n   */\r\n  getExtent(extent) {\r\n    if (this.extentRevision_ != this.getRevision()) {\r\n      const extent = this.computeExtent(this.extent_);\r\n      if (isNaN(extent[0]) || isNaN(extent[1])) {\r\n        createOrUpdateEmpty(extent);\r\n      }\r\n      this.extentRevision_ = this.getRevision();\r\n    }\r\n    return returnOrUpdate(this.extent_, extent);\r\n  }\r\n\r\n  /**\r\n   * Rotate the geometry around a given coordinate. This modifies the geometry\r\n   * coordinates in place.\r\n   * @abstract\r\n   * @param {number} angle Rotation angle in radians.\r\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\r\n   * @api\r\n   */\r\n  rotate(angle, anchor) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Scale the geometry (with an optional origin).  This modifies the geometry\r\n   * coordinates in place.\r\n   * @abstract\r\n   * @param {number} sx The scaling factor in the x-direction.\r\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\r\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\r\n   *     of the geometry extent).\r\n   * @api\r\n   */\r\n  scale(sx, sy, anchor) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Create a simplified version of this geometry.  For linestrings, this uses\r\n   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\r\n   * algorithm.  For polygons, a quantization-based\r\n   * simplification is used to preserve topology.\r\n   * @param {number} tolerance The tolerance distance for simplification.\r\n   * @return {Geometry} A new, simplified version of the original geometry.\r\n   * @api\r\n   */\r\n  simplify(tolerance) {\r\n    return this.getSimplifiedGeometry(tolerance * tolerance);\r\n  }\r\n\r\n  /**\r\n   * Create a simplified version of this geometry using the Douglas Peucker\r\n   * algorithm.\r\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\r\n   * @abstract\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {Geometry} Simplified geometry.\r\n   */\r\n  getSimplifiedGeometry(squaredTolerance) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @abstract\r\n   * @return {Type} Geometry type.\r\n   */\r\n  getType() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Apply a transform function to the coordinates of the geometry.\r\n   * The geometry is modified in place.\r\n   * If you do not want the geometry modified in place, first `clone()` it and\r\n   * then use this function on the clone.\r\n   * @abstract\r\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\r\n   * Called with a flat array of geometry coordinates.\r\n   */\r\n  applyTransform(transformFn) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @abstract\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   */\r\n  intersectsExtent(extent) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\r\n   * instead you want a new geometry, first `clone()` this geometry.\r\n   * @abstract\r\n   * @param {number} deltaX Delta X.\r\n   * @param {number} deltaY Delta Y.\r\n   * @api\r\n   */\r\n  translate(deltaX, deltaY) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Transform each coordinate of the geometry from one coordinate reference\r\n   * system to another. The geometry is modified in place.\r\n   * For example, a line will be transformed to a line and a circle to a circle.\r\n   * If you do not want the geometry modified in place, first `clone()` it and\r\n   * then use this function on the clone.\r\n   *\r\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\r\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\r\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\r\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\r\n   * @return {this} This geometry.  Note that original geometry is\r\n   *     modified in place.\r\n   * @api\r\n   */\r\n  transform(source, destination) {\r\n    /** @type {import(\"../proj/Projection.js\").default} */\r\n    const sourceProj = getProjection(source);\r\n    const transformFn =\r\n      sourceProj.getUnits() == 'tile-pixels'\r\n        ? function (inCoordinates, outCoordinates, stride) {\r\n            const pixelExtent = sourceProj.getExtent();\r\n            const projectedExtent = sourceProj.getWorldExtent();\r\n            const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\r\n            composeTransform(\r\n              tmpTransform,\r\n              projectedExtent[0],\r\n              projectedExtent[3],\r\n              scale,\r\n              -scale,\r\n              0,\r\n              0,\r\n              0,\r\n            );\r\n            transform2D(\r\n              inCoordinates,\r\n              0,\r\n              inCoordinates.length,\r\n              stride,\r\n              tmpTransform,\r\n              outCoordinates,\r\n            );\r\n            return getTransform(sourceProj, destination)(\r\n              inCoordinates,\r\n              outCoordinates,\r\n              stride,\r\n            );\r\n          }\r\n        : getTransform(sourceProj, destination);\r\n    this.applyTransform(transformFn);\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Geometry;\r\n","/**\r\n * @module CME2D/geom/SimpleGeometry\r\n */\r\nimport Geometry from './Geometry.js';\r\nimport {abstract} from '../util.js';\r\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\r\nimport {rotate, scale, transform2D, translate} from './flat/transform.js';\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; only used for creating subclasses; do not instantiate\r\n * in apps, as cannot be rendered.\r\n *\r\n * @abstract\r\n * @api\r\n */\r\nclass SimpleGeometry extends Geometry {\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./Geometry.js\").GeometryLayout}\r\n     */\r\n    this.layout = 'XY';\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.stride = 2;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {Array<number>}\r\n     */\r\n    this.flatCoordinates;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @protected\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   * @override\r\n   */\r\n  computeExtent(extent) {\r\n    return createOrUpdateFromFlatCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      extent,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @return {Array<*> | null} Coordinates.\r\n   */\r\n  getCoordinates() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the first coordinate of the geometry.\r\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\r\n   * @api\r\n   */\r\n  getFirstCoordinate() {\r\n    return this.flatCoordinates.slice(0, this.stride);\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Flat coordinates.\r\n   */\r\n  getFlatCoordinates() {\r\n    return this.flatCoordinates;\r\n  }\r\n\r\n  /**\r\n   * Return the last coordinate of the geometry.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\r\n   * @api\r\n   */\r\n  getLastCoordinate() {\r\n    return this.flatCoordinates.slice(\r\n      this.flatCoordinates.length - this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\r\n   * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\r\n   * @api\r\n   */\r\n  getLayout() {\r\n    return this.layout;\r\n  }\r\n\r\n  /**\r\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {SimpleGeometry} Simplified geometry.\r\n   * @override\r\n   */\r\n  getSimplifiedGeometry(squaredTolerance) {\r\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\r\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\r\n      this.simplifiedGeometryRevision = this.getRevision();\r\n    }\r\n    // If squaredTolerance is negative or if we know that simplification will not\r\n    // have any effect then just return this.\r\n    if (\r\n      squaredTolerance < 0 ||\r\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\r\n        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)\r\n    ) {\r\n      return this;\r\n    }\r\n\r\n    const simplifiedGeometry =\r\n      this.getSimplifiedGeometryInternal(squaredTolerance);\r\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\r\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\r\n      return simplifiedGeometry;\r\n    }\r\n    // Simplification did not actually remove any coordinates.  We now know\r\n    // that any calls to getSimplifiedGeometry with a squaredTolerance less\r\n    // than or equal to the current squaredTolerance will also not have any\r\n    // effect.  This allows us to short circuit simplification (saving CPU\r\n    // cycles) and prevents the cache of simplified geometries from filling\r\n    // up with useless identical copies of this geometry (saving memory).\r\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {SimpleGeometry} Simplified geometry.\r\n   * @protected\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Stride.\r\n   */\r\n  getStride() {\r\n    return this.stride;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\r\n   * @param {Array<number>} flatCoordinates Flat coordinates.\r\n   */\r\n  setFlatCoordinates(layout, flatCoordinates) {\r\n    this.stride = getStrideForLayout(layout);\r\n    this.layout = layout;\r\n    this.flatCoordinates = flatCoordinates;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {!Array<*>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\r\n   * @param {Array<*>} coordinates Coordinates.\r\n   * @param {number} nesting Nesting.\r\n   * @protected\r\n   */\r\n  setLayout(layout, coordinates, nesting) {\r\n    let stride;\r\n    if (layout) {\r\n      stride = getStrideForLayout(layout);\r\n    } else {\r\n      for (let i = 0; i < nesting; ++i) {\r\n        if (coordinates.length === 0) {\r\n          this.layout = 'XY';\r\n          this.stride = 2;\r\n          return;\r\n        }\r\n        coordinates = /** @type {Array<unknown>} */ (coordinates[0]);\r\n      }\r\n      stride = coordinates.length;\r\n      layout = getLayoutForStride(stride);\r\n    }\r\n    this.layout = layout;\r\n    this.stride = stride;\r\n  }\r\n\r\n  /**\r\n   * Apply a transform function to the coordinates of the geometry.\r\n   * The geometry is modified in place.\r\n   * If you do not want the geometry modified in place, first `clone()` it and\r\n   * then use this function on the clone.\r\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\r\n   * Called with a flat array of geometry coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  applyTransform(transformFn) {\r\n    if (this.flatCoordinates) {\r\n      transformFn(\r\n        this.flatCoordinates,\r\n        this.flatCoordinates,\r\n        this.layout.startsWith('XYZ') ? 3 : 2,\r\n        this.stride,\r\n      );\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rotate the geometry around a given coordinate. This modifies the geometry\r\n   * coordinates in place.\r\n   * @param {number} angle Rotation angle in counter-clockwise radians.\r\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\r\n   * @api\r\n   * @override\r\n   */\r\n  rotate(angle, anchor) {\r\n    const flatCoordinates = this.getFlatCoordinates();\r\n    if (flatCoordinates) {\r\n      const stride = this.getStride();\r\n      rotate(\r\n        flatCoordinates,\r\n        0,\r\n        flatCoordinates.length,\r\n        stride,\r\n        angle,\r\n        anchor,\r\n        flatCoordinates,\r\n      );\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scale the geometry (with an optional origin).  This modifies the geometry\r\n   * coordinates in place.\r\n   * @param {number} sx The scaling factor in the x-direction.\r\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\r\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\r\n   *     of the geometry extent).\r\n   * @api\r\n   * @override\r\n   */\r\n  scale(sx, sy, anchor) {\r\n    if (sy === undefined) {\r\n      sy = sx;\r\n    }\r\n    if (!anchor) {\r\n      anchor = getCenter(this.getExtent());\r\n    }\r\n    const flatCoordinates = this.getFlatCoordinates();\r\n    if (flatCoordinates) {\r\n      const stride = this.getStride();\r\n      scale(\r\n        flatCoordinates,\r\n        0,\r\n        flatCoordinates.length,\r\n        stride,\r\n        sx,\r\n        sy,\r\n        anchor,\r\n        flatCoordinates,\r\n      );\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\r\n   * instead you want a new geometry, first `clone()` this geometry.\r\n   * @param {number} deltaX Delta X.\r\n   * @param {number} deltaY Delta Y.\r\n   * @api\r\n   * @override\r\n   */\r\n  translate(deltaX, deltaY) {\r\n    const flatCoordinates = this.getFlatCoordinates();\r\n    if (flatCoordinates) {\r\n      const stride = this.getStride();\r\n      translate(\r\n        flatCoordinates,\r\n        0,\r\n        flatCoordinates.length,\r\n        stride,\r\n        deltaX,\r\n        deltaY,\r\n        flatCoordinates,\r\n      );\r\n      this.changed();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} stride Stride.\r\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\r\n */\r\nexport function getLayoutForStride(stride) {\r\n  let layout;\r\n  if (stride == 2) {\r\n    layout = 'XY';\r\n  } else if (stride == 3) {\r\n    layout = 'XYZ';\r\n  } else if (stride == 4) {\r\n    layout = 'XYZM';\r\n  }\r\n  return /** @type {import(\"./Geometry.js\").GeometryLayout} */ (layout);\r\n}\r\n\r\n/**\r\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\r\n * @return {number} Stride.\r\n */\r\nexport function getStrideForLayout(layout) {\r\n  let stride;\r\n  if (layout == 'XY') {\r\n    stride = 2;\r\n  } else if (layout == 'XYZ' || layout == 'XYM') {\r\n    stride = 3;\r\n  } else if (layout == 'XYZM') {\r\n    stride = 4;\r\n  }\r\n  return /** @type {number} */ (stride);\r\n}\r\n\r\n/**\r\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\r\n * @param {import(\"../transform.js\").Transform} transform Transform.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed flat coordinates.\r\n */\r\nexport function transformGeom2D(simpleGeometry, transform, dest) {\r\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\r\n  if (!flatCoordinates) {\r\n    return null;\r\n  }\r\n  const stride = simpleGeometry.getStride();\r\n  return transform2D(\r\n    flatCoordinates,\r\n    0,\r\n    flatCoordinates.length,\r\n    stride,\r\n    transform,\r\n    dest,\r\n  );\r\n}\r\n\r\nexport default SimpleGeometry;\r\n","/**\r\n * @module CME2D/geom/flat/closest\r\n */\r\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\r\n\r\n/**\r\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\r\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\r\n * dimensions are linearly interpolated.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset1 Offset 1.\r\n * @param {number} offset2 Offset 2.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n */\r\nfunction assignClosest(\r\n  flatCoordinates,\r\n  offset1,\r\n  offset2,\r\n  stride,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n) {\r\n  const x1 = flatCoordinates[offset1];\r\n  const y1 = flatCoordinates[offset1 + 1];\r\n  const dx = flatCoordinates[offset2] - x1;\r\n  const dy = flatCoordinates[offset2 + 1] - y1;\r\n  let offset;\r\n  if (dx === 0 && dy === 0) {\r\n    offset = offset1;\r\n  } else {\r\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\r\n    if (t > 1) {\r\n      offset = offset2;\r\n    } else if (t > 0) {\r\n      for (let i = 0; i < stride; ++i) {\r\n        closestPoint[i] = lerp(\r\n          flatCoordinates[offset1 + i],\r\n          flatCoordinates[offset2 + i],\r\n          t,\r\n        );\r\n      }\r\n      closestPoint.length = stride;\r\n      return;\r\n    } else {\r\n      offset = offset1;\r\n    }\r\n  }\r\n  for (let i = 0; i < stride; ++i) {\r\n    closestPoint[i] = flatCoordinates[offset + i];\r\n  }\r\n  closestPoint.length = stride;\r\n}\r\n\r\n/**\r\n * Return the squared of the largest distance between any pair of consecutive\r\n * coordinates.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\r\n    if (squaredDelta > max) {\r\n      max = squaredDelta;\r\n    }\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function arrayMaxSquaredDelta(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  max,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\r\n    offset = end;\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function multiArrayMaxSquaredDelta(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  max,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint,\r\n) {\r\n  if (offset == end) {\r\n    return minSquaredDistance;\r\n  }\r\n  let i, squaredDistance;\r\n  if (maxDelta === 0) {\r\n    // All points are identical, so just test the first point.\r\n    squaredDistance = squaredDx(\r\n      x,\r\n      y,\r\n      flatCoordinates[offset],\r\n      flatCoordinates[offset + 1],\r\n    );\r\n    if (squaredDistance < minSquaredDistance) {\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = flatCoordinates[offset + i];\r\n      }\r\n      closestPoint.length = stride;\r\n      return squaredDistance;\r\n    }\r\n    return minSquaredDistance;\r\n  }\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  let index = offset + stride;\r\n  while (index < end) {\r\n    assignClosest(\r\n      flatCoordinates,\r\n      index - stride,\r\n      index,\r\n      stride,\r\n      x,\r\n      y,\r\n      tmpPoint,\r\n    );\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n      index += stride;\r\n    } else {\r\n      // Skip ahead multiple points, because we know that all the skipped\r\n      // points cannot be any closer than the closest point we have found so\r\n      // far.  We know this because we know how close the current point is, how\r\n      // close the closest point we have found so far is, and the maximum\r\n      // distance between consecutive points.  For example, if we're currently\r\n      // at distance 10, the best we've found so far is 3, and that the maximum\r\n      // distance between consecutive points is 2, then we'll need to skip at\r\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\r\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\r\n      // always advance at least one point, to avoid an infinite loop.\r\n      index +=\r\n        stride *\r\n        Math.max(\r\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\r\n            maxDelta) |\r\n            0,\r\n          1,\r\n        );\r\n    }\r\n  }\r\n  if (isRing) {\r\n    // Check the closing segment.\r\n    assignClosest(\r\n      flatCoordinates,\r\n      end - stride,\r\n      offset,\r\n      stride,\r\n      x,\r\n      y,\r\n      tmpPoint,\r\n    );\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n    }\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestArrayPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint,\r\n) {\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    minSquaredDistance = assignClosestPoint(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      maxDelta,\r\n      isRing,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n      tmpPoint,\r\n    );\r\n    offset = end;\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestMultiArrayPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint,\r\n) {\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    minSquaredDistance = assignClosestArrayPoint(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      maxDelta,\r\n      isRing,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n      tmpPoint,\r\n    );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/deflate\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {number} stride Stride.\r\n * @return {number} offset Offset.\r\n */\r\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\r\n  for (let i = 0, ii = coordinate.length; i < ii; ++i) {\r\n    flatCoordinates[offset++] = coordinate[i];\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @param {number} stride Stride.\r\n * @return {number} offset Offset.\r\n */\r\nexport function deflateCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  coordinates,\r\n  stride,\r\n) {\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    const coordinate = coordinates[i];\r\n    for (let j = 0; j < stride; ++j) {\r\n      flatCoordinates[offset++] = coordinate[j];\r\n    }\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\r\n * @param {number} stride Stride.\r\n * @param {Array<number>} [ends] Ends.\r\n * @return {Array<number>} Ends.\r\n */\r\nexport function deflateCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  coordinatess,\r\n  stride,\r\n  ends,\r\n) {\r\n  ends = ends ? ends : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {\r\n    const end = deflateCoordinates(\r\n      flatCoordinates,\r\n      offset,\r\n      coordinatess[j],\r\n      stride,\r\n    );\r\n    ends[i++] = end;\r\n    offset = end;\r\n  }\r\n  ends.length = i;\r\n  return ends;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<number>>} [endss] Endss.\r\n * @return {Array<Array<number>>} Endss.\r\n */\r\nexport function deflateMultiCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  coordinatesss,\r\n  stride,\r\n  endss,\r\n) {\r\n  endss = endss ? endss : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {\r\n    const ends = deflateCoordinatesArray(\r\n      flatCoordinates,\r\n      offset,\r\n      coordinatesss[j],\r\n      stride,\r\n      endss[i],\r\n    );\r\n    if (ends.length === 0) {\r\n      ends[0] = offset;\r\n    }\r\n    endss[i++] = ends;\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  endss.length = i;\r\n  return endss;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/simplify\r\n */\r\n// Based on simplify-js https://github.com/mourner/simplify-js\r\n// Copyright (c) 2012, Vladimir Agafonkin\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//\r\n//    1. Redistributions of source code must retain the above copyright notice,\r\n//       this list of conditions and the following disclaimer.\r\n//\r\n//    2. Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n// POSSIBILITY OF SUCH DAMAGE.\r\n\r\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {boolean} highQuality Highest quality.\r\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\r\n *     coordinates.\r\n * @return {Array<number>} Simplified line string.\r\n */\r\nexport function simplifyLineString(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  highQuality,\r\n  simplifiedFlatCoordinates,\r\n) {\r\n  simplifiedFlatCoordinates =\r\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\r\n  if (!highQuality) {\r\n    end = radialDistance(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n    );\r\n    flatCoordinates = simplifiedFlatCoordinates;\r\n    offset = 0;\r\n    stride = 2;\r\n  }\r\n  simplifiedFlatCoordinates.length = douglasPeucker(\r\n    flatCoordinates,\r\n    offset,\r\n    end,\r\n    stride,\r\n    squaredTolerance,\r\n    simplifiedFlatCoordinates,\r\n    0,\r\n  );\r\n  return simplifiedFlatCoordinates;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeucker(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n) {\r\n  const n = (end - offset) / stride;\r\n  if (n < 3) {\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  /** @type {Array<number>} */\r\n  const markers = new Array(n);\r\n  markers[0] = 1;\r\n  markers[n - 1] = 1;\r\n  /** @type {Array<number>} */\r\n  const stack = [offset, end - stride];\r\n  let index = 0;\r\n  while (stack.length > 0) {\r\n    const last = stack.pop();\r\n    const first = stack.pop();\r\n    let maxSquaredDistance = 0;\r\n    const x1 = flatCoordinates[first];\r\n    const y1 = flatCoordinates[first + 1];\r\n    const x2 = flatCoordinates[last];\r\n    const y2 = flatCoordinates[last + 1];\r\n    for (let i = first + stride; i < last; i += stride) {\r\n      const x = flatCoordinates[i];\r\n      const y = flatCoordinates[i + 1];\r\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\r\n      if (squaredDistance > maxSquaredDistance) {\r\n        index = i;\r\n        maxSquaredDistance = squaredDistance;\r\n      }\r\n    }\r\n    if (maxSquaredDistance > squaredTolerance) {\r\n      markers[(index - offset) / stride] = 1;\r\n      if (first + stride < index) {\r\n        stack.push(first, index);\r\n      }\r\n      if (index + stride < last) {\r\n        stack.push(index, last);\r\n      }\r\n    }\r\n  }\r\n  for (let i = 0; i < n; ++i) {\r\n    if (markers[i]) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + i * stride];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + i * stride + 1];\r\n    }\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEnds,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = douglasPeucker(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n    );\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEndss,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    /** @type {Array<number>} */\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = douglasPeuckerArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n      simplifiedEnds,\r\n    );\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function radialDistance(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n) {\r\n  if (end <= offset + stride) {\r\n    // zero or one point, no simplification possible, so copy and return\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  // copy first point\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  let x2 = x1;\r\n  let y2 = y1;\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    x2 = flatCoordinates[offset];\r\n    y2 = flatCoordinates[offset + 1];\r\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\r\n      // copy point at offset\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n  }\r\n  if (x2 != x1 || y2 != y1) {\r\n    // copy last point\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {number} value Value.\r\n * @param {number} tolerance Tolerance.\r\n * @return {number} Rounded value.\r\n */\r\nexport function snap(value, tolerance) {\r\n  return tolerance * Math.round(value / tolerance);\r\n}\r\n\r\n/**\r\n * Simplifies a line string using an algorithm designed by Tim Schaub.\r\n * Coordinates are snapped to the nearest value in a virtual grid and\r\n * consecutive duplicate coordinates are discarded.  This effectively preserves\r\n * topology as the simplification of any subsection of a line string is\r\n * independent of the rest of the line string.  This means that, for examples,\r\n * the common edge between two polygons will be simplified to the same line\r\n * string independently in both polygons.  This implementation uses a single\r\n * pass over the coordinates and eliminates intermediate collinear points.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantize(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n) {\r\n  // do nothing if the line is empty\r\n  if (offset == end) {\r\n    return simplifiedOffset;\r\n  }\r\n  // snap the first coordinate (P1)\r\n  let x1 = snap(flatCoordinates[offset], tolerance);\r\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\r\n  offset += stride;\r\n  // add the first coordinate to the output\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  // find the next coordinate that does not snap to the same value as the first\r\n  // coordinate (P2)\r\n  let x2, y2;\r\n  do {\r\n    x2 = snap(flatCoordinates[offset], tolerance);\r\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    if (offset == end) {\r\n      // all coordinates snap to the same value, the line collapses to a point\r\n      // push the last snapped value anyway to ensure that the output contains\r\n      // at least two points\r\n      // FIXME should we really return at least two points anyway?\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      return simplifiedOffset;\r\n    }\r\n  } while (x2 == x1 && y2 == y1);\r\n  while (offset < end) {\r\n    // snap the next coordinate (P3)\r\n    const x3 = snap(flatCoordinates[offset], tolerance);\r\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    // skip P3 if it is equal to P2\r\n    if (x3 == x2 && y3 == y2) {\r\n      continue;\r\n    }\r\n    // calculate the delta between P1 and P2\r\n    const dx1 = x2 - x1;\r\n    const dy1 = y2 - y1;\r\n    // calculate the delta between P3 and P1\r\n    const dx2 = x3 - x1;\r\n    const dy2 = y3 - y1;\r\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\r\n    // P1 in the same direction then P2 is on the straight line between P1 and\r\n    // P3\r\n    if (\r\n      dx1 * dy2 == dy1 * dx2 &&\r\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\r\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\r\n    ) {\r\n      // discard P2 and set P2 = P3\r\n      x2 = x3;\r\n      y2 = y3;\r\n      continue;\r\n    }\r\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\r\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\r\n    // and continue with P1 = P2 and P2 = P3\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n    x1 = x2;\r\n    y1 = y2;\r\n    x2 = x3;\r\n    y2 = y3;\r\n  }\r\n  // add the last point (P2)\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEnds,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = quantize(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n    );\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEndss,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    /** @type {Array<number>} */\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = quantizeArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n      simplifiedEnds,\r\n    );\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/inflate\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\r\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\r\n */\r\nexport function inflateCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  coordinates,\r\n) {\r\n  coordinates = coordinates !== undefined ? coordinates : [];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\r\n  }\r\n  coordinates.length = i;\r\n  return coordinates;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\r\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\r\n */\r\nexport function inflateCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  coordinatess,\r\n) {\r\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\r\n    const end = ends[j];\r\n    coordinatess[i++] = inflateCoordinates(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      coordinatess[i],\r\n    );\r\n    offset = end;\r\n  }\r\n  coordinatess.length = i;\r\n  return coordinatess;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\r\n *     Coordinatesss.\r\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\r\n */\r\nexport function inflateMultiCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  coordinatesss,\r\n) {\r\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\r\n    const ends = endss[j];\r\n    coordinatesss[i++] =\r\n      ends.length === 1 && ends[0] === offset\r\n        ? []\r\n        : inflateCoordinatesArray(\r\n            flatCoordinates,\r\n            offset,\r\n            ends,\r\n            stride,\r\n            coordinatesss[i],\r\n          );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  coordinatesss.length = i;\r\n  return coordinatesss;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/area\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {number} Area.\r\n */\r\nexport function linearRing(flatCoordinates, offset, end, stride) {\r\n  let twiceArea = 0;\r\n  const x0 = flatCoordinates[end - stride];\r\n  const y0 = flatCoordinates[end - stride + 1];\r\n  let dx1 = 0;\r\n  let dy1 = 0;\r\n  for (; offset < end; offset += stride) {\r\n    const dx2 = flatCoordinates[offset] - x0;\r\n    const dy2 = flatCoordinates[offset + 1] - y0;\r\n    twiceArea += dy1 * dx2 - dx1 * dy2;\r\n    dx1 = dx2;\r\n    dy1 = dy2;\r\n  }\r\n  return twiceArea / 2;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @return {number} Area.\r\n */\r\nexport function linearRings(flatCoordinates, offset, ends, stride) {\r\n  let area = 0;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    area += linearRing(flatCoordinates, offset, end, stride);\r\n    offset = end;\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @return {number} Area.\r\n */\r\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\r\n  let area = 0;\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    area += linearRings(flatCoordinates, offset, ends, stride);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return area;\r\n}\r\n","/**\r\n * @module CME2D/geom/LinearRing\r\n */\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY} from '../extent.js';\r\nimport {deflateCoordinates} from './flat/deflate.js';\r\nimport {douglasPeucker} from './flat/simplify.js';\r\nimport {inflateCoordinates} from './flat/inflate.js';\r\nimport {linearRing as linearRingArea} from './flat/area.js';\r\n\r\n/**\r\n * @classdesc\r\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\r\n * on its own.\r\n *\r\n * @api\r\n */\r\nclass LinearRing extends SimpleGeometry {\r\n  /**\r\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\r\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  constructor(coordinates, layout) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates),\r\n      );\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\r\n          coordinates\r\n        ),\r\n        layout,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!LinearRing} Clone.\r\n   * @api\r\n   * @override\r\n   */\r\n  clone() {\r\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   * @override\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        maxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.flatCoordinates.length,\r\n          this.stride,\r\n          0,\r\n        ),\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestPoint(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      true,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the area of the linear ring on projected plane.\r\n   * @return {number} Area (on projected plane).\r\n   * @api\r\n   */\r\n  getArea() {\r\n    return linearRingArea(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the coordinates of the linear ring.\r\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  getCoordinates() {\r\n    return inflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {LinearRing} Simplified LinearRing.\r\n   * @protected\r\n   * @override\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    /** @type {Array<number>} */\r\n    const simplifiedFlatCoordinates = [];\r\n    simplifiedFlatCoordinates.length = douglasPeucker(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n    );\r\n    return new LinearRing(simplifiedFlatCoordinates, 'XY');\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   * @override\r\n   */\r\n  getType() {\r\n    return 'LinearRing';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   * @override\r\n   */\r\n  intersectsExtent(extent) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the linear ring.\r\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   * @override\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 1);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    this.flatCoordinates.length = deflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n    );\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default LinearRing;\r\n","/**\r\n * @module CME2D/geom/Point\r\n */\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {containsXY, createOrUpdateFromCoordinate} from '../extent.js';\r\nimport {deflateCoordinate} from './flat/deflate.js';\r\nimport {squaredDistance as squaredDx} from '../math.js';\r\n\r\n/**\r\n * @classdesc\r\n * Point geometry.\r\n *\r\n * @api\r\n */\r\nclass Point extends SimpleGeometry {\r\n  /**\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  constructor(coordinates, layout) {\r\n    super();\r\n    this.setCoordinates(coordinates, layout);\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!Point} Clone.\r\n   * @api\r\n   * @override\r\n   */\r\n  clone() {\r\n    const point = new Point(this.flatCoordinates.slice(), this.layout);\r\n    point.applyProperties(this);\r\n    return point;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   * @override\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const squaredDistance = squaredDx(\r\n      x,\r\n      y,\r\n      flatCoordinates[0],\r\n      flatCoordinates[1],\r\n    );\r\n    if (squaredDistance < minSquaredDistance) {\r\n      const stride = this.stride;\r\n      for (let i = 0; i < stride; ++i) {\r\n        closestPoint[i] = flatCoordinates[i];\r\n      }\r\n      closestPoint.length = stride;\r\n      return squaredDistance;\r\n    }\r\n    return minSquaredDistance;\r\n  }\r\n\r\n  /**\r\n   * Return the coordinate of the point.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  getCoordinates() {\r\n    return this.flatCoordinates.slice();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @protected\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   * @override\r\n   */\r\n  computeExtent(extent) {\r\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   * @override\r\n   */\r\n  getType() {\r\n    return 'Point';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   * @override\r\n   */\r\n  intersectsExtent(extent) {\r\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\r\n  }\r\n\r\n  /**\r\n   * @param {!Array<*>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   * @override\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 0);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    this.flatCoordinates.length = deflateCoordinate(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n    );\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default Point;\r\n","/**\r\n * @module CME2D/geom/flat/interiorpoint\r\n */\r\nimport {ascending} from '../../array.js';\r\nimport {linearRingsContainsXY} from './contains.js';\r\n\r\n/**\r\n * Calculates a point that is likely to lie in the interior of the linear rings.\r\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {Array<number>} flatCenters Flat centers.\r\n * @param {number} flatCentersOffset Flat center offset.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\r\n * length of the horizontal intersection that the point belongs to.\r\n */\r\nexport function getInteriorPointOfArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  flatCenters,\r\n  flatCentersOffset,\r\n  dest,\r\n) {\r\n  let i, ii, x, x1, x2, y1, y2;\r\n  const y = flatCenters[flatCentersOffset + 1];\r\n  /** @type {Array<number>} */\r\n  const intersections = [];\r\n  // Calculate intersections with the horizontal line\r\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\r\n    const end = ends[r];\r\n    x1 = flatCoordinates[end - stride];\r\n    y1 = flatCoordinates[end - stride + 1];\r\n    for (i = offset; i < end; i += stride) {\r\n      x2 = flatCoordinates[i];\r\n      y2 = flatCoordinates[i + 1];\r\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\r\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\r\n        intersections.push(x);\r\n      }\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n  }\r\n  // Find the longest segment of the horizontal line that has its center point\r\n  // inside the linear ring.\r\n  let pointX = NaN;\r\n  let maxSegmentLength = -Infinity;\r\n  intersections.sort(ascending);\r\n  x1 = intersections[0];\r\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\r\n    x2 = intersections[i];\r\n    const segmentLength = Math.abs(x2 - x1);\r\n    if (segmentLength > maxSegmentLength) {\r\n      x = (x1 + x2) / 2;\r\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\r\n        pointX = x;\r\n        maxSegmentLength = segmentLength;\r\n      }\r\n    }\r\n    x1 = x2;\r\n  }\r\n  if (isNaN(pointX)) {\r\n    // There is no horizontal line that has its center point inside the linear\r\n    // ring.  Use the center of the the linear ring's extent.\r\n    pointX = flatCenters[flatCentersOffset];\r\n  }\r\n  if (dest) {\r\n    dest.push(pointX, y, maxSegmentLength);\r\n    return dest;\r\n  }\r\n  return [pointX, y, maxSegmentLength];\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {Array<number>} flatCenters Flat centers.\r\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\r\n * length of the horizontal intersection that the point belongs to.\r\n */\r\nexport function getInteriorPointsOfMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  flatCenters,\r\n) {\r\n  /** @type {Array<number>} */\r\n  let interiorPoints = [];\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    interiorPoints = getInteriorPointOfArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      flatCenters,\r\n      2 * i,\r\n      interiorPoints,\r\n    );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return interiorPoints;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/reverse\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n */\r\nexport function coordinates(flatCoordinates, offset, end, stride) {\r\n  while (offset < end - stride) {\r\n    for (let i = 0; i < stride; ++i) {\r\n      const tmp = flatCoordinates[offset + i];\r\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\r\n      flatCoordinates[end - stride + i] = tmp;\r\n    }\r\n    offset += stride;\r\n    end -= stride;\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/orient\r\n */\r\nimport {coordinates as reverseCoordinates} from './reverse.js';\r\n\r\n/**\r\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\r\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\r\n * the ring's orientation is clockwise when this function returns false.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {boolean|undefined} Is clockwise.\r\n */\r\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\r\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\r\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\r\n  let edge = 0;\r\n  let x1 = flatCoordinates[end - stride];\r\n  let y1 = flatCoordinates[end - stride + 1];\r\n  for (; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    edge += (x2 - x1) * (y2 + y1);\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return edge === 0 ? undefined : edge > 0;\r\n}\r\n\r\n/**\r\n * Determines if linear rings are oriented.  By default, left-hand orientation\r\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\r\n * To test for right-hand orientation, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Array of end indexes.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Test for right-hand orientation\r\n *     (counter-clockwise exterior ring and clockwise interior rings).\r\n * @return {boolean} Rings are correctly oriented.\r\n */\r\nexport function linearRingsAreOriented(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  right,\r\n) {\r\n  right = right !== undefined ? right : false;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    const isClockwise = linearRingIsClockwise(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n    );\r\n    if (i === 0) {\r\n      if ((right && isClockwise) || (!right && !isClockwise)) {\r\n        return false;\r\n      }\r\n    } else {\r\n      if ((right && !isClockwise) || (!right && isClockwise)) {\r\n        return false;\r\n      }\r\n    }\r\n    offset = end;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Determines if linear rings are oriented.  By default, left-hand orientation\r\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\r\n * To test for right-hand orientation, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Array of array of end indexes.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Test for right-hand orientation\r\n *     (counter-clockwise exterior ring and clockwise interior rings).\r\n * @return {boolean} Rings are correctly oriented.\r\n */\r\nexport function linearRingssAreOriented(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  right,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\r\n      return false;\r\n    }\r\n    if (ends.length) {\r\n      offset = ends[ends.length - 1];\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Orient coordinates in a flat array of linear rings.  By default, rings\r\n * are oriented following the left-hand rule (clockwise for exterior and\r\n * counter-clockwise for interior rings).  To orient according to the\r\n * right-hand rule, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Follow the right-hand rule for orientation.\r\n * @return {number} End.\r\n */\r\nexport function orientLinearRings(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  right,\r\n) {\r\n  right = right !== undefined ? right : false;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    const isClockwise = linearRingIsClockwise(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n    );\r\n    const reverse =\r\n      i === 0\r\n        ? (right && isClockwise) || (!right && !isClockwise)\r\n        : (right && !isClockwise) || (!right && isClockwise);\r\n    if (reverse) {\r\n      reverseCoordinates(flatCoordinates, offset, end, stride);\r\n    }\r\n    offset = end;\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * Orient coordinates in a flat array of linear rings.  By default, rings\r\n * are oriented following the left-hand rule (clockwise for exterior and\r\n * counter-clockwise for interior rings).  To orient according to the\r\n * right-hand rule, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Array of array of end indexes.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Follow the right-hand rule for orientation.\r\n * @return {number} End.\r\n */\r\nexport function orientLinearRingsArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  right,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    offset = orientLinearRings(\r\n      flatCoordinates,\r\n      offset,\r\n      endss[i],\r\n      stride,\r\n      right,\r\n    );\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * Return a two-dimensional endss\r\n * @param {Array<number>} flatCoordinates Flat coordinates\r\n * @param {Array<number>} ends Linear ring end indexes\r\n * @return {Array<Array<number>>} Two dimensional endss array that can\r\n * be used to construct a MultiPolygon\r\n */\r\nexport function inflateEnds(flatCoordinates, ends) {\r\n  const endss = [];\r\n  let offset = 0;\r\n  let prevEndIndex = 0;\r\n  let startOrientation;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    // classifies an array of rings into polygons with outer rings and holes\r\n    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);\r\n    if (startOrientation === undefined) {\r\n      startOrientation = orientation;\r\n    }\r\n    if (orientation === startOrientation) {\r\n      endss.push(ends.slice(prevEndIndex, i + 1));\r\n    } else {\r\n      if (endss.length === 0) {\r\n        continue;\r\n      }\r\n      endss[endss.length - 1].push(ends[prevEndIndex]);\r\n    }\r\n    prevEndIndex = i + 1;\r\n    offset = end;\r\n  }\r\n  return endss;\r\n}\r\n","/**\r\n * @module CME2D/geom/Polygon\r\n */\r\nimport LinearRing from './LinearRing.js';\r\nimport Point from './Point.js';\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY, getCenter, isEmpty} from '../extent.js';\r\nimport {deflateCoordinatesArray} from './flat/deflate.js';\r\nimport {extend} from '../array.js';\r\nimport {getInteriorPointOfArray} from './flat/interiorpoint.js';\r\nimport {inflateCoordinatesArray} from './flat/inflate.js';\r\nimport {intersectsLinearRingArray} from './flat/intersectsextent.js';\r\nimport {linearRingsAreOriented, orientLinearRings} from './flat/orient.js';\r\nimport {linearRings as linearRingsArea} from './flat/area.js';\r\nimport {linearRingsContainsXY} from './flat/contains.js';\r\nimport {modulo} from '../math.js';\r\nimport {quantizeArray} from './flat/simplify.js';\r\nimport {offset as sphereOffset} from '../sphere.js';\r\n\r\n/**\r\n * @classdesc\r\n * Polygon geometry.\r\n *\r\n * @api\r\n */\r\nclass Polygon extends SimpleGeometry {\r\n  /**\r\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\r\n   *     Array of linear rings that define the polygon. The first linear ring of the\r\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\r\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\r\n   *     an array of vertices' coordinates where the first coordinate and the last are\r\n   *     equivalent. (For internal use, flat coordinates in combination with\r\n   *     `layout` and `ends` are also accepted.)\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).\r\n   */\r\n  constructor(coordinates, layout, ends) {\r\n    super();\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.ends_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.flatInteriorPointRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate|null}\r\n     */\r\n    this.flatInteriorPoint_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.orientedRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>|null}\r\n     */\r\n    this.orientedFlatCoordinates_ = null;\r\n\r\n    if (layout !== undefined && ends) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates),\r\n      );\r\n      this.ends_ = ends;\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\r\n          coordinates\r\n        ),\r\n        layout,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the passed linear ring to this polygon.\r\n   * @param {LinearRing} linearRing Linear ring.\r\n   * @api\r\n   */\r\n  appendLinearRing(linearRing) {\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\r\n    } else {\r\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\r\n    }\r\n    this.ends_.push(this.flatCoordinates.length);\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!Polygon} Clone.\r\n   * @api\r\n   * @override\r\n   */\r\n  clone() {\r\n    const polygon = new Polygon(\r\n      this.flatCoordinates.slice(),\r\n      this.layout,\r\n      this.ends_.slice(),\r\n    );\r\n    polygon.applyProperties(this);\r\n    return polygon;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   * @override\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        arrayMaxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.ends_,\r\n          this.stride,\r\n          0,\r\n        ),\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestArrayPoint(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      true,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   * @override\r\n   */\r\n  containsXY(x, y) {\r\n    return linearRingsContainsXY(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the area of the polygon on projected plane.\r\n   * @return {number} Area (on projected plane).\r\n   * @api\r\n   */\r\n  getArea() {\r\n    return linearRingsArea(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the coordinate array for this geometry.  This array has the structure\r\n   * of a GeoJSON coordinate array for polygons.\r\n   *\r\n   * @param {boolean} [right] Orient coordinates according to the right-hand\r\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\r\n   *     If `false`, coordinates will be oriented according to the left-hand rule\r\n   *     (clockwise for exterior and counter-clockwise for interior rings).\r\n   *     By default, coordinate orientation will depend on how the geometry was\r\n   *     constructed.\r\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  getCoordinates(right) {\r\n    let flatCoordinates;\r\n    if (right !== undefined) {\r\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\r\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);\r\n    } else {\r\n      flatCoordinates = this.flatCoordinates;\r\n    }\r\n\r\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Ends.\r\n   */\r\n  getEnds() {\r\n    return this.ends_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Interior point.\r\n   */\r\n  getFlatInteriorPoint() {\r\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\r\n      const flatCenter = getCenter(this.getExtent());\r\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\r\n        this.getOrientedFlatCoordinates(),\r\n        0,\r\n        this.ends_,\r\n        this.stride,\r\n        flatCenter,\r\n        0,\r\n      );\r\n      this.flatInteriorPointRevision_ = this.getRevision();\r\n    }\r\n    return /** @type {import(\"../coordinate.js\").Coordinate} */ (\r\n      this.flatInteriorPoint_\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return an interior point of the polygon.\r\n   * @return {Point} Interior point as XYM coordinate, where M is the\r\n   * length of the horizontal intersection that the point belongs to.\r\n   * @api\r\n   */\r\n  getInteriorPoint() {\r\n    return new Point(this.getFlatInteriorPoint(), 'XYM');\r\n  }\r\n\r\n  /**\r\n   * Return the number of rings of the polygon,  this includes the exterior\r\n   * ring and any interior rings.\r\n   *\r\n   * @return {number} Number of rings.\r\n   * @api\r\n   */\r\n  getLinearRingCount() {\r\n    return this.ends_.length;\r\n  }\r\n\r\n  /**\r\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\r\n   * given index is out of range.\r\n   * The exterior linear ring is available at index `0` and the interior rings\r\n   * at index `1` and beyond.\r\n   *\r\n   * @param {number} index Index.\r\n   * @return {LinearRing|null} Linear ring.\r\n   * @api\r\n   */\r\n  getLinearRing(index) {\r\n    if (index < 0 || this.ends_.length <= index) {\r\n      return null;\r\n    }\r\n    return new LinearRing(\r\n      this.flatCoordinates.slice(\r\n        index === 0 ? 0 : this.ends_[index - 1],\r\n        this.ends_[index],\r\n      ),\r\n      this.layout,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the linear rings of the polygon.\r\n   * @return {Array<LinearRing>} Linear rings.\r\n   * @api\r\n   */\r\n  getLinearRings() {\r\n    const layout = this.layout;\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const ends = this.ends_;\r\n    const linearRings = [];\r\n    let offset = 0;\r\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n      const end = ends[i];\r\n      const linearRing = new LinearRing(\r\n        flatCoordinates.slice(offset, end),\r\n        layout,\r\n      );\r\n      linearRings.push(linearRing);\r\n      offset = end;\r\n    }\r\n    return linearRings;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Oriented flat coordinates.\r\n   */\r\n  getOrientedFlatCoordinates() {\r\n    if (this.orientedRevision_ != this.getRevision()) {\r\n      const flatCoordinates = this.flatCoordinates;\r\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\r\n        this.orientedFlatCoordinates_ = flatCoordinates;\r\n      } else {\r\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\r\n        this.orientedFlatCoordinates_.length = orientLinearRings(\r\n          this.orientedFlatCoordinates_,\r\n          0,\r\n          this.ends_,\r\n          this.stride,\r\n        );\r\n      }\r\n      this.orientedRevision_ = this.getRevision();\r\n    }\r\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {Polygon} Simplified Polygon.\r\n   * @protected\r\n   * @override\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    /** @type {Array<number>} */\r\n    const simplifiedFlatCoordinates = [];\r\n    /** @type {Array<number>} */\r\n    const simplifiedEnds = [];\r\n    simplifiedFlatCoordinates.length = quantizeArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      Math.sqrt(squaredTolerance),\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n      simplifiedEnds,\r\n    );\r\n    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   * @override\r\n   */\r\n  getType() {\r\n    return 'Polygon';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   * @override\r\n   */\r\n  intersectsExtent(extent) {\r\n    return intersectsLinearRingArray(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      extent,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the polygon.\r\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   * @override\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 2);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    const ends = deflateCoordinatesArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n      this.ends_,\r\n    );\r\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default Polygon;\r\n\r\n/**\r\n * Create an approximation of a circle on the surface of a sphere.\r\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\r\n * @param {number} radius The great-circle distance from the center to\r\n *     the polygon vertices in meters.\r\n * @param {number} [n] Optional number of vertices for the resulting\r\n *     polygon. Default is `32`.\r\n * @param {number} [sphereRadius] Optional radius for the sphere (defaults to\r\n *     the Earth's mean radius using the WGS84 ellipsoid).\r\n * @return {Polygon} The \"circular\" polygon.\r\n * @api\r\n */\r\nexport function circular(center, radius, n, sphereRadius) {\r\n  n = n ? n : 32;\r\n  /** @type {Array<number>} */\r\n  const flatCoordinates = [];\r\n  for (let i = 0; i < n; ++i) {\r\n    extend(\r\n      flatCoordinates,\r\n      sphereOffset(center, radius, (2 * Math.PI * i) / n, sphereRadius),\r\n    );\r\n  }\r\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\r\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\r\n}\r\n\r\n/**\r\n * Create a polygon from an extent. The layout used is `XY`.\r\n * @param {import(\"../extent.js\").Extent} extent The extent.\r\n * @return {Polygon} The polygon.\r\n * @api\r\n */\r\nexport function fromExtent(extent) {\r\n  if (isEmpty(extent)) {\r\n    throw new Error('Cannot create polygon from empty extent');\r\n  }\r\n  const minX = extent[0];\r\n  const minY = extent[1];\r\n  const maxX = extent[2];\r\n  const maxY = extent[3];\r\n  const flatCoordinates = [\r\n    minX,\r\n    minY,\r\n    minX,\r\n    maxY,\r\n    maxX,\r\n    maxY,\r\n    maxX,\r\n    minY,\r\n    minX,\r\n    minY,\r\n  ];\r\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\r\n}\r\n\r\n/**\r\n * Create a regular polygon from a circle.\r\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\r\n * @param {number} [sides] Number of sides of the polygon. Default is 32.\r\n * @param {number} [angle] Start angle for the first vertex of the polygon in\r\n *     counter-clockwise radians. 0 means East. Default is 0.\r\n * @return {Polygon} Polygon geometry.\r\n * @api\r\n */\r\nexport function fromCircle(circle, sides, angle) {\r\n  sides = sides ? sides : 32;\r\n  const stride = circle.getStride();\r\n  const layout = circle.getLayout();\r\n  const center = circle.getCenter();\r\n  const arrayLength = stride * (sides + 1);\r\n  const flatCoordinates = new Array(arrayLength);\r\n  for (let i = 0; i < arrayLength; i += stride) {\r\n    flatCoordinates[i] = 0;\r\n    flatCoordinates[i + 1] = 0;\r\n    for (let j = 2; j < stride; j++) {\r\n      flatCoordinates[i + j] = center[j];\r\n    }\r\n  }\r\n  const ends = [flatCoordinates.length];\r\n  const polygon = new Polygon(flatCoordinates, layout, ends);\r\n  makeRegular(polygon, center, circle.getRadius(), angle);\r\n  return polygon;\r\n}\r\n\r\n/**\r\n * Modify the coordinates of a polygon to make it a regular polygon.\r\n * @param {Polygon} polygon Polygon geometry.\r\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\r\n * @param {number} radius Radius of the regular polygon.\r\n * @param {number} [angle] Start angle for the first vertex of the polygon in\r\n *     counter-clockwise radians. 0 means East. Default is 0.\r\n */\r\nexport function makeRegular(polygon, center, radius, angle) {\r\n  const flatCoordinates = polygon.getFlatCoordinates();\r\n  const stride = polygon.getStride();\r\n  const sides = flatCoordinates.length / stride - 1;\r\n  const startAngle = angle ? angle : 0;\r\n  for (let i = 0; i <= sides; ++i) {\r\n    const offset = i * stride;\r\n    const angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\r\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\r\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\r\n  }\r\n  polygon.changed();\r\n}\r\n","/**\r\n * @module CME2D/View\r\n */\r\nimport BaseObject from './Object.js';\r\nimport ViewHint from './ViewHint.js';\r\nimport ViewProperty from './ViewProperty.js';\r\nimport {DEFAULT_TILE_SIZE} from './tilegrid/common.js';\r\nimport {\r\n  METERS_PER_UNIT,\r\n  createProjection,\r\n  disableCoordinateWarning,\r\n  fromUserCoordinate,\r\n  fromUserExtent,\r\n  getUserProjection,\r\n  toUserCoordinate,\r\n  toUserExtent,\r\n} from './proj.js';\r\nimport {VOID} from './functions.js';\r\nimport {\r\n  add as addCoordinate,\r\n  equals as coordinatesEqual,\r\n  equals,\r\n  rotate as rotateCoordinate,\r\n} from './coordinate.js';\r\nimport {assert} from './asserts.js';\r\nimport {none as centerNone, createExtent} from './centerconstraint.js';\r\nimport {clamp, modulo} from './math.js';\r\nimport {\r\n  createMinMaxResolution,\r\n  createSnapToPower,\r\n  createSnapToResolutions,\r\n} from './resolutionconstraint.js';\r\nimport {\r\n  createSnapToN,\r\n  createSnapToZero,\r\n  disable,\r\n  none as rotationNone,\r\n} from './rotationconstraint.js';\r\nimport {easeOut, inAndOut} from './easing.js';\r\nimport {\r\n  getCenter,\r\n  getForViewAndSize,\r\n  getHeight,\r\n  getWidth,\r\n  isEmpty,\r\n} from './extent.js';\r\nimport {linearFindNearest} from './array.js';\r\nimport {fromExtent as polygonFromExtent} from './geom/Polygon.js';\r\n\r\n/**\r\n * An animation configuration\r\n *\r\n * @typedef {Object} Animation\r\n * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter] Source center.\r\n * @property {import(\"./coordinate.js\").Coordinate} [targetCenter] Target center.\r\n * @property {number} [sourceResolution] Source resolution.\r\n * @property {number} [targetResolution] Target resolution.\r\n * @property {number} [sourceRotation] Source rotation.\r\n * @property {number} [targetRotation] Target rotation.\r\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Anchor.\r\n * @property {number} start Start.\r\n * @property {number} duration Duration.\r\n * @property {boolean} complete Complete.\r\n * @property {function(number):number} easing Easing.\r\n * @property {function(boolean):void} callback Callback.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Constraints\r\n * @property {import(\"./centerconstraint.js\").Type} center Center.\r\n * @property {import(\"./resolutionconstraint.js\").Type} resolution Resolution.\r\n * @property {import(\"./rotationconstraint.js\").Type} rotation Rotation.\r\n */\r\n\r\n/**\r\n * @typedef {Object} FitOptions\r\n * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to\r\n * fit the extent into. Defaults to the size of the map the view is associated with.\r\n * If no map or multiple maps are connected to the view, provide the desired box size\r\n * (e.g. `map.getSize()`).\r\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\r\n * cleared inside the view. Values in the array are top, right, bottom and left\r\n * padding.\r\n * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,\r\n * get the nearest extent instead of the closest that actually fits the view.\r\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\r\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\r\n * `minResolution` is given, this property is ignored.\r\n * @property {number} [duration] The duration of the animation in milliseconds.\r\n * By default, there is no animation to the target extent.\r\n * @property {function(number):number} [easing] The easing function used during\r\n * the animation (defaults to {@link module:ol/easing.inAndOut}).\r\n * The function will be called for each frame with a number representing a\r\n * fraction of the animation's duration.  The function should return a number\r\n * between 0 and 1 representing the progress toward the destination state.\r\n * @property {function(boolean):void} [callback] Function called when the view is in\r\n * its final position. The callback will be called with `true` if the animation\r\n * series completed on its own or `false` if it was cancelled.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ViewOptions\r\n * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\r\n * the view. If a user projection is not set, the coordinate system for the center is\r\n * specified with the `projection` option. Layer sources will not be fetched if this\r\n * is not set, but the center can be set later with {@link #setCenter}.\r\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\r\n * `false` means no constraint. `true` means no constraint, but snap to zero\r\n * near zero. A number constrains the rotation to that number of values. For\r\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\r\n * @property {boolean} [enableRotation=true] Enable rotation.\r\n * If `false`, a rotation constraint that always sets the rotation to zero is\r\n * used. The `constrainRotation` option has no effect if `enableRotation` is\r\n * `false`.\r\n * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\r\n * view, in other words, nothing outside of this extent can be visible on the map.\r\n * @property {boolean} [constrainOnlyCenter=false] If true, the extent\r\n * constraint will only apply to the view center and not the whole extent.\r\n * @property {boolean} [smoothExtentConstraint=true] If true, the extent\r\n * constraint will be applied smoothly, i.e. allow the view to go slightly outside\r\n * of the given `extent`.\r\n * @property {number} [maxResolution] The maximum resolution used to determine\r\n * the resolution constraint. It is used together with `minResolution` (or\r\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\r\n * that the projection's validity extent fits in a 256x256 px tile. If the\r\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\r\n * to `40075016.68557849 / 256 = 156543.03392804097`.\r\n * @property {number} [minResolution] The minimum resolution used to determine\r\n * the resolution constraint.  It is used together with `maxResolution` (or\r\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\r\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\r\n * (the default) then `minResolution` defaults to\r\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\r\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\r\n * resolution constraint. It is used together with `minZoom` (or\r\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\r\n * provided, it is given precedence over `maxZoom`.\r\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\r\n * resolution constraint. It is used together with `maxZoom` (or\r\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\r\n * provided, it is given precedence over `minZoom`.\r\n * @property {boolean} [multiWorld=false] If `false` the view is constrained so\r\n * only one world is visible, and you cannot pan off the edge.  If `true` the map\r\n * may show multiple worlds at low zoom levels.  Only used if the `projection` is\r\n * global.  Note that if `extent` is also provided it is given precedence.\r\n * @property {boolean} [constrainResolution=false] If true, the view will always\r\n * animate to the closest zoom level after an interaction; false means\r\n * intermediary zoom levels are allowed.\r\n * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution\r\n * min/max values will be applied smoothly, i. e. allow the view to exceed slightly\r\n * the given resolution or zoom bounds.\r\n * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to\r\n * show the full configured extent. By default, when a view is configured with an\r\n * extent, users will not be able to zoom out so the viewport exceeds the extent in\r\n * either dimension. This means the full extent may not be visible if the viewport\r\n * is taller or wider than the aspect ratio of the configured extent. If\r\n * showFullExtent is true, the user will be able to zoom out so that the viewport\r\n * exceeds the height or width of the configured extent, but not both, allowing the\r\n * full extent to be shown.\r\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\r\n * projection. The default is Spherical Mercator.\r\n * @property {number} [resolution] The initial resolution for the view. The\r\n * units are `projection` units per pixel (e.g. meters per pixel). An\r\n * alternative to setting this is to set `zoom`. Layer sources will not be\r\n * fetched if neither this nor `zoom` are defined, but they can be set later\r\n * with {@link #setZoom} or {@link #setResolution}.\r\n * @property {Array<number>} [resolutions] Resolutions that determine the\r\n * zoom levels if specified. The index in the array corresponds to the zoom level,\r\n * therefore the resolution values have to be in descending order. It also constrains\r\n * the resolution by the minimum and maximum value. If set the `maxResolution`,\r\n * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\r\n * @property {number} [rotation=0] The initial rotation for the view in radians\r\n * (positive rotation clockwise, 0 means North).\r\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\r\n * level used to calculate the initial resolution for the view.\r\n * @property {number} [zoomFactor=2] The zoom factor used to compute the\r\n * corresponding resolution.\r\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).\r\n * If the map viewport is partially covered with other content (overlays) along\r\n * its edges, this setting allows to shift the center of the viewport away from\r\n * that content. The order of the values is top, right, bottom, left.\r\n */\r\n\r\n/**\r\n * @typedef {Object} AnimationOptions\r\n * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\r\n * the animation.\r\n * @property {number} [zoom] The zoom level of the view at the end of the\r\n * animation. This takes precedence over `resolution`.\r\n * @property {number} [resolution] The resolution of the view at the end\r\n * of the animation.  If `zoom` is also provided, this option will be ignored.\r\n * @property {number} [rotation] The rotation of the view at the end of\r\n * the animation.\r\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remain fixed\r\n * during a rotation or resolution animation.\r\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\r\n * @property {function(number):number} [easing] The easing function used\r\n * during the animation (defaults to {@link module:ol/easing.inAndOut}).\r\n * The function will be called for each frame with a number representing a\r\n * fraction of the animation's duration.  The function should return a number\r\n * between 0 and 1 representing the progress toward the destination state.\r\n */\r\n\r\n/**\r\n * @typedef {Object} State\r\n * @property {import(\"./coordinate.js\").Coordinate} center Center (in view projection coordinates).\r\n * @property {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @property {number} resolution Resolution.\r\n * @property {import(\"./coordinate.js\").Coordinate} [nextCenter] The next center during an animation series.\r\n * @property {number} [nextResolution] The next resolution during an animation series.\r\n * @property {number} [nextRotation] The next rotation during an animation series.\r\n * @property {number} rotation Rotation.\r\n * @property {number} zoom Zoom.\r\n */\r\n\r\n/**\r\n * Like {@link import(\"./Map.js\").FrameState}, but just `viewState` and `extent`.\r\n * @typedef {Object} ViewStateLayerStateExtent\r\n * @property {State} viewState View state.\r\n * @property {import(\"./extent.js\").Extent} extent Extent (in user projection coordinates).\r\n * @property {Array<import(\"./layer/Layer.js\").State>} [layerStatesArray] Layer states.\r\n */\r\n\r\n/**\r\n * Default min zoom level for the map view.\r\n * @type {number}\r\n */\r\nconst DEFAULT_MIN_ZOOM = 0;\r\n\r\n/**\r\n * @typedef {import(\"./ObjectEventType\").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\r\n *   import(\"./Observable\").OnSignature<ViewObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\r\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A View object represents a simple 2D view of the map.\r\n *\r\n * This is the object to act upon to change the center, resolution,\r\n * and rotation of the map.\r\n *\r\n * A View has a `projection`. The projection determines the\r\n * coordinate system of the center, and its units determine the units of the\r\n * resolution (projection units per pixel). The default projection is\r\n * Web Mercator (EPSG:3857).\r\n *\r\n * ### The view states\r\n *\r\n * A View is determined by three states: `center`, `resolution`,\r\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\r\n * `getCenter` and `setCenter` for the `center` state.\r\n *\r\n * The `zoom` state is actually not saved on the view: all computations\r\n * internally use the `resolution` state. Still, the `setZoom` and `getZoom`\r\n * methods are available, as well as `getResolutionForZoom` and\r\n * `getZoomForResolution` to switch from one system to the other.\r\n *\r\n * ### The constraints\r\n *\r\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\r\n * states of the view, but any constraint defined in the constructor will\r\n * be applied along the way.\r\n *\r\n * A View object can have a *resolution constraint*, a *rotation constraint*\r\n * and a *center constraint*.\r\n *\r\n * The *resolution constraint* typically restricts min/max values and\r\n * snaps to specific resolutions. It is determined by the following\r\n * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.\r\n * If `resolutions` is set, the other three options are ignored. See\r\n * documentation for each option for more information. By default, the view\r\n * only has a min/max restriction and allow intermediary zoom levels when\r\n * pinch-zooming for example.\r\n *\r\n * The *rotation constraint* snaps to specific angles. It is determined\r\n * by the following options: `enableRotation` and `constrainRotation`.\r\n * By default rotation is allowed and its value is snapped to zero when approaching the\r\n * horizontal.\r\n *\r\n * The *center constraint* is determined by the `extent` option. By\r\n * default the view center is not constrained at all.\r\n *\r\n * ### Changing the view state\r\n *\r\n * It is important to note that `setZoom`, `setResolution`, `setCenter` and\r\n * `setRotation` are subject to the above mentioned constraints. As such, it\r\n * may sometimes not be possible to know in advance the resulting state of the\r\n * View. For example, calling `setResolution(10)` does not guarantee that\r\n * `getResolution()` will return `10`.\r\n *\r\n * A consequence of this is that, when applying a delta on the view state, one\r\n * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`\r\n * rather than the corresponding setters. This will let view do its internal\r\n * computations. Besides, the `adjust*` methods also take an `anchor`\r\n * argument which allows specifying an origin for the transformation.\r\n *\r\n * ### Interacting with the view\r\n *\r\n * View constraints are usually only applied when the view is *at rest*, meaning that\r\n * no interaction or animation is ongoing. As such, if the user puts the view in a\r\n * state that is not equivalent to a constrained one (e.g. rotating the view when\r\n * the snap angle is 0), an animation will be triggered at the interaction end to\r\n * put back the view to a stable state;\r\n *\r\n * @api\r\n */\r\nclass View extends BaseObject {\r\n  /**\r\n   * @param {ViewOptions} [options] View options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /***\r\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {ViewOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    options = Object.assign({}, options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.hints_ = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Array<Animation>>}\r\n     */\r\n    this.animations_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.updateAnimationKey_;\r\n\r\n    /**\r\n     * @private\r\n     * @const\r\n     * @type {import(\"./proj/Projection.js\").default}\r\n     */\r\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./size.js\").Size}\r\n     */\r\n    this.viewportSize_ = [100, 100];\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\r\n     */\r\n    this.targetCenter_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.targetResolution_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.targetRotation_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./coordinate.js\").Coordinate}\r\n     */\r\n    this.nextCenter_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.nextResolution_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.nextRotation_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\r\n     */\r\n    this.cancelAnchor_ = undefined;\r\n\r\n    if (options.projection) {\r\n      disableCoordinateWarning();\r\n    }\r\n    if (options.center) {\r\n      options.center = fromUserCoordinate(options.center, this.projection_);\r\n    }\r\n    if (options.extent) {\r\n      options.extent = fromUserExtent(options.extent, this.projection_);\r\n    }\r\n\r\n    this.applyOptions_(options);\r\n  }\r\n\r\n  /**\r\n   * Set up the view with the given options.\r\n   * @param {ViewOptions} options View options.\r\n   */\r\n  applyOptions_(options) {\r\n    const properties = Object.assign({}, options);\r\n    for (const key in ViewProperty) {\r\n      delete properties[key];\r\n    }\r\n    this.setProperties(properties, true);\r\n\r\n    const resolutionConstraintInfo = createResolutionConstraint(options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>|undefined}\r\n     */\r\n    this.resolutions_ = options.resolutions;\r\n\r\n    /**\r\n     * @type {Array<number>|undefined}\r\n     * @private\r\n     */\r\n    this.padding_ = options.padding;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\r\n\r\n    const centerConstraint = createCenterConstraint(options);\r\n    const resolutionConstraint = resolutionConstraintInfo.constraint;\r\n    const rotationConstraint = createRotationConstraint(options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Constraints}\r\n     */\r\n    this.constraints_ = {\r\n      center: centerConstraint,\r\n      resolution: resolutionConstraint,\r\n      rotation: rotationConstraint,\r\n    };\r\n\r\n    this.setRotation(options.rotation !== undefined ? options.rotation : 0);\r\n    this.setCenterInternal(\r\n      options.center !== undefined ? options.center : null,\r\n    );\r\n    if (options.resolution !== undefined) {\r\n      this.setResolution(options.resolution);\r\n    } else if (options.zoom !== undefined) {\r\n      this.setZoom(options.zoom);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Padding (in css pixels).\r\n   * If the map viewport is partially covered with other content (overlays) along\r\n   * its edges, this setting allows to shift the center of the viewport away from that\r\n   * content. The order of the values in the array is top, right, bottom, left.\r\n   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.\r\n   * @type {Array<number>|undefined}\r\n   * @api\r\n   */\r\n  get padding() {\r\n    return this.padding_;\r\n  }\r\n  set padding(padding) {\r\n    let oldPadding = this.padding_;\r\n    this.padding_ = padding;\r\n    const center = this.getCenterInternal();\r\n    if (center) {\r\n      const newPadding = padding || [0, 0, 0, 0];\r\n      oldPadding = oldPadding || [0, 0, 0, 0];\r\n      const resolution = this.getResolution();\r\n      const offsetX =\r\n        (resolution / 2) *\r\n        (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\r\n      const offsetY =\r\n        (resolution / 2) *\r\n        (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\r\n      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get an updated version of the view options used to construct the view.  The\r\n   * current resolution (or zoom), center, and rotation are applied to any stored\r\n   * options.  The provided options can be used to apply new min/max zoom or\r\n   * resolution limits.\r\n   * @param {ViewOptions} newOptions New options to be applied.\r\n   * @return {ViewOptions} New options updated with the current view state.\r\n   */\r\n  getUpdatedOptions_(newOptions) {\r\n    const options = this.getProperties();\r\n\r\n    // preserve resolution (or zoom)\r\n    if (options.resolution !== undefined) {\r\n      options.resolution = this.getResolution();\r\n    } else {\r\n      options.zoom = this.getZoom();\r\n    }\r\n\r\n    // preserve center\r\n    options.center = this.getCenterInternal();\r\n\r\n    // preserve rotation\r\n    options.rotation = this.getRotation();\r\n\r\n    return Object.assign({}, options, newOptions);\r\n  }\r\n\r\n  /**\r\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\r\n   * can be animated for smooth transitions between view states.  For example,\r\n   * to animate the view to a new zoom level:\r\n   *\r\n   *     view.animate({zoom: view.getZoom() + 1});\r\n   *\r\n   * By default, the animation lasts one second and uses in-and-out easing.  You\r\n   * can customize this behavior by including `duration` (in milliseconds) and\r\n   * `easing` options (see {@link module:ol/easing}).\r\n   *\r\n   * To chain together multiple animations, call the method with multiple\r\n   * animation objects.  For example, to first zoom and then pan:\r\n   *\r\n   *     view.animate({zoom: 10}, {center: [0, 0]});\r\n   *\r\n   * If you provide a function as the last argument to the animate method, it\r\n   * will get called at the end of an animation series.  The callback will be\r\n   * called with `true` if the animation series completed on its own or `false`\r\n   * if it was cancelled.\r\n   *\r\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\r\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\r\n   * (or another method that calls one of these).\r\n   *\r\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation\r\n   *     options.  Multiple animations can be run in series by passing multiple\r\n   *     options objects.  To run multiple animations in parallel, call the method\r\n   *     multiple times.  An optional callback can be provided as a final\r\n   *     argument.  The callback will be called with a boolean indicating whether\r\n   *     the animation completed without being cancelled.\r\n   * @api\r\n   */\r\n  animate(var_args) {\r\n    if (this.isDef() && !this.getAnimating()) {\r\n      this.resolveConstraints(0);\r\n    }\r\n    const args = new Array(arguments.length);\r\n    for (let i = 0; i < args.length; ++i) {\r\n      let options = arguments[i];\r\n      if (options.center) {\r\n        options = Object.assign({}, options);\r\n        options.center = fromUserCoordinate(\r\n          options.center,\r\n          this.getProjection(),\r\n        );\r\n      }\r\n      if (options.anchor) {\r\n        options = Object.assign({}, options);\r\n        options.anchor = fromUserCoordinate(\r\n          options.anchor,\r\n          this.getProjection(),\r\n        );\r\n      }\r\n      args[i] = options;\r\n    }\r\n    this.animateInternal.apply(this, args);\r\n  }\r\n\r\n  /**\r\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.\r\n   */\r\n  animateInternal(var_args) {\r\n    let animationCount = arguments.length;\r\n    let callback;\r\n    if (\r\n      animationCount > 1 &&\r\n      typeof arguments[animationCount - 1] === 'function'\r\n    ) {\r\n      callback = arguments[animationCount - 1];\r\n      --animationCount;\r\n    }\r\n\r\n    let i = 0;\r\n    for (; i < animationCount && !this.isDef(); ++i) {\r\n      // if view properties are not yet set, shortcut to the final state\r\n      const state = arguments[i];\r\n      if (state.center) {\r\n        this.setCenterInternal(state.center);\r\n      }\r\n      if (state.zoom !== undefined) {\r\n        this.setZoom(state.zoom);\r\n      } else if (state.resolution) {\r\n        this.setResolution(state.resolution);\r\n      }\r\n      if (state.rotation !== undefined) {\r\n        this.setRotation(state.rotation);\r\n      }\r\n    }\r\n    if (i === animationCount) {\r\n      if (callback) {\r\n        animationCallback(callback, true);\r\n      }\r\n      return;\r\n    }\r\n\r\n    let start = Date.now();\r\n    let center = this.targetCenter_.slice();\r\n    let resolution = this.targetResolution_;\r\n    let rotation = this.targetRotation_;\r\n    const series = [];\r\n    for (; i < animationCount; ++i) {\r\n      const options = /** @type {AnimationOptions} */ (arguments[i]);\r\n\r\n      const animation = {\r\n        start: start,\r\n        complete: false,\r\n        anchor: options.anchor,\r\n        duration: options.duration !== undefined ? options.duration : 1000,\r\n        easing: options.easing || inAndOut,\r\n        callback: callback,\r\n      };\r\n\r\n      if (options.center) {\r\n        animation.sourceCenter = center;\r\n        animation.targetCenter = options.center.slice();\r\n        center = animation.targetCenter;\r\n      }\r\n\r\n      if (options.zoom !== undefined) {\r\n        animation.sourceResolution = resolution;\r\n        animation.targetResolution = this.getResolutionForZoom(options.zoom);\r\n        resolution = animation.targetResolution;\r\n      } else if (options.resolution) {\r\n        animation.sourceResolution = resolution;\r\n        animation.targetResolution = options.resolution;\r\n        resolution = animation.targetResolution;\r\n      }\r\n\r\n      if (options.rotation !== undefined) {\r\n        animation.sourceRotation = rotation;\r\n        const delta =\r\n          modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\r\n        animation.targetRotation = rotation + delta;\r\n        rotation = animation.targetRotation;\r\n      }\r\n\r\n      // check if animation is a no-op\r\n      if (isNoopAnimation(animation)) {\r\n        animation.complete = true;\r\n        // we still push it onto the series for callback handling\r\n      } else {\r\n        start += animation.duration;\r\n      }\r\n      series.push(animation);\r\n    }\r\n    this.animations_.push(series);\r\n    this.setHint(ViewHint.ANIMATING, 1);\r\n    this.updateAnimations_();\r\n  }\r\n\r\n  /**\r\n   * Determine if the view is being animated.\r\n   * @return {boolean} The view is being animated.\r\n   * @api\r\n   */\r\n  getAnimating() {\r\n    return this.hints_[ViewHint.ANIMATING] > 0;\r\n  }\r\n\r\n  /**\r\n   * Determine if the user is interacting with the view, such as panning or zooming.\r\n   * @return {boolean} The view is being interacted with.\r\n   * @api\r\n   */\r\n  getInteracting() {\r\n    return this.hints_[ViewHint.INTERACTING] > 0;\r\n  }\r\n\r\n  /**\r\n   * Cancel any ongoing animations.\r\n   * @api\r\n   */\r\n  cancelAnimations() {\r\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\r\n    let anchor;\r\n    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {\r\n      const series = this.animations_[i];\r\n      if (series[0].callback) {\r\n        animationCallback(series[0].callback, false);\r\n      }\r\n      if (!anchor) {\r\n        for (let j = 0, jj = series.length; j < jj; ++j) {\r\n          const animation = series[j];\r\n          if (!animation.complete) {\r\n            anchor = animation.anchor;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.animations_.length = 0;\r\n    this.cancelAnchor_ = anchor;\r\n    this.nextCenter_ = null;\r\n    this.nextResolution_ = NaN;\r\n    this.nextRotation_ = NaN;\r\n  }\r\n\r\n  /**\r\n   * Update all animations.\r\n   */\r\n  updateAnimations_() {\r\n    if (this.updateAnimationKey_ !== undefined) {\r\n      cancelAnimationFrame(this.updateAnimationKey_);\r\n      this.updateAnimationKey_ = undefined;\r\n    }\r\n    if (!this.getAnimating()) {\r\n      return;\r\n    }\r\n    const now = Date.now();\r\n    let more = false;\r\n    for (let i = this.animations_.length - 1; i >= 0; --i) {\r\n      const series = this.animations_[i];\r\n      let seriesComplete = true;\r\n      for (let j = 0, jj = series.length; j < jj; ++j) {\r\n        const animation = series[j];\r\n        if (animation.complete) {\r\n          continue;\r\n        }\r\n        const elapsed = now - animation.start;\r\n        let fraction =\r\n          animation.duration > 0 ? elapsed / animation.duration : 1;\r\n        if (fraction >= 1) {\r\n          animation.complete = true;\r\n          fraction = 1;\r\n        } else {\r\n          seriesComplete = false;\r\n        }\r\n        const progress = animation.easing(fraction);\r\n        if (animation.sourceCenter) {\r\n          const x0 = animation.sourceCenter[0];\r\n          const y0 = animation.sourceCenter[1];\r\n          const x1 = animation.targetCenter[0];\r\n          const y1 = animation.targetCenter[1];\r\n          this.nextCenter_ = animation.targetCenter;\r\n          const x = x0 + progress * (x1 - x0);\r\n          const y = y0 + progress * (y1 - y0);\r\n          this.targetCenter_ = [x, y];\r\n        }\r\n        if (animation.sourceResolution && animation.targetResolution) {\r\n          const resolution =\r\n            progress === 1\r\n              ? animation.targetResolution\r\n              : animation.sourceResolution +\r\n                progress *\r\n                  (animation.targetResolution - animation.sourceResolution);\r\n          if (animation.anchor) {\r\n            const size = this.getViewportSize_(this.getRotation());\r\n            const constrainedResolution = this.constraints_.resolution(\r\n              resolution,\r\n              0,\r\n              size,\r\n              true,\r\n            );\r\n            this.targetCenter_ = this.calculateCenterZoom(\r\n              constrainedResolution,\r\n              animation.anchor,\r\n            );\r\n          }\r\n          this.nextResolution_ = animation.targetResolution;\r\n          this.targetResolution_ = resolution;\r\n          this.applyTargetState_(true);\r\n        }\r\n        if (\r\n          animation.sourceRotation !== undefined &&\r\n          animation.targetRotation !== undefined\r\n        ) {\r\n          const rotation =\r\n            progress === 1\r\n              ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -\r\n                Math.PI\r\n              : animation.sourceRotation +\r\n                progress *\r\n                  (animation.targetRotation - animation.sourceRotation);\r\n          if (animation.anchor) {\r\n            const constrainedRotation = this.constraints_.rotation(\r\n              rotation,\r\n              true,\r\n            );\r\n            this.targetCenter_ = this.calculateCenterRotate(\r\n              constrainedRotation,\r\n              animation.anchor,\r\n            );\r\n          }\r\n          this.nextRotation_ = animation.targetRotation;\r\n          this.targetRotation_ = rotation;\r\n        }\r\n        this.applyTargetState_(true);\r\n        more = true;\r\n        if (!animation.complete) {\r\n          break;\r\n        }\r\n      }\r\n      if (seriesComplete) {\r\n        this.animations_[i] = null;\r\n        this.setHint(ViewHint.ANIMATING, -1);\r\n        this.nextCenter_ = null;\r\n        this.nextResolution_ = NaN;\r\n        this.nextRotation_ = NaN;\r\n        const callback = series[0].callback;\r\n        if (callback) {\r\n          animationCallback(callback, true);\r\n        }\r\n      }\r\n    }\r\n    // prune completed series\r\n    this.animations_ = this.animations_.filter(Boolean);\r\n    if (more && this.updateAnimationKey_ === undefined) {\r\n      this.updateAnimationKey_ = requestAnimationFrame(\r\n        this.updateAnimations_.bind(this),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} rotation Target rotation.\r\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\r\n   */\r\n  calculateCenterRotate(rotation, anchor) {\r\n    let center;\r\n    const currentCenter = this.getCenterInternal();\r\n    if (currentCenter !== undefined) {\r\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\r\n      rotateCoordinate(center, rotation - this.getRotation());\r\n      addCoordinate(center, anchor);\r\n    }\r\n    return center;\r\n  }\r\n\r\n  /**\r\n   * @param {number} resolution Target resolution.\r\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\r\n   */\r\n  calculateCenterZoom(resolution, anchor) {\r\n    let center;\r\n    const currentCenter = this.getCenterInternal();\r\n    const currentResolution = this.getResolution();\r\n    if (currentCenter !== undefined && currentResolution !== undefined) {\r\n      const x =\r\n        anchor[0] -\r\n        (resolution * (anchor[0] - currentCenter[0])) / currentResolution;\r\n      const y =\r\n        anchor[1] -\r\n        (resolution * (anchor[1] - currentCenter[1])) / currentResolution;\r\n      center = [x, y];\r\n    }\r\n    return center;\r\n  }\r\n\r\n  /**\r\n   * Returns the current viewport size.\r\n   * @private\r\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\r\n   * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\r\n   */\r\n  getViewportSize_(rotation) {\r\n    const size = this.viewportSize_;\r\n    if (rotation) {\r\n      const w = size[0];\r\n      const h = size[1];\r\n      return [\r\n        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),\r\n        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation)),\r\n      ];\r\n    }\r\n    return size;\r\n  }\r\n\r\n  /**\r\n   * Stores the viewport size on the view. The viewport size is not read every time from the DOM\r\n   * to avoid performance hit and layout reflow.\r\n   * This should be done on map size change.\r\n   * Note: the constraints are not resolved during an animation to avoid stopping it\r\n   * @param {import(\"./size.js\").Size} [size] Viewport size; if undefined, [100, 100] is assumed\r\n   */\r\n  setViewportSize(size) {\r\n    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];\r\n    if (!this.getAnimating()) {\r\n      this.resolveConstraints(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the view center.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getCenter() {\r\n    const center = this.getCenterInternal();\r\n    if (!center) {\r\n      return center;\r\n    }\r\n    return toUserCoordinate(center, this.getProjection());\r\n  }\r\n\r\n  /**\r\n   * Get the view center without transforming to user projection.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\r\n   */\r\n  getCenterInternal() {\r\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\r\n      this.get(ViewProperty.CENTER)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {Constraints} Constraints.\r\n   */\r\n  getConstraints() {\r\n    return this.constraints_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Resolution constraint is set\r\n   */\r\n  getConstrainResolution() {\r\n    return this.get('constrainResolution');\r\n  }\r\n\r\n  /**\r\n   * @param {Array<number>} [hints] Destination array.\r\n   * @return {Array<number>} Hint.\r\n   */\r\n  getHints(hints) {\r\n    if (hints !== undefined) {\r\n      hints[0] = this.hints_[0];\r\n      hints[1] = this.hints_[1];\r\n      return hints;\r\n    }\r\n    return this.hints_.slice();\r\n  }\r\n\r\n  /**\r\n   * Calculate the extent for the current view state and the passed box size.\r\n   * @param {import(\"./size.js\").Size} [size] The pixel dimensions of the box\r\n   * into which the calculated extent should fit. Defaults to the size of the\r\n   * map the view is associated with.\r\n   * If no map or multiple maps are connected to the view, provide the desired\r\n   * box size (e.g. `map.getSize()`).\r\n   * @return {import(\"./extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  calculateExtent(size) {\r\n    const extent = this.calculateExtentInternal(size);\r\n    return toUserExtent(extent, this.getProjection());\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided,\r\n   * the map's last known viewport size will be used.\r\n   * @return {import(\"./extent.js\").Extent} Extent.\r\n   */\r\n  calculateExtentInternal(size) {\r\n    size = size || this.getViewportSizeMinusPadding_();\r\n    const center = /** @type {!import(\"./coordinate.js\").Coordinate} */ (\r\n      this.getCenterInternal()\r\n    );\r\n    assert(center, 'The view center is not defined');\r\n    const resolution = /** @type {!number} */ (this.getResolution());\r\n    assert(resolution !== undefined, 'The view resolution is not defined');\r\n    const rotation = /** @type {!number} */ (this.getRotation());\r\n    assert(rotation !== undefined, 'The view rotation is not defined');\r\n\r\n    return getForViewAndSize(center, resolution, rotation, size);\r\n  }\r\n\r\n  /**\r\n   * Get the maximum resolution of the view.\r\n   * @return {number} The maximum resolution of the view.\r\n   * @api\r\n   */\r\n  getMaxResolution() {\r\n    return this.maxResolution_;\r\n  }\r\n\r\n  /**\r\n   * Get the minimum resolution of the view.\r\n   * @return {number} The minimum resolution of the view.\r\n   * @api\r\n   */\r\n  getMinResolution() {\r\n    return this.minResolution_;\r\n  }\r\n\r\n  /**\r\n   * Get the maximum zoom level for the view.\r\n   * @return {number} The maximum zoom level.\r\n   * @api\r\n   */\r\n  getMaxZoom() {\r\n    return /** @type {number} */ (\r\n      this.getZoomForResolution(this.minResolution_)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set a new maximum zoom level for the view.\r\n   * @param {number} zoom The maximum zoom level.\r\n   * @api\r\n   */\r\n  setMaxZoom(zoom) {\r\n    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\r\n  }\r\n\r\n  /**\r\n   * Get the minimum zoom level for the view.\r\n   * @return {number} The minimum zoom level.\r\n   * @api\r\n   */\r\n  getMinZoom() {\r\n    return /** @type {number} */ (\r\n      this.getZoomForResolution(this.maxResolution_)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set a new minimum zoom level for the view.\r\n   * @param {number} zoom The minimum zoom level.\r\n   * @api\r\n   */\r\n  setMinZoom(zoom) {\r\n    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\r\n  }\r\n\r\n  /**\r\n   * Set whether the view should allow intermediary zoom levels.\r\n   * @param {boolean} enabled Whether the resolution is constrained.\r\n   * @api\r\n   */\r\n  setConstrainResolution(enabled) {\r\n    this.applyOptions_(this.getUpdatedOptions_({constrainResolution: enabled}));\r\n  }\r\n\r\n  /**\r\n   * Get the view projection.\r\n   * @return {import(\"./proj/Projection.js\").default} The projection of the view.\r\n   * @api\r\n   */\r\n  getProjection() {\r\n    return this.projection_;\r\n  }\r\n\r\n  /**\r\n   * Get the view resolution.\r\n   * @return {number|undefined} The resolution of the view.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getResolution() {\r\n    return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\r\n  }\r\n\r\n  /**\r\n   * Get the resolutions for the view. This returns the array of resolutions\r\n   * passed to the constructor of the View, or undefined if none were given.\r\n   * @return {Array<number>|undefined} The resolutions of the view.\r\n   * @api\r\n   */\r\n  getResolutions() {\r\n    return this.resolutions_;\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\r\n   * @return {number} The resolution at which the provided extent will render at\r\n   *     the given size.\r\n   * @api\r\n   */\r\n  getResolutionForExtent(extent, size) {\r\n    return this.getResolutionForExtentInternal(\r\n      fromUserExtent(extent, this.getProjection()),\r\n      size,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\r\n   * @return {number} The resolution at which the provided extent will render at\r\n   *     the given size.\r\n   */\r\n  getResolutionForExtentInternal(extent, size) {\r\n    size = size || this.getViewportSizeMinusPadding_();\r\n    const xResolution = getWidth(extent) / size[0];\r\n    const yResolution = getHeight(extent) / size[1];\r\n    return Math.max(xResolution, yResolution);\r\n  }\r\n\r\n  /**\r\n   * Return a function that returns a value between 0 and 1 for a\r\n   * resolution. Exponential scaling is assumed.\r\n   * @param {number} [power] Power.\r\n   * @return {function(number): number} Resolution for value function.\r\n   */\r\n  getResolutionForValueFunction(power) {\r\n    power = power || 2;\r\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\r\n    const minResolution = this.minResolution_;\r\n    const max = Math.log(maxResolution / minResolution) / Math.log(power);\r\n    return (\r\n      /**\r\n       * @param {number} value Value.\r\n       * @return {number} Resolution.\r\n       */\r\n      function (value) {\r\n        const resolution = maxResolution / Math.pow(power, value * max);\r\n        return resolution;\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the view rotation.\r\n   * @return {number} The rotation of the view in radians.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getRotation() {\r\n    return /** @type {number} */ (this.get(ViewProperty.ROTATION));\r\n  }\r\n\r\n  /**\r\n   * Return a function that returns a resolution for a value between\r\n   * 0 and 1. Exponential scaling is assumed.\r\n   * @param {number} [power] Power.\r\n   * @return {function(number): number} Value for resolution function.\r\n   */\r\n  getValueForResolutionFunction(power) {\r\n    const logPower = Math.log(power || 2);\r\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\r\n    const minResolution = this.minResolution_;\r\n    const max = Math.log(maxResolution / minResolution) / logPower;\r\n    return (\r\n      /**\r\n       * @param {number} resolution Resolution.\r\n       * @return {number} Value.\r\n       */\r\n      function (resolution) {\r\n        const value = Math.log(maxResolution / resolution) / logPower / max;\r\n        return value;\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the size of the viewport minus padding.\r\n   * @private\r\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\r\n   * @return {import(\"./size.js\").Size} Viewport size reduced by the padding.\r\n   */\r\n  getViewportSizeMinusPadding_(rotation) {\r\n    let size = this.getViewportSize_(rotation);\r\n    const padding = this.padding_;\r\n    if (padding) {\r\n      size = [\r\n        size[0] - padding[1] - padding[3],\r\n        size[1] - padding[0] - padding[2],\r\n      ];\r\n    }\r\n    return size;\r\n  }\r\n\r\n  /**\r\n   * @return {State} View state.\r\n   */\r\n  getState() {\r\n    const projection = this.getProjection();\r\n    const resolution = this.getResolution();\r\n    const rotation = this.getRotation();\r\n    let center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\r\n      this.getCenterInternal()\r\n    );\r\n    const padding = this.padding_;\r\n    if (padding) {\r\n      const reducedSize = this.getViewportSizeMinusPadding_();\r\n      center = calculateCenterOn(\r\n        center,\r\n        this.getViewportSize_(),\r\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\r\n        resolution,\r\n        rotation,\r\n      );\r\n    }\r\n    return {\r\n      center: center.slice(0),\r\n      projection: projection !== undefined ? projection : null,\r\n      resolution: resolution,\r\n      nextCenter: this.nextCenter_,\r\n      nextResolution: this.nextResolution_,\r\n      nextRotation: this.nextRotation_,\r\n      rotation: rotation,\r\n      zoom: this.getZoom(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.\r\n   */\r\n  getViewStateAndExtent() {\r\n    return {\r\n      viewState: this.getState(),\r\n      extent: this.calculateExtent(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get the current zoom level. This method may return non-integer zoom levels\r\n   * if the view does not constrain the resolution, or if an interaction or\r\n   * animation is underway.\r\n   * @return {number|undefined} Zoom.\r\n   * @api\r\n   */\r\n  getZoom() {\r\n    let zoom;\r\n    const resolution = this.getResolution();\r\n    if (resolution !== undefined) {\r\n      zoom = this.getZoomForResolution(resolution);\r\n    }\r\n    return zoom;\r\n  }\r\n\r\n  /**\r\n   * Get the zoom level for a resolution.\r\n   * @param {number} resolution The resolution.\r\n   * @return {number|undefined} The zoom level for the provided resolution.\r\n   * @api\r\n   */\r\n  getZoomForResolution(resolution) {\r\n    let offset = this.minZoom_ || 0;\r\n    let max, zoomFactor;\r\n    if (this.resolutions_) {\r\n      const nearest = linearFindNearest(this.resolutions_, resolution, 1);\r\n      offset = nearest;\r\n      max = this.resolutions_[nearest];\r\n      if (nearest == this.resolutions_.length - 1) {\r\n        zoomFactor = 2;\r\n      } else {\r\n        zoomFactor = max / this.resolutions_[nearest + 1];\r\n      }\r\n    } else {\r\n      max = this.maxResolution_;\r\n      zoomFactor = this.zoomFactor_;\r\n    }\r\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for a zoom level.\r\n   * @param {number} zoom Zoom level.\r\n   * @return {number} The view resolution for the provided zoom level.\r\n   * @api\r\n   */\r\n  getResolutionForZoom(zoom) {\r\n    if (this.resolutions_) {\r\n      if (this.resolutions_.length <= 1) {\r\n        return 0;\r\n      }\r\n      const baseLevel = clamp(\r\n        Math.floor(zoom),\r\n        0,\r\n        this.resolutions_.length - 2,\r\n      );\r\n      const zoomFactor =\r\n        this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\r\n      return (\r\n        this.resolutions_[baseLevel] /\r\n        Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1))\r\n      );\r\n    }\r\n    return (\r\n      this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Fit the given geometry or extent based on the given map size and border.\r\n   * The size is pixel dimensions of the box to fit the extent into.\r\n   * In most cases you will want to use the map size, that is `map.getSize()`.\r\n   * Takes care of the map angle.\r\n   * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\r\n   *     extent to fit the view to.\r\n   * @param {FitOptions} [options] Options.\r\n   * @api\r\n   */\r\n  fit(geometryOrExtent, options) {\r\n    /** @type {import(\"./geom/SimpleGeometry.js\").default} */\r\n    let geometry;\r\n    assert(\r\n      Array.isArray(geometryOrExtent) ||\r\n        typeof (/** @type {?} */ (geometryOrExtent).getSimplifiedGeometry) ===\r\n          'function',\r\n      'Invalid extent or geometry provided as `geometry`',\r\n    );\r\n    if (Array.isArray(geometryOrExtent)) {\r\n      assert(\r\n        !isEmpty(geometryOrExtent),\r\n        'Cannot fit empty extent provided as `geometry`',\r\n      );\r\n      const extent = fromUserExtent(geometryOrExtent, this.getProjection());\r\n      geometry = polygonFromExtent(extent);\r\n    } else if (geometryOrExtent.getType() === 'Circle') {\r\n      const extent = fromUserExtent(\r\n        geometryOrExtent.getExtent(),\r\n        this.getProjection(),\r\n      );\r\n      geometry = polygonFromExtent(extent);\r\n      geometry.rotate(this.getRotation(), getCenter(extent));\r\n    } else {\r\n      const userProjection = getUserProjection();\r\n      if (userProjection) {\r\n        geometry = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n          geometryOrExtent\r\n            .clone()\r\n            .transform(userProjection, this.getProjection())\r\n        );\r\n      } else {\r\n        geometry = geometryOrExtent;\r\n      }\r\n    }\r\n\r\n    this.fitInternal(geometry, options);\r\n  }\r\n\r\n  /**\r\n   * Calculate rotated extent\r\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\r\n   * @return {import(\"./extent\").Extent} The rotated extent for the geometry.\r\n   */\r\n  rotatedExtentForGeometry(geometry) {\r\n    const rotation = this.getRotation();\r\n    const cosAngle = Math.cos(rotation);\r\n    const sinAngle = Math.sin(-rotation);\r\n    const coords = geometry.getFlatCoordinates();\r\n    const stride = geometry.getStride();\r\n    let minRotX = +Infinity;\r\n    let minRotY = +Infinity;\r\n    let maxRotX = -Infinity;\r\n    let maxRotY = -Infinity;\r\n    for (let i = 0, ii = coords.length; i < ii; i += stride) {\r\n      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\r\n      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\r\n      minRotX = Math.min(minRotX, rotX);\r\n      minRotY = Math.min(minRotY, rotY);\r\n      maxRotX = Math.max(maxRotX, rotX);\r\n      maxRotY = Math.max(maxRotY, rotY);\r\n    }\r\n    return [minRotX, minRotY, maxRotX, maxRotY];\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\r\n   * @param {FitOptions} [options] Options.\r\n   */\r\n  fitInternal(geometry, options) {\r\n    options = options || {};\r\n    let size = options.size;\r\n    if (!size) {\r\n      size = this.getViewportSizeMinusPadding_();\r\n    }\r\n    const padding =\r\n      options.padding !== undefined ? options.padding : [0, 0, 0, 0];\r\n    const nearest = options.nearest !== undefined ? options.nearest : false;\r\n    let minResolution;\r\n    if (options.minResolution !== undefined) {\r\n      minResolution = options.minResolution;\r\n    } else if (options.maxZoom !== undefined) {\r\n      minResolution = this.getResolutionForZoom(options.maxZoom);\r\n    } else {\r\n      minResolution = 0;\r\n    }\r\n\r\n    const rotatedExtent = this.rotatedExtentForGeometry(geometry);\r\n\r\n    // calculate resolution\r\n    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [\r\n      size[0] - padding[1] - padding[3],\r\n      size[1] - padding[0] - padding[2],\r\n    ]);\r\n    resolution = isNaN(resolution)\r\n      ? minResolution\r\n      : Math.max(resolution, minResolution);\r\n    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);\r\n\r\n    // calculate center\r\n    const rotation = this.getRotation();\r\n    const sinAngle = Math.sin(rotation);\r\n    const cosAngle = Math.cos(rotation);\r\n    const centerRot = getCenter(rotatedExtent);\r\n    centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;\r\n    centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;\r\n    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\r\n    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\r\n    const center = this.getConstrainedCenter([centerX, centerY], resolution);\r\n    const callback = options.callback ? options.callback : VOID;\r\n\r\n    if (options.duration !== undefined) {\r\n      this.animateInternal(\r\n        {\r\n          resolution: resolution,\r\n          center: center,\r\n          duration: options.duration,\r\n          easing: options.easing,\r\n        },\r\n        callback,\r\n      );\r\n    } else {\r\n      this.targetResolution_ = resolution;\r\n      this.targetCenter_ = center;\r\n      this.applyTargetState_(false, true);\r\n      animationCallback(callback, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Center on coordinate and view position.\r\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"./size.js\").Size} size Box pixel size.\r\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\r\n   * @api\r\n   */\r\n  centerOn(coordinate, size, position) {\r\n    this.centerOnInternal(\r\n      fromUserCoordinate(coordinate, this.getProjection()),\r\n      size,\r\n      position,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"./size.js\").Size} size Box pixel size.\r\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\r\n   */\r\n  centerOnInternal(coordinate, size, position) {\r\n    this.setCenterInternal(\r\n      calculateCenterOn(\r\n        coordinate,\r\n        size,\r\n        position,\r\n        this.getResolution(),\r\n        this.getRotation(),\r\n      ),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Calculates the shift between map and viewport center.\r\n   * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} rotation Rotation.\r\n   * @param {import(\"./size.js\").Size} size Size.\r\n   * @return {Array<number>|undefined} Center shift.\r\n   */\r\n  calculateCenterShift(center, resolution, rotation, size) {\r\n    let centerShift;\r\n    const padding = this.padding_;\r\n    if (padding && center) {\r\n      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);\r\n      const shiftedCenter = calculateCenterOn(\r\n        center,\r\n        size,\r\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\r\n        resolution,\r\n        rotation,\r\n      );\r\n      centerShift = [\r\n        center[0] - shiftedCenter[0],\r\n        center[1] - shiftedCenter[1],\r\n      ];\r\n    }\r\n    return centerShift;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Is defined.\r\n   */\r\n  isDef() {\r\n    return !!this.getCenterInternal() && this.getResolution() !== undefined;\r\n  }\r\n\r\n  /**\r\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\r\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\r\n   * @api\r\n   */\r\n  adjustCenter(deltaCoordinates) {\r\n    const center = toUserCoordinate(this.targetCenter_, this.getProjection());\r\n    this.setCenter([\r\n      center[0] + deltaCoordinates[0],\r\n      center[1] + deltaCoordinates[1],\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\r\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\r\n   */\r\n  adjustCenterInternal(deltaCoordinates) {\r\n    const center = this.targetCenter_;\r\n    this.setCenterInternal([\r\n      center[0] + deltaCoordinates[0],\r\n      center[1] + deltaCoordinates[1],\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\r\n   * constraint will apply.\r\n   * @param {number} ratio The ratio to apply on the view resolution.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   * @api\r\n   */\r\n  adjustResolution(ratio, anchor) {\r\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\r\n    this.adjustResolutionInternal(ratio, anchor);\r\n  }\r\n\r\n  /**\r\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\r\n   * constraint will apply.\r\n   * @param {number} ratio The ratio to apply on the view resolution.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   */\r\n  adjustResolutionInternal(ratio, anchor) {\r\n    const isMoving = this.getAnimating() || this.getInteracting();\r\n    const size = this.getViewportSize_(this.getRotation());\r\n    const newResolution = this.constraints_.resolution(\r\n      this.targetResolution_ * ratio,\r\n      0,\r\n      size,\r\n      isMoving,\r\n    );\r\n\r\n    if (anchor) {\r\n      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);\r\n    }\r\n\r\n    this.targetResolution_ *= ratio;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * Adds a value to the view zoom level, optionally using an anchor. Any resolution\r\n   * constraint will apply.\r\n   * @param {number} delta Relative value to add to the zoom level.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   * @api\r\n   */\r\n  adjustZoom(delta, anchor) {\r\n    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);\r\n  }\r\n\r\n  /**\r\n   * Adds a value to the view rotation, optionally using an anchor. Any rotation\r\n   * constraint will apply.\r\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\r\n   * @api\r\n   */\r\n  adjustRotation(delta, anchor) {\r\n    if (anchor) {\r\n      anchor = fromUserCoordinate(anchor, this.getProjection());\r\n    }\r\n    this.adjustRotationInternal(delta, anchor);\r\n  }\r\n\r\n  /**\r\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\r\n   */\r\n  adjustRotationInternal(delta, anchor) {\r\n    const isMoving = this.getAnimating() || this.getInteracting();\r\n    const newRotation = this.constraints_.rotation(\r\n      this.targetRotation_ + delta,\r\n      isMoving,\r\n    );\r\n    if (anchor) {\r\n      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);\r\n    }\r\n    this.targetRotation_ += delta;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * Set the center of the current view. Any extent constraint will apply.\r\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setCenter(center) {\r\n    this.setCenterInternal(\r\n      center ? fromUserCoordinate(center, this.getProjection()) : center,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the center using the view projection (not the user projection).\r\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\r\n   */\r\n  setCenterInternal(center) {\r\n    this.targetCenter_ = center;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./ViewHint.js\").default} hint Hint.\r\n   * @param {number} delta Delta.\r\n   * @return {number} New value.\r\n   */\r\n  setHint(hint, delta) {\r\n    this.hints_[hint] += delta;\r\n    this.changed();\r\n    return this.hints_[hint];\r\n  }\r\n\r\n  /**\r\n   * Set the resolution for this view. Any resolution constraint will apply.\r\n   * @param {number|undefined} resolution The resolution of the view.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setResolution(resolution) {\r\n    this.targetResolution_ = resolution;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * Set the rotation for this view. Any rotation constraint will apply.\r\n   * @param {number} rotation The rotation of the view in radians.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setRotation(rotation) {\r\n    this.targetRotation_ = rotation;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * Zoom to a specific zoom level. Any resolution constrain will apply.\r\n   * @param {number} zoom Zoom level.\r\n   * @api\r\n   */\r\n  setZoom(zoom) {\r\n    this.setResolution(this.getResolutionForZoom(zoom));\r\n  }\r\n\r\n  /**\r\n   * Recompute rotation/resolution/center based on target values.\r\n   * Note: we have to compute rotation first, then resolution and center considering that\r\n   * parameters can influence one another in case a view extent constraint is present.\r\n   * @param {boolean} [doNotCancelAnims] Do not cancel animations.\r\n   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.\r\n   * @private\r\n   */\r\n  applyTargetState_(doNotCancelAnims, forceMoving) {\r\n    const isMoving =\r\n      this.getAnimating() || this.getInteracting() || forceMoving;\r\n\r\n    // compute rotation\r\n    const newRotation = this.constraints_.rotation(\r\n      this.targetRotation_,\r\n      isMoving,\r\n    );\r\n    const size = this.getViewportSize_(newRotation);\r\n    const newResolution = this.constraints_.resolution(\r\n      this.targetResolution_,\r\n      0,\r\n      size,\r\n      isMoving,\r\n    );\r\n    const newCenter = this.constraints_.center(\r\n      this.targetCenter_,\r\n      newResolution,\r\n      size,\r\n      isMoving,\r\n      this.calculateCenterShift(\r\n        this.targetCenter_,\r\n        newResolution,\r\n        newRotation,\r\n        size,\r\n      ),\r\n    );\r\n\r\n    if (this.get(ViewProperty.ROTATION) !== newRotation) {\r\n      this.set(ViewProperty.ROTATION, newRotation);\r\n    }\r\n    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\r\n      this.set(ViewProperty.RESOLUTION, newResolution);\r\n      this.set('zoom', this.getZoom(), true);\r\n    }\r\n    if (\r\n      !newCenter ||\r\n      !this.get(ViewProperty.CENTER) ||\r\n      !equals(this.get(ViewProperty.CENTER), newCenter)\r\n    ) {\r\n      this.set(ViewProperty.CENTER, newCenter);\r\n    }\r\n\r\n    if (this.getAnimating() && !doNotCancelAnims) {\r\n      this.cancelAnimations();\r\n    }\r\n    this.cancelAnchor_ = undefined;\r\n  }\r\n\r\n  /**\r\n   * If any constraints need to be applied, an animation will be triggered.\r\n   * This is typically done on interaction end.\r\n   * Note: calling this with a duration of 0 will apply the constrained values straight away,\r\n   * without animation.\r\n   * @param {number} [duration] The animation duration in ms.\r\n   * @param {number} [resolutionDirection] Which direction to zoom.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   */\r\n  resolveConstraints(duration, resolutionDirection, anchor) {\r\n    duration = duration !== undefined ? duration : 200;\r\n    const direction = resolutionDirection || 0;\r\n\r\n    const newRotation = this.constraints_.rotation(this.targetRotation_);\r\n    const size = this.getViewportSize_(newRotation);\r\n    const newResolution = this.constraints_.resolution(\r\n      this.targetResolution_,\r\n      direction,\r\n      size,\r\n    );\r\n    const newCenter = this.constraints_.center(\r\n      this.targetCenter_,\r\n      newResolution,\r\n      size,\r\n      false,\r\n      this.calculateCenterShift(\r\n        this.targetCenter_,\r\n        newResolution,\r\n        newRotation,\r\n        size,\r\n      ),\r\n    );\r\n\r\n    if (duration === 0 && !this.cancelAnchor_) {\r\n      this.targetResolution_ = newResolution;\r\n      this.targetRotation_ = newRotation;\r\n      this.targetCenter_ = newCenter;\r\n      this.applyTargetState_();\r\n      return;\r\n    }\r\n\r\n    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);\r\n    this.cancelAnchor_ = undefined;\r\n\r\n    if (\r\n      this.getResolution() !== newResolution ||\r\n      this.getRotation() !== newRotation ||\r\n      !this.getCenterInternal() ||\r\n      !equals(this.getCenterInternal(), newCenter)\r\n    ) {\r\n      if (this.getAnimating()) {\r\n        this.cancelAnimations();\r\n      }\r\n\r\n      this.animateInternal({\r\n        rotation: newRotation,\r\n        center: newCenter,\r\n        resolution: newResolution,\r\n        duration: duration,\r\n        easing: easeOut,\r\n        anchor: anchor,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notify the View that an interaction has started.\r\n   * The view state will be resolved to a stable one if needed\r\n   * (depending on its constraints).\r\n   * @api\r\n   */\r\n  beginInteraction() {\r\n    this.resolveConstraints(0);\r\n\r\n    this.setHint(ViewHint.INTERACTING, 1);\r\n  }\r\n\r\n  /**\r\n   * Notify the View that an interaction has ended. The view state will be resolved\r\n   * to a stable one if needed (depending on its constraints).\r\n   * @param {number} [duration] Animation duration in ms.\r\n   * @param {number} [resolutionDirection] Which direction to zoom.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   * @api\r\n   */\r\n  endInteraction(duration, resolutionDirection, anchor) {\r\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\r\n    this.endInteractionInternal(duration, resolutionDirection, anchor);\r\n  }\r\n\r\n  /**\r\n   * Notify the View that an interaction has ended. The view state will be resolved\r\n   * to a stable one if needed (depending on its constraints).\r\n   * @param {number} [duration] Animation duration in ms.\r\n   * @param {number} [resolutionDirection] Which direction to zoom.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   */\r\n  endInteractionInternal(duration, resolutionDirection, anchor) {\r\n    if (!this.getInteracting()) {\r\n      return;\r\n    }\r\n    this.setHint(ViewHint.INTERACTING, -1);\r\n    this.resolveConstraints(duration, resolutionDirection, anchor);\r\n  }\r\n\r\n  /**\r\n   * Get a valid position for the view center according to the current constraints.\r\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} targetCenter Target center position.\r\n   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.\r\n   * This is useful to guess a valid center position at a different zoom level.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Valid center position.\r\n   */\r\n  getConstrainedCenter(targetCenter, targetResolution) {\r\n    const size = this.getViewportSize_(this.getRotation());\r\n    return this.constraints_.center(\r\n      targetCenter,\r\n      targetResolution || this.getResolution(),\r\n      size,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get a valid zoom level according to the current view constraints.\r\n   * @param {number|undefined} targetZoom Target zoom.\r\n   * @param {number} [direction=0] Indicate which resolution should be used\r\n   * by a renderer if the view resolution does not match any resolution of the tile source.\r\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\r\n   * will be used. If -1, the nearest higher resolution will be used.\r\n   * @return {number|undefined} Valid zoom level.\r\n   */\r\n  getConstrainedZoom(targetZoom, direction) {\r\n    const targetRes = this.getResolutionForZoom(targetZoom);\r\n    return this.getZoomForResolution(\r\n      this.getConstrainedResolution(targetRes, direction),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get a valid resolution according to the current view constraints.\r\n   * @param {number|undefined} targetResolution Target resolution.\r\n   * @param {number} [direction=0] Indicate which resolution should be used\r\n   * by a renderer if the view resolution does not match any resolution of the tile source.\r\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\r\n   * will be used. If -1, the nearest higher resolution will be used.\r\n   * @return {number|undefined} Valid resolution.\r\n   */\r\n  getConstrainedResolution(targetResolution, direction) {\r\n    direction = direction || 0;\r\n    const size = this.getViewportSize_(this.getRotation());\r\n\r\n    return this.constraints_.resolution(targetResolution, direction, size);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Function} callback Callback.\r\n * @param {*} returnValue Return value.\r\n */\r\nfunction animationCallback(callback, returnValue) {\r\n  setTimeout(function () {\r\n    callback(returnValue);\r\n  }, 0);\r\n}\r\n\r\n/**\r\n * @param {ViewOptions} options View options.\r\n * @return {import(\"./centerconstraint.js\").Type} The constraint.\r\n */\r\nexport function createCenterConstraint(options) {\r\n  if (options.extent !== undefined) {\r\n    const smooth =\r\n      options.smoothExtentConstraint !== undefined\r\n        ? options.smoothExtentConstraint\r\n        : true;\r\n    return createExtent(options.extent, options.constrainOnlyCenter, smooth);\r\n  }\r\n\r\n  const projection = createProjection(options.projection, 'EPSG:3857');\r\n  if (options.multiWorld !== true && projection.isGlobal()) {\r\n    const extent = projection.getExtent().slice();\r\n    extent[0] = -Infinity;\r\n    extent[2] = Infinity;\r\n    return createExtent(extent, false, false);\r\n  }\r\n\r\n  return centerNone;\r\n}\r\n\r\n/**\r\n * @param {ViewOptions} options View options.\r\n * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\r\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\r\n */\r\nexport function createResolutionConstraint(options) {\r\n  let resolutionConstraint;\r\n  let maxResolution;\r\n  let minResolution;\r\n\r\n  // TODO: move these to be ol constants\r\n  // see https://github.com/openlayers/openlayers/issues/2076\r\n  const defaultMaxZoom = 28;\r\n  const defaultZoomFactor = 2;\r\n\r\n  let minZoom =\r\n    options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\r\n\r\n  let maxZoom =\r\n    options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\r\n\r\n  const zoomFactor =\r\n    options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\r\n\r\n  const multiWorld =\r\n    options.multiWorld !== undefined ? options.multiWorld : false;\r\n\r\n  const smooth =\r\n    options.smoothResolutionConstraint !== undefined\r\n      ? options.smoothResolutionConstraint\r\n      : true;\r\n\r\n  const showFullExtent =\r\n    options.showFullExtent !== undefined ? options.showFullExtent : false;\r\n\r\n  const projection = createProjection(options.projection, 'EPSG:3857');\r\n  const projExtent = projection.getExtent();\r\n  let constrainOnlyCenter = options.constrainOnlyCenter;\r\n  let extent = options.extent;\r\n  if (!multiWorld && !extent && projection.isGlobal()) {\r\n    constrainOnlyCenter = false;\r\n    extent = projExtent;\r\n  }\r\n\r\n  if (options.resolutions !== undefined) {\r\n    const resolutions = options.resolutions;\r\n    maxResolution = resolutions[minZoom];\r\n    minResolution =\r\n      resolutions[maxZoom] !== undefined\r\n        ? resolutions[maxZoom]\r\n        : resolutions[resolutions.length - 1];\r\n\r\n    if (options.constrainResolution) {\r\n      resolutionConstraint = createSnapToResolutions(\r\n        resolutions,\r\n        smooth,\r\n        !constrainOnlyCenter && extent,\r\n        showFullExtent,\r\n      );\r\n    } else {\r\n      resolutionConstraint = createMinMaxResolution(\r\n        maxResolution,\r\n        minResolution,\r\n        smooth,\r\n        !constrainOnlyCenter && extent,\r\n        showFullExtent,\r\n      );\r\n    }\r\n  } else {\r\n    // calculate the default min and max resolution\r\n    const size = !projExtent\r\n      ? // use an extent that can fit the whole world if need be\r\n        (360 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit()\r\n      : Math.max(getWidth(projExtent), getHeight(projExtent));\r\n\r\n    const defaultMaxResolution =\r\n      size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\r\n\r\n    const defaultMinResolution =\r\n      defaultMaxResolution /\r\n      Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\r\n\r\n    // user provided maxResolution takes precedence\r\n    maxResolution = options.maxResolution;\r\n    if (maxResolution !== undefined) {\r\n      minZoom = 0;\r\n    } else {\r\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\r\n    }\r\n\r\n    // user provided minResolution takes precedence\r\n    minResolution = options.minResolution;\r\n    if (minResolution === undefined) {\r\n      if (options.maxZoom !== undefined) {\r\n        if (options.maxResolution !== undefined) {\r\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\r\n        } else {\r\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\r\n        }\r\n      } else {\r\n        minResolution = defaultMinResolution;\r\n      }\r\n    }\r\n\r\n    // given discrete zoom levels, minResolution may be different than provided\r\n    maxZoom =\r\n      minZoom +\r\n      Math.floor(\r\n        Math.log(maxResolution / minResolution) / Math.log(zoomFactor),\r\n      );\r\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\r\n\r\n    if (options.constrainResolution) {\r\n      resolutionConstraint = createSnapToPower(\r\n        zoomFactor,\r\n        maxResolution,\r\n        minResolution,\r\n        smooth,\r\n        !constrainOnlyCenter && extent,\r\n        showFullExtent,\r\n      );\r\n    } else {\r\n      resolutionConstraint = createMinMaxResolution(\r\n        maxResolution,\r\n        minResolution,\r\n        smooth,\r\n        !constrainOnlyCenter && extent,\r\n        showFullExtent,\r\n      );\r\n    }\r\n  }\r\n  return {\r\n    constraint: resolutionConstraint,\r\n    maxResolution: maxResolution,\r\n    minResolution: minResolution,\r\n    minZoom: minZoom,\r\n    zoomFactor: zoomFactor,\r\n  };\r\n}\r\n\r\n/**\r\n * @param {ViewOptions} options View options.\r\n * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\r\n */\r\nexport function createRotationConstraint(options) {\r\n  const enableRotation =\r\n    options.enableRotation !== undefined ? options.enableRotation : true;\r\n  if (enableRotation) {\r\n    const constrainRotation = options.constrainRotation;\r\n    if (constrainRotation === undefined || constrainRotation === true) {\r\n      return createSnapToZero();\r\n    }\r\n    if (constrainRotation === false) {\r\n      return rotationNone;\r\n    }\r\n    if (typeof constrainRotation === 'number') {\r\n      return createSnapToN(constrainRotation);\r\n    }\r\n    return rotationNone;\r\n  }\r\n  return disable;\r\n}\r\n\r\n/**\r\n * Determine if an animation involves no view change.\r\n * @param {Animation} animation The animation.\r\n * @return {boolean} The animation involves no view change.\r\n */\r\nexport function isNoopAnimation(animation) {\r\n  if (animation.sourceCenter && animation.targetCenter) {\r\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\r\n      return false;\r\n    }\r\n  }\r\n  if (animation.sourceResolution !== animation.targetResolution) {\r\n    return false;\r\n  }\r\n  if (animation.sourceRotation !== animation.targetRotation) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {import(\"./size.js\").Size} size Box pixel size.\r\n * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @return {import(\"./coordinate.js\").Coordinate} Shifted center.\r\n */\r\nfunction calculateCenterOn(coordinate, size, position, resolution, rotation) {\r\n  // calculate rotated position\r\n  const cosAngle = Math.cos(-rotation);\r\n  let sinAngle = Math.sin(-rotation);\r\n  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\r\n  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\r\n  rotX += (size[0] / 2 - position[0]) * resolution;\r\n  rotY += (position[1] - size[1] / 2) * resolution;\r\n\r\n  // go back to original angle\r\n  sinAngle = -sinAngle; // go back to original rotation\r\n  const centerX = rotX * cosAngle - rotY * sinAngle;\r\n  const centerY = rotY * cosAngle + rotX * sinAngle;\r\n\r\n  return [centerX, centerY];\r\n}\r\n\r\nexport default View;\r\n","/**\r\n * @module CME2D/layer/Layer\r\n */\r\nimport BaseLayer from './Base.js';\r\nimport EventType from '../events/EventType.js';\r\nimport LayerProperty from './Property.js';\r\nimport RenderEventType from '../render/EventType.js';\r\nimport View from '../View.js';\r\nimport {assert} from '../asserts.js';\r\nimport {intersects} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {function(import(\"../Map.js\").FrameState):HTMLElement} RenderFunction\r\n */\r\n\r\n/**\r\n * @typedef {'sourceready'|'change:source'} LayerEventType\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\r\n *     LayerEventType, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|LayerEventType|\r\n *     import(\"../render/EventType\").LayerRenderEventTypes, Return>} LayerOnSignature\r\n */\r\n\r\n/**\r\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,\r\n * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after\r\n * construction.\r\n * @property {import(\"../Map.js\").default|null} [map] Map.\r\n * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an\r\n * HTML element. Will overwrite the default rendering for the layer.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @typedef {Object} State\r\n * @property {import(\"./Layer.js\").default} layer Layer.\r\n * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.\r\n * @property {boolean} visible Visible.\r\n * @property {boolean} managed Managed.\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\r\n * @property {number} zIndex ZIndex.\r\n * @property {number} maxResolution Maximum resolution.\r\n * @property {number} minResolution Minimum resolution.\r\n * @property {number} minZoom Minimum zoom.\r\n * @property {number} maxZoom Maximum zoom.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class from which all layer types are derived. This should only be instantiated\r\n * in the case where a custom layer is added to the map with a custom `render` function.\r\n * Such a function can be specified in the `options` object, and is expected to return an HTML element.\r\n *\r\n * A visual representation of raster or vector map data.\r\n * Layers group together those properties that pertain to how the data is to be\r\n * displayed, irrespective of the source of that data.\r\n *\r\n * Layers are usually added to a map with [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\r\n * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers\r\n * internally. These unmanaged layers are associated with the map using\r\n * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.\r\n *\r\n * A generic `change` event is fired when the state of the source changes.\r\n * A `sourceready` event is fired when the layer's source is ready.\r\n *\r\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\r\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\r\n * @fires import(\"../events/Event.js\").BaseEvent#sourceready\r\n *\r\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\r\n * @template {import(\"../renderer/Layer.js\").default} [RendererType=import(\"../renderer/Layer.js\").default]\r\n * @api\r\n */\r\nclass Layer extends BaseLayer {\r\n  /**\r\n   * @param {Options<SourceType>} options Layer options.\r\n   */\r\n  constructor(options) {\r\n    const baseOptions = Object.assign({}, options);\r\n    delete baseOptions.source;\r\n\r\n    super(baseOptions);\r\n\r\n    /***\r\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {LayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.mapPrecomposeKey_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.mapRenderKey_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.sourceChangeKey_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {RendererType}\r\n     */\r\n    this.renderer_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.sourceReady_ = false;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {boolean}\r\n     */\r\n    this.rendered = false;\r\n\r\n    // Overwrite default render method with a custom one\r\n    if (options.render) {\r\n      this.render = options.render;\r\n    }\r\n\r\n    if (options.map) {\r\n      this.setMap(options.map);\r\n    }\r\n\r\n    this.addChangeListener(\r\n      LayerProperty.SOURCE,\r\n      this.handleSourcePropertyChange_,\r\n    );\r\n\r\n    const source = options.source\r\n      ? /** @type {SourceType} */ (options.source)\r\n      : null;\r\n    this.setSource(source);\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\r\n   * @override\r\n   */\r\n  getLayersArray(array) {\r\n    array = array ? array : [];\r\n    array.push(this);\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer states (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\r\n   * @override\r\n   */\r\n  getLayerStatesArray(states) {\r\n    states = states ? states : [];\r\n    states.push(this.getLayerState());\r\n    return states;\r\n  }\r\n\r\n  /**\r\n   * Get the layer source.\r\n   * @return {SourceType|null} The layer source (or `null` if not yet set).\r\n   * @observable\r\n   * @api\r\n   */\r\n  getSource() {\r\n    return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;\r\n  }\r\n\r\n  /**\r\n   * @return {SourceType|null} The source being rendered.\r\n   */\r\n  getRenderSource() {\r\n    return this.getSource();\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../source/Source.js\").State} Source state.\r\n   * @override\r\n   */\r\n  getSourceState() {\r\n    const source = this.getSource();\r\n    return !source ? 'undefined' : source.getState();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleSourceChange_() {\r\n    this.changed();\r\n    if (this.sourceReady_ || this.getSource().getState() !== 'ready') {\r\n      return;\r\n    }\r\n    this.sourceReady_ = true;\r\n    this.dispatchEvent('sourceready');\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleSourcePropertyChange_() {\r\n    if (this.sourceChangeKey_) {\r\n      unlistenByKey(this.sourceChangeKey_);\r\n      this.sourceChangeKey_ = null;\r\n    }\r\n    this.sourceReady_ = false;\r\n    const source = this.getSource();\r\n    if (source) {\r\n      this.sourceChangeKey_ = listen(\r\n        source,\r\n        EventType.CHANGE,\r\n        this.handleSourceChange_,\r\n        this,\r\n      );\r\n      if (source.getState() === 'ready') {\r\n        this.sourceReady_ = true;\r\n        setTimeout(() => {\r\n          this.dispatchEvent('sourceready');\r\n        }, 0);\r\n      }\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\r\n   * an array of features.\r\n   */\r\n  getFeatures(pixel) {\r\n    if (!this.renderer_) {\r\n      return Promise.resolve([]);\r\n    }\r\n    return this.renderer_.getFeatures(pixel);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   */\r\n  getData(pixel) {\r\n    if (!this.renderer_ || !this.rendered) {\r\n      return null;\r\n    }\r\n    return this.renderer_.getData(pixel);\r\n  }\r\n\r\n  /**\r\n   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and\r\n   * extent, not set to `visible: false`, and not inside a layer group that is set\r\n   * to `visible: false`.\r\n   * @param {View|import(\"../View.js\").ViewStateLayerStateExtent} [view] View or {@link import(\"../Map.js\").FrameState}.\r\n   * Only required when the layer is not added to a map.\r\n   * @return {boolean} The layer is visible in the map view.\r\n   * @api\r\n   */\r\n  isVisible(view) {\r\n    let frameState;\r\n    const map = this.getMapInternal();\r\n    if (!view && map) {\r\n      view = map.getView();\r\n    }\r\n    if (view instanceof View) {\r\n      frameState = {\r\n        viewState: view.getState(),\r\n        extent: view.calculateExtent(),\r\n      };\r\n    } else {\r\n      frameState = view;\r\n    }\r\n    if (!frameState.layerStatesArray && map) {\r\n      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();\r\n    }\r\n    let layerState;\r\n    if (frameState.layerStatesArray) {\r\n      layerState = frameState.layerStatesArray.find(\r\n        (layerState) => layerState.layer === this,\r\n      );\r\n    } else {\r\n      layerState = this.getLayerState();\r\n    }\r\n\r\n    const layerExtent = this.getExtent();\r\n\r\n    return (\r\n      inView(layerState, frameState.viewState) &&\r\n      (!layerExtent || intersects(layerExtent, frameState.extent))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the attributions of the source of this layer for the given view.\r\n   * @param {View|import(\"../View.js\").ViewStateLayerStateExtent} [view] View or {@link import(\"../Map.js\").FrameState}.\r\n   * Only required when the layer is not added to a map.\r\n   * @return {Array<string>} Attributions for this layer at the given view.\r\n   * @api\r\n   */\r\n  getAttributions(view) {\r\n    if (!this.isVisible(view)) {\r\n      return [];\r\n    }\r\n    const getAttributions = this.getSource()?.getAttributions();\r\n    if (!getAttributions) {\r\n      return [];\r\n    }\r\n    const frameState =\r\n      view instanceof View ? view.getViewStateAndExtent() : view;\r\n    let attributions = getAttributions(frameState);\r\n    if (!Array.isArray(attributions)) {\r\n      attributions = [attributions];\r\n    }\r\n    return attributions;\r\n  }\r\n\r\n  /**\r\n   * In charge to manage the rendering of the layer. One layer type is\r\n   * bounded with one layer renderer.\r\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\r\n   * for rendering its content.\r\n   * @return {HTMLElement|null} The rendered element.\r\n   */\r\n  render(frameState, target) {\r\n    const layerRenderer = this.getRenderer();\r\n\r\n    if (layerRenderer.prepareFrame(frameState)) {\r\n      this.rendered = true;\r\n      return layerRenderer.renderFrame(frameState, target);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Called when a layer is not visible during a map render.\r\n   */\r\n  unrender() {\r\n    this.rendered = false;\r\n  }\r\n\r\n  /** @return {string} Declutter */\r\n  getDeclutter() {\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../layer/Layer.js\").State} layerState Layer state.\r\n   */\r\n  renderDeclutter(frameState, layerState) {}\r\n\r\n  /**\r\n   * When the renderer follows a layout -> render approach, do the final rendering here.\r\n   * @param {import('../Map.js').FrameState} frameState Frame state\r\n   */\r\n  renderDeferred(frameState) {\r\n    const layerRenderer = this.getRenderer();\r\n    if (!layerRenderer) {\r\n      return;\r\n    }\r\n    layerRenderer.renderDeferred(frameState);\r\n  }\r\n\r\n  /**\r\n   * For use inside the library only.\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   */\r\n  setMapInternal(map) {\r\n    if (!map) {\r\n      this.unrender();\r\n    }\r\n    this.set(LayerProperty.MAP, map);\r\n  }\r\n\r\n  /**\r\n   * For use inside the library only.\r\n   * @return {import(\"../Map.js\").default|null} Map.\r\n   */\r\n  getMapInternal() {\r\n    return this.get(LayerProperty.MAP);\r\n  }\r\n\r\n  /**\r\n   * Sets the layer to be rendered on top of other layers on a map. The map will\r\n   * not manage this layer in its layers collection. This\r\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\r\n   * use `#setMap(null)`.\r\n   *\r\n   * To add the layer to a map and have it managed by the map, use\r\n   * {@link module:ol/Map~Map#addLayer} instead.\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   * @api\r\n   */\r\n  setMap(map) {\r\n    if (this.mapPrecomposeKey_) {\r\n      unlistenByKey(this.mapPrecomposeKey_);\r\n      this.mapPrecomposeKey_ = null;\r\n    }\r\n    if (!map) {\r\n      this.changed();\r\n    }\r\n    if (this.mapRenderKey_) {\r\n      unlistenByKey(this.mapRenderKey_);\r\n      this.mapRenderKey_ = null;\r\n    }\r\n    if (map) {\r\n      this.mapPrecomposeKey_ = listen(\r\n        map,\r\n        RenderEventType.PRECOMPOSE,\r\n        (evt) => {\r\n          const renderEvent =\r\n            /** @type {import(\"../render/Event.js\").default} */ (evt);\r\n          const layerStatesArray = renderEvent.frameState.layerStatesArray;\r\n          const layerState = this.getLayerState(false);\r\n          assert(\r\n            !layerStatesArray.some(function (arrayLayerState) {\r\n              return arrayLayerState.layer === layerState.layer;\r\n            }),\r\n            'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.',\r\n          );\r\n          layerStatesArray.push(layerState);\r\n        },\r\n      );\r\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the layer source.\r\n   * @param {SourceType|null} source The layer source.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setSource(source) {\r\n    this.set(LayerProperty.SOURCE, source);\r\n  }\r\n\r\n  /**\r\n   * Get the renderer for this layer.\r\n   * @return {RendererType|null} The layer renderer.\r\n   */\r\n  getRenderer() {\r\n    if (!this.renderer_) {\r\n      this.renderer_ = this.createRenderer();\r\n    }\r\n    return this.renderer_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} The layer has a renderer.\r\n   */\r\n  hasRenderer() {\r\n    return !!this.renderer_;\r\n  }\r\n\r\n  /**\r\n   * Create a renderer for this layer.\r\n   * @return {RendererType} A layer renderer.\r\n   * @protected\r\n   */\r\n  createRenderer() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    if (this.renderer_) {\r\n      this.renderer_.dispose();\r\n      delete this.renderer_;\r\n    }\r\n\r\n    this.setSource(null);\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\n/**\r\n * Return `true` if the layer is visible and if the provided view state\r\n * has resolution and zoom levels that are in range of the layer's min/max.\r\n * @param {State} layerState Layer state.\r\n * @param {import(\"../View.js\").State} viewState View state.\r\n * @return {boolean} The layer is visible at the given view state.\r\n */\r\nexport function inView(layerState, viewState) {\r\n  if (!layerState.visible) {\r\n    return false;\r\n  }\r\n  const resolution = viewState.resolution;\r\n  if (\r\n    resolution < layerState.minResolution ||\r\n    resolution >= layerState.maxResolution\r\n  ) {\r\n    return false;\r\n  }\r\n  const zoom = viewState.zoom;\r\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\r\n}\r\n\r\nexport default Layer;\r\n","/**\r\n * @module CME2D/layer/TileProperty\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  PRELOAD: 'preload',\r\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\r\n};\r\n","/**\r\n * @module CME2D/layer/BaseTile\r\n */\r\nimport Layer from './Layer.js';\r\nimport TileProperty from './TileProperty.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\r\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\r\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\r\n */\r\n\r\n/**\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\r\n * means no preloading.\r\n * @property {TileSourceType} [source] Source for this layer.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\r\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\r\n * two zoom levels worth of tiles.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @template {import(\"../renderer/Layer.js\").default} RendererType\r\n * @extends {Layer<TileSourceType, RendererType>}\r\n * @api\r\n */\r\nclass BaseTileLayer extends Layer {\r\n  /**\r\n   * @param {Options<TileSourceType>} [options] Tile layer options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    const baseOptions = Object.assign({}, options);\r\n\r\n    const cacheSize = options.cacheSize;\r\n    delete options.cacheSize;\r\n\r\n    delete baseOptions.preload;\r\n    delete baseOptions.useInterimTilesOnError;\r\n    super(baseOptions);\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @type {number|undefined}\r\n     * @private\r\n     */\r\n    this.cacheSize_ = cacheSize;\r\n\r\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\r\n    this.setUseInterimTilesOnError(\r\n      options.useInterimTilesOnError !== undefined\r\n        ? options.useInterimTilesOnError\r\n        : true,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {number|undefined} The suggested cache size\r\n   * @protected\r\n   */\r\n  getCacheSize() {\r\n    return this.cacheSize_;\r\n  }\r\n\r\n  /**\r\n   * Return the level as number to which we will preload tiles up to.\r\n   * @return {number} The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getPreload() {\r\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\r\n  }\r\n\r\n  /**\r\n   * Set the level as number to which we will preload tiles up to.\r\n   * @param {number} preload The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setPreload(preload) {\r\n    this.set(TileProperty.PRELOAD, preload);\r\n  }\r\n\r\n  /**\r\n   * Deprecated.  Whether we use interim tiles on error.\r\n   * @return {boolean} Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getUseInterimTilesOnError() {\r\n    return /** @type {boolean} */ (\r\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Deprecated.  Set whether we use interim tiles on error.\r\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setUseInterimTilesOnError(useInterimTilesOnError) {\r\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\r\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\r\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\r\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\r\n   *\r\n   * ```js\r\n   * // display layer data on every pointer move\r\n   * map.on('pointermove', (event) => {\r\n   *   console.log(layer.getData(event.pixel));\r\n   * });\r\n   * ```\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   * @api\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    return super.getData(pixel);\r\n  }\r\n}\r\n\r\nexport default BaseTileLayer;\r\n","/**\r\n * @module CME2D/reproj/Tile\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport EventType from '../events/EventType.js';\r\nimport Tile from '../Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {\r\n  calculateSourceExtentResolution,\r\n  canvasPool,\r\n  render as renderReprojected,\r\n} from '../reproj.js';\r\nimport {clamp} from '../math.js';\r\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\nimport {releaseCanvas} from '../dom.js';\r\n\r\n/**\r\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\r\n */\r\n\r\n/**\r\n * @typedef {Object} TileOffset\r\n * @property {import(\"../ImageTile.js\").default} tile Tile.\r\n * @property {number} offset Offset.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected tile.\r\n * See {@link module:ol/source/TileImage~TileImage}.\r\n *\r\n */\r\nclass ReprojTile extends Tile {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {number} gutter Gutter of the source tiles.\r\n   * @param {FunctionType} getTileFunction\r\n   *     Function returning source tiles (z, x, y, pixelRatio).\r\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\r\n   * @param {boolean} [renderEdges] Render reprojection edges.\r\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    sourceTileGrid,\r\n    targetProj,\r\n    targetTileGrid,\r\n    tileCoord,\r\n    wrappedTileCoord,\r\n    pixelRatio,\r\n    gutter,\r\n    getTileFunction,\r\n    errorThreshold,\r\n    renderEdges,\r\n    options,\r\n  ) {\r\n    super(tileCoord, TileState.IDLE, options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = pixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = gutter;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.sourceTileGrid_ = sourceTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.targetTileGrid_ = targetTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilecoord.js\").TileCoord}\r\n     */\r\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<TileOffset>}\r\n     */\r\n    this.sourceTiles_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.sourcesListenerKeys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourceZ_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.clipExtent_ = sourceProj.canWrapX()\r\n      ? sourceProj.getExtent()\r\n      : undefined;\r\n\r\n    const targetExtent = targetTileGrid.getTileCoordExtent(\r\n      this.wrappedTileCoord_,\r\n    );\r\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\r\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    if (getArea(limitedTargetExtent) === 0) {\r\n      // Tile is completely outside range -> EMPTY\r\n      // TODO: is it actually correct that the source even creates the tile ?\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const sourceProjExtent = sourceProj.getExtent();\r\n    if (sourceProjExtent) {\r\n      if (!maxSourceExtent) {\r\n        maxSourceExtent = sourceProjExtent;\r\n      } else {\r\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\r\n      }\r\n    }\r\n\r\n    const targetResolution = targetTileGrid.getResolution(\r\n      this.wrappedTileCoord_[0],\r\n    );\r\n\r\n    const sourceResolution = calculateSourceExtentResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      targetResolution,\r\n    );\r\n\r\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n      // invalid sourceResolution -> EMPTY\r\n      // probably edges of the projections when no extent is defined\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const errorThresholdInPixels =\r\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution,\r\n    );\r\n\r\n    if (this.triangulation_.getTriangles().length === 0) {\r\n      // no valid triangles -> EMPTY\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\r\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\r\n\r\n    if (maxSourceExtent) {\r\n      if (sourceProj.canWrapX()) {\r\n        sourceExtent[1] = clamp(\r\n          sourceExtent[1],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n        sourceExtent[3] = clamp(\r\n          sourceExtent[3],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n      } else {\r\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\r\n      }\r\n    }\r\n\r\n    if (!getArea(sourceExtent)) {\r\n      this.state = TileState.EMPTY;\r\n    } else {\r\n      let worldWidth = 0;\r\n      let worldsAway = 0;\r\n      if (sourceProj.canWrapX()) {\r\n        worldWidth = getWidth(sourceProjExtent);\r\n        worldsAway = Math.floor(\r\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\r\n        );\r\n      }\r\n\r\n      const sourceExtents = wrapAndSliceX(\r\n        sourceExtent.slice(),\r\n        sourceProj,\r\n        true,\r\n      );\r\n      sourceExtents.forEach((extent) => {\r\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\r\n          extent,\r\n          this.sourceZ_,\r\n        );\r\n\r\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\r\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\r\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\r\n            if (tile) {\r\n              const offset = worldsAway * worldWidth;\r\n              this.sourceTiles_.push({tile, offset});\r\n            }\r\n          }\r\n        }\r\n        ++worldsAway;\r\n      });\r\n\r\n      if (this.sourceTiles_.length === 0) {\r\n        this.state = TileState.EMPTY;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the HTML Canvas element for this tile.\r\n   * @return {HTMLCanvasElement} Canvas.\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const sources = [];\r\n    this.sourceTiles_.forEach((source) => {\r\n      const tile = source.tile;\r\n      if (tile && tile.getState() == TileState.LOADED) {\r\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\r\n        extent[0] += source.offset;\r\n        extent[2] += source.offset;\r\n        const clipExtent = this.clipExtent_?.slice();\r\n        if (clipExtent) {\r\n          clipExtent[0] += source.offset;\r\n          clipExtent[2] += source.offset;\r\n        }\r\n        sources.push({\r\n          extent: extent,\r\n          clipExtent: clipExtent,\r\n          image: tile.getImage(),\r\n        });\r\n      }\r\n    });\r\n    this.sourceTiles_.length = 0;\r\n\r\n    if (sources.length === 0) {\r\n      this.state = TileState.ERROR;\r\n    } else {\r\n      const z = this.wrappedTileCoord_[0];\r\n      const size = this.targetTileGrid_.getTileSize(z);\r\n      const width = typeof size === 'number' ? size : size[0];\r\n      const height = typeof size === 'number' ? size : size[1];\r\n      const targetResolution = this.targetTileGrid_.getResolution(z);\r\n      const sourceResolution = this.sourceTileGrid_.getResolution(\r\n        this.sourceZ_,\r\n      );\r\n\r\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n        this.wrappedTileCoord_,\r\n      );\r\n\r\n      this.canvas_ = renderReprojected(\r\n        width,\r\n        height,\r\n        this.pixelRatio_,\r\n        sourceResolution,\r\n        this.sourceTileGrid_.getExtent(),\r\n        targetResolution,\r\n        targetExtent,\r\n        this.triangulation_,\r\n        sources,\r\n        this.gutter_,\r\n        this.renderEdges_,\r\n        this.interpolate,\r\n      );\r\n\r\n      this.state = TileState.LOADED;\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      this.changed();\r\n\r\n      let leftToLoad = 0;\r\n\r\n      this.sourcesListenerKeys_ = [];\r\n      this.sourceTiles_.forEach(({tile}) => {\r\n        const state = tile.getState();\r\n        if (state == TileState.IDLE || state == TileState.LOADING) {\r\n          leftToLoad++;\r\n\r\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\r\n            const state = tile.getState();\r\n            if (\r\n              state == TileState.LOADED ||\r\n              state == TileState.ERROR ||\r\n              state == TileState.EMPTY\r\n            ) {\r\n              unlistenByKey(sourceListenKey);\r\n              leftToLoad--;\r\n              if (leftToLoad === 0) {\r\n                this.unlistenSources_();\r\n                this.reproject_();\r\n              }\r\n            }\r\n          });\r\n          this.sourcesListenerKeys_.push(sourceListenKey);\r\n        }\r\n      });\r\n\r\n      if (leftToLoad === 0) {\r\n        setTimeout(this.reproject_.bind(this), 0);\r\n      } else {\r\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\r\n          const state = tile.getState();\r\n          if (state == TileState.IDLE) {\r\n            tile.load();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSources_() {\r\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\r\n    this.sourcesListenerKeys_ = null;\r\n  }\r\n\r\n  /**\r\n   * Remove from the cache due to expiry\r\n   * @override\r\n   */\r\n  release() {\r\n    if (this.canvas_) {\r\n      releaseCanvas(this.canvas_.getContext('2d'));\r\n      canvasPool.push(this.canvas_);\r\n      this.canvas_ = null;\r\n    }\r\n    super.release();\r\n  }\r\n}\r\n\r\nexport default ReprojTile;\r\n","/**\r\n * @module CME2D/ImageState\r\n */\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nexport default {\r\n  IDLE: 0,\r\n  LOADING: 1,\r\n  LOADED: 2,\r\n  ERROR: 3,\r\n  EMPTY: 4,\r\n};\r\n","/**\r\n * @module CME2D/Image\r\n */\r\nimport EventTarget from './events/Target.js';\r\nimport EventType from './events/EventType.js';\r\nimport ImageState from './ImageState.js';\r\nimport {CREATE_IMAGE_BITMAP, IMAGE_DECODE} from './has.js';\r\nimport {listenOnce, unlistenByKey} from './events.js';\r\nimport {toPromise} from './functions.js';\r\n\r\n/**\r\n * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a\r\n * `{string}` for the src as arguments. It is supposed to make it so the\r\n * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the\r\n * content specified by the src. If not specified, the default is\r\n *\r\n *     function(image, src) {\r\n *       image.getImage().src = src;\r\n *     }\r\n *\r\n * Providing a custom `imageLoadFunction` can be useful to load images with\r\n * post requests or - in general - through XHR requests, where the src of the\r\n * image element would be set to a data URI when the content is loaded.\r\n *\r\n * @typedef {function(import(\"./Image.js\").default, string): void} LoadFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {Object} ImageObject\r\n * @property {import(\"./extent.js\").Extent} [extent] Extent, if different from the requested one.\r\n * @property {import(\"./resolution.js\").ResolutionLike} [resolution] Resolution, if different from the requested one.\r\n * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).\r\n * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.\r\n * @property {import('./DataTile.js').ImageLike} image Image.\r\n */\r\n\r\n/**\r\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\r\n * For images that cover any extent and resolution (static images), the loader function should not accept\r\n * any arguments. The function returns an {@link import(\"./DataTile.js\").ImageLike image}, an\r\n * {@link import(\"./Image.js\").ImageObject image object}, or a promise for the same.\r\n * For loaders that generate images, the promise should not resolve until the image is loaded.\r\n * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,\r\n * it has to return an {@link import(\"./Image.js\").ImageObject image object} with the `image` and the\r\n * correct `extent`, `resolution` and `pixelRatio`.\r\n *\r\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} Loader\r\n * @api\r\n */\r\n\r\n/**\r\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\r\n * The function returns a promise for an  {@link import(\"./Image.js\").ImageObject image object}.\r\n *\r\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} ImageObjectPromiseLoader\r\n */\r\n\r\nclass ImageWrapper extends EventTarget {\r\n  /**\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y\r\n   * resolution will be assumed.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"./ImageState.js\").default|import(\"./Image.js\").Loader} stateOrLoader State.\r\n   */\r\n  constructor(extent, resolution, pixelRatio, stateOrLoader) {\r\n    super();\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./extent.js\").Extent}\r\n     */\r\n    this.extent = extent;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = pixelRatio;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number|Array<number>|undefined}\r\n     */\r\n    this.resolution = resolution;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./ImageState.js\").default}\r\n     */\r\n    this.state =\r\n      typeof stateOrLoader === 'function' ? ImageState.IDLE : stateOrLoader;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import('./DataTile.js').ImageLike|null}\r\n     */\r\n    this.image_ = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./Image.js\").Loader}\r\n     */\r\n    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  changed() {\r\n    this.dispatchEvent(EventType.CHANGE);\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./extent.js\").Extent} Extent.\r\n   */\r\n  getExtent() {\r\n    return this.extent;\r\n  }\r\n\r\n  /**\r\n   * @return {import('./DataTile.js').ImageLike} Image.\r\n   */\r\n  getImage() {\r\n    return this.image_;\r\n  }\r\n\r\n  /**\r\n   * @return {number} PixelRatio.\r\n   */\r\n  getPixelRatio() {\r\n    return this.pixelRatio_;\r\n  }\r\n\r\n  /**\r\n   * @return {number|Array<number>} Resolution.\r\n   */\r\n  getResolution() {\r\n    return /** @type {number} */ (this.resolution);\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./ImageState.js\").default} State.\r\n   */\r\n  getState() {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   */\r\n  load() {\r\n    if (this.state == ImageState.IDLE) {\r\n      if (this.loader) {\r\n        this.state = ImageState.LOADING;\r\n        this.changed();\r\n        const resolution = this.getResolution();\r\n        const requestResolution = Array.isArray(resolution)\r\n          ? resolution[0]\r\n          : resolution;\r\n        toPromise(() =>\r\n          this.loader(\r\n            this.getExtent(),\r\n            requestResolution,\r\n            this.getPixelRatio(),\r\n          ),\r\n        )\r\n          .then((image) => {\r\n            if ('image' in image) {\r\n              this.image_ = image.image;\r\n            }\r\n            if ('extent' in image) {\r\n              this.extent = image.extent;\r\n            }\r\n            if ('resolution' in image) {\r\n              this.resolution = image.resolution;\r\n            }\r\n            if ('pixelRatio' in image) {\r\n              this.pixelRatio_ = image.pixelRatio;\r\n            }\r\n            if (\r\n              image instanceof HTMLImageElement ||\r\n              image instanceof ImageBitmap ||\r\n              image instanceof HTMLCanvasElement ||\r\n              image instanceof HTMLVideoElement\r\n            ) {\r\n              this.image_ = image;\r\n            }\r\n            this.state = ImageState.LOADED;\r\n          })\r\n          .catch((error) => {\r\n            this.state = ImageState.ERROR;\r\n            console.error(error); // eslint-disable-line no-console\r\n          })\r\n          .finally(() => this.changed());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import('./DataTile.js').ImageLike} image The image.\r\n   */\r\n  setImage(image) {\r\n    this.image_ = image;\r\n  }\r\n\r\n  /**\r\n   * @param {number|Array<number>} resolution Resolution.\r\n   */\r\n  setResolution(resolution) {\r\n    this.resolution = resolution;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./DataTile.js').ImageLike} image Image element.\r\n * @param {function():any} loadHandler Load callback function.\r\n * @param {function():any} errorHandler Error callback function.\r\n * @return {function():void} Callback to stop listening.\r\n */\r\nexport function listenImage(image, loadHandler, errorHandler) {\r\n  const img = /** @type {HTMLImageElement} */ (image);\r\n  let listening = true;\r\n  let decoding = false;\r\n  let loaded = false;\r\n\r\n  const listenerKeys = [\r\n    listenOnce(img, EventType.LOAD, function () {\r\n      loaded = true;\r\n      if (!decoding) {\r\n        loadHandler();\r\n      }\r\n    }),\r\n  ];\r\n\r\n  if (img.src && IMAGE_DECODE) {\r\n    decoding = true;\r\n    img\r\n      .decode()\r\n      .then(function () {\r\n        if (listening) {\r\n          loadHandler();\r\n        }\r\n      })\r\n      .catch(function (error) {\r\n        if (listening) {\r\n          if (loaded) {\r\n            loadHandler();\r\n          } else {\r\n            errorHandler();\r\n          }\r\n        }\r\n      });\r\n  } else {\r\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\r\n  }\r\n\r\n  return function unlisten() {\r\n    listening = false;\r\n    listenerKeys.forEach(unlistenByKey);\r\n  };\r\n}\r\n\r\n/**\r\n * Loads an image.\r\n * @param {HTMLImageElement} image Image, not yet loaded.\r\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\r\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\r\n * @api\r\n */\r\nexport function load(image, src) {\r\n  return new Promise((resolve, reject) => {\r\n    function handleLoad() {\r\n      unlisten();\r\n      resolve(image);\r\n    }\r\n    function handleError() {\r\n      unlisten();\r\n      reject(new Error('Image load error'));\r\n    }\r\n    function unlisten() {\r\n      image.removeEventListener('load', handleLoad);\r\n      image.removeEventListener('error', handleError);\r\n    }\r\n    image.addEventListener('load', handleLoad);\r\n    image.addEventListener('error', handleError);\r\n    if (src) {\r\n      image.src = src;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * @param {HTMLImageElement} image Image, not yet loaded.\r\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\r\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\r\n */\r\nexport function decodeFallback(image, src) {\r\n  if (src) {\r\n    image.src = src;\r\n  }\r\n  return image.src && IMAGE_DECODE\r\n    ? new Promise((resolve, reject) =>\r\n        image\r\n          .decode()\r\n          .then(() => resolve(image))\r\n          .catch((e) =>\r\n            image.complete && image.width ? resolve(image) : reject(e),\r\n          ),\r\n      )\r\n    : load(image);\r\n}\r\n\r\n/**\r\n * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns\r\n * the loaded image otherwise.\r\n * @param {HTMLImageElement} image Image, not yet loaded.\r\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\r\n * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an\r\n * `HTMLImageElement` if `createImageBitmap()` is not supported.\r\n * @api\r\n */\r\nexport function decode(image, src) {\r\n  if (src) {\r\n    image.src = src;\r\n  }\r\n  return image.src && IMAGE_DECODE && CREATE_IMAGE_BITMAP\r\n    ? image\r\n        .decode()\r\n        .then(() => createImageBitmap(image))\r\n        .catch((e) => {\r\n          if (image.complete && image.width) {\r\n            return image;\r\n          }\r\n          throw e;\r\n        })\r\n    : decodeFallback(image);\r\n}\r\n\r\nexport default ImageWrapper;\r\n","/**\r\n * @module CME2D/ImageTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport TileState from './TileState.js';\r\nimport {createCanvasContext2D} from './dom.js';\r\nimport {listenImage} from './Image.js';\r\n\r\nclass ImageTile extends Tile {\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {string} src Image source URI.\r\n   * @param {?string} crossOrigin Cross origin.\r\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\r\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\r\n   */\r\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\r\n    super(tileCoord, state, options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {?string}\r\n     */\r\n    this.crossOrigin_ = crossOrigin;\r\n\r\n    /**\r\n     * Image URI\r\n     *\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.src_ = src;\r\n\r\n    this.key = src;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLImageElement|HTMLCanvasElement}\r\n     */\r\n    this.image_ = new Image();\r\n    if (crossOrigin !== null) {\r\n      this.image_.crossOrigin = crossOrigin;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {?function():void}\r\n     */\r\n    this.unlisten_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./Tile.js\").LoadFunction}\r\n     */\r\n    this.tileLoadFunction_ = tileLoadFunction;\r\n  }\r\n\r\n  /**\r\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\r\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\r\n   * @api\r\n   */\r\n  getImage() {\r\n    return this.image_;\r\n  }\r\n\r\n  /**\r\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\r\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\r\n   */\r\n  setImage(element) {\r\n    this.image_ = element;\r\n    this.state = TileState.LOADED;\r\n    this.unlistenImage_();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Tracks loading or read errors.\r\n   *\r\n   * @private\r\n   */\r\n  handleImageError_() {\r\n    this.state = TileState.ERROR;\r\n    this.unlistenImage_();\r\n    this.image_ = getBlankImage();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Tracks successful image load.\r\n   *\r\n   * @private\r\n   */\r\n  handleImageLoad_() {\r\n    const image = /** @type {HTMLImageElement} */ (this.image_);\r\n    if (image.naturalWidth && image.naturalHeight) {\r\n      this.state = TileState.LOADED;\r\n    } else {\r\n      this.state = TileState.EMPTY;\r\n    }\r\n    this.unlistenImage_();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load the image or retry if loading previously failed.\r\n   * Loading is taken care of by the tile queue, and calling this method is\r\n   * only needed for preloading or for reloading in case of an error.\r\n   *\r\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\r\n   * that checks for error status codes and reloads only when the status code is\r\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\r\n   * made already:\r\n   *\r\n   * ```js\r\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\r\n   * const retries = {};\r\n   * source.setTileLoadFunction((tile, src) => {\r\n   *   const image = tile.getImage();\r\n   *   fetch(src)\r\n   *     .then((response) => {\r\n   *       if (retryCodes.includes(response.status)) {\r\n   *         retries[src] = (retries[src] || 0) + 1;\r\n   *         if (retries[src] <= 3) {\r\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\r\n   *         }\r\n   *         return Promise.reject();\r\n   *       }\r\n   *       return response.blob();\r\n   *     })\r\n   *     .then((blob) => {\r\n   *       const imageUrl = URL.createObjectURL(blob);\r\n   *       image.src = imageUrl;\r\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\r\n   *     })\r\n   *     .catch(() => tile.setState(3)); // error\r\n   * });\r\n   * ```\r\n   * @api\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state == TileState.ERROR) {\r\n      this.state = TileState.IDLE;\r\n      this.image_ = new Image();\r\n      if (this.crossOrigin_ !== null) {\r\n        this.image_.crossOrigin = this.crossOrigin_;\r\n      }\r\n    }\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      this.changed();\r\n      this.tileLoadFunction_(this, this.src_);\r\n      this.unlisten_ = listenImage(\r\n        this.image_,\r\n        this.handleImageLoad_.bind(this),\r\n        this.handleImageError_.bind(this),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Discards event handlers which listen for load completion or errors.\r\n   *\r\n   * @private\r\n   */\r\n  unlistenImage_() {\r\n    if (this.unlisten_) {\r\n      this.unlisten_();\r\n      this.unlisten_ = null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get a 1-pixel blank image.\r\n * @return {HTMLCanvasElement} Blank image.\r\n */\r\nfunction getBlankImage() {\r\n  const ctx = createCanvasContext2D(1, 1);\r\n  ctx.fillStyle = 'rgba(0,0,0,0)';\r\n  ctx.fillRect(0, 0, 1, 1);\r\n  return ctx.canvas;\r\n}\r\n\r\nexport default ImageTile;\r\n","/**\r\n * @module CME2D/webgl/BaseTileRepresentation\r\n */\r\n\r\nimport EventTarget from '../events/Target.js';\r\nimport EventType from '../events/EventType.js';\r\nimport ImageTile from '../ImageTile.js';\r\nimport TileState from '../TileState.js';\r\nimport {abstract} from '../util.js';\r\n\r\n/**\r\n * @typedef {import(\"../Tile.js\").default} BaseTileType\r\n */\r\n\r\n/**\r\n * @template {BaseTileType} TileType\r\n * @typedef {Object} TileRepresentationOptions\r\n * @property {TileType} tile The tile.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid Tile grid.\r\n * @property {import(\"../webgl/Helper.js\").default} helper WebGL helper.\r\n * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for representing a tile in a webgl context\r\n * @template {import(\"../Tile.js\").default} TileType\r\n * @abstract\r\n */\r\nclass BaseTileRepresentation extends EventTarget {\r\n  /**\r\n   * @param {TileRepresentationOptions<TileType>} options The tile representation options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * @type {TileType}\r\n     */\r\n    this.tile;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\r\n\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.gutter = options.gutter || 0;\r\n\r\n    /**\r\n     * @type {import(\"../webgl/Helper.js\").default}\r\n     * @protected\r\n     */\r\n    this.helper = options.helper;\r\n\r\n    this.loaded = false;\r\n    this.ready = false;\r\n  }\r\n\r\n  /**\r\n   * @param {TileType} tile Tile.\r\n   */\r\n  setTile(tile) {\r\n    if (tile !== this.tile) {\r\n      if (this.tile) {\r\n        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\r\n      }\r\n      this.tile = tile;\r\n      this.loaded = tile.getState() === TileState.LOADED;\r\n      if (this.loaded) {\r\n        this.uploadTile();\r\n      } else {\r\n        if (tile instanceof ImageTile) {\r\n          const image = tile.getImage();\r\n          if (image instanceof Image && !image.crossOrigin) {\r\n            image.crossOrigin = 'anonymous';\r\n          }\r\n        }\r\n        tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @protected\r\n   */\r\n  uploadTile() {\r\n    abstract();\r\n  }\r\n\r\n  setReady() {\r\n    this.ready = true;\r\n    this.dispatchEvent(EventType.CHANGE);\r\n  }\r\n\r\n  handleTileChange_() {\r\n    if (this.tile.getState() === TileState.LOADED) {\r\n      this.loaded = true;\r\n      this.uploadTile();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./Helper.js\").default} helper The WebGL helper.\r\n   */\r\n  setHelper(helper) {\r\n    this.helper = helper;\r\n    if (this.helper && this.loaded) {\r\n      this.uploadTile();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    this.setHelper(null);\r\n    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\r\n  }\r\n}\r\n\r\nexport default BaseTileRepresentation;\r\n","/**\r\n * @module CME2D/webgl\r\n */\r\n\r\nimport {SAFARI_BUG_237906} from './has.js';\r\n\r\n/**\r\n * Constants taken from goog.webgl\r\n */\r\n\r\n/**\r\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as\r\n * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer\r\n * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const ARRAY_BUFFER = 0x8892;\r\n\r\n/**\r\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.\r\n * Index buffers are essentially lists of references to vertices defined in a vertex buffer\r\n * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const ELEMENT_ARRAY_BUFFER = 0x8893;\r\n\r\n/**\r\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const STREAM_DRAW = 0x88e0;\r\n\r\n/**\r\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const STATIC_DRAW = 0x88e4;\r\n\r\n/**\r\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const DYNAMIC_DRAW = 0x88e8;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const UNSIGNED_BYTE = 0x1401;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const UNSIGNED_SHORT = 0x1403;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const UNSIGNED_INT = 0x1405;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const FLOAT = 0x1406;\r\n\r\n/** end of goog.webgl constants\r\n */\r\n\r\n/**\r\n * @const\r\n * @type {Array<string>}\r\n */\r\nconst CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];\r\n\r\n/**\r\n * @param {HTMLCanvasElement} canvas Canvas.\r\n * @param {Object} [attributes] Attributes.\r\n * @return {WebGLRenderingContext|null} WebGL rendering context.\r\n */\r\nexport function getContext(canvas, attributes) {\r\n  attributes = Object.assign(\r\n    {\r\n      preserveDrawingBuffer: true,\r\n      antialias: SAFARI_BUG_237906 ? false : true, // https://bugs.webkit.org/show_bug.cgi?id=237906\r\n    },\r\n    attributes,\r\n  );\r\n  const ii = CONTEXT_IDS.length;\r\n  for (let i = 0; i < ii; ++i) {\r\n    try {\r\n      const context = canvas.getContext(CONTEXT_IDS[i], attributes);\r\n      if (context) {\r\n        return /** @type {!WebGLRenderingContext} */ (context);\r\n      }\r\n    } catch (e) {\r\n      // pass\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * @type {Array<string>|null}\r\n */\r\nlet supportedExtensions = null;\r\n\r\n/**\r\n * @return {Array<string>|null} List of supported WebGL extensions.\r\n */\r\nexport function getSupportedExtensions() {\r\n  if (!supportedExtensions) {\r\n    const canvas = document.createElement('canvas');\r\n    const gl = getContext(canvas);\r\n    if (gl) {\r\n      supportedExtensions = gl.getSupportedExtensions();\r\n    }\r\n  }\r\n  return supportedExtensions;\r\n}\r\n","/**\r\n * @module CME2D/webgl/Buffer\r\n */\r\nimport {\r\n  ARRAY_BUFFER,\r\n  DYNAMIC_DRAW,\r\n  ELEMENT_ARRAY_BUFFER,\r\n  STATIC_DRAW,\r\n  STREAM_DRAW,\r\n} from '../webgl.js';\r\nimport {assert} from '../asserts.js';\r\n\r\n/**\r\n * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`\r\n * or `DYNAMIC_DRAW`.\r\n * @enum {number}\r\n */\r\nexport const BufferUsage = {\r\n  STATIC_DRAW: STATIC_DRAW,\r\n  STREAM_DRAW: STREAM_DRAW,\r\n  DYNAMIC_DRAW: DYNAMIC_DRAW,\r\n};\r\n\r\n/**\r\n * @classdesc\r\n * Object used to store an array of data as well as usage information for that data.\r\n * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on\r\n * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.\r\n *\r\n * To populate the array, you can either use:\r\n * * A size using `#ofSize(buffer)`\r\n * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`\r\n * * A plain array using `#fromArray(array)`\r\n *\r\n * Note:\r\n * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)\r\n * for more info on buffer usage.\r\n */\r\nclass WebGLArrayBuffer {\r\n  /**\r\n   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\r\n   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.\r\n   * Default is `STATIC_DRAW`.\r\n   */\r\n  constructor(type, usage) {\r\n    /**\r\n     * @private\r\n     * @type {Float32Array|Uint32Array|null}\r\n     */\r\n    this.array_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.type_ = type;\r\n\r\n    assert(\r\n      type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER,\r\n      'A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`',\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.usage_ = usage !== undefined ? usage : BufferUsage.STATIC_DRAW;\r\n  }\r\n\r\n  /**\r\n   * Populates the buffer with an array of the given size (all values will be zeroes).\r\n   * @param {number} size Array size\r\n   * @return {WebGLArrayBuffer} This\r\n   */\r\n  ofSize(size) {\r\n    this.array_ = new (getArrayClassForType(this.type_))(size);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Populates the buffer with an array of the given size.\r\n   * @param {Array<number>} array Numerical array\r\n   * @return {WebGLArrayBuffer} This\r\n   */\r\n  fromArray(array) {\r\n    this.array_ = getArrayClassForType(this.type_).from(array);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Populates the buffer with a raw binary array buffer.\r\n   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been\r\n   * initialized for the same typed array class.\r\n   * @return {WebGLArrayBuffer} This\r\n   */\r\n  fromArrayBuffer(buffer) {\r\n    this.array_ = new (getArrayClassForType(this.type_))(buffer);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Buffer type.\r\n   */\r\n  getType() {\r\n    return this.type_;\r\n  }\r\n\r\n  /**\r\n   * Will return null if the buffer was not initialized\r\n   * @return {Float32Array|Uint32Array|null} Array.\r\n   */\r\n  getArray() {\r\n    return this.array_;\r\n  }\r\n\r\n  /**\r\n   * @param {Float32Array|Uint32Array} array Array.\r\n   */\r\n  setArray(array) {\r\n    const ArrayType = getArrayClassForType(this.type_);\r\n    if (!(array instanceof ArrayType)) {\r\n      throw new Error(`Expected ${ArrayType}`);\r\n    }\r\n    this.array_ = array;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Usage.\r\n   */\r\n  getUsage() {\r\n    return this.usage_;\r\n  }\r\n\r\n  /**\r\n   * Will return 0 if the buffer is not initialized\r\n   * @return {number} Array size\r\n   */\r\n  getSize() {\r\n    return this.array_ ? this.array_.length : 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a typed array constructor based on the given buffer type\r\n * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\r\n * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.\r\n */\r\nexport function getArrayClassForType(type) {\r\n  switch (type) {\r\n    case ARRAY_BUFFER:\r\n      return Float32Array;\r\n    case ELEMENT_ARRAY_BUFFER:\r\n      return Uint32Array;\r\n    default:\r\n      return Float32Array;\r\n  }\r\n}\r\n\r\nexport default WebGLArrayBuffer;\r\n","/**\r\n * @module CME2D/webgl/TileTexture\r\n */\r\n\r\nimport BaseTileRepresentation from './BaseTileRepresentation.js';\r\nimport DataTile, {asArrayLike, asImageLike} from '../DataTile.js';\r\nimport ImageTile from '../ImageTile.js';\r\nimport ReprojTile from '../reproj/Tile.js';\r\nimport WebGLArrayBuffer from './Buffer.js';\r\nimport {ARRAY_BUFFER, STATIC_DRAW} from '../webgl.js';\r\nimport {createCanvasContext2D} from '../dom.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @param {WebGLRenderingContext} gl The WebGL context.\r\n * @param {WebGLTexture} texture The texture.\r\n * @param {boolean} interpolate Interpolate when resampling.\r\n */\r\nfunction bindAndConfigure(gl, texture, interpolate) {\r\n  const resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;\r\n  gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);\r\n}\r\n\r\n/**\r\n * @param {WebGLRenderingContext} gl The WebGL context.\r\n * @param {WebGLTexture} texture The texture.\r\n * @param {import(\"../DataTile.js\").ImageLike} image The image.\r\n * @param {boolean} interpolate Interpolate when resampling.\r\n */\r\nfunction uploadImageTexture(gl, texture, image, interpolate) {\r\n  bindAndConfigure(gl, texture, interpolate);\r\n\r\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n}\r\n\r\n/**\r\n * @param {import(\"./Helper.js\").default} helper The WebGL helper.\r\n * @param {WebGLTexture} texture The texture.\r\n * @param {import(\"../DataTile.js\").ArrayLike} data The pixel data.\r\n * @param {import(\"../size.js\").Size} size The pixel size.\r\n * @param {number} bandCount The band count.\r\n * @param {boolean} interpolate Interpolate when resampling.\r\n */\r\nfunction uploadDataTexture(\r\n  helper,\r\n  texture,\r\n  data,\r\n  size,\r\n  bandCount,\r\n  interpolate,\r\n) {\r\n  const gl = helper.getGL();\r\n  let textureType;\r\n  let canInterpolate;\r\n  if (data instanceof Float32Array) {\r\n    textureType = gl.FLOAT;\r\n    helper.getExtension('OES_texture_float');\r\n    const extension = helper.getExtension('OES_texture_float_linear');\r\n    canInterpolate = extension !== null;\r\n  } else {\r\n    textureType = gl.UNSIGNED_BYTE;\r\n    canInterpolate = true;\r\n  }\r\n  bindAndConfigure(gl, texture, interpolate && canInterpolate);\r\n\r\n  const bytesPerRow = data.byteLength / size[1];\r\n  let unpackAlignment = 1;\r\n  if (bytesPerRow % 8 === 0) {\r\n    unpackAlignment = 8;\r\n  } else if (bytesPerRow % 4 === 0) {\r\n    unpackAlignment = 4;\r\n  } else if (bytesPerRow % 2 === 0) {\r\n    unpackAlignment = 2;\r\n  }\r\n\r\n  let format;\r\n  switch (bandCount) {\r\n    case 1: {\r\n      format = gl.LUMINANCE;\r\n      break;\r\n    }\r\n    case 2: {\r\n      format = gl.LUMINANCE_ALPHA;\r\n      break;\r\n    }\r\n    case 3: {\r\n      format = gl.RGB;\r\n      break;\r\n    }\r\n    case 4: {\r\n      format = gl.RGBA;\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error(`Unsupported number of bands: ${bandCount}`);\r\n    }\r\n  }\r\n\r\n  const oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);\r\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\r\n  gl.texImage2D(\r\n    gl.TEXTURE_2D,\r\n    0,\r\n    format,\r\n    size[0],\r\n    size[1],\r\n    0,\r\n    format,\r\n    textureType,\r\n    data,\r\n  );\r\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);\r\n}\r\n\r\n/**\r\n * @type {CanvasRenderingContext2D}\r\n */\r\nlet pixelContext = null;\r\n\r\nfunction createPixelContext() {\r\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\r\n    willReadFrequently: true,\r\n  });\r\n}\r\n\r\n/**\r\n * @typedef {import(\"../DataTile.js\").default|ImageTile|ReprojTile} TileType\r\n */\r\n\r\n/**\r\n * @extends {BaseTileRepresentation<TileType>}\r\n */\r\nclass TileTexture extends BaseTileRepresentation {\r\n  /**\r\n   * @param {import(\"./BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options The tile texture options.\r\n   */\r\n  constructor(options) {\r\n    super(options);\r\n\r\n    /**\r\n     * @type {Array<WebGLTexture>}\r\n     */\r\n    this.textures = [];\r\n\r\n    /**\r\n     * @type {import(\"../size.js\").Size}\r\n     * @private\r\n     */\r\n    this.renderSize_ = toSize(\r\n      options.grid.getTileSize(options.tile.tileCoord[0]),\r\n    );\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.bandCount = NaN;\r\n\r\n    const coords = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\r\n    coords.fromArray([\r\n      0, // P0\r\n      1,\r\n      1, // P1\r\n      1,\r\n      1, // P2\r\n      0,\r\n      0, // P3\r\n      0,\r\n    ]);\r\n    this.helper.flushBufferData(coords);\r\n\r\n    /**\r\n     * @type {WebGLArrayBuffer}\r\n     */\r\n    this.coords = coords;\r\n\r\n    this.setTile(options.tile);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @param {import(\"./Helper.js\").default} helper The WebGL helper.\r\n   */\r\n  setHelper(helper) {\r\n    const gl = this.helper?.getGL();\r\n    if (gl) {\r\n      this.helper.deleteBuffer(this.coords);\r\n      for (let i = 0; i < this.textures.length; ++i) {\r\n        gl.deleteTexture(this.textures[i]);\r\n      }\r\n    }\r\n\r\n    super.setHelper(helper);\r\n\r\n    if (helper) {\r\n      helper.flushBufferData(this.coords);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  uploadTile() {\r\n    const helper = this.helper;\r\n    const gl = helper.getGL();\r\n    const tile = this.tile;\r\n\r\n    this.textures.length = 0;\r\n\r\n    /**\r\n     * @type {import(\"../DataTile.js\").Data}\r\n     */\r\n    let data;\r\n\r\n    if (tile instanceof ImageTile || tile instanceof ReprojTile) {\r\n      data = tile.getImage();\r\n    } else {\r\n      data = tile.getData();\r\n    }\r\n\r\n    const image = asImageLike(data);\r\n    if (image) {\r\n      const texture = gl.createTexture();\r\n      this.textures.push(texture);\r\n      this.bandCount = 4;\r\n      uploadImageTexture(gl, texture, image, tile.interpolate);\r\n      this.setReady();\r\n      return;\r\n    }\r\n\r\n    data = asArrayLike(data);\r\n\r\n    const sourceTileSize = /** @type {DataTile} */ (tile).getSize();\r\n    const pixelSize = [\r\n      sourceTileSize[0] + 2 * this.gutter,\r\n      sourceTileSize[1] + 2 * this.gutter,\r\n    ];\r\n    const isFloat = data instanceof Float32Array;\r\n    const pixelCount = pixelSize[0] * pixelSize[1];\r\n    const DataType = isFloat ? Float32Array : Uint8Array;\r\n    const bytesPerElement = DataType.BYTES_PER_ELEMENT;\r\n    const bytesPerRow = data.byteLength / pixelSize[1];\r\n\r\n    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\r\n    const textureCount = Math.ceil(this.bandCount / 4);\r\n\r\n    if (textureCount === 1) {\r\n      const texture = gl.createTexture();\r\n      this.textures.push(texture);\r\n      uploadDataTexture(\r\n        helper,\r\n        texture,\r\n        data,\r\n        pixelSize,\r\n        this.bandCount,\r\n        tile.interpolate,\r\n      );\r\n      this.setReady();\r\n      return;\r\n    }\r\n\r\n    const textureDataArrays = new Array(textureCount);\r\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\r\n      const texture = gl.createTexture();\r\n      this.textures.push(texture);\r\n\r\n      const bandCount =\r\n        textureIndex < textureCount - 1 ? 4 : ((this.bandCount - 1) % 4) + 1;\r\n      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);\r\n    }\r\n\r\n    let dataIndex = 0;\r\n    let rowOffset = 0;\r\n    const colCount = pixelSize[0] * this.bandCount;\r\n    for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\r\n      for (let colIndex = 0; colIndex < colCount; ++colIndex) {\r\n        const dataValue = data[rowOffset + colIndex];\r\n\r\n        const pixelIndex = Math.floor(dataIndex / this.bandCount);\r\n        const bandIndex = colIndex % this.bandCount;\r\n        const textureIndex = Math.floor(bandIndex / 4);\r\n        const textureData = textureDataArrays[textureIndex];\r\n        const bandCount = textureData.length / pixelCount;\r\n        const textureBandIndex = bandIndex % 4;\r\n        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;\r\n\r\n        ++dataIndex;\r\n      }\r\n      rowOffset += bytesPerRow / bytesPerElement;\r\n    }\r\n\r\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\r\n      const texture = this.textures[textureIndex];\r\n      const textureData = textureDataArrays[textureIndex];\r\n      const bandCount = textureData.length / pixelCount;\r\n      uploadDataTexture(\r\n        helper,\r\n        texture,\r\n        textureData,\r\n        pixelSize,\r\n        bandCount,\r\n        tile.interpolate,\r\n      );\r\n    }\r\n\r\n    this.setReady();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../DataTile.js\").ImageLike} image The image.\r\n   * @param {number} renderCol The column index (in rendered tile space).\r\n   * @param {number} renderRow The row index (in rendered tile space).\r\n   * @return {Uint8ClampedArray|null} The data.\r\n   * @private\r\n   */\r\n  getImagePixelData_(image, renderCol, renderRow) {\r\n    const gutter = this.gutter;\r\n    const renderWidth = this.renderSize_[0];\r\n    const renderHeight = this.renderSize_[1];\r\n\r\n    if (!pixelContext) {\r\n      createPixelContext();\r\n    }\r\n    pixelContext.clearRect(0, 0, 1, 1);\r\n\r\n    const sourceWidth = image.width;\r\n    const sourceHeight = image.height;\r\n\r\n    const sourceWidthWithoutGutter = sourceWidth - 2 * gutter;\r\n    const sourceHeightWithoutGutter = sourceHeight - 2 * gutter;\r\n\r\n    const sourceCol =\r\n      gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\r\n\r\n    const sourceRow =\r\n      gutter +\r\n      Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\r\n\r\n    let data;\r\n    try {\r\n      pixelContext.drawImage(image, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);\r\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\r\n    } catch (err) {\r\n      pixelContext = null;\r\n      return null;\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../DataTile.js\").ArrayLike} data The data.\r\n   * @param {import(\"../size.js\").Size} sourceSize The size.\r\n   * @param {number} renderCol The column index (in rendered tile space).\r\n   * @param {number} renderRow The row index (in rendered tile space).\r\n   * @return {import(\"../DataTile.js\").ArrayLike|null} The data.\r\n   * @private\r\n   */\r\n  getArrayPixelData_(data, sourceSize, renderCol, renderRow) {\r\n    const gutter = this.gutter;\r\n    const renderWidth = this.renderSize_[0];\r\n    const renderHeight = this.renderSize_[1];\r\n\r\n    const sourceWidthWithoutGutter = sourceSize[0];\r\n    const sourceHeightWithoutGutter = sourceSize[1];\r\n    const sourceWidth = sourceWidthWithoutGutter + 2 * gutter;\r\n    const sourceHeight = sourceHeightWithoutGutter + 2 * gutter;\r\n\r\n    const sourceCol =\r\n      gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\r\n\r\n    const sourceRow =\r\n      gutter +\r\n      Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\r\n\r\n    if (data instanceof DataView) {\r\n      const bytesPerPixel = data.byteLength / (sourceWidth * sourceHeight);\r\n      const offset = bytesPerPixel * (sourceRow * sourceWidth + sourceCol);\r\n      const buffer = data.buffer.slice(offset, offset + bytesPerPixel);\r\n      return new DataView(buffer);\r\n    }\r\n\r\n    const offset = this.bandCount * (sourceRow * sourceWidth + sourceCol);\r\n    return data.slice(offset, offset + this.bandCount);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel.  If the tile is not loaded, null is returned.\r\n   * @param {number} renderCol The column index (in rendered tile space).\r\n   * @param {number} renderRow The row index (in rendered tile space).\r\n   * @return {import(\"../DataTile.js\").ArrayLike|null} The data.\r\n   */\r\n  getPixelData(renderCol, renderRow) {\r\n    if (!this.loaded) {\r\n      return null;\r\n    }\r\n\r\n    if (this.tile instanceof DataTile) {\r\n      const data = this.tile.getData();\r\n      const arrayData = asArrayLike(data);\r\n      if (arrayData) {\r\n        const sourceSize = this.tile.getSize();\r\n        return this.getArrayPixelData_(\r\n          arrayData,\r\n          sourceSize,\r\n          renderCol,\r\n          renderRow,\r\n        );\r\n      }\r\n      return this.getImagePixelData_(asImageLike(data), renderCol, renderRow);\r\n    }\r\n\r\n    return this.getImagePixelData_(this.tile.getImage(), renderCol, renderRow);\r\n  }\r\n}\r\n\r\nexport default TileTexture;\r\n","/**\r\n * @module CME2D/renderer/Layer\r\n */\r\nimport EventType from '../events/EventType.js';\r\nimport ImageState from '../ImageState.js';\r\nimport Observable from '../Observable.js';\r\nimport {abstract} from '../util.js';\r\n\r\nconst maxStaleKeys = 5;\r\n\r\n/**\r\n * @template {import(\"../layer/Layer.js\").default} LayerType\r\n */\r\nclass LayerRenderer extends Observable {\r\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   */\r\n  constructor(layer) {\r\n    super();\r\n\r\n    /**\r\n     * The renderer is initialized and ready to render.\r\n     * @type {boolean}\r\n     */\r\n    this.ready = true;\r\n\r\n    /** @private */\r\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\r\n\r\n    /**\r\n     * @private\r\n     * @type {LayerType}\r\n     */\r\n    this.layer_ = layer;\r\n\r\n    /**\r\n     * @type {Array<string>}\r\n     * @private\r\n     */\r\n    this.staleKeys_ = new Array();\r\n\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.maxStaleKeys = maxStaleKeys;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<string>} Get the list of stale keys.\r\n   */\r\n  getStaleKeys() {\r\n    return this.staleKeys_;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key The new stale key.\r\n   */\r\n  prependStaleKey(key) {\r\n    this.staleKeys_.unshift(key);\r\n    if (this.staleKeys_.length > this.maxStaleKeys) {\r\n      this.staleKeys_.length = this.maxStaleKeys;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Asynchronous layer level hit detection.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\r\n   * an array of features.\r\n   */\r\n  getFeatures(pixel) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   */\r\n  getData(pixel) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @abstract\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   */\r\n  prepareFrame(frameState) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @abstract\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement|null} target Target that may be used to render content to.\r\n   * @return {HTMLElement|null} The rendered element.\r\n   */\r\n  renderFrame(frameState, target) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\r\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\r\n  forEachFeatureAtCoordinate(\r\n    coordinate,\r\n    frameState,\r\n    hitTolerance,\r\n    callback,\r\n    matches,\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @return {LayerType} Layer.\r\n   */\r\n  getLayer() {\r\n    return this.layer_;\r\n  }\r\n\r\n  /**\r\n   * Perform action necessary to get the layer rendered after new fonts have loaded\r\n   * @abstract\r\n   */\r\n  handleFontsChanged() {}\r\n\r\n  /**\r\n   * Handle changes in image state.\r\n   * @param {import(\"../events/Event.js\").default} event Image change event.\r\n   * @private\r\n   */\r\n  handleImageChange_(event) {\r\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\r\n    if (\r\n      image.getState() === ImageState.LOADED ||\r\n      image.getState() === ImageState.ERROR\r\n    ) {\r\n      this.renderIfReadyAndVisible();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load the image if not already loaded, and register the image change\r\n   * listener if needed.\r\n   * @param {import(\"../Image.js\").default} image Image.\r\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\r\n   * @protected\r\n   */\r\n  loadImage(image) {\r\n    let imageState = image.getState();\r\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\r\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\r\n    }\r\n    if (imageState == ImageState.IDLE) {\r\n      image.load();\r\n      imageState = image.getState();\r\n    }\r\n    return imageState == ImageState.LOADED;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  renderIfReadyAndVisible() {\r\n    const layer = this.getLayer();\r\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\r\n      layer.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\r\n  renderDeferred(frameState) {}\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    delete this.layer_;\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default LayerRenderer;\r\n","/**\r\n * @module CME2D/render/Event\r\n */\r\n\r\nimport Event from '../events/Event.js';\r\n\r\nclass RenderEvent extends Event {\r\n  /**\r\n   * @param {import(\"./EventType.js\").default} type Type.\r\n   * @param {import(\"../transform.js\").Transform} [inversePixelTransform] Transform for\r\n   *     CSS pixels to rendered pixels.\r\n   * @param {import(\"../Map.js\").FrameState} [frameState] Frame state.\r\n   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.\r\n   */\r\n  constructor(type, inversePixelTransform, frameState, context) {\r\n    super(type);\r\n\r\n    /**\r\n     * Transform from CSS pixels (relative to the top-left corner of the map viewport)\r\n     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.\r\n     * @type {import(\"../transform.js\").Transform|undefined}\r\n     * @api\r\n     */\r\n    this.inversePixelTransform = inversePixelTransform;\r\n\r\n    /**\r\n     * An object representing the current render frame state.\r\n     * @type {import(\"../Map.js\").FrameState|undefined}\r\n     * @api\r\n     */\r\n    this.frameState = frameState;\r\n\r\n    /**\r\n     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,\r\n     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL\r\n     * context.\r\n     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}\r\n     * @api\r\n     */\r\n    this.context = context;\r\n  }\r\n}\r\n\r\nexport default RenderEvent;\r\n","/**\r\n * @module CME2D/webgl/ContextEventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  LOST: 'webglcontextlost',\r\n  RESTORED: 'webglcontextrestored',\r\n};\r\n","/**\r\n * @module CME2D/webgl/PostProcessingPass\r\n */\r\n\r\nimport {getUid} from '../util.js';\r\n\r\nconst DEFAULT_VERTEX_SHADER = `\r\n  precision mediump float;\r\n\r\n  attribute vec2 a_position;\r\n  varying vec2 v_texCoord;\r\n  varying vec2 v_screenCoord;\r\n\r\n  uniform vec2 u_screenSize;\r\n\r\n  void main() {\r\n    v_texCoord = a_position * 0.5 + 0.5;\r\n    v_screenCoord = v_texCoord * u_screenSize;\r\n    gl_Position = vec4(a_position, 0.0, 1.0);\r\n  }\r\n`;\r\n\r\nconst DEFAULT_FRAGMENT_SHADER = `\r\n  precision mediump float;\r\n\r\n  uniform sampler2D u_image;\r\n  uniform float u_opacity;\r\n\r\n  varying vec2 v_texCoord;\r\n\r\n  void main() {\r\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\r\n  }\r\n`;\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\r\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\r\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\r\n * @property {string} [vertexShader] Vertex shader source\r\n * @property {string} [fragmentShader] Fragment shader source\r\n * @property {Object<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\r\n */\r\n\r\n/**\r\n * @typedef {Object} UniformInternalDescription\r\n * @property {import(\"./Helper\").UniformValue} value Value\r\n * @property {WebGLUniformLocation} location Location\r\n * @property {WebGLTexture} [texture] Texture\r\n * @private\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * This class is used to define Post Processing passes with custom shaders and uniforms.\r\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\r\n *\r\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\r\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\r\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\r\n *\r\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\r\n * premultiplied.\r\n *\r\n * Default shaders are shown hereafter:\r\n *\r\n * * Vertex shader:\r\n *\r\n *   ```\r\n *   precision mediump float;\r\n *\r\n *   attribute vec2 a_position;\r\n *   varying vec2 v_texCoord;\r\n *   varying vec2 v_screenCoord;\r\n *\r\n *   uniform vec2 u_screenSize;\r\n *\r\n *   void main() {\r\n *     v_texCoord = a_position * 0.5 + 0.5;\r\n *     v_screenCoord = v_texCoord * u_screenSize;\r\n *     gl_Position = vec4(a_position, 0.0, 1.0);\r\n *   }\r\n *   ```\r\n *\r\n * * Fragment shader:\r\n *\r\n *   ```\r\n *   precision mediump float;\r\n *\r\n *   uniform sampler2D u_image;\r\n *   uniform float u_opacity;\r\n *\r\n *   varying vec2 v_texCoord;\r\n *\r\n *   void main() {\r\n *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\r\n *   }\r\n *   ```\r\n */\r\nclass WebGLPostProcessingPass {\r\n  /**\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @private\r\n     */\r\n    this.gl_ = options.webGlContext;\r\n    const gl = this.gl_;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.scaleRatio_ = options.scaleRatio || 1;\r\n\r\n    /**\r\n     * @type {WebGLTexture}\r\n     * @private\r\n     */\r\n    this.renderTargetTexture_ = gl.createTexture();\r\n\r\n    /**\r\n     * @type {import('../size.js').Size|null}\r\n     * @private\r\n     */\r\n    this.renderTargetTextureSize_ = null;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.frameBuffer_ = gl.createFramebuffer();\r\n    /**\r\n     * @private\r\n     */\r\n    this.depthBuffer_ = gl.createRenderbuffer();\r\n\r\n    // compile the program for the frame buffer\r\n    // TODO: make compilation errors show up\r\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n    gl.shaderSource(\r\n      vertexShader,\r\n      options.vertexShader || DEFAULT_VERTEX_SHADER,\r\n    );\r\n    gl.compileShader(vertexShader);\r\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(\r\n      fragmentShader,\r\n      options.fragmentShader || DEFAULT_FRAGMENT_SHADER,\r\n    );\r\n    gl.compileShader(fragmentShader);\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetProgram_ = gl.createProgram();\r\n    gl.attachShader(this.renderTargetProgram_, vertexShader);\r\n    gl.attachShader(this.renderTargetProgram_, fragmentShader);\r\n    gl.linkProgram(this.renderTargetProgram_);\r\n\r\n    // bind the vertices buffer for the frame buffer\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetVerticesBuffer_ = gl.createBuffer();\r\n    const verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\r\n    gl.bufferData(\r\n      gl.ARRAY_BUFFER,\r\n      new Float32Array(verticesArray),\r\n      gl.STATIC_DRAW,\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetAttribLocation_ = gl.getAttribLocation(\r\n      this.renderTargetProgram_,\r\n      'a_position',\r\n    );\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetUniformLocation_ = gl.getUniformLocation(\r\n      this.renderTargetProgram_,\r\n      'u_screenSize',\r\n    );\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetOpacityLocation_ = gl.getUniformLocation(\r\n      this.renderTargetProgram_,\r\n      'u_opacity',\r\n    );\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetTextureLocation_ = gl.getUniformLocation(\r\n      this.renderTargetProgram_,\r\n      'u_image',\r\n    );\r\n\r\n    /**\r\n     * Holds info about custom uniforms used in the post processing pass\r\n     * @type {Array<UniformInternalDescription>}\r\n     * @private\r\n     */\r\n    this.uniforms_ = [];\r\n    options.uniforms &&\r\n      Object.keys(options.uniforms).forEach((name) => {\r\n        this.uniforms_.push({\r\n          value: options.uniforms[name],\r\n          location: gl.getUniformLocation(this.renderTargetProgram_, name),\r\n        });\r\n      });\r\n  }\r\n\r\n  getRenderTargetTexture() {\r\n    return this.renderTargetTexture_;\r\n  }\r\n\r\n  /**\r\n   * Get the WebGL rendering context\r\n   * @return {WebGLRenderingContext} The rendering context.\r\n   */\r\n  getGL() {\r\n    return this.gl_;\r\n  }\r\n\r\n  /**\r\n   * Initialize the render target texture of the post process, make sure it is at the\r\n   * right size and bind it as a render target for the next draw calls.\r\n   * The last step to be initialized will be the one where the primitives are rendered.\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   */\r\n  init(frameState) {\r\n    const gl = this.getGL();\r\n    const textureSize = [\r\n      gl.drawingBufferWidth * this.scaleRatio_,\r\n      gl.drawingBufferHeight * this.scaleRatio_,\r\n    ];\r\n\r\n    // rendering goes to my buffer\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\r\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.getDepthBuffer());\r\n    gl.viewport(0, 0, textureSize[0], textureSize[1]);\r\n\r\n    // if size has changed: adjust canvas & render target texture\r\n    if (\r\n      !this.renderTargetTextureSize_ ||\r\n      this.renderTargetTextureSize_[0] !== textureSize[0] ||\r\n      this.renderTargetTextureSize_[1] !== textureSize[1]\r\n    ) {\r\n      this.renderTargetTextureSize_ = textureSize;\r\n\r\n      // create a new texture\r\n      const level = 0;\r\n      const internalFormat = gl.RGBA;\r\n      const border = 0;\r\n      const format = gl.RGBA;\r\n      const type = gl.UNSIGNED_BYTE;\r\n      const data = null;\r\n      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        level,\r\n        internalFormat,\r\n        textureSize[0],\r\n        textureSize[1],\r\n        border,\r\n        format,\r\n        type,\r\n        data,\r\n      );\r\n\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n      // bind the texture to the framebuffer\r\n      gl.framebufferTexture2D(\r\n        gl.FRAMEBUFFER,\r\n        gl.COLOR_ATTACHMENT0,\r\n        gl.TEXTURE_2D,\r\n        this.renderTargetTexture_,\r\n        0,\r\n      );\r\n\r\n      gl.renderbufferStorage(\r\n        gl.RENDERBUFFER,\r\n        gl.DEPTH_COMPONENT16,\r\n        textureSize[0],\r\n        textureSize[1],\r\n      );\r\n      gl.framebufferRenderbuffer(\r\n        gl.FRAMEBUFFER,\r\n        gl.DEPTH_ATTACHMENT,\r\n        gl.RENDERBUFFER,\r\n        this.depthBuffer_,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render to the next postprocessing pass (or to the canvas if final pass).\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\r\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\r\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\r\n   */\r\n  apply(frameState, nextPass, preCompose, postCompose) {\r\n    const gl = this.getGL();\r\n    const size = frameState.size;\r\n\r\n    gl.bindFramebuffer(\r\n      gl.FRAMEBUFFER,\r\n      nextPass ? nextPass.getFrameBuffer() : null,\r\n    );\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\r\n\r\n    if (!nextPass) {\r\n      // clear the canvas if we are the first to render to it\r\n      // and preserveDrawingBuffer is true\r\n      const canvasId = getUid(gl.canvas);\r\n      if (!frameState.renderTargets[canvasId]) {\r\n        const attributes = gl.getContextAttributes();\r\n        if (attributes && attributes.preserveDrawingBuffer) {\r\n          gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n          gl.clearDepth(1.0);\r\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        }\r\n\r\n        frameState.renderTargets[canvasId] = true;\r\n      }\r\n    }\r\n\r\n    gl.disable(gl.DEPTH_TEST);\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\r\n\r\n    gl.useProgram(this.renderTargetProgram_);\r\n    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\r\n    gl.vertexAttribPointer(\r\n      this.renderTargetAttribLocation_,\r\n      2,\r\n      gl.FLOAT,\r\n      false,\r\n      0,\r\n      0,\r\n    );\r\n    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\r\n    gl.uniform1i(this.renderTargetTextureLocation_, 0);\r\n\r\n    const opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;\r\n    gl.uniform1f(this.renderTargetOpacityLocation_, opacity);\r\n\r\n    this.applyUniforms(frameState);\r\n\r\n    if (preCompose) {\r\n      preCompose(gl, frameState);\r\n    }\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    if (postCompose) {\r\n      postCompose(gl, frameState);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {WebGLFramebuffer} Frame buffer\r\n   */\r\n  getFrameBuffer() {\r\n    return this.frameBuffer_;\r\n  }\r\n\r\n  /**\r\n   * @return {WebGLRenderbuffer} Depth buffer\r\n   */\r\n  getDepthBuffer() {\r\n    return this.depthBuffer_;\r\n  }\r\n\r\n  /**\r\n   * Sets the custom uniforms based on what was given in the constructor.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @private\r\n   */\r\n  applyUniforms(frameState) {\r\n    const gl = this.getGL();\r\n\r\n    let value;\r\n    let textureSlot = 1;\r\n    this.uniforms_.forEach(function (uniform) {\r\n      value =\r\n        typeof uniform.value === 'function'\r\n          ? uniform.value(frameState)\r\n          : uniform.value;\r\n\r\n      // apply value based on type\r\n      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\r\n        // create a texture & put data\r\n        if (!uniform.texture) {\r\n          uniform.texture = gl.createTexture();\r\n        }\r\n        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);\r\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        if (value instanceof ImageData) {\r\n          gl.texImage2D(\r\n            gl.TEXTURE_2D,\r\n            0,\r\n            gl.RGBA,\r\n            gl.RGBA,\r\n            value.width,\r\n            value.height,\r\n            0,\r\n            gl.UNSIGNED_BYTE,\r\n            new Uint8Array(value.data),\r\n          );\r\n        } else {\r\n          gl.texImage2D(\r\n            gl.TEXTURE_2D,\r\n            0,\r\n            gl.RGBA,\r\n            gl.RGBA,\r\n            gl.UNSIGNED_BYTE,\r\n            value,\r\n          );\r\n        }\r\n\r\n        // fill texture slots\r\n        gl.uniform1i(uniform.location, textureSlot++);\r\n      } else if (Array.isArray(value)) {\r\n        switch (value.length) {\r\n          case 2:\r\n            gl.uniform2f(uniform.location, value[0], value[1]);\r\n            return;\r\n          case 3:\r\n            gl.uniform3f(uniform.location, value[0], value[1], value[2]);\r\n            return;\r\n          case 4:\r\n            gl.uniform4f(\r\n              uniform.location,\r\n              value[0],\r\n              value[1],\r\n              value[2],\r\n              value[3],\r\n            );\r\n            return;\r\n          default:\r\n            return;\r\n        }\r\n      } else if (typeof value === 'number') {\r\n        gl.uniform1f(uniform.location, value);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default WebGLPostProcessingPass;\r\n","/**\r\n * @module CME2D/vec/mat4\r\n */\r\n\r\n/**\r\n * @return {Array<number>} \"4x4 matrix representing a 3D identity transform.\"\r\n */\r\nexport function create() {\r\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\r\n}\r\n\r\n/**\r\n * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.\r\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\r\n * @return {Array<number>} \"2D transformation matrix as flattened 4x4 matrix.\"\r\n */\r\nexport function fromTransform(mat4, transform) {\r\n  mat4[0] = transform[0];\r\n  mat4[1] = transform[1];\r\n  mat4[4] = transform[2];\r\n  mat4[5] = transform[3];\r\n  mat4[12] = transform[4];\r\n  mat4[13] = transform[5];\r\n  return mat4;\r\n}\r\n","/**\r\n * @module CME2D/webgl/Helper\r\n */\r\nimport ContextEventType from '../webgl/ContextEventType.js';\r\nimport Disposable from '../Disposable.js';\r\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\r\nimport {\r\n  FLOAT,\r\n  UNSIGNED_BYTE,\r\n  UNSIGNED_INT,\r\n  UNSIGNED_SHORT,\r\n  getContext,\r\n} from '../webgl.js';\r\nimport {clear} from '../obj.js';\r\nimport {\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n} from '../transform.js';\r\nimport {create, fromTransform} from '../vec/mat4.js';\r\nimport {getUid} from '../util.js';\r\n\r\n/**\r\n * @typedef {Object} BufferCacheEntry\r\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\r\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\r\n */\r\n\r\n/**\r\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\r\n * @enum {number}\r\n */\r\nexport const ShaderType = {\r\n  FRAGMENT_SHADER: 0x8b30,\r\n  VERTEX_SHADER: 0x8b31,\r\n};\r\n\r\n/**\r\n * Names of uniforms made available to all shaders.\r\n * Please note: changing these *will* break custom shaders!\r\n * @enum {string}\r\n */\r\nexport const DefaultUniform = {\r\n  PROJECTION_MATRIX: 'u_projectionMatrix',\r\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\r\n  TIME: 'u_time',\r\n  ZOOM: 'u_zoom',\r\n  RESOLUTION: 'u_resolution',\r\n  ROTATION: 'u_rotation',\r\n  VIEWPORT_SIZE_PX: 'u_viewportSizePx',\r\n  PIXEL_RATIO: 'u_pixelRatio',\r\n  HIT_DETECTION: 'u_hitDetection',\r\n};\r\n\r\n/**\r\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\r\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\r\n * @enum {number}\r\n */\r\nexport const AttributeType = {\r\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\r\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\r\n  UNSIGNED_INT: UNSIGNED_INT,\r\n  FLOAT: FLOAT,\r\n};\r\n\r\n/**\r\n * Description of an attribute in a buffer\r\n * @typedef {Object} AttributeDescription\r\n * @property {string} name Attribute name to use in shaders\r\n * @property {number} size Number of components per attributes\r\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\r\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\r\n * Default is `FLOAT`.\r\n */\r\n\r\n/**\r\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|WebGLTexture|import(\"../transform\").Transform} UniformLiteralValue\r\n */\r\n\r\n/**\r\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\r\n * one of the previous types.\r\n * @typedef {UniformLiteralValue|function(import(\"../Map.js\").FrameState):UniformLiteralValue} UniformValue\r\n */\r\n\r\n/**\r\n * @typedef {Object} PostProcessesOptions\r\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\r\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\r\n * @property {string} [vertexShader] Vertex shader source\r\n * @property {string} [fragmentShader] Fragment shader source\r\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\r\n * names in the provided or default shaders.\r\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\r\n * @property {string} [canvasCacheKey] The cache key for the canvas.\r\n */\r\n\r\n/**\r\n * @typedef {Object} UniformInternalDescription\r\n * @property {string} name Name\r\n * @property {UniformValue} [value] Value\r\n * @property {UniformValue} [prevValue] The previous value.\r\n * @property {WebGLTexture} [texture] Texture\r\n * @private\r\n */\r\n\r\n/**\r\n * @typedef {Object} CanvasCacheItem\r\n * @property {WebGLRenderingContext} context The context of this canvas.\r\n * @property {number} users The count of users of this canvas.\r\n */\r\n\r\n/**\r\n * @type {Object<string,CanvasCacheItem>}\r\n */\r\nconst canvasCache = {};\r\n\r\n/**\r\n * @param {string} key The cache key for the canvas.\r\n * @return {string} The shared cache key.\r\n */\r\nfunction getSharedCanvasCacheKey(key) {\r\n  return 'shared/' + key;\r\n}\r\n\r\nlet uniqueCanvasCacheKeyCount = 0;\r\n\r\n/**\r\n * @return {string} The unique cache key.\r\n */\r\nfunction getUniqueCanvasCacheKey() {\r\n  const key = 'unique/' + uniqueCanvasCacheKeyCount;\r\n  uniqueCanvasCacheKeyCount += 1;\r\n  return key;\r\n}\r\n\r\n/**\r\n * @param {string} key The cache key for the canvas.\r\n * @return {WebGLRenderingContext} The canvas.\r\n */\r\nfunction getOrCreateContext(key) {\r\n  let cacheItem = canvasCache[key];\r\n  if (!cacheItem) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = 1;\r\n    canvas.height = 1;\r\n    canvas.style.position = 'absolute';\r\n    canvas.style.left = '0';\r\n    const context = getContext(canvas);\r\n    cacheItem = {users: 0, context};\r\n    canvasCache[key] = cacheItem;\r\n  }\r\n\r\n  cacheItem.users += 1;\r\n  return cacheItem.context;\r\n}\r\n\r\n/**\r\n * @param {string} key The cache key for the canvas.\r\n */\r\nfunction releaseCanvas(key) {\r\n  const cacheItem = canvasCache[key];\r\n  if (!cacheItem) {\r\n    return;\r\n  }\r\n\r\n  cacheItem.users -= 1;\r\n  if (cacheItem.users > 0) {\r\n    return;\r\n  }\r\n\r\n  const gl = cacheItem.context;\r\n  const extension = gl.getExtension('WEBGL_lose_context');\r\n  if (extension) {\r\n    extension.loseContext();\r\n  }\r\n  const canvas = gl.canvas;\r\n  canvas.width = 1;\r\n  canvas.height = 1;\r\n\r\n  delete canvasCache[key];\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\r\n * directly the WebGL API should not be required anymore.\r\n *\r\n * Several operations are handled by the `WebGLHelper` class:\r\n *\r\n * ### Define custom shaders and uniforms\r\n *\r\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\r\n *\r\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\r\n *   Outputs are:\r\n *\r\n *   * `gl_Position`: position of the vertex in screen space\r\n *\r\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\r\n *\r\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\r\n *\r\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\r\n *   can be changed at every frame and can be of type float, arrays of float or images.\r\n *\r\n *   Shaders must be compiled and assembled into a program like so:\r\n *   ```js\r\n *   // here we simply create two shaders and assemble them in a program which is then used\r\n *   // for subsequent rendering calls; note how a frameState is required to set up a program,\r\n *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)\r\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\r\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\r\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\r\n *   helper.useProgram(this.program, frameState);\r\n *   ```\r\n *\r\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\r\n *   You can also change their value along the way like so:\r\n *   ```js\r\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\r\n *   ```\r\n *\r\n * ### Defining post processing passes\r\n *\r\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\r\n *   while applying special effects in screen space.\r\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\r\n *\r\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\r\n *   A post process step accepts the following options:\r\n *\r\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\r\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\r\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\r\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\r\n *\r\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\r\n *\r\n * ### Binding WebGL buffers and flushing data into them\r\n *\r\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\r\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\r\n *   This is done using {@link bindBuffer}.\r\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\r\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\r\n *\r\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\r\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\r\n *\r\n *   Examples below:\r\n *   ```js\r\n *   // at initialization phase\r\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\r\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\r\n *\r\n *   // when array values have changed\r\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\r\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n *\r\n *   // at rendering phase\r\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\r\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n *   ```\r\n *\r\n * ### Specifying attributes\r\n *\r\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\r\n *   Attributes are used to specify these uses. Specify the attribute names with\r\n *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).\r\n *\r\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\r\n *   ```js\r\n *   // here we indicate that the data array has the following structure:\r\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\r\n *   helper.enableAttributes([\r\n *     {\r\n *        name: 'a_position',\r\n *        size: 2\r\n *     },\r\n *     {\r\n *       name: 'a_offset',\r\n *       size: 2\r\n *     },\r\n *     {\r\n *       name: 'a_texCoord',\r\n *       size: 2\r\n *     }\r\n *   ])\r\n *   ```\r\n *\r\n * ### Rendering primitives\r\n *\r\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\r\n *   ```js\r\n *   // frame preparation step\r\n *   helper.prepareDraw(frameState);\r\n *\r\n *   // call this for every data array that has to be rendered on screen\r\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\r\n *\r\n *   // finalize the rendering by applying post processes\r\n *   helper.finalizeDraw(frameState);\r\n *   ```\r\n *\r\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\r\n */\r\nclass WebGLHelper extends Disposable {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n    options = options || {};\r\n\r\n    /** @private */\r\n    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);\r\n\r\n    /** @private */\r\n    this.boundHandleWebGLContextRestored_ =\r\n      this.handleWebGLContextRestored.bind(this);\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.canvasCacheKey_ = options.canvasCacheKey\r\n      ? getSharedCanvasCacheKey(options.canvasCacheKey)\r\n      : getUniqueCanvasCacheKey();\r\n\r\n    /**\r\n     * @private\r\n     * @type {WebGLRenderingContext}\r\n     */\r\n    this.gl_ = getOrCreateContext(this.canvasCacheKey_);\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, BufferCacheEntry>}\r\n     */\r\n    this.bufferCache_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Object>}\r\n     */\r\n    this.extensionCache_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {WebGLProgram}\r\n     */\r\n    this.currentProgram_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type boolean\r\n     */\r\n    this.needsToBeRecreated_ = false;\r\n\r\n    const canvas = this.gl_.canvas;\r\n\r\n    canvas.addEventListener(\r\n      ContextEventType.LOST,\r\n      this.boundHandleWebGLContextLost_,\r\n    );\r\n    canvas.addEventListener(\r\n      ContextEventType.RESTORED,\r\n      this.boundHandleWebGLContextRestored_,\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../transform.js\").Transform}\r\n     */\r\n    this.offsetRotateMatrix_ = createTransform();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../transform.js\").Transform}\r\n     */\r\n    this.offsetScaleMatrix_ = createTransform();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.tmpMat4_ = create();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Object<string, WebGLUniformLocation>>}\r\n     */\r\n    this.uniformLocationsByProgram_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Object<string, number>>}\r\n     */\r\n    this.attribLocationsByProgram_ = {};\r\n\r\n    /**\r\n     * Holds info about custom uniforms used in the post processing pass.\r\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\r\n     * @type {Array<UniformInternalDescription>}\r\n     * @private\r\n     */\r\n    this.uniforms_ = [];\r\n    if (options.uniforms) {\r\n      this.setUniforms(options.uniforms);\r\n    }\r\n\r\n    /**\r\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\r\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\r\n     * the frame buffer logic).\r\n     * @type {Array<WebGLPostProcessingPass>}\r\n     * @private\r\n     */\r\n    this.postProcessPasses_ = options.postProcesses\r\n      ? options.postProcesses.map(\r\n          (options) =>\r\n            new WebGLPostProcessingPass({\r\n              webGlContext: this.gl_,\r\n              scaleRatio: options.scaleRatio,\r\n              vertexShader: options.vertexShader,\r\n              fragmentShader: options.fragmentShader,\r\n              uniforms: options.uniforms,\r\n            }),\r\n        )\r\n      : [new WebGLPostProcessingPass({webGlContext: this.gl_})];\r\n\r\n    /**\r\n     * @type {string|null}\r\n     * @private\r\n     */\r\n    this.shaderCompileErrors_ = null;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.startTime_ = Date.now();\r\n  }\r\n\r\n  /**\r\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\r\n   */\r\n  setUniforms(uniforms) {\r\n    this.uniforms_ = [];\r\n    this.addUniforms(uniforms);\r\n  }\r\n\r\n  /**\r\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\r\n   */\r\n  addUniforms(uniforms) {\r\n    for (const name in uniforms) {\r\n      this.uniforms_.push({\r\n        name: name,\r\n        value: uniforms[name],\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} canvasCacheKey The canvas cache key.\r\n   * @return {boolean} The provided key matches the one this helper was constructed with.\r\n   */\r\n  canvasCacheKeyMatches(canvasCacheKey) {\r\n    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);\r\n  }\r\n\r\n  /**\r\n   * Get a WebGL extension.  If the extension is not supported, null is returned.\r\n   * Extensions are cached after they are enabled for the first time.\r\n   * @param {string} name The extension name.\r\n   * @return {Object|null} The extension or null if not supported.\r\n   */\r\n  getExtension(name) {\r\n    if (name in this.extensionCache_) {\r\n      return this.extensionCache_[name];\r\n    }\r\n    const extension = this.gl_.getExtension(name);\r\n    this.extensionCache_[name] = extension;\r\n    return extension;\r\n  }\r\n\r\n  /**\r\n   * Just bind the buffer if it's in the cache. Otherwise create\r\n   * the WebGL buffer, bind it, populate it, and add an entry to\r\n   * the cache.\r\n   * @param {import(\"./Buffer\").default} buffer Buffer.\r\n   */\r\n  bindBuffer(buffer) {\r\n    const gl = this.gl_;\r\n    const bufferKey = getUid(buffer);\r\n    let bufferCache = this.bufferCache_[bufferKey];\r\n    if (!bufferCache) {\r\n      const webGlBuffer = gl.createBuffer();\r\n      bufferCache = {\r\n        buffer: buffer,\r\n        webGlBuffer: webGlBuffer,\r\n      };\r\n      this.bufferCache_[bufferKey] = bufferCache;\r\n    }\r\n    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\r\n  }\r\n\r\n  /**\r\n   * Update the data contained in the buffer array; this is required for the\r\n   * new data to be rendered\r\n   * @param {import(\"./Buffer\").default} buffer Buffer.\r\n   */\r\n  flushBufferData(buffer) {\r\n    const gl = this.gl_;\r\n    this.bindBuffer(buffer);\r\n    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./Buffer.js\").default} buf Buffer.\r\n   */\r\n  deleteBuffer(buf) {\r\n    const bufferKey = getUid(buf);\r\n    // Note: gl.deleteBuffer is not called here since we let WebGL garbage collect it automatically\r\n    delete this.bufferCache_[bufferKey];\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    const canvas = this.gl_.canvas;\r\n    canvas.removeEventListener(\r\n      ContextEventType.LOST,\r\n      this.boundHandleWebGLContextLost_,\r\n    );\r\n    canvas.removeEventListener(\r\n      ContextEventType.RESTORED,\r\n      this.boundHandleWebGLContextRestored_,\r\n    );\r\n\r\n    releaseCanvas(this.canvasCacheKey_);\r\n\r\n    delete this.gl_;\r\n  }\r\n\r\n  /**\r\n   * Clear the buffer & set the viewport to draw.\r\n   * Post process passes will be initialized here, the first one being bound as a render target for\r\n   * subsequent draw calls.\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\r\n   * @param {boolean} [enableDepth] If true, enables depth testing.\r\n   */\r\n  prepareDraw(frameState, disableAlphaBlend, enableDepth) {\r\n    const gl = this.gl_;\r\n    const canvas = this.getCanvas();\r\n    const size = frameState.size;\r\n    const pixelRatio = frameState.pixelRatio;\r\n\r\n    if (\r\n      canvas.width !== size[0] * pixelRatio ||\r\n      canvas.height !== size[1] * pixelRatio\r\n    ) {\r\n      canvas.width = size[0] * pixelRatio;\r\n      canvas.height = size[1] * pixelRatio;\r\n      canvas.style.width = size[0] + 'px';\r\n      canvas.style.height = size[1] + 'px';\r\n    }\r\n\r\n    // loop backwards in post processes list\r\n    for (let i = this.postProcessPasses_.length - 1; i >= 0; i--) {\r\n      this.postProcessPasses_[i].init(frameState);\r\n    }\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n\r\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n    gl.depthRange(0.0, 1.0);\r\n    gl.clearDepth(1.0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\r\n    if (enableDepth) {\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.depthFunc(gl.LEQUAL);\r\n    } else {\r\n      gl.disable(gl.DEPTH_TEST);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLFramebuffer|null} frameBuffer The frame buffer.\r\n   * @param {WebGLTexture} [texture] The texture.\r\n   */\r\n  bindFrameBuffer(frameBuffer, texture) {\r\n    const gl = this.getGL();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\r\n    if (texture) {\r\n      gl.framebufferTexture2D(\r\n        gl.FRAMEBUFFER,\r\n        gl.COLOR_ATTACHMENT0,\r\n        gl.TEXTURE_2D,\r\n        texture,\r\n        0,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bind the frame buffer from the initial render.\r\n   */\r\n  bindInitialFrameBuffer() {\r\n    const gl = this.getGL();\r\n    const frameBuffer = this.postProcessPasses_[0].getFrameBuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\r\n    const texture = this.postProcessPasses_[0].getRenderTargetTexture();\r\n    gl.framebufferTexture2D(\r\n      gl.FRAMEBUFFER,\r\n      gl.COLOR_ATTACHMENT0,\r\n      gl.TEXTURE_2D,\r\n      texture,\r\n      0,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Prepare a program to use a texture.\r\n   * @param {WebGLTexture} texture The texture.\r\n   * @param {number} slot The texture slot.\r\n   * @param {string} uniformName The corresponding uniform name.\r\n   */\r\n  bindTexture(texture, slot, uniformName) {\r\n    const gl = this.gl_;\r\n    gl.activeTexture(gl.TEXTURE0 + slot);\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.uniform1i(this.getUniformLocation(uniformName), slot);\r\n  }\r\n\r\n  /**\r\n   * Set up an attribute array buffer for use in the vertex shader.\r\n   * @param {import(\"./Buffer\").default} buffer The buffer.\r\n   * @param {string} attributeName The attribute name.\r\n   * @param {number} size The number of components per attribute vertex.\r\n   */\r\n  bindAttribute(buffer, attributeName, size) {\r\n    const gl = this.getGL();\r\n    this.bindBuffer(buffer);\r\n    const index = this.getAttributeLocation(attributeName);\r\n    gl.enableVertexAttribArray(index);\r\n    gl.vertexAttribPointer(index, size, gl.FLOAT, false, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Clear the render target & bind it for future draw operations.\r\n   * This is similar to `prepareDraw`, only post processes will not be applied.\r\n   * Note: the whole viewport will be drawn to the render target, regardless of its size.\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\r\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\r\n   * @param {boolean} [enableDepth] If true, enables depth testing.\r\n   */\r\n  prepareDrawToRenderTarget(\r\n    frameState,\r\n    renderTarget,\r\n    disableAlphaBlend,\r\n    enableDepth,\r\n  ) {\r\n    const gl = this.gl_;\r\n    const size = renderTarget.getSize();\r\n\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\r\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderTarget.getDepthbuffer());\r\n    gl.viewport(0, 0, size[0], size[1]);\r\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\r\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n    gl.depthRange(0.0, 1.0);\r\n    gl.clearDepth(1.0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\r\n    if (enableDepth) {\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.depthFunc(gl.LEQUAL);\r\n    } else {\r\n      gl.disable(gl.DEPTH_TEST);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute a draw call based on the currently bound program, texture, buffers, attributes.\r\n   * @param {number} start Start index.\r\n   * @param {number} end End index.\r\n   */\r\n  drawElements(start, end) {\r\n    const gl = this.gl_;\r\n    this.getExtension('OES_element_index_uint');\r\n\r\n    const elementType = gl.UNSIGNED_INT;\r\n    const elementSize = 4;\r\n\r\n    const numItems = end - start;\r\n    const offsetInBytes = start * elementSize;\r\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\r\n  }\r\n\r\n  /**\r\n   * Apply the successive post process passes which will eventually render to the actual canvas.\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\r\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\r\n   */\r\n  finalizeDraw(frameState, preCompose, postCompose) {\r\n    // apply post processes using the next one as target\r\n    for (let i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {\r\n      if (i === ii - 1) {\r\n        this.postProcessPasses_[i].apply(\r\n          frameState,\r\n          null,\r\n          preCompose,\r\n          postCompose,\r\n        );\r\n      } else {\r\n        this.postProcessPasses_[i].apply(\r\n          frameState,\r\n          this.postProcessPasses_[i + 1],\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Canvas.\r\n   */\r\n  getCanvas() {\r\n    return /** @type {HTMLCanvasElement} */ (this.gl_.canvas);\r\n  }\r\n\r\n  /**\r\n   * Get the WebGL rendering context\r\n   * @return {WebGLRenderingContext} The rendering context.\r\n   */\r\n  getGL() {\r\n    return this.gl_;\r\n  }\r\n\r\n  /**\r\n   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\r\n  applyFrameState(frameState) {\r\n    const size = frameState.size;\r\n    const rotation = frameState.viewState.rotation;\r\n    const pixelRatio = frameState.pixelRatio;\r\n\r\n    this.setUniformFloatValue(\r\n      DefaultUniform.TIME,\r\n      (Date.now() - this.startTime_) * 0.001,\r\n    );\r\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\r\n    this.setUniformFloatValue(\r\n      DefaultUniform.RESOLUTION,\r\n      frameState.viewState.resolution,\r\n    );\r\n    this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);\r\n    this.setUniformFloatVec2(DefaultUniform.VIEWPORT_SIZE_PX, [\r\n      size[0],\r\n      size[1],\r\n    ]);\r\n    this.setUniformFloatValue(DefaultUniform.ROTATION, rotation);\r\n  }\r\n\r\n  /**\r\n   * Sets the `u_hitDetection` uniform.\r\n   * @param {boolean} enabled Whether to enable the hit detection code path\r\n   */\r\n  applyHitDetectionUniform(enabled) {\r\n    const loc = this.getUniformLocation(DefaultUniform.HIT_DETECTION);\r\n    this.getGL().uniform1i(loc, enabled ? 1 : 0);\r\n\r\n    // hit detection uses a fixed pixel ratio\r\n    if (enabled) {\r\n      this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, 0.5);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\r\n  applyUniforms(frameState) {\r\n    const gl = this.gl_;\r\n\r\n    let value;\r\n    let textureSlot = 0;\r\n    this.uniforms_.forEach((uniform) => {\r\n      value =\r\n        typeof uniform.value === 'function'\r\n          ? uniform.value(frameState)\r\n          : uniform.value;\r\n\r\n      // apply value based on type\r\n      if (\r\n        value instanceof HTMLCanvasElement ||\r\n        value instanceof HTMLImageElement ||\r\n        value instanceof ImageData ||\r\n        value instanceof WebGLTexture\r\n      ) {\r\n        // create a texture & put data\r\n        if (value instanceof WebGLTexture && !uniform.texture) {\r\n          uniform.prevValue = undefined;\r\n          uniform.texture = value;\r\n        } else if (!uniform.texture) {\r\n          uniform.prevValue = undefined;\r\n          uniform.texture = gl.createTexture();\r\n        }\r\n        this.bindTexture(uniform.texture, textureSlot, uniform.name);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        const imageReady =\r\n          !(value instanceof HTMLImageElement) ||\r\n          /** @type {HTMLImageElement} */ (value).complete;\r\n        if (\r\n          !(value instanceof WebGLTexture) &&\r\n          imageReady &&\r\n          uniform.prevValue !== value\r\n        ) {\r\n          uniform.prevValue = value;\r\n          gl.texImage2D(\r\n            gl.TEXTURE_2D,\r\n            0,\r\n            gl.RGBA,\r\n            gl.RGBA,\r\n            gl.UNSIGNED_BYTE,\r\n            value,\r\n          );\r\n        }\r\n        textureSlot++;\r\n      } else if (Array.isArray(value) && value.length === 6) {\r\n        this.setUniformMatrixValue(\r\n          uniform.name,\r\n          fromTransform(this.tmpMat4_, value),\r\n        );\r\n      } else if (Array.isArray(value) && value.length <= 4) {\r\n        switch (value.length) {\r\n          case 2:\r\n            gl.uniform2f(\r\n              this.getUniformLocation(uniform.name),\r\n              value[0],\r\n              value[1],\r\n            );\r\n            return;\r\n          case 3:\r\n            gl.uniform3f(\r\n              this.getUniformLocation(uniform.name),\r\n              value[0],\r\n              value[1],\r\n              value[2],\r\n            );\r\n            return;\r\n          case 4:\r\n            gl.uniform4f(\r\n              this.getUniformLocation(uniform.name),\r\n              value[0],\r\n              value[1],\r\n              value[2],\r\n              value[3],\r\n            );\r\n            return;\r\n          default:\r\n            return;\r\n        }\r\n      } else if (typeof value === 'number') {\r\n        gl.uniform1f(this.getUniformLocation(uniform.name), value);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up a program for use. The program will be set as the current one. Then, the uniforms used\r\n   * in the program will be set based on the current frame state and the helper configuration.\r\n   * @param {WebGLProgram} program Program.\r\n   * @param {import(\"../Map.js\").FrameState} [frameState] Frame state.\r\n   */\r\n  useProgram(program, frameState) {\r\n    const gl = this.gl_;\r\n    gl.useProgram(program);\r\n    this.currentProgram_ = program;\r\n    if (frameState) {\r\n      this.applyFrameState(frameState);\r\n      this.applyUniforms(frameState);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Will attempt to compile a vertex or fragment shader based on source\r\n   * On error, the shader will be returned but\r\n   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\r\n   * Use `gl.getShaderInfoLog(shader)` to have details\r\n   * @param {string} source Shader source\r\n   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\r\n   * @return {WebGLShader} Shader object\r\n   */\r\n  compileShader(source, type) {\r\n    const gl = this.gl_;\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    return shader;\r\n  }\r\n\r\n  /**\r\n   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\r\n   * @param {string} fragmentShaderSource Fragment shader source.\r\n   * @param {string} vertexShaderSource Vertex shader source.\r\n   * @return {WebGLProgram} Program\r\n   */\r\n  getProgram(fragmentShaderSource, vertexShaderSource) {\r\n    const gl = this.gl_;\r\n\r\n    const fragmentShader = this.compileShader(\r\n      fragmentShaderSource,\r\n      gl.FRAGMENT_SHADER,\r\n    );\r\n\r\n    const vertexShader = this.compileShader(\r\n      vertexShaderSource,\r\n      gl.VERTEX_SHADER,\r\n    );\r\n\r\n    const program = gl.createProgram();\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.attachShader(program, vertexShader);\r\n    gl.linkProgram(program);\r\n\r\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n      const message = `Fragment shader compilation failed: ${gl.getShaderInfoLog(\r\n        fragmentShader,\r\n      )}`;\r\n      throw new Error(message);\r\n    }\r\n    gl.deleteShader(fragmentShader);\r\n\r\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n      const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(\r\n        vertexShader,\r\n      )}`;\r\n      throw new Error(message);\r\n    }\r\n    gl.deleteShader(vertexShader);\r\n\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n      const message = `GL program linking failed: ${gl.getProgramInfoLog(\r\n        program,\r\n      )}`;\r\n      throw new Error(message);\r\n    }\r\n\r\n    return program;\r\n  }\r\n\r\n  /**\r\n   * Will get the location from the shader or the cache\r\n   * @param {string} name Uniform name\r\n   * @return {WebGLUniformLocation} uniformLocation\r\n   */\r\n  getUniformLocation(name) {\r\n    const programUid = getUid(this.currentProgram_);\r\n    if (this.uniformLocationsByProgram_[programUid] === undefined) {\r\n      this.uniformLocationsByProgram_[programUid] = {};\r\n    }\r\n    if (this.uniformLocationsByProgram_[programUid][name] === undefined) {\r\n      this.uniformLocationsByProgram_[programUid][name] =\r\n        this.gl_.getUniformLocation(this.currentProgram_, name);\r\n    }\r\n    return this.uniformLocationsByProgram_[programUid][name];\r\n  }\r\n\r\n  /**\r\n   * Will get the location from the shader or the cache\r\n   * @param {string} name Attribute name\r\n   * @return {number} attribLocation\r\n   */\r\n  getAttributeLocation(name) {\r\n    const programUid = getUid(this.currentProgram_);\r\n    if (this.attribLocationsByProgram_[programUid] === undefined) {\r\n      this.attribLocationsByProgram_[programUid] = {};\r\n    }\r\n    if (this.attribLocationsByProgram_[programUid][name] === undefined) {\r\n      this.attribLocationsByProgram_[programUid][name] =\r\n        this.gl_.getAttribLocation(this.currentProgram_, name);\r\n    }\r\n    return this.attribLocationsByProgram_[programUid][name];\r\n  }\r\n\r\n  /**\r\n   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.\r\n   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../transform\").Transform} transform Transform to update.\r\n   * @return {import(\"../transform\").Transform} The updated transform object.\r\n   */\r\n  makeProjectionTransform(frameState, transform) {\r\n    const size = frameState.size;\r\n    const rotation = frameState.viewState.rotation;\r\n    const resolution = frameState.viewState.resolution;\r\n    const center = frameState.viewState.center;\r\n    composeTransform(\r\n      transform,\r\n      0,\r\n      0,\r\n      2 / (resolution * size[0]),\r\n      2 / (resolution * size[1]),\r\n      -rotation,\r\n      -center[0],\r\n      -center[1],\r\n    );\r\n    return transform;\r\n  }\r\n\r\n  /**\r\n   * Give a value for a standard float uniform\r\n   * @param {string} uniform Uniform name\r\n   * @param {number} value Value\r\n   */\r\n  setUniformFloatValue(uniform, value) {\r\n    this.gl_.uniform1f(this.getUniformLocation(uniform), value);\r\n  }\r\n\r\n  /**\r\n   * Give a value for a vec2 uniform\r\n   * @param {string} uniform Uniform name\r\n   * @param {Array<number>} value Array of length 4.\r\n   */\r\n  setUniformFloatVec2(uniform, value) {\r\n    this.gl_.uniform2fv(this.getUniformLocation(uniform), value);\r\n  }\r\n\r\n  /**\r\n   * Give a value for a vec4 uniform\r\n   * @param {string} uniform Uniform name\r\n   * @param {Array<number>} value Array of length 4.\r\n   */\r\n  setUniformFloatVec4(uniform, value) {\r\n    this.gl_.uniform4fv(this.getUniformLocation(uniform), value);\r\n  }\r\n\r\n  /**\r\n   * Give a value for a standard matrix4 uniform\r\n   * @param {string} uniform Uniform name\r\n   * @param {Array<number>} value Matrix value\r\n   */\r\n  setUniformMatrixValue(uniform, value) {\r\n    this.gl_.uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\r\n  }\r\n\r\n  /**\r\n   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\r\n   * internally.\r\n   * @param {string} attribName Attribute name\r\n   * @param {number} size Number of components per attributes\r\n   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\r\n   * @param {number} stride Stride in bytes (0 means attribs are packed)\r\n   * @param {number} offset Offset in bytes\r\n   * @private\r\n   */\r\n  enableAttributeArray_(attribName, size, type, stride, offset) {\r\n    const location = this.getAttributeLocation(attribName);\r\n    // the attribute has not been found in the shaders or is not used; do not enable it\r\n    if (location < 0) {\r\n      return;\r\n    }\r\n    this.gl_.enableVertexAttribArray(location);\r\n    this.gl_.vertexAttribPointer(location, size, type, false, stride, offset);\r\n  }\r\n\r\n  /**\r\n   * Will enable the following attributes to be read from the currently bound buffer,\r\n   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\r\n   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\r\n   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\r\n   */\r\n  enableAttributes(attributes) {\r\n    const stride = computeAttributesStride(attributes);\r\n    let offset = 0;\r\n    for (let i = 0; i < attributes.length; i++) {\r\n      const attr = attributes[i];\r\n      this.enableAttributeArray_(\r\n        attr.name,\r\n        attr.size,\r\n        attr.type || FLOAT,\r\n        stride,\r\n        offset,\r\n      );\r\n      offset += attr.size * getByteSizeFromType(attr.type);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * WebGL context was lost\r\n   * @param {WebGLContextEvent} event The context loss event.\r\n   * @private\r\n   */\r\n  handleWebGLContextLost(event) {\r\n    clear(this.bufferCache_);\r\n    this.currentProgram_ = null;\r\n\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * WebGL context was restored\r\n   * @private\r\n   */\r\n  handleWebGLContextRestored() {\r\n    this.needsToBeRecreated_ = true;\r\n  }\r\n\r\n  /**\r\n   * Returns whether this helper needs to be recreated, as the context was lost and then restored.\r\n   * @return {boolean} Whether this helper needs to be recreated.\r\n   */\r\n  needsToBeRecreated() {\r\n    return this.needsToBeRecreated_;\r\n  }\r\n\r\n  /**\r\n   * Will create or reuse a given webgl texture and apply the given size. If no image data\r\n   * specified, the texture will be empty, otherwise image data will be used and the `size`\r\n   * parameter will be ignored.  If a Uint8Array is provided for data, a size must also be provided.\r\n   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\r\n   * @param {Array<number>} size Expected size of the texture\r\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|Uint8Array|null} data Image data/object to bind to the texture\r\n   * @param {WebGLTexture} [texture] Existing texture to reuse\r\n   * @param {boolean} [nearest] Use gl.NEAREST for min/mag filter.\r\n   * @return {WebGLTexture} The generated texture\r\n   */\r\n  createTexture(size, data, texture, nearest) {\r\n    const gl = this.gl_;\r\n    texture = texture || gl.createTexture();\r\n    const filter = nearest ? gl.NEAREST : gl.LINEAR;\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    const level = 0;\r\n    const internalFormat = gl.RGBA;\r\n    const border = 0;\r\n    const format = gl.RGBA;\r\n    const type = gl.UNSIGNED_BYTE;\r\n\r\n    if (data instanceof Uint8Array) {\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        level,\r\n        internalFormat,\r\n        size[0],\r\n        size[1],\r\n        border,\r\n        format,\r\n        type,\r\n        data,\r\n      );\r\n    } else if (data) {\r\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);\r\n    } else {\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        level,\r\n        internalFormat,\r\n        size[0],\r\n        size[1],\r\n        border,\r\n        format,\r\n        type,\r\n        null,\r\n      );\r\n    }\r\n    return texture;\r\n  }\r\n}\r\n\r\n/**\r\n * Compute a stride in bytes based on a list of attributes\r\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\r\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\r\n */\r\nexport function computeAttributesStride(attributes) {\r\n  let stride = 0;\r\n  for (let i = 0; i < attributes.length; i++) {\r\n    const attr = attributes[i];\r\n    stride += attr.size * getByteSizeFromType(attr.type);\r\n  }\r\n  return stride;\r\n}\r\n\r\n/**\r\n * Computes the size in byte of an attribute type.\r\n * @param {AttributeType} type Attribute type\r\n * @return {number} The size in bytes\r\n */\r\nfunction getByteSizeFromType(type) {\r\n  switch (type) {\r\n    case AttributeType.UNSIGNED_BYTE:\r\n      return Uint8Array.BYTES_PER_ELEMENT;\r\n    case AttributeType.UNSIGNED_SHORT:\r\n      return Uint16Array.BYTES_PER_ELEMENT;\r\n    case AttributeType.UNSIGNED_INT:\r\n      return Uint32Array.BYTES_PER_ELEMENT;\r\n    case AttributeType.FLOAT:\r\n    default:\r\n      return Float32Array.BYTES_PER_ELEMENT;\r\n  }\r\n}\r\n\r\nexport default WebGLHelper;\r\n","/**\r\n * @module CME2D/renderer/webgl/Layer\r\n */\r\nimport LayerProperty from '../../layer/Property.js';\r\nimport LayerRenderer from '../Layer.js';\r\nimport RenderEvent from '../../render/Event.js';\r\nimport RenderEventType from '../../render/EventType.js';\r\nimport WebGLHelper from '../../webgl/Helper.js';\r\nimport {\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n} from '../../transform.js';\r\n\r\n/**\r\n * @typedef {Object} PostProcessesOptions\r\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\r\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\r\n * @property {string} [vertexShader] Vertex shader source\r\n * @property {string} [fragmentShader] Fragment shader source\r\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\r\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base WebGL renderer class.\r\n * Holds all logic related to data manipulation & some common rendering logic\r\n * @template {import(\"../../layer/Layer.js\").default} LayerType\r\n * @extends {LayerRenderer<LayerType>}\r\n */\r\nclass WebGLLayerRenderer extends LayerRenderer {\r\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(layer, options) {\r\n    super(layer);\r\n\r\n    options = options || {};\r\n\r\n    /**\r\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\r\n     * set before dispatching rendering events.\r\n     * @private\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.inversePixelTransform_ = createTransform();\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.postProcesses_ = options.postProcesses;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.uniforms_ = options.uniforms;\r\n\r\n    /**\r\n     * @type {WebGLHelper}\r\n     * @protected\r\n     */\r\n    this.helper;\r\n\r\n    this.onMapChanged_ = () => {\r\n      this.clearCache();\r\n      this.removeHelper();\r\n    };\r\n\r\n    layer.addChangeListener(LayerProperty.MAP, this.onMapChanged_);\r\n\r\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\r\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  dispatchPreComposeEvent(context, frameState) {\r\n    const layer = this.getLayer();\r\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\r\n      const event = new RenderEvent(\r\n        RenderEventType.PRECOMPOSE,\r\n        undefined,\r\n        frameState,\r\n        context,\r\n      );\r\n      layer.dispatchEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  dispatchPostComposeEvent(context, frameState) {\r\n    const layer = this.getLayer();\r\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\r\n      const event = new RenderEvent(\r\n        RenderEventType.POSTCOMPOSE,\r\n        undefined,\r\n        frameState,\r\n        context,\r\n      );\r\n      layer.dispatchEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset options (only handles uniforms).\r\n   * @param {Options} options Options.\r\n   */\r\n  reset(options) {\r\n    this.uniforms_ = options.uniforms;\r\n    if (this.helper) {\r\n      this.helper.setUniforms(this.uniforms_);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  removeHelper() {\r\n    if (this.helper) {\r\n      this.helper.dispose();\r\n      delete this.helper;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine whether renderFrame should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   * @override\r\n   */\r\n  prepareFrame(frameState) {\r\n    if (this.getLayer().getRenderSource()) {\r\n      let incrementGroup = true;\r\n      let groupNumber = -1;\r\n      let className;\r\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\r\n        const layer = frameState.layerStatesArray[i].layer;\r\n        const renderer = layer.getRenderer();\r\n        if (!(renderer instanceof WebGLLayerRenderer)) {\r\n          incrementGroup = true;\r\n          continue;\r\n        }\r\n        const layerClassName = layer.getClassName();\r\n        if (incrementGroup || layerClassName !== className) {\r\n          groupNumber += 1;\r\n          incrementGroup = false;\r\n        }\r\n        className = layerClassName;\r\n        if (renderer === this) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      const canvasCacheKey =\r\n        'map/' + frameState.mapId + '/group/' + groupNumber;\r\n\r\n      if (\r\n        !this.helper ||\r\n        !this.helper.canvasCacheKeyMatches(canvasCacheKey) ||\r\n        this.helper.needsToBeRecreated()\r\n      ) {\r\n        this.removeHelper();\r\n\r\n        this.helper = new WebGLHelper({\r\n          postProcesses: this.postProcesses_,\r\n          uniforms: this.uniforms_,\r\n          canvasCacheKey: canvasCacheKey,\r\n        });\r\n\r\n        if (className) {\r\n          this.helper.getCanvas().className = className;\r\n        }\r\n\r\n        this.afterHelperCreated();\r\n      }\r\n    }\r\n\r\n    return this.prepareFrameInternal(frameState);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  afterHelperCreated() {}\r\n\r\n  /**\r\n   * Determine whether renderFrame should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   * @protected\r\n   */\r\n  prepareFrameInternal(frameState) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  clearCache() {}\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    this.clearCache();\r\n    this.removeHelper();\r\n    this.getLayer()?.removeChangeListener(\r\n      LayerProperty.MAP,\r\n      this.onMapChanged_,\r\n    );\r\n    super.disposeInternal();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\r\n   * @param {WebGLRenderingContext} context The rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @private\r\n   */\r\n  dispatchRenderEvent_(type, context, frameState) {\r\n    const layer = this.getLayer();\r\n    if (layer.hasListener(type)) {\r\n      composeTransform(\r\n        this.inversePixelTransform_,\r\n        0,\r\n        0,\r\n        frameState.pixelRatio,\r\n        -frameState.pixelRatio,\r\n        0,\r\n        0,\r\n        -frameState.size[1],\r\n      );\r\n\r\n      const event = new RenderEvent(\r\n        type,\r\n        this.inversePixelTransform_,\r\n        frameState,\r\n        context,\r\n      );\r\n      layer.dispatchEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} context The rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  preRender(context, frameState) {\r\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} context The rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  postRender(context, frameState) {\r\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\r\n  }\r\n}\r\n\r\nexport default WebGLLayerRenderer;\r\n","/**\r\n * @module CME2D/renderer/webgl/TileLayerBase\r\n */\r\nimport LRUCache from '../../structs/LRUCache.js';\r\nimport ReprojDataTile from '../../reproj/DataTile.js';\r\nimport ReprojTile from '../../reproj/Tile.js';\r\nimport TileRange from '../../TileRange.js';\r\nimport TileState from '../../TileState.js';\r\nimport WebGLLayerRenderer from './Layer.js';\r\nimport {abstract, getUid} from '../../util.js';\r\nimport {create as createMat4} from '../../vec/mat4.js';\r\nimport {\r\n  createOrUpdate as createTileCoord,\r\n  getKey as getTileCoordKey,\r\n} from '../../tilecoord.js';\r\nimport {\r\n  create as createTransform,\r\n  reset as resetTransform,\r\n  rotate as rotateTransform,\r\n  scale as scaleTransform,\r\n  translate as translateTransform,\r\n} from '../../transform.js';\r\nimport {descending} from '../../array.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\nimport {getIntersection, isEmpty} from '../../extent.js';\r\nimport {toSize} from '../../size.js';\r\n\r\nexport const Uniforms = {\r\n  TILE_TRANSFORM: 'u_tileTransform',\r\n  TRANSITION_ALPHA: 'u_transitionAlpha',\r\n  DEPTH: 'u_depth',\r\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\r\n  PATTERN_ORIGIN: 'u_patternOrigin',\r\n  RESOLUTION: 'u_resolution',\r\n  ZOOM: 'u_zoom',\r\n  GLOBAL_ALPHA: 'u_globalAlpha',\r\n  PROJECTION_MATRIX: 'u_projectionMatrix',\r\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\r\n};\r\n\r\n/**\r\n * @type {Object<string, boolean>}\r\n */\r\nconst empty = {};\r\n\r\n/**\r\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\r\n * have a depth trending towards 0\r\n * @param {number} z A zoom level.\r\n * @return {number} A depth value.\r\n */\r\nfunction depthForZ(z) {\r\n  return 1 / (z + 2);\r\n}\r\n\r\n/**\r\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\r\n */\r\n/**\r\n * @typedef {Object} TileRepresentationLookup\r\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\r\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\r\n */\r\n\r\n/**\r\n * @return {TileRepresentationLookup} A new tile representation lookup.\r\n */\r\nexport function newTileRepresentationLookup() {\r\n  return {tileIds: new Set(), representationsByZ: {}};\r\n}\r\n\r\n/**\r\n * Check if a tile is already in the tile representation lookup.\r\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\r\n * @param {import(\"../../Tile.js\").default} tile A tile.\r\n * @return {boolean} The tile is already in the lookup.\r\n */\r\nfunction lookupHasTile(tileRepresentationLookup, tile) {\r\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\r\n}\r\n\r\n/**\r\n * Add a tile representation to the lookup.\r\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\r\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\r\n * @param {number} z The zoom level.\r\n */\r\nfunction addTileRepresentationToLookup(\r\n  tileRepresentationLookup,\r\n  tileRepresentation,\r\n  z,\r\n) {\r\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\r\n  if (!(z in representationsByZ)) {\r\n    representationsByZ[z] = new Set();\r\n  }\r\n  representationsByZ[z].add(tileRepresentation);\r\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\r\n}\r\n\r\n/**\r\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\r\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\r\n */\r\nfunction getRenderExtent(frameState, extent) {\r\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n  if (layerState.extent) {\r\n    extent = getIntersection(\r\n      extent,\r\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\r\n    );\r\n  }\r\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\r\n    layerState.layer.getRenderSource()\r\n  );\r\n  if (!source.getWrapX()) {\r\n    const gridExtent = source\r\n      .getTileGridForProjection(frameState.viewState.projection)\r\n      .getExtent();\r\n    if (gridExtent) {\r\n      extent = getIntersection(extent, gridExtent);\r\n    }\r\n  }\r\n  return extent;\r\n}\r\n\r\nexport function getCacheKey(source, tileCoord) {\r\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\r\n}\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\r\n * made available to shaders.\r\n * @property {number} [cacheSize=512] The tile representation cache size.\r\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base WebGL renderer for tile layers.\r\n * @template {BaseLayerType} LayerType\r\n * @template {import(\"../../Tile.js\").default} TileType\r\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\r\n * @extends {WebGLLayerRenderer<LayerType>}\r\n */\r\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\r\n  /**\r\n   * @param {LayerType} tileLayer Tile layer.\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(tileLayer, options) {\r\n    super(tileLayer, {\r\n      uniforms: options.uniforms,\r\n      postProcesses: options.postProcesses,\r\n    });\r\n\r\n    /**\r\n     * The last call to `renderFrame` was completed with all tiles loaded\r\n     * @type {boolean}\r\n     */\r\n    this.renderComplete = false;\r\n\r\n    /**\r\n     * This transform converts representation coordinates to screen coordinates.\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     * @private\r\n     */\r\n    this.tileTransform_ = createTransform();\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @protected\r\n     */\r\n    this.tempMat4 = createMat4();\r\n\r\n    /**\r\n     * @type {import(\"../../TileRange.js\").default}\r\n     * @private\r\n     */\r\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\r\n\r\n    /**\r\n     * @type {import(\"../../tilecoord.js\").TileCoord}\r\n     * @private\r\n     */\r\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\r\n\r\n    /**\r\n     * @type {import(\"../../size.js\").Size}\r\n     * @private\r\n     */\r\n    this.tempSize_ = [0, 0];\r\n\r\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\r\n    /**\r\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\r\n     * @protected\r\n     */\r\n    this.tileRepresentationCache = new LRUCache(cacheSize);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../Map.js\").FrameState|null}\r\n     */\r\n    this.frameState = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../../proj/Projection.js\").default}\r\n     */\r\n    this.projection_ = undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {Options} options Options.\r\n   * @override\r\n   */\r\n  reset(options) {\r\n    super.reset({\r\n      uniforms: options.uniforms,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Determine whether renderFrame should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   * @override\r\n   */\r\n  prepareFrameInternal(frameState) {\r\n    if (!this.projection_) {\r\n      this.projection_ = frameState.viewState.projection;\r\n    } else if (frameState.viewState.projection !== this.projection_) {\r\n      this.clearCache();\r\n      this.projection_ = frameState.viewState.projection;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const source = layer.getRenderSource();\r\n    if (!source) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\r\n      return false;\r\n    }\r\n    return source.getState() === 'ready';\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\r\n   * @return {TileRepresentation} A new tile representation\r\n   * @protected\r\n   */\r\n  createTileRepresentation(options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\r\n   * @param {number} initialZ The zoom level.\r\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\r\n   * @param {number} preload Number of additional levels to load.\r\n   */\r\n  enqueueTiles(\r\n    frameState,\r\n    extent,\r\n    initialZ,\r\n    tileRepresentationLookup,\r\n    preload,\r\n  ) {\r\n    const viewState = frameState.viewState;\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getRenderSource();\r\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\r\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\r\n\r\n    const tileSourceKey = getUid(tileSource);\r\n    if (!(tileSourceKey in frameState.wantedTiles)) {\r\n      frameState.wantedTiles[tileSourceKey] = {};\r\n    }\r\n\r\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\r\n    const tileRepresentationCache = this.tileRepresentationCache;\r\n\r\n    const map = tileLayer.getMapInternal();\r\n    const minZ = Math.max(\r\n      initialZ - preload,\r\n      tileGrid.getMinZoom(),\r\n      tileGrid.getZForResolution(\r\n        Math.min(\r\n          tileLayer.getMaxResolution(),\r\n          map\r\n            ? map\r\n                .getView()\r\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\r\n            : tileGrid.getResolution(0),\r\n        ),\r\n        tileSource.zDirection,\r\n      ),\r\n    );\r\n    for (let z = initialZ; z >= minZ; --z) {\r\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\r\n        extent,\r\n        z,\r\n        this.tempTileRange_,\r\n      );\r\n\r\n      const tileResolution = tileGrid.getResolution(z);\r\n\r\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\r\n          const cacheKey = getCacheKey(tileSource, tileCoord);\r\n\r\n          /** @type {TileRepresentation} */\r\n          let tileRepresentation;\r\n\r\n          /** @type {TileType} */\r\n          let tile;\r\n\r\n          if (tileRepresentationCache.containsKey(cacheKey)) {\r\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\r\n            tile = tileRepresentation.tile;\r\n          }\r\n          if (\r\n            !tileRepresentation ||\r\n            tileRepresentation.tile.key !== tileSource.getKey()\r\n          ) {\r\n            tile = tileSource.getTile(\r\n              z,\r\n              x,\r\n              y,\r\n              frameState.pixelRatio,\r\n              viewState.projection,\r\n            );\r\n            if (!tile) {\r\n              continue;\r\n            }\r\n          }\r\n\r\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\r\n            continue;\r\n          }\r\n\r\n          if (!tileRepresentation) {\r\n            tileRepresentation = this.createTileRepresentation({\r\n              tile: tile,\r\n              grid: tileGrid,\r\n              helper: this.helper,\r\n              gutter: gutter,\r\n            });\r\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\r\n          } else {\r\n            tileRepresentation.setTile(tile);\r\n          }\r\n\r\n          addTileRepresentationToLookup(\r\n            tileRepresentationLookup,\r\n            tileRepresentation,\r\n            z,\r\n          );\r\n\r\n          const tileQueueKey = tile.getKey();\r\n          wantedTiles[tileQueueKey] = true;\r\n\r\n          if (tile.getState() === TileState.IDLE) {\r\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\r\n              frameState.tileQueue.enqueue([\r\n                tile,\r\n                tileSourceKey,\r\n                tileGrid.getTileCoordCenter(tileCoord),\r\n                tileResolution,\r\n              ]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\r\n   * @protected\r\n   */\r\n  beforeTilesRender(frameState, tilesWithAlpha) {\r\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} If returns false, tile mask rendering will be skipped\r\n   * @protected\r\n   */\r\n  beforeTilesMaskRender(frameState) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {TileRepresentation} tileRepresentation Tile representation\r\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\r\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\r\n   * @param {number} tileResolution Tile resolution\r\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\r\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\r\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\r\n   * @param {number} depth Depth\r\n   * @param {number} gutter Gutter\r\n   * @param {number} alpha Alpha\r\n   * @protected\r\n   */\r\n  renderTile(\r\n    tileRepresentation,\r\n    tileTransform,\r\n    frameState,\r\n    renderExtent,\r\n    tileResolution,\r\n    tileSize,\r\n    tileOrigin,\r\n    tileExtent,\r\n    depth,\r\n    gutter,\r\n    alpha,\r\n  ) {}\r\n\r\n  /**\r\n   * @param {TileRepresentation} tileRepresentation Tile representation\r\n   * @param {number} tileZ Tile Z\r\n   * @param {import(\"../../extent.js\").Extent} extent Render extent\r\n   * @param {number} depth Depth\r\n   * @protected\r\n   */\r\n  renderTileMask(tileRepresentation, tileZ, extent, depth) {}\r\n\r\n  drawTile_(\r\n    frameState,\r\n    tileRepresentation,\r\n    tileZ,\r\n    gutter,\r\n    extent,\r\n    alphaLookup,\r\n    tileGrid,\r\n  ) {\r\n    if (!tileRepresentation.ready) {\r\n      return;\r\n    }\r\n    const tile = tileRepresentation.tile;\r\n    const tileCoord = tile.tileCoord;\r\n    const tileCoordKey = getTileCoordKey(tileCoord);\r\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\r\n\r\n    const tileResolution = tileGrid.getResolution(tileZ);\r\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\r\n    const tileOrigin = tileGrid.getOrigin(tileZ);\r\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\r\n    // tiles with alpha are rendered last to allow blending\r\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\r\n    if (alpha < 1) {\r\n      frameState.animate = true;\r\n    }\r\n\r\n    const viewState = frameState.viewState;\r\n    const centerX = viewState.center[0];\r\n    const centerY = viewState.center[1];\r\n\r\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\r\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\r\n\r\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\r\n\r\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\r\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\r\n\r\n    const tileScale = viewState.resolution / tileResolution;\r\n\r\n    const tileCenterI = tileCoord[1];\r\n    const tileCenterJ = tileCoord[2];\r\n\r\n    resetTransform(this.tileTransform_);\r\n    scaleTransform(\r\n      this.tileTransform_,\r\n      2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\r\n      -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter),\r\n    );\r\n    rotateTransform(this.tileTransform_, viewState.rotation);\r\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\r\n    translateTransform(\r\n      this.tileTransform_,\r\n      (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter,\r\n      (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter,\r\n    );\r\n\r\n    this.renderTile(\r\n      /** @type {TileRepresentation} */ (tileRepresentation),\r\n      this.tileTransform_,\r\n      frameState,\r\n      extent,\r\n      tileResolution,\r\n      tileSize,\r\n      tileOrigin,\r\n      tileExtent,\r\n      depth,\r\n      gutter,\r\n      alpha,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {HTMLElement} The rendered element.\r\n   * @override\r\n   */\r\n  renderFrame(frameState) {\r\n    this.frameState = frameState;\r\n    this.renderComplete = true;\r\n    const gl = this.helper.getGL();\r\n    this.preRender(gl, frameState);\r\n\r\n    const viewState = frameState.viewState;\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getRenderSource();\r\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\r\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\r\n    const extent = getRenderExtent(frameState, frameState.extent);\r\n    const z = tileGrid.getZForResolution(\r\n      viewState.resolution,\r\n      tileSource.zDirection,\r\n    );\r\n    /**\r\n     * @type {TileRepresentationLookup}\r\n     */\r\n    const tileRepresentationLookup = newTileRepresentationLookup();\r\n\r\n    const preload = tileLayer.getPreload();\r\n    if (frameState.nextExtent) {\r\n      const targetZ = tileGrid.getZForResolution(\r\n        viewState.nextResolution,\r\n        tileSource.zDirection,\r\n      );\r\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\r\n      this.enqueueTiles(\r\n        frameState,\r\n        nextExtent,\r\n        targetZ,\r\n        tileRepresentationLookup,\r\n        preload,\r\n      );\r\n    }\r\n\r\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\r\n    if (preload > 0) {\r\n      setTimeout(() => {\r\n        this.enqueueTiles(\r\n          frameState,\r\n          extent,\r\n          z - 1,\r\n          tileRepresentationLookup,\r\n          preload - 1,\r\n        );\r\n      }, 0);\r\n    }\r\n\r\n    /**\r\n     * A lookup of alpha values for tiles at the target rendering resolution\r\n     * for tiles that are in transition.  If a tile coord key is absent from\r\n     * this lookup, the tile should be rendered at alpha 1.\r\n     * @type {Object<string, number>}\r\n     */\r\n    const alphaLookup = {};\r\n\r\n    const uid = getUid(this);\r\n    const time = frameState.time;\r\n    let blend = false;\r\n\r\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\r\n\r\n    // look for cached tiles to use if a target tile is not ready\r\n    if (z in representationsByZ) {\r\n      for (const tileRepresentation of representationsByZ[z]) {\r\n        const tile = tileRepresentation.tile;\r\n        if (\r\n          (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\r\n          tile.getState() === TileState.EMPTY\r\n        ) {\r\n          continue;\r\n        }\r\n        const tileCoord = tile.tileCoord;\r\n\r\n        if (tileRepresentation.ready) {\r\n          const alpha = tile.getAlpha(uid, time);\r\n          if (alpha === 1) {\r\n            // no need to look for alt tiles\r\n            tile.endTransition(uid);\r\n            continue;\r\n          }\r\n          blend = true;\r\n          const tileCoordKey = getTileCoordKey(tileCoord);\r\n          alphaLookup[tileCoordKey] = alpha;\r\n        }\r\n        this.renderComplete = false;\r\n\r\n        // first look for child tiles (at z + 1)\r\n        const coveredByChildren = this.findAltTiles_(\r\n          tileGrid,\r\n          tileCoord,\r\n          z + 1,\r\n          tileRepresentationLookup,\r\n        );\r\n\r\n        if (coveredByChildren) {\r\n          continue;\r\n        }\r\n\r\n        // next look for parent tiles\r\n        const minZoom = tileGrid.getMinZoom();\r\n        for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\r\n          const coveredByParent = this.findAltTiles_(\r\n            tileGrid,\r\n            tileCoord,\r\n            parentZ,\r\n            tileRepresentationLookup,\r\n          );\r\n\r\n          if (coveredByParent) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\r\n\r\n    const renderTileMask = this.beforeTilesMaskRender(frameState);\r\n\r\n    if (renderTileMask) {\r\n      for (let j = 0, jj = zs.length; j < jj; ++j) {\r\n        const tileZ = zs[j];\r\n        for (const tileRepresentation of representationsByZ[tileZ]) {\r\n          const tileCoord = tileRepresentation.tile.tileCoord;\r\n          const tileCoordKey = getTileCoordKey(tileCoord);\r\n          // do not render the tile mask if alpha < 1\r\n          if (tileCoordKey in alphaLookup) {\r\n            continue;\r\n          }\r\n          const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\r\n          this.renderTileMask(\r\n            /** @type {TileRepresentation} */ (tileRepresentation),\r\n            tileZ,\r\n            tileExtent,\r\n            depthForZ(tileZ),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    this.beforeTilesRender(frameState, blend);\r\n\r\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\r\n      const tileZ = zs[j];\r\n      for (const tileRepresentation of representationsByZ[tileZ]) {\r\n        const tileCoord = tileRepresentation.tile.tileCoord;\r\n        const tileCoordKey = getTileCoordKey(tileCoord);\r\n        if (tileCoordKey in alphaLookup) {\r\n          continue;\r\n        }\r\n\r\n        this.drawTile_(\r\n          frameState,\r\n          tileRepresentation,\r\n          tileZ,\r\n          gutter,\r\n          extent,\r\n          alphaLookup,\r\n          tileGrid,\r\n        );\r\n      }\r\n    }\r\n\r\n    if (z in representationsByZ) {\r\n      for (const tileRepresentation of representationsByZ[z]) {\r\n        const tileCoord = tileRepresentation.tile.tileCoord;\r\n        const tileCoordKey = getTileCoordKey(tileCoord);\r\n        if (tileCoordKey in alphaLookup) {\r\n          this.drawTile_(\r\n            frameState,\r\n            tileRepresentation,\r\n            z,\r\n            gutter,\r\n            extent,\r\n            alphaLookup,\r\n            tileGrid,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    this.beforeFinalize(frameState);\r\n    this.helper.finalizeDraw(\r\n      frameState,\r\n      this.dispatchPreComposeEvent,\r\n      this.dispatchPostComposeEvent,\r\n    );\r\n\r\n    const canvas = this.helper.getCanvas();\r\n\r\n    const tileRepresentationCache = this.tileRepresentationCache;\r\n    while (tileRepresentationCache.canExpireCache()) {\r\n      const tileRepresentation = tileRepresentationCache.pop();\r\n      tileRepresentation.dispose();\r\n    }\r\n\r\n    // TODO: let the renderers manage their own cache instead of managing the source cache\r\n    /**\r\n     * Here we unconditionally expire the source cache since the renderer maintains\r\n     * its own cache.\r\n     * @param {import(\"../../Map.js\").default} map Map.\r\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n     */\r\n    const postRenderFunction = function (map, frameState) {\r\n      tileSource.expireCache(frameState.viewState.projection, empty);\r\n    };\r\n\r\n    frameState.postRenderFunctions.push(postRenderFunction);\r\n\r\n    this.postRender(gl, frameState);\r\n    return canvas;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  beforeFinalize(frameState) {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Look for tiles covering the provided tile coordinate at an alternate\r\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\r\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\r\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\r\n   * @param {number} altZ The alternate zoom level.\r\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\r\n   * tile representations by zoom level.\r\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\r\n   * @private\r\n   */\r\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\r\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\r\n      tileCoord,\r\n      altZ,\r\n      this.tempTileRange_,\r\n    );\r\n\r\n    if (!tileRange) {\r\n      return false;\r\n    }\r\n\r\n    let covered = true;\r\n    const tileRepresentationCache = this.tileRepresentationCache;\r\n    const source = this.getLayer().getRenderSource();\r\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\r\n        let loaded = false;\r\n        if (tileRepresentationCache.containsKey(cacheKey)) {\r\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\r\n          if (\r\n            tileRepresentation.ready &&\r\n            !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)\r\n          ) {\r\n            addTileRepresentationToLookup(\r\n              tileRepresentationLookup,\r\n              tileRepresentation,\r\n              altZ,\r\n            );\r\n            loaded = true;\r\n          }\r\n        }\r\n        if (!loaded) {\r\n          covered = false;\r\n        }\r\n      }\r\n    }\r\n    return covered;\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  clearCache() {\r\n    super.clearCache();\r\n\r\n    const tileRepresentationCache = this.tileRepresentationCache;\r\n    tileRepresentationCache.forEach((tileRepresentation) =>\r\n      tileRepresentation.dispose(),\r\n    );\r\n    tileRepresentationCache.clear();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  afterHelperCreated() {\r\n    super.afterHelperCreated();\r\n\r\n    this.tileRepresentationCache.forEach((tileRepresentation) =>\r\n      tileRepresentation.setHelper(this.helper),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    super.disposeInternal();\r\n    delete this.frameState;\r\n  }\r\n}\r\n\r\nexport default WebGLBaseTileLayerRenderer;\r\n","/**\r\n * @module CME2D/renderer/webgl/TileLayer\r\n */\r\nimport ReprojDataTile from '../../reproj/DataTile.js';\r\nimport ReprojTile from '../../reproj/Tile.js';\r\nimport TileState from '../../TileState.js';\r\nimport TileTexture from '../../webgl/TileTexture.js';\r\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\r\nimport WebGLBaseTileLayerRenderer, {\r\n  Uniforms as BaseUniforms,\r\n  getCacheKey,\r\n} from './TileLayerBase.js';\r\nimport {AttributeType} from '../../webgl/Helper.js';\r\nimport {ELEMENT_ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\r\nimport {apply as applyTransform} from '../../transform.js';\r\nimport {\r\n  boundingExtent,\r\n  containsCoordinate,\r\n  getIntersection,\r\n} from '../../extent.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\nimport {fromTransform as mat4FromTransform} from '../../vec/mat4.js';\r\nimport {toSize} from '../../size.js';\r\n\r\nexport const Uniforms = {\r\n  ...BaseUniforms,\r\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\r\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\r\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\r\n  TEXTURE_RESOLUTION: 'u_textureResolution', // map units per texture pixel\r\n  TEXTURE_ORIGIN_X: 'u_textureOriginX', // map x coordinate of left edge of texture\r\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY', // map y coordinate of top edge of texture\r\n};\r\n\r\nexport const Attributes = {\r\n  TEXTURE_COORD: 'a_textureCoord',\r\n};\r\n\r\n/**\r\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\r\n */\r\nconst attributeDescriptions = [\r\n  {\r\n    name: Attributes.TEXTURE_COORD,\r\n    size: 2,\r\n    type: AttributeType.FLOAT,\r\n  },\r\n];\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} vertexShader Vertex shader source.\r\n * @property {string} fragmentShader Fragment shader source.\r\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\r\n * made available to shaders.\r\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\r\n * @property {number} [cacheSize=512] The texture cache size.\r\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../webgl/TileTexture.js\").TileType} TileTextureType\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../webgl/TileTexture.js\").default} TileTextureRepresentation\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * WebGL renderer for tile layers.\r\n * @template {import(\"../../layer/WebGLTile.js\").default|import(\"../../layer/Flow.js\").default} LayerType\r\n * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}\r\n * @api\r\n */\r\nclass WebGLTileLayerRenderer extends WebGLBaseTileLayerRenderer {\r\n  /**\r\n   * @param {LayerType} tileLayer Tile layer.\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(tileLayer, options) {\r\n    super(tileLayer, options);\r\n\r\n    /**\r\n     * @type {WebGLProgram}\r\n     * @private\r\n     */\r\n    this.program_;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.vertexShader_ = options.vertexShader;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.fragmentShader_ = options.fragmentShader;\r\n\r\n    /**\r\n     * Tiles are rendered as a quad with the following structure:\r\n     *\r\n     *  [P3]---------[P2]\r\n     *   |`           |\r\n     *   |  `     B   |\r\n     *   |    `       |\r\n     *   |      `     |\r\n     *   |   A    `   |\r\n     *   |          ` |\r\n     *  [P0]---------[P1]\r\n     *\r\n     * Triangle A: P0, P1, P3\r\n     * Triangle B: P1, P2, P3\r\n     *\r\n     * @private\r\n     */\r\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\r\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\r\n\r\n    /**\r\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\r\n     * @private\r\n     */\r\n    this.paletteTextures_ = options.paletteTextures || [];\r\n  }\r\n\r\n  /**\r\n   * @param {Options} options Options.\r\n   * @override\r\n   */\r\n  reset(options) {\r\n    super.reset(options);\r\n    if (this.helper) {\r\n      const gl = this.helper.getGL();\r\n      for (const paletteTexture of this.paletteTextures_) {\r\n        paletteTexture.delete(gl);\r\n      }\r\n    }\r\n\r\n    this.vertexShader_ = options.vertexShader;\r\n    this.fragmentShader_ = options.fragmentShader;\r\n    this.paletteTextures_ = options.paletteTextures || [];\r\n\r\n    if (this.helper) {\r\n      this.program_ = this.helper.getProgram(\r\n        this.fragmentShader_,\r\n        this.vertexShader_,\r\n      );\r\n      const gl = this.helper.getGL();\r\n      for (const paletteTexture of this.paletteTextures_) {\r\n        // upload the texture data\r\n        paletteTexture.getTexture(gl);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  afterHelperCreated() {\r\n    super.afterHelperCreated();\r\n\r\n    const gl = this.helper.getGL();\r\n    for (const paletteTexture of this.paletteTextures_) {\r\n      // upload the texture data\r\n      paletteTexture.getTexture(gl);\r\n    }\r\n\r\n    this.program_ = this.helper.getProgram(\r\n      this.fragmentShader_,\r\n      this.vertexShader_,\r\n    );\r\n    this.helper.flushBufferData(this.indices_);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  removeHelper() {\r\n    if (this.helper) {\r\n      const gl = this.helper.getGL();\r\n      for (const paletteTexture of this.paletteTextures_) {\r\n        paletteTexture.delete(gl);\r\n      }\r\n    }\r\n\r\n    super.removeHelper();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  createTileRepresentation(options) {\r\n    return new TileTexture(options);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  beforeTilesRender(frameState, tilesWithAlpha) {\r\n    super.beforeTilesRender(frameState, tilesWithAlpha);\r\n    this.helper.useProgram(this.program_, frameState);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  renderTile(\r\n    tileTexture,\r\n    tileTransform,\r\n    frameState,\r\n    renderExtent,\r\n    tileResolution,\r\n    tileSize,\r\n    tileOrigin,\r\n    tileExtent,\r\n    depth,\r\n    gutter,\r\n    alpha,\r\n  ) {\r\n    const gl = this.helper.getGL();\r\n    this.helper.bindBuffer(tileTexture.coords);\r\n    this.helper.bindBuffer(this.indices_);\r\n    this.helper.enableAttributes(attributeDescriptions);\r\n\r\n    let textureSlot = 0;\r\n    while (textureSlot < tileTexture.textures.length) {\r\n      const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\r\n      this.helper.bindTexture(\r\n        tileTexture.textures[textureSlot],\r\n        textureSlot,\r\n        uniformName,\r\n      );\r\n      ++textureSlot;\r\n    }\r\n\r\n    for (\r\n      let paletteIndex = 0;\r\n      paletteIndex < this.paletteTextures_.length;\r\n      ++paletteIndex\r\n    ) {\r\n      const paletteTexture = this.paletteTextures_[paletteIndex];\r\n      const texture = paletteTexture.getTexture(gl);\r\n      this.helper.bindTexture(texture, textureSlot, paletteTexture.name);\r\n      ++textureSlot;\r\n    }\r\n\r\n    const viewState = frameState.viewState;\r\n\r\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\r\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\r\n\r\n    const tile = tileTexture.tile;\r\n    const tileCoord = tile.tileCoord;\r\n\r\n    const tileCenterI = tileCoord[1];\r\n    const tileCenterJ = tileCoord[2];\r\n\r\n    this.helper.setUniformMatrixValue(\r\n      Uniforms.TILE_TRANSFORM,\r\n      mat4FromTransform(this.tempMat4, tileTransform),\r\n    );\r\n\r\n    this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\r\n    this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\r\n\r\n    let gutterExtent = renderExtent;\r\n    if (gutter > 0) {\r\n      gutterExtent = tileExtent;\r\n      getIntersection(gutterExtent, renderExtent, gutterExtent);\r\n    }\r\n    this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\r\n\r\n    this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\r\n    this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\r\n\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_PIXEL_WIDTH,\r\n      tileWidthWithGutter,\r\n    );\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_PIXEL_HEIGHT,\r\n      tileHeightWithGutter,\r\n    );\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_RESOLUTION,\r\n      tileResolution,\r\n    );\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_ORIGIN_X,\r\n      tileOrigin[0] +\r\n        tileCenterI * tileSize[0] * tileResolution -\r\n        gutter * tileResolution,\r\n    );\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_ORIGIN_Y,\r\n      tileOrigin[1] -\r\n        tileCenterJ * tileSize[1] * tileResolution +\r\n        gutter * tileResolution,\r\n    );\r\n\r\n    this.helper.drawElements(0, this.indices_.getSize());\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    const gl = this.helper.getGL();\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    const frameState = this.frameState;\r\n    if (!frameState) {\r\n      return null;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const coordinate = applyTransform(\r\n      frameState.pixelToCoordinateTransform,\r\n      pixel.slice(),\r\n    );\r\n\r\n    const viewState = frameState.viewState;\r\n    const layerExtent = layer.getExtent();\r\n    if (layerExtent) {\r\n      if (\r\n        !containsCoordinate(\r\n          fromUserExtent(layerExtent, viewState.projection),\r\n          coordinate,\r\n        )\r\n      ) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // determine last source suitable for rendering at coordinate\r\n    const sources = layer.getSources(\r\n      boundingExtent([coordinate]),\r\n      viewState.resolution,\r\n    );\r\n    let i, source, tileGrid;\r\n    for (i = sources.length - 1; i >= 0; --i) {\r\n      source = sources[i];\r\n      if (source.getState() === 'ready') {\r\n        tileGrid = source.getTileGridForProjection(viewState.projection);\r\n        if (source.getWrapX()) {\r\n          break;\r\n        }\r\n        const gridExtent = tileGrid.getExtent();\r\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (i < 0) {\r\n      return null;\r\n    }\r\n\r\n    const tileTextureCache = this.tileRepresentationCache;\r\n    for (\r\n      let z = tileGrid.getZForResolution(viewState.resolution);\r\n      z >= tileGrid.getMinZoom();\r\n      --z\r\n    ) {\r\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\r\n      const cacheKey = getCacheKey(source, tileCoord);\r\n      if (!tileTextureCache.containsKey(cacheKey)) {\r\n        continue;\r\n      }\r\n      const tileTexture = tileTextureCache.get(cacheKey);\r\n      const tile = tileTexture.tile;\r\n      if (\r\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\r\n        tile.getState() === TileState.EMPTY\r\n      ) {\r\n        return null;\r\n      }\r\n      if (!tileTexture.loaded) {\r\n        continue;\r\n      }\r\n      const tileOrigin = tileGrid.getOrigin(z);\r\n      const tileSize = toSize(tileGrid.getTileSize(z));\r\n      const tileResolution = tileGrid.getResolution(z);\r\n\r\n      const col =\r\n        (coordinate[0] - tileOrigin[0]) / tileResolution -\r\n        tileCoord[1] * tileSize[0];\r\n\r\n      const row =\r\n        (tileOrigin[1] - coordinate[1]) / tileResolution -\r\n        tileCoord[2] * tileSize[1];\r\n\r\n      return tileTexture.getPixelData(col, row);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    const helper = this.helper;\r\n    if (helper) {\r\n      const gl = helper.getGL();\r\n      for (const paletteTexture of this.paletteTextures_) {\r\n        paletteTexture.delete(gl);\r\n      }\r\n      this.paletteTextures_.length = 0;\r\n\r\n      gl.deleteProgram(this.program_);\r\n      delete this.program_;\r\n      helper.deleteBuffer(this.indices_);\r\n    }\r\n    super.disposeInternal();\r\n    delete this.indices_;\r\n  }\r\n}\r\n\r\nexport default WebGLTileLayerRenderer;\r\n","/**\n * RGB space.\n *\n * @module  color-space/rgb\n */\n\nexport default {\n\tname: 'rgb',\n\tmin: [0,0,0],\n\tmax: [255,255,255],\n\tchannel: ['red', 'green', 'blue'],\n\talias: ['RGB']\n};\n","/**\n * CIE XYZ\n *\n * @module  color-space/xyz\n */\nimport rgb from './rgb.js';\n\nvar xyz = {\n\tname: 'xyz',\n\tmin: [0,0,0],\n\tchannel: ['X','Y','Z'],\n\talias: ['XYZ', 'ciexyz', 'cie1931']\n};\n\n\n/**\n * Whitepoint reference values with observer/illuminant\n *\n * http://en.wikipedia.org/wiki/Standard_illuminant\n */\nxyz.whitepoint = {\n\t//1931 2\n\t2: {\n\t\t//incadescent\n\t\tA:[109.85, 100, 35.585],\n\t\t// B:[],\n\t\tC: [98.074, 100, 118.232],\n\t\tD50: [96.422, 100, 82.521],\n\t\tD55: [95.682, 100, 92.149],\n\t\t//daylight\n\t\tD65: [95.045592705167, 100, 108.9057750759878],\n\t\tD75: [94.972, 100, 122.638],\n\t\t//flourescent\n\t\t// F1: [],\n\t\tF2: [99.187, 100, 67.395],\n\t\t// F3: [],\n\t\t// F4: [],\n\t\t// F5: [],\n\t\t// F6:[],\n\t\tF7: [95.044, 100, 108.755],\n\t\t// F8: [],\n\t\t// F9: [],\n\t\t// F10: [],\n\t\tF11: [100.966, 100, 64.370],\n\t\t// F12: [],\n\t\tE: [100,100,100]\n\t},\n\n\t//1964  10\n\t10: {\n\t\t//incadescent\n\t\tA:[111.144, 100, 35.200],\n\t\tC: [97.285, 100, 116.145],\n\t\tD50: [96.720, 100, 81.427],\n\t\tD55: [95.799, 100, 90.926],\n\t\t//daylight\n\t\tD65: [94.811, 100, 107.304],\n\t\tD75: [94.416, 100, 120.641],\n\t\t//flourescent\n\t\tF2: [103.280, 100, 69.026],\n\t\tF7: [95.792, 100, 107.687],\n\t\tF11: [103.866, 100, 65.627],\n\t\tE: [100,100,100]\n\t}\n};\n\n\n/**\n * Top values are the whitepoints top values, default are D65\n */\nxyz.max = xyz.whitepoint[2].D65;\n\n\n/**\n * Transform xyz to rgb\n *\n * @param {Array} xyz Array of xyz values\n *\n * @return {Array} RGB values\n */\nxyz.rgb = function (_xyz, white) {\n\t//FIXME: make sure we have to divide like this. Probably we have to replace matrix as well then\n\twhite = white || xyz.whitepoint[2].E;\n\n\tvar x = _xyz[0] / white[0],\n\t\ty = _xyz[1] / white[1],\n\t\tz = _xyz[2] / white[2],\n\t\tr, g, b;\n\n\t// assume sRGB\n\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\tr = (x * 3.240969941904521) + (y * -1.537383177570093) + (z * -0.498610760293);\n\tg = (x * -0.96924363628087) + (y * 1.87596750150772) + (z * 0.041555057407175);\n\tb = (x * 0.055630079696993) + (y * -0.20397695888897) + (z * 1.056971514242878);\n\n\tr = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r = (r * 12.92);\n\n\tg = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g = (g * 12.92);\n\n\tb = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b = (b * 12.92);\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n}\n\n\n\n/**\n * RGB to XYZ\n *\n * @param {Array} rgb RGB channels\n *\n * @return {Array} XYZ channels\n */\nrgb.xyz = function(rgb, white) {\n\tvar r = rgb[0] / 255,\n\t\t\tg = rgb[1] / 255,\n\t\t\tb = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.41239079926595) + (g * 0.35758433938387) + (b * 0.18048078840183);\n\tvar y = (r * 0.21263900587151) + (g * 0.71516867876775) + (b * 0.072192315360733);\n\tvar z = (r * 0.019330818715591) + (g * 0.11919477979462) + (b * 0.95053215224966);\n\n\twhite = white || xyz.whitepoint[2].E;\n\n\treturn [x * white[0], y * white[1], z * white[2]];\n};\n\n\n\nexport default xyz;\n","/**\n * CIE LUV (C'est la vie)\n *\n * @module color-space/luv\n */\n import xyz from './xyz.js';\n\nexport default {\n\tname: 'luv',\n\t//NOTE: luv has no rigidly defined limits\n\t//easyrgb fails to get proper coords\n\t//boronine states no rigid limits\n\t//colorMine refers this ones:\n\tmin: [0,-134,-140],\n\tmax: [100,224,122],\n\tchannel: ['lightness', 'u', 'v'],\n\talias: ['LUV', 'cieluv', 'cie1976'],\n\n\txyz: function(arg, i, o){\n\t\tvar _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;\n\t\tl = arg[0], u = arg[1], v = arg[2];\n\n\t\tif (l === 0) return [0,0,0];\n\n\t\t//get constants\n\t\t//var e = 0.008856451679035631; //(6/29)^3\n\t\tvar k = 0.0011070564598794539; //(3/29)^3\n\n\t\t//get illuminant/observer\n\t\ti = i || 'D65';\n\t\to = o || 2;\n\n\t\txn = xyz.whitepoint[o][i][0];\n\t\tyn = xyz.whitepoint[o][i][1];\n\t\tzn = xyz.whitepoint[o][i][2];\n\n\t\tun = (4 * xn) / (xn + (15 * yn) + (3 * zn));\n\t\tvn = (9 * yn) / (xn + (15 * yn) + (3 * zn));\n\t\t// un = 0.19783000664283;\n\t\t// vn = 0.46831999493879;\n\n\n\t\t_u = u / (13 * l) + un || 0;\n\t\t_v = v / (13 * l) + vn || 0;\n\n\t\ty = l > 8 ? yn * Math.pow( (l + 16) / 116 , 3) : yn * l * k;\n\n\t\t//wikipedia method\n\t\tx = y * 9 * _u / (4 * _v) || 0;\n\t\tz = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;\n\n\t\t//boronine method\n\t\t//https://github.com/boronine/husl/blob/master/husl.coffee#L201\n\t\t// x = 0 - (9 * y * _u) / ((_u - 4) * _v - _u * _v);\n\t\t// z = (9 * y - (15 * _v * y) - (_v * x)) / (3 * _v);\n\n\t\treturn [x, y, z];\n\t}\n};\n\n// http://www.brucelindbloom.com/index.html?Equations.html\n// https://github.com/boronine/husl/blob/master/husl.coffee\n//i - illuminant\n//o - observer\nxyz.luv = function(arg, i, o) {\n\tvar _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;\n\n\t//get constants\n\tvar e = 0.008856451679035631; //(6/29)^3\n\tvar k = 903.2962962962961; //(29/3)^3\n\n\t//get illuminant/observer coords\n\ti = i || 'D65';\n\to = o || 2;\n\n\txn = xyz.whitepoint[o][i][0];\n\tyn = xyz.whitepoint[o][i][1];\n\tzn = xyz.whitepoint[o][i][2];\n\n\tun = (4 * xn) / (xn + (15 * yn) + (3 * zn));\n\tvn = (9 * yn) / (xn + (15 * yn) + (3 * zn));\n\n\n\tx = arg[0], y = arg[1], z = arg[2];\n\n\n\t_u = (4 * x) / (x + (15 * y) + (3 * z)) || 0;\n\t_v = (9 * y) / (x + (15 * y) + (3 * z)) || 0;\n\n\tvar yr = y/yn;\n\n\tl = yr <= e ? k * yr : 116 * Math.pow(yr, 1/3) - 16;\n\n\tu = 13 * l * (_u - un);\n\tv = 13 * l * (_v - vn);\n\n\treturn [l, u, v];\n};\n","/**\n * Cylindrical CIE LUV\n *\n * @module color-space/lchuv\n */\nimport luv from './luv.js';\nimport xyz from './xyz.js';\n\n//cylindrical luv\nvar lchuv = {\n\tname: 'lchuv',\n\tchannel: ['lightness', 'chroma', 'hue'],\n\talias: ['LCHuv', 'cielchuv'],\n\tmin: [0,0,0],\n\tmax: [100,100,360],\n\n\tluv: function(luv){\n\t\tvar l = luv[0],\n\t\tc = luv[1],\n\t\th = luv[2],\n\t\tu, v, hr;\n\n\t\thr = h / 360 * 2 * Math.PI;\n\t\tu = c * Math.cos(hr);\n\t\tv = c * Math.sin(hr);\n\t\treturn [l, u, v];\n\t},\n\n\txyz: function(arg) {\n\t\treturn luv.xyz(lchuv.luv(arg));\n\t}\n};\n\nexport default lchuv;\n\nluv.lchuv = function(luv){\n\tvar l = luv[0], u = luv[1], v = luv[2];\n\n\tvar c = Math.sqrt(u*u + v*v);\n\tvar hr = Math.atan2(v,u);\n\tvar h = hr * 360 / 2 / Math.PI;\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\treturn [l,c,h]\n};\n\nxyz.lchuv = function(arg){\n  return luv.lchuv(xyz.luv(arg));\n};\n","export default {\n\taliceblue: [240, 248, 255],\n\tantiquewhite: [250, 235, 215],\n\taqua: [0, 255, 255],\n\taquamarine: [127, 255, 212],\n\tazure: [240, 255, 255],\n\tbeige: [245, 245, 220],\n\tbisque: [255, 228, 196],\n\tblack: [0, 0, 0],\n\tblanchedalmond: [255, 235, 205],\n\tblue: [0, 0, 255],\n\tblueviolet: [138, 43, 226],\n\tbrown: [165, 42, 42],\n\tburlywood: [222, 184, 135],\n\tcadetblue: [95, 158, 160],\n\tchartreuse: [127, 255, 0],\n\tchocolate: [210, 105, 30],\n\tcoral: [255, 127, 80],\n\tcornflowerblue: [100, 149, 237],\n\tcornsilk: [255, 248, 220],\n\tcrimson: [220, 20, 60],\n\tcyan: [0, 255, 255],\n\tdarkblue: [0, 0, 139],\n\tdarkcyan: [0, 139, 139],\n\tdarkgoldenrod: [184, 134, 11],\n\tdarkgray: [169, 169, 169],\n\tdarkgreen: [0, 100, 0],\n\tdarkgrey: [169, 169, 169],\n\tdarkkhaki: [189, 183, 107],\n\tdarkmagenta: [139, 0, 139],\n\tdarkolivegreen: [85, 107, 47],\n\tdarkorange: [255, 140, 0],\n\tdarkorchid: [153, 50, 204],\n\tdarkred: [139, 0, 0],\n\tdarksalmon: [233, 150, 122],\n\tdarkseagreen: [143, 188, 143],\n\tdarkslateblue: [72, 61, 139],\n\tdarkslategray: [47, 79, 79],\n\tdarkslategrey: [47, 79, 79],\n\tdarkturquoise: [0, 206, 209],\n\tdarkviolet: [148, 0, 211],\n\tdeeppink: [255, 20, 147],\n\tdeepskyblue: [0, 191, 255],\n\tdimgray: [105, 105, 105],\n\tdimgrey: [105, 105, 105],\n\tdodgerblue: [30, 144, 255],\n\tfirebrick: [178, 34, 34],\n\tfloralwhite: [255, 250, 240],\n\tforestgreen: [34, 139, 34],\n\tfuchsia: [255, 0, 255],\n\tgainsboro: [220, 220, 220],\n\tghostwhite: [248, 248, 255],\n\tgold: [255, 215, 0],\n\tgoldenrod: [218, 165, 32],\n\tgray: [128, 128, 128],\n\tgreen: [0, 128, 0],\n\tgreenyellow: [173, 255, 47],\n\tgrey: [128, 128, 128],\n\thoneydew: [240, 255, 240],\n\thotpink: [255, 105, 180],\n\tindianred: [205, 92, 92],\n\tindigo: [75, 0, 130],\n\tivory: [255, 255, 240],\n\tkhaki: [240, 230, 140],\n\tlavender: [230, 230, 250],\n\tlavenderblush: [255, 240, 245],\n\tlawngreen: [124, 252, 0],\n\tlemonchiffon: [255, 250, 205],\n\tlightblue: [173, 216, 230],\n\tlightcoral: [240, 128, 128],\n\tlightcyan: [224, 255, 255],\n\tlightgoldenrodyellow: [250, 250, 210],\n\tlightgray: [211, 211, 211],\n\tlightgreen: [144, 238, 144],\n\tlightgrey: [211, 211, 211],\n\tlightpink: [255, 182, 193],\n\tlightsalmon: [255, 160, 122],\n\tlightseagreen: [32, 178, 170],\n\tlightskyblue: [135, 206, 250],\n\tlightslategray: [119, 136, 153],\n\tlightslategrey: [119, 136, 153],\n\tlightsteelblue: [176, 196, 222],\n\tlightyellow: [255, 255, 224],\n\tlime: [0, 255, 0],\n\tlimegreen: [50, 205, 50],\n\tlinen: [250, 240, 230],\n\tmagenta: [255, 0, 255],\n\tmaroon: [128, 0, 0],\n\tmediumaquamarine: [102, 205, 170],\n\tmediumblue: [0, 0, 205],\n\tmediumorchid: [186, 85, 211],\n\tmediumpurple: [147, 112, 219],\n\tmediumseagreen: [60, 179, 113],\n\tmediumslateblue: [123, 104, 238],\n\tmediumspringgreen: [0, 250, 154],\n\tmediumturquoise: [72, 209, 204],\n\tmediumvioletred: [199, 21, 133],\n\tmidnightblue: [25, 25, 112],\n\tmintcream: [245, 255, 250],\n\tmistyrose: [255, 228, 225],\n\tmoccasin: [255, 228, 181],\n\tnavajowhite: [255, 222, 173],\n\tnavy: [0, 0, 128],\n\toldlace: [253, 245, 230],\n\tolive: [128, 128, 0],\n\tolivedrab: [107, 142, 35],\n\torange: [255, 165, 0],\n\torangered: [255, 69, 0],\n\torchid: [218, 112, 214],\n\tpalegoldenrod: [238, 232, 170],\n\tpalegreen: [152, 251, 152],\n\tpaleturquoise: [175, 238, 238],\n\tpalevioletred: [219, 112, 147],\n\tpapayawhip: [255, 239, 213],\n\tpeachpuff: [255, 218, 185],\n\tperu: [205, 133, 63],\n\tpink: [255, 192, 203],\n\tplum: [221, 160, 221],\n\tpowderblue: [176, 224, 230],\n\tpurple: [128, 0, 128],\n\trebeccapurple: [102, 51, 153],\n\tred: [255, 0, 0],\n\trosybrown: [188, 143, 143],\n\troyalblue: [65, 105, 225],\n\tsaddlebrown: [139, 69, 19],\n\tsalmon: [250, 128, 114],\n\tsandybrown: [244, 164, 96],\n\tseagreen: [46, 139, 87],\n\tseashell: [255, 245, 238],\n\tsienna: [160, 82, 45],\n\tsilver: [192, 192, 192],\n\tskyblue: [135, 206, 235],\n\tslateblue: [106, 90, 205],\n\tslategray: [112, 128, 144],\n\tslategrey: [112, 128, 144],\n\tsnow: [255, 250, 250],\n\tspringgreen: [0, 255, 127],\n\tsteelblue: [70, 130, 180],\n\ttan: [210, 180, 140],\n\tteal: [0, 128, 128],\n\tthistle: [216, 191, 216],\n\ttomato: [255, 99, 71],\n\tturquoise: [64, 224, 208],\n\tviolet: [238, 130, 238],\n\twheat: [245, 222, 179],\n\twhite: [255, 255, 255],\n\twhitesmoke: [245, 245, 245],\n\tyellow: [255, 255, 0],\n\tyellowgreen: [154, 205, 50]\n}\n","/**\n * @module color-parse\n */\nimport names from 'color-name'\n\nexport default parse\n\n/**\n * Base hues\n * http://dev.w3.org/csswg/css-color/#typedef-named-hue\n */\n//FIXME: use external hue detector\nvar baseHues = {\n\tred: 0,\n\torange: 60,\n\tyellow: 120,\n\tgreen: 180,\n\tblue: 240,\n\tpurple: 300\n}\n\n/**\n * Parse color from the string passed\n *\n * @return {Object} A space indicator `space`, an array `values` and `alpha`\n */\nfunction parse(cstr) {\n\tvar m, parts = [], alpha = 1, space\n\n\t//numeric case\n\tif (typeof cstr === 'number') {\n\t\treturn { space: 'rgb', values: [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff], alpha: 1 }\n\t}\n\tif (typeof cstr === 'number') return { space: 'rgb', values: [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff], alpha: 1 }\n\n\tcstr = String(cstr).toLowerCase();\n\n\t//keyword\n\tif (names[cstr]) {\n\t\tparts = names[cstr].slice()\n\t\tspace = 'rgb'\n\t}\n\n\t//reserved words\n\telse if (cstr === 'transparent') {\n\t\talpha = 0\n\t\tspace = 'rgb'\n\t\tparts = [0, 0, 0]\n\t}\n\n\t//hex\n\telse if (cstr[0] === '#') {\n\t\tvar base = cstr.slice(1)\n\t\tvar size = base.length\n\t\tvar isShort = size <= 4\n\t\talpha = 1\n\n\t\tif (isShort) {\n\t\t\tparts = [\n\t\t\t\tparseInt(base[0] + base[0], 16),\n\t\t\t\tparseInt(base[1] + base[1], 16),\n\t\t\t\tparseInt(base[2] + base[2], 16)\n\t\t\t]\n\t\t\tif (size === 4) {\n\t\t\t\talpha = parseInt(base[3] + base[3], 16) / 255\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tparts = [\n\t\t\t\tparseInt(base[0] + base[1], 16),\n\t\t\t\tparseInt(base[2] + base[3], 16),\n\t\t\t\tparseInt(base[4] + base[5], 16)\n\t\t\t]\n\t\t\tif (size === 8) {\n\t\t\t\talpha = parseInt(base[6] + base[7], 16) / 255\n\t\t\t}\n\t\t}\n\n\t\tif (!parts[0]) parts[0] = 0\n\t\tif (!parts[1]) parts[1] = 0\n\t\tif (!parts[2]) parts[2] = 0\n\n\t\tspace = 'rgb'\n\t}\n\n\t// color space\n\telse if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\\s*\\(([^\\)]*)\\)/.exec(cstr)) {\n\t\tvar name = m[1]\n\t\tspace = name.replace(/a$/, '')\n\t\tvar dims = space === 'cmyk' ? 4 : space === 'gray' ? 1 : 3\n\t\tparts = m[2].trim().split(/\\s*[,\\/]\\s*|\\s+/)\n\n\t\t// color(srgb-linear x x x) -> srgb-linear(x x x)\n\t\tif (space === 'color') space = parts.shift()\n\n\t\tparts = parts.map(function (x, i) {\n\t\t\t//<percentage>\n\t\t\tif (x[x.length - 1] === '%') {\n\t\t\t\tx = parseFloat(x) / 100\n\t\t\t\t// alpha -> 0..1\n\t\t\t\tif (i === 3) return x\n\t\t\t\t// rgb -> 0..255\n\t\t\t\tif (space === 'rgb') return x * 255\n\t\t\t\t// hsl, hwb H -> 0..100\n\t\t\t\tif (space[0] === 'h') return x * 100\n\t\t\t\t// lch, lab L -> 0..100\n\t\t\t\tif (space[0] === 'l' && !i) return x * 100\n\t\t\t\t// lab A B -> -125..125\n\t\t\t\tif (space === 'lab') return x * 125\n\t\t\t\t// lch C -> 0..150, H -> 0..360\n\t\t\t\tif (space === 'lch') return i < 2 ? x * 150 : x * 360\n\t\t\t\t// oklch/oklab L -> 0..1\n\t\t\t\tif (space[0] === 'o' && !i) return x\n\t\t\t\t// oklab A B -> -0.4..0.4\n\t\t\t\tif (space === 'oklab') return x * 0.4\n\t\t\t\t// oklch C -> 0..0.4, H -> 0..360\n\t\t\t\tif (space === 'oklch') return i < 2 ? x * 0.4 : x * 360\n\t\t\t\t// color(xxx) -> 0..1\n\t\t\t\treturn x\n\t\t\t}\n\n\t\t\t//hue\n\t\t\tif (space[i] === 'h' || (i === 2 && space[space.length - 1] === 'h')) {\n\t\t\t\t//<base-hue>\n\t\t\t\tif (baseHues[x] !== undefined) return baseHues[x]\n\t\t\t\t//<deg>\n\t\t\t\tif (x.endsWith('deg')) return parseFloat(x)\n\t\t\t\t//<turn>\n\t\t\t\tif (x.endsWith('turn')) return parseFloat(x) * 360\n\t\t\t\tif (x.endsWith('grad')) return parseFloat(x) * 360 / 400\n\t\t\t\tif (x.endsWith('rad')) return parseFloat(x) * 180 / Math.PI\n\t\t\t}\n\t\t\tif (x === 'none') return 0\n\t\t\treturn parseFloat(x)\n\t\t});\n\n\t\talpha = parts.length > dims ? parts.pop() : 1\n\t}\n\n\t//named channels case\n\telse if (/[0-9](?:\\s|\\/|,)/.test(cstr)) {\n\t\tparts = cstr.match(/([0-9]+)/g).map(function (value) {\n\t\t\treturn parseFloat(value)\n\t\t})\n\n\t\tspace = cstr.match(/([a-z])/ig)?.join('')?.toLowerCase() || 'rgb'\n\t}\n\n\treturn {\n\t\tspace,\n\t\tvalues: parts,\n\t\talpha\n\t}\n}\n","/**\n * @module color-space/hsl\n */\nimport rgb from './rgb.js';\n\nexport default {\n\tname: 'hsl',\n\tmin: [0,0,0],\n\tmax: [360,100,100],\n\tchannel: ['hue', 'saturation', 'lightness'],\n\talias: ['HSL'],\n\n\trgb: function(hsl) {\n\t\tvar h = hsl[0]/360, s = hsl[1]/100, l = hsl[2]/100, t1, t2, t3, rgb, val, i=0;\n\n\t\tif (s === 0) return val = l * 255, [val, val, val];\n\n\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n\t\tt1 = 2 * l - t2;\n\n\t\trgb = [0, 0, 0];\n\t\tfor (;i<3;) {\n\t\t\tt3 = h + 1 / 3 * - (i - 1);\n\t\t\tt3 < 0 ? t3++ : t3 > 1 && t3--;\n\t\t\tval = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 :\n\t\t\t2 * t3 < 1 ? t2 :\n\t\t\t3 * t3 < 2 ?  t1 + (t2 - t1) * (2 / 3 - t3) * 6 :\n\t\t\tt1;\n\t\t\trgb[i++] = val * 255;\n\t\t}\n\n\t\treturn rgb;\n\t}\n};\n\n\n//extend rgb\nrgb.hsl = function(rgb) {\n\tvar r = rgb[0]/255,\n\t\t\tg = rgb[1]/255,\n\t\t\tb = rgb[2]/255,\n\t\t\tmin = Math.min(r, g, b),\n\t\t\tmax = Math.max(r, g, b),\n\t\t\tdelta = max - min,\n\t\t\th, s, l;\n\n\tif (max === min) {\n\t\th = 0;\n\t}\n\telse if (r === max) {\n\t\th = (g - b) / delta;\n\t}\n\telse if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t}\n\telse if (b === max) {\n\t\th = 4 + (r - g)/ delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t}\n\telse if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t}\n\telse {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n","/** @module  color-rgba */\nimport parse from 'color-parse'\nimport rgb from 'color-space/rgb.js'\nimport hsl from 'color-space/hsl.js'\n\nexport default function rgba(color) {\n\t// template literals\n\tif (Array.isArray(color) && color.raw) color = String.raw(...arguments)\n\tif (color instanceof Number) color = +color\n\n\tvar values, i, l\n\n\t//attempt to parse non-array arguments\n\tvar parsed = parse(color)\n\n\tif (!parsed.space) return []\n\n\tconst min = parsed.space[0] === 'h' ? hsl.min : rgb.min\n\tconst max = parsed.space[0] === 'h' ? hsl.max : rgb.max\n\n\tvalues = Array(3)\n\tvalues[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0])\n\tvalues[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1])\n\tvalues[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2])\n\n\tif (parsed.space[0] === 'h') {\n\t\tvalues = hsl.rgb(values)\n\t}\n\n\tvalues.push(Math.min(Math.max(parsed.alpha, 0), 1))\n\n\treturn values\n}\n","/**\r\n * @module CME2D/color\r\n */\r\nimport lchuv from 'color-space/lchuv.js';\r\nimport parseRgba from 'color-rgba';\r\nimport rgb from 'color-space/rgb.js';\r\nimport xyz from 'color-space/xyz.js';\r\nimport {clamp} from './math.js';\r\n\r\n/**\r\n * A color represented as a short array [red, green, blue, alpha].\r\n * red, green, and blue should be integers in the range 0..255 inclusive.\r\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\r\n * given then `1` will be used.\r\n * @typedef {Array<number>} Color\r\n * @api\r\n */\r\n\r\n/**\r\n * Color to indicate that no color should be rendered. This is meant to be used for per-reference\r\n * comparisons only.\r\n * @type {Color}\r\n */\r\nexport const NO_COLOR = [NaN, NaN, NaN, 0];\r\n\r\n/**\r\n * Return the color as an rgba string.\r\n * @param {Color|string} color Color.\r\n * @return {string} Rgba string.\r\n * @api\r\n */\r\nexport function asString(color) {\r\n  if (typeof color === 'string') {\r\n    return color;\r\n  }\r\n  return toString(color);\r\n}\r\n\r\n/**\r\n * @type {number}\r\n */\r\nconst MAX_CACHE_SIZE = 1024;\r\n\r\n/**\r\n * We maintain a small cache of parsed strings.  Whenever the cache grows too large,\r\n * we delete an arbitrary set of the entries.\r\n *\r\n * @type {Object<string, Color>}\r\n */\r\nconst cache = {};\r\n\r\n/**\r\n * @type {number}\r\n */\r\nlet cacheSize = 0;\r\n\r\n/**\r\n * @param {Color} color A color that may or may not have an alpha channel.\r\n * @return {Color} The input color with an alpha channel.  If the input color has\r\n * an alpha channel, the input color will be returned unchanged.  Otherwise, a new\r\n * array will be returned with the input color and an alpha channel of 1.\r\n */\r\nexport function withAlpha(color) {\r\n  if (color.length === 4) {\r\n    return color;\r\n  }\r\n  const output = color.slice();\r\n  output[3] = 1;\r\n  return output;\r\n}\r\n\r\n/**\r\n * @param {Color} color RGBA color.\r\n * @return {Color} LCHuv color with alpha.\r\n */\r\nexport function rgbaToLcha(color) {\r\n  const output = xyz.lchuv(rgb.xyz(color));\r\n  output[3] = color[3];\r\n  return output;\r\n}\r\n\r\n/**\r\n * @param {Color} color LCHuv color with alpha.\r\n * @return {Color} RGBA color.\r\n */\r\nexport function lchaToRgba(color) {\r\n  const output = xyz.rgb(lchuv.xyz(color));\r\n  output[3] = color[3];\r\n  return output;\r\n}\r\n\r\n/**\r\n * @param {string} s String.\r\n * @return {Color} Color.\r\n */\r\nexport function fromString(s) {\r\n  if (s === 'none') {\r\n    return NO_COLOR;\r\n  }\r\n  if (cache.hasOwnProperty(s)) {\r\n    return cache[s];\r\n  }\r\n  if (cacheSize >= MAX_CACHE_SIZE) {\r\n    let i = 0;\r\n    for (const key in cache) {\r\n      if ((i++ & 3) === 0) {\r\n        delete cache[key];\r\n        --cacheSize;\r\n      }\r\n    }\r\n  }\r\n\r\n  const color = parseRgba(s);\r\n  if (color.length !== 4) {\r\n    throw new Error('failed to parse \"' + s + '\" as color');\r\n  }\r\n  for (const c of color) {\r\n    if (isNaN(c)) {\r\n      throw new Error('failed to parse \"' + s + '\" as color');\r\n    }\r\n  }\r\n  normalize(color);\r\n  cache[s] = color;\r\n  ++cacheSize;\r\n  return color;\r\n}\r\n\r\n/**\r\n * Return the color as an array. This function maintains a cache of calculated\r\n * arrays which means the result should not be modified.\r\n * @param {Color|string} color Color.\r\n * @return {Color} Color.\r\n * @api\r\n */\r\nexport function asArray(color) {\r\n  if (Array.isArray(color)) {\r\n    return color;\r\n  }\r\n  return fromString(color);\r\n}\r\n\r\n/**\r\n * Exported for the tests.\r\n * @param {Color} color Color.\r\n * @return {Color} Clamped color.\r\n */\r\nexport function normalize(color) {\r\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\r\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\r\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\r\n  color[3] = clamp(color[3], 0, 1);\r\n  return color;\r\n}\r\n\r\n/**\r\n * @param {Color} color Color.\r\n * @return {string} String.\r\n */\r\nexport function toString(color) {\r\n  let r = color[0];\r\n  if (r != (r | 0)) {\r\n    r = (r + 0.5) | 0;\r\n  }\r\n  let g = color[1];\r\n  if (g != (g | 0)) {\r\n    g = (g + 0.5) | 0;\r\n  }\r\n  let b = color[2];\r\n  if (b != (b | 0)) {\r\n    b = (b + 0.5) | 0;\r\n  }\r\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 1000) / 1000;\r\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\r\n}\r\n\r\n/**\r\n * @param {string} s String.\r\n * @return {boolean} Whether the string is actually a valid color\r\n */\r\nexport function isStringColor(s) {\r\n  try {\r\n    fromString(s);\r\n    return true;\r\n  } catch (_) {\r\n    return false;\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/expr/expression\r\n */\r\nimport {ascending} from '../array.js';\r\nimport {fromString as colorFromString} from '../color.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\r\n * The result of parsing an encoded expression is one of the specific expression classes.\r\n * During parsing, information is added to the parsing context about the data accessed by the\r\n * expression.\r\n */\r\n\r\n/**\r\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\r\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\r\n *\r\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\r\n *\r\n * * Reading operators:\r\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\r\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\r\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\r\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\r\n *     of bands, depending on the underlying data source and\r\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\r\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\r\n *   * `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.\r\n *   * `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a\r\n *     feature property. The result is `undefined` when there is nothing at the specified key or index.\r\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\r\n *     `Multi*` values are returned as their singular equivalent\r\n *     `Circle` geometries are returned as 'Polygon'\r\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\r\n *   * `['resolution']` returns the current resolution\r\n *   * `['time']` The time in seconds since the creation of the layer (WebGL only).\r\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\r\n *   * `['zoom']` The current zoom level (WebGL only).\r\n *   * `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line\r\n *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.\r\n *      Please note that the M component will be linearly interpolated between the two points composing a segment.\r\n *\r\n * * Math operators:\r\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\r\n *   * `['/', value1, value2]` divides `value1` by `value2`\r\n *   * `['+', value1, value2, ...]` adds the values\r\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\r\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\r\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\r\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\r\n *   * `['abs', value1]` returns the absolute value of `value1`\r\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\r\n *   * `['round', value1]` returns the nearest integer to `value1`\r\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\r\n *   * `['sin', value1]` returns the sine of `value1`\r\n *   * `['cos', value1]` returns the cosine of `value1`\r\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\r\n *   * `['sqrt', value1]` returns the square root of `value1`\r\n *\r\n * * Transform operators:\r\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\r\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\r\n *     All conditions should be `boolean`, output and fallback can be any kind.\r\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\r\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\r\n *     returns the `fallback` value.\r\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\r\n *     `fallback` values must be of the same type, and can be of any kind.\r\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\r\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\r\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\r\n *     of 1 is equivalent to `['linear']`.\r\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\r\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\r\n *     between `output1` and `outputN`.\r\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\r\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\r\n *     (Canvas only).\r\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\r\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\r\n *     (Canvas only).\r\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\r\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\r\n *     (Canvas only).\r\n *\r\n * * Logical operators:\r\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\r\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\r\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\r\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\r\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\r\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\r\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\r\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\r\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\r\n *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,\r\n *     `false` otherwise.\r\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\r\n *     (inclusively), or `false` otherwise.\r\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\r\n *     `false` otherwise.\r\n *     This operator has the following limitations:\r\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\r\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\r\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\r\n *     `['literal', ['abc', 'def', 'ghi']]`\r\n *\r\n * * Conversion operators:\r\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\r\n *     values can currently only be 2, 3 or 4 (WebGL only).\r\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\r\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\r\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\r\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\r\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\r\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\r\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\r\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\r\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\r\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\r\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\r\n *\r\n * Values can either be literals or another operator, as they will be evaluated recursively.\r\n * Literal values can be of the following types:\r\n * * `boolean`\r\n * * `number`\r\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\r\n * * `string`\r\n * * {@link module:ol/color~Color}\r\n *\r\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\r\n * @api\r\n */\r\n\r\nlet numTypes = 0;\r\nexport const NoneType = 0;\r\nexport const BooleanType = 1 << numTypes++;\r\nexport const NumberType = 1 << numTypes++;\r\nexport const StringType = 1 << numTypes++;\r\nexport const ColorType = 1 << numTypes++;\r\nexport const NumberArrayType = 1 << numTypes++;\r\nexport const SizeType = 1 << numTypes++;\r\nexport const AnyType = Math.pow(2, numTypes) - 1;\r\n\r\nconst typeNames = {\r\n  [BooleanType]: 'boolean',\r\n  [NumberType]: 'number',\r\n  [StringType]: 'string',\r\n  [ColorType]: 'color',\r\n  [NumberArrayType]: 'number[]',\r\n  [SizeType]: 'size',\r\n};\r\n\r\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\r\n\r\n/**\r\n * @param {number} type The type.\r\n * @return {boolean} The type is one of the specific types (not any or a union type).\r\n */\r\nfunction isSpecific(type) {\r\n  return type in typeNames;\r\n}\r\n\r\n/**\r\n * Get a string representation for a type.\r\n * @param {number} type The type.\r\n * @return {string} The type name.\r\n */\r\nexport function typeName(type) {\r\n  const names = [];\r\n  for (const namedType of namedTypes) {\r\n    if (includesType(type, namedType)) {\r\n      names.push(typeNames[namedType]);\r\n    }\r\n  }\r\n  if (names.length === 0) {\r\n    return 'untyped';\r\n  }\r\n  if (names.length < 3) {\r\n    return names.join(' or ');\r\n  }\r\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\r\n}\r\n\r\n/**\r\n * @param {number} broad The broad type.\r\n * @param {number} specific The specific type.\r\n * @return {boolean} The broad type includes the specific type.\r\n */\r\nexport function includesType(broad, specific) {\r\n  return (broad & specific) === specific;\r\n}\r\n\r\n/**\r\n * @param {number} oneType One type.\r\n * @param {number} otherType Another type.\r\n * @return {boolean} The set of types overlap (share a common specific type)\r\n */\r\nexport function overlapsType(oneType, otherType) {\r\n  return !!(oneType & otherType);\r\n}\r\n\r\n/**\r\n * @param {number} type The type.\r\n * @param {number} expected The expected type.\r\n * @return {boolean} The given type is exactly the expected type.\r\n */\r\nexport function isType(type, expected) {\r\n  return type === expected;\r\n}\r\n\r\n/**\r\n * @typedef {boolean|number|string|Array<number>} LiteralValue\r\n */\r\n\r\nexport class LiteralExpression {\r\n  /**\r\n   * @param {number} type The value type.\r\n   * @param {LiteralValue} value The literal value.\r\n   */\r\n  constructor(type, value) {\r\n    if (!isSpecific(type)) {\r\n      throw new Error(\r\n        `literal expressions must have a specific type, got ${typeName(type)}`,\r\n      );\r\n    }\r\n    this.type = type;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\nexport class CallExpression {\r\n  /**\r\n   * @param {number} type The return type.\r\n   * @param {string} operator The operator.\r\n   * @param {...Expression} args The arguments.\r\n   */\r\n  constructor(type, operator, ...args) {\r\n    this.type = type;\r\n    this.operator = operator;\r\n    this.args = args;\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {LiteralExpression|CallExpression} Expression\r\n */\r\n\r\n/**\r\n * @typedef {Object} ParsingContext\r\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\r\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\r\n * @property {boolean} featureId The style uses the feature id.\r\n * @property {boolean} geometryType The style uses the feature geometry type.\r\n */\r\n\r\n/**\r\n * @return {ParsingContext} A new parsing context.\r\n */\r\nexport function newParsingContext() {\r\n  return {\r\n    variables: new Set(),\r\n    properties: new Set(),\r\n    featureId: false,\r\n    geometryType: false,\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {LiteralValue|Array} EncodedExpression\r\n */\r\n\r\n/**\r\n * @param {EncodedExpression} encoded The encoded expression.\r\n * @param {number} expectedType The expected type.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {Expression} The parsed expression result.\r\n */\r\nexport function parse(encoded, expectedType, context) {\r\n  switch (typeof encoded) {\r\n    case 'boolean': {\r\n      if (isType(expectedType, StringType)) {\r\n        return new LiteralExpression(StringType, encoded ? 'true' : 'false');\r\n      }\r\n      if (!includesType(expectedType, BooleanType)) {\r\n        throw new Error(\r\n          `got a boolean, but expected ${typeName(expectedType)}`,\r\n        );\r\n      }\r\n      return new LiteralExpression(BooleanType, encoded);\r\n    }\r\n    case 'number': {\r\n      if (isType(expectedType, SizeType)) {\r\n        return new LiteralExpression(SizeType, toSize(encoded));\r\n      }\r\n      if (isType(expectedType, BooleanType)) {\r\n        return new LiteralExpression(BooleanType, !!encoded);\r\n      }\r\n      if (isType(expectedType, StringType)) {\r\n        return new LiteralExpression(StringType, encoded.toString());\r\n      }\r\n      if (!includesType(expectedType, NumberType)) {\r\n        throw new Error(`got a number, but expected ${typeName(expectedType)}`);\r\n      }\r\n      return new LiteralExpression(NumberType, encoded);\r\n    }\r\n    case 'string': {\r\n      if (isType(expectedType, ColorType)) {\r\n        return new LiteralExpression(ColorType, colorFromString(encoded));\r\n      }\r\n      if (isType(expectedType, BooleanType)) {\r\n        return new LiteralExpression(BooleanType, !!encoded);\r\n      }\r\n      if (!includesType(expectedType, StringType)) {\r\n        throw new Error(`got a string, but expected ${typeName(expectedType)}`);\r\n      }\r\n      return new LiteralExpression(StringType, encoded);\r\n    }\r\n    default: {\r\n      // pass\r\n    }\r\n  }\r\n\r\n  if (!Array.isArray(encoded)) {\r\n    throw new Error('expression must be an array or a primitive value');\r\n  }\r\n\r\n  if (encoded.length === 0) {\r\n    throw new Error('empty expression');\r\n  }\r\n\r\n  if (typeof encoded[0] === 'string') {\r\n    return parseCallExpression(encoded, expectedType, context);\r\n  }\r\n\r\n  for (const item of encoded) {\r\n    if (typeof item !== 'number') {\r\n      throw new Error('expected an array of numbers');\r\n    }\r\n  }\r\n\r\n  if (isType(expectedType, SizeType)) {\r\n    if (encoded.length !== 2) {\r\n      throw new Error(\r\n        `expected an array of two values for a size, got ${encoded.length}`,\r\n      );\r\n    }\r\n    return new LiteralExpression(SizeType, encoded);\r\n  }\r\n\r\n  if (isType(expectedType, ColorType)) {\r\n    if (encoded.length === 3) {\r\n      return new LiteralExpression(ColorType, [...encoded, 1]);\r\n    }\r\n    if (encoded.length === 4) {\r\n      return new LiteralExpression(ColorType, encoded);\r\n    }\r\n    throw new Error(\r\n      `expected an array of 3 or 4 values for a color, got ${encoded.length}`,\r\n    );\r\n  }\r\n\r\n  if (!includesType(expectedType, NumberArrayType)) {\r\n    throw new Error(\r\n      `got an array of numbers, but expected ${typeName(expectedType)}`,\r\n    );\r\n  }\r\n\r\n  return new LiteralExpression(NumberArrayType, encoded);\r\n}\r\n\r\n/**\r\n * @type {Object<string, string>}\r\n */\r\nexport const Ops = {\r\n  Get: 'get',\r\n  Var: 'var',\r\n  Concat: 'concat',\r\n  GeometryType: 'geometry-type',\r\n  LineMetric: 'line-metric',\r\n  Any: 'any',\r\n  All: 'all',\r\n  Not: '!',\r\n  Resolution: 'resolution',\r\n  Zoom: 'zoom',\r\n  Time: 'time',\r\n  Equal: '==',\r\n  NotEqual: '!=',\r\n  GreaterThan: '>',\r\n  GreaterThanOrEqualTo: '>=',\r\n  LessThan: '<',\r\n  LessThanOrEqualTo: '<=',\r\n  Multiply: '*',\r\n  Divide: '/',\r\n  Add: '+',\r\n  Subtract: '-',\r\n  Clamp: 'clamp',\r\n  Mod: '%',\r\n  Pow: '^',\r\n  Abs: 'abs',\r\n  Floor: 'floor',\r\n  Ceil: 'ceil',\r\n  Round: 'round',\r\n  Sin: 'sin',\r\n  Cos: 'cos',\r\n  Atan: 'atan',\r\n  Sqrt: 'sqrt',\r\n  Match: 'match',\r\n  Between: 'between',\r\n  Interpolate: 'interpolate',\r\n  Coalesce: 'coalesce',\r\n  Case: 'case',\r\n  In: 'in',\r\n  Number: 'number',\r\n  String: 'string',\r\n  Array: 'array',\r\n  Color: 'color',\r\n  Id: 'id',\r\n  Band: 'band',\r\n  Palette: 'palette',\r\n  ToString: 'to-string',\r\n  Has: 'has',\r\n};\r\n\r\n/**\r\n * @typedef {function(Array, number, ParsingContext):Expression} Parser\r\n *\r\n * Second argument is the expected type.\r\n */\r\n\r\n/**\r\n * @type {Object<string, Parser>}\r\n */\r\nconst parsers = {\r\n  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\r\n  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),\r\n  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\r\n  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),\r\n  [Ops.Concat]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfType(StringType),\r\n  ),\r\n  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),\r\n  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),\r\n  [Ops.Resolution]: createCallExpressionParser(withNoArgs),\r\n  [Ops.Zoom]: createCallExpressionParser(withNoArgs),\r\n  [Ops.Time]: createCallExpressionParser(withNoArgs),\r\n  [Ops.Any]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfType(BooleanType),\r\n  ),\r\n  [Ops.All]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfType(BooleanType),\r\n  ),\r\n  [Ops.Not]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(BooleanType),\r\n  ),\r\n  [Ops.Equal]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(AnyType),\r\n  ),\r\n  [Ops.NotEqual]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(AnyType),\r\n  ),\r\n  [Ops.GreaterThan]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.LessThan]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.LessThanOrEqualTo]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Multiply]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfReturnType,\r\n  ),\r\n  [Ops.Coalesce]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfReturnType,\r\n  ),\r\n  [Ops.Divide]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Add]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Subtract]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Clamp]: createCallExpressionParser(\r\n    hasArgsCount(3, 3),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Mod]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Pow]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Abs]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Floor]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Ceil]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Round]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Sin]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Cos]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Atan]: createCallExpressionParser(\r\n    hasArgsCount(1, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Sqrt]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Match]: createCallExpressionParser(\r\n    hasArgsCount(4, Infinity),\r\n    hasEvenArgs,\r\n    withMatchArgs,\r\n  ),\r\n  [Ops.Between]: createCallExpressionParser(\r\n    hasArgsCount(3, 3),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Interpolate]: createCallExpressionParser(\r\n    hasArgsCount(6, Infinity),\r\n    hasEvenArgs,\r\n    withInterpolateArgs,\r\n  ),\r\n  [Ops.Case]: createCallExpressionParser(\r\n    hasArgsCount(3, Infinity),\r\n    hasOddArgs,\r\n    withCaseArgs,\r\n  ),\r\n  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),\r\n  [Ops.Number]: createCallExpressionParser(\r\n    hasArgsCount(1, Infinity),\r\n    withArgsOfType(AnyType),\r\n  ),\r\n  [Ops.String]: createCallExpressionParser(\r\n    hasArgsCount(1, Infinity),\r\n    withArgsOfType(AnyType),\r\n  ),\r\n  [Ops.Array]: createCallExpressionParser(\r\n    hasArgsCount(1, Infinity),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Color]: createCallExpressionParser(\r\n    hasArgsCount(1, 4),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Band]: createCallExpressionParser(\r\n    hasArgsCount(1, 3),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Palette]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withPaletteArgs,\r\n  ),\r\n  [Ops.ToString]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(BooleanType | NumberType | StringType | ColorType),\r\n  ),\r\n};\r\n\r\n/**\r\n * @typedef {function(Array<EncodedExpression>, number, ParsingContext):Array<Expression>|void} ArgValidator\r\n *\r\n * An argument validator applies various checks to an encoded expression arguments and\r\n * returns the parsed arguments if any.  The second argument is the return type of the call expression.\r\n */\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withGetArgs(encoded, returnType, context) {\r\n  const argsCount = encoded.length - 1;\r\n  const args = new Array(argsCount);\r\n  for (let i = 0; i < argsCount; ++i) {\r\n    const key = encoded[i + 1];\r\n    switch (typeof key) {\r\n      case 'number': {\r\n        args[i] = new LiteralExpression(NumberType, key);\r\n        break;\r\n      }\r\n      case 'string': {\r\n        args[i] = new LiteralExpression(StringType, key);\r\n        break;\r\n      }\r\n      default: {\r\n        throw new Error(\r\n          `expected a string key or numeric array index for a get operation, got ${key}`,\r\n        );\r\n      }\r\n    }\r\n    if (i === 0) {\r\n      context.properties.add(String(key));\r\n    }\r\n  }\r\n  return args;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withVarArgs(encoded, returnType, context) {\r\n  const name = encoded[1];\r\n  if (typeof name !== 'string') {\r\n    throw new Error('expected a string argument for var operation');\r\n  }\r\n  context.variables.add(name);\r\n\r\n  return [new LiteralExpression(StringType, name)];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction usesFeatureId(encoded, returnType, context) {\r\n  context.featureId = true;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction usesGeometryType(encoded, returnType, context) {\r\n  context.geometryType = true;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withNoArgs(encoded, returnType, context) {\r\n  const operation = encoded[0];\r\n  if (encoded.length !== 1) {\r\n    throw new Error(`expected no arguments for ${operation} operation`);\r\n  }\r\n  return [];\r\n}\r\n\r\n/**\r\n * @param {number} minArgs The minimum number of arguments.\r\n * @param {number} maxArgs The maximum number of arguments.\r\n * @return {ArgValidator} The argument validator\r\n */\r\nfunction hasArgsCount(minArgs, maxArgs) {\r\n  return function (encoded, returnType, context) {\r\n    const operation = encoded[0];\r\n    const argCount = encoded.length - 1;\r\n    if (minArgs === maxArgs) {\r\n      if (argCount !== minArgs) {\r\n        const plural = minArgs === 1 ? '' : 's';\r\n        throw new Error(\r\n          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`,\r\n        );\r\n      }\r\n    } else if (argCount < minArgs || argCount > maxArgs) {\r\n      const range =\r\n        maxArgs === Infinity\r\n          ? `${minArgs} or more`\r\n          : `${minArgs} to ${maxArgs}`;\r\n      throw new Error(\r\n        `expected ${range} arguments for ${operation}, got ${argCount}`,\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * @type {ArgValidator}\r\n */\r\nfunction withArgsOfReturnType(encoded, returnType, context) {\r\n  const argCount = encoded.length - 1;\r\n  /**\r\n   * @type {Array<Expression>}\r\n   */\r\n  const args = new Array(argCount);\r\n  for (let i = 0; i < argCount; ++i) {\r\n    const expression = parse(encoded[i + 1], returnType, context);\r\n    args[i] = expression;\r\n  }\r\n  return args;\r\n}\r\n\r\n/**\r\n * @param {number} argType The argument type.\r\n * @return {ArgValidator} The argument validator\r\n */\r\nfunction withArgsOfType(argType) {\r\n  return function (encoded, returnType, context) {\r\n    const argCount = encoded.length - 1;\r\n    /**\r\n     * @type {Array<Expression>}\r\n     */\r\n    const args = new Array(argCount);\r\n    for (let i = 0; i < argCount; ++i) {\r\n      const expression = parse(encoded[i + 1], argType, context);\r\n      args[i] = expression;\r\n    }\r\n    return args;\r\n  };\r\n}\r\n\r\n/**\r\n * @type {ArgValidator}\r\n */\r\nfunction hasOddArgs(encoded, returnType, context) {\r\n  const operation = encoded[0];\r\n  const argCount = encoded.length - 1;\r\n  if (argCount % 2 === 0) {\r\n    throw new Error(\r\n      `expected an odd number of arguments for ${operation}, got ${argCount} instead`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @type {ArgValidator}\r\n */\r\nfunction hasEvenArgs(encoded, returnType, context) {\r\n  const operation = encoded[0];\r\n  const argCount = encoded.length - 1;\r\n  if (argCount % 2 === 1) {\r\n    throw new Error(\r\n      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withMatchArgs(encoded, returnType, context) {\r\n  const argsCount = encoded.length - 1;\r\n\r\n  const inputType = StringType | NumberType | BooleanType;\r\n\r\n  const input = parse(encoded[1], inputType, context);\r\n\r\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\r\n\r\n  const args = new Array(argsCount - 2);\r\n  for (let i = 0; i < argsCount - 2; i += 2) {\r\n    try {\r\n      const match = parse(encoded[i + 2], input.type, context);\r\n      args[i] = match;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 1} of match expression: ${err.message}`,\r\n      );\r\n    }\r\n    try {\r\n      const output = parse(encoded[i + 3], fallback.type, context);\r\n      args[i + 1] = output;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 2} of match expression: ${err.message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  return [input, ...args, fallback];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withInterpolateArgs(encoded, returnType, context) {\r\n  const interpolationType = encoded[1];\r\n  /**\r\n   * @type {number}\r\n   */\r\n  let base;\r\n  switch (interpolationType[0]) {\r\n    case 'linear':\r\n      base = 1;\r\n      break;\r\n    case 'exponential':\r\n      const b = interpolationType[1];\r\n      if (typeof b !== 'number' || b <= 0) {\r\n        throw new Error(\r\n          `expected a number base for exponential interpolation` +\r\n            `, got ${JSON.stringify(b)} instead`,\r\n        );\r\n      }\r\n      base = b;\r\n      break;\r\n    default:\r\n      throw new Error(\r\n        `invalid interpolation type: ${JSON.stringify(interpolationType)}`,\r\n      );\r\n  }\r\n\r\n  const interpolation = new LiteralExpression(NumberType, base);\r\n\r\n  let input;\r\n  try {\r\n    input = parse(encoded[2], NumberType, context);\r\n  } catch (err) {\r\n    throw new Error(\r\n      `failed to parse argument 1 in interpolate expression: ${err.message}`,\r\n    );\r\n  }\r\n\r\n  const args = new Array(encoded.length - 3);\r\n  for (let i = 0; i < args.length; i += 2) {\r\n    try {\r\n      const stop = parse(encoded[i + 3], NumberType, context);\r\n      args[i] = stop;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 2} for interpolate expression: ${err.message}`,\r\n      );\r\n    }\r\n    try {\r\n      const output = parse(encoded[i + 4], returnType, context);\r\n      args[i + 1] = output;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 3} for interpolate expression: ${err.message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  return [interpolation, input, ...args];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withCaseArgs(encoded, returnType, context) {\r\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\r\n\r\n  const args = new Array(encoded.length - 1);\r\n  for (let i = 0; i < args.length - 1; i += 2) {\r\n    try {\r\n      const condition = parse(encoded[i + 1], BooleanType, context);\r\n      args[i] = condition;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i} of case expression: ${err.message}`,\r\n      );\r\n    }\r\n    try {\r\n      const output = parse(encoded[i + 2], fallback.type, context);\r\n      args[i + 1] = output;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 1} of case expression: ${err.message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  args[args.length - 1] = fallback;\r\n  return args;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withInArgs(encoded, returnType, context) {\r\n  let haystack = encoded[2];\r\n  if (!Array.isArray(haystack)) {\r\n    throw new Error(\r\n      `the second argument for the \"in\" operator must be an array`,\r\n    );\r\n  }\r\n  /**\r\n   * @type {number}\r\n   */\r\n  let needleType;\r\n  if (typeof haystack[0] === 'string') {\r\n    if (haystack[0] !== 'literal') {\r\n      throw new Error(\r\n        `for the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions`,\r\n      );\r\n    }\r\n    if (!Array.isArray(haystack[1])) {\r\n      throw new Error(\r\n        `failed to parse \"in\" expression: the literal operator must be followed by an array`,\r\n      );\r\n    }\r\n    haystack = haystack[1];\r\n    needleType = StringType;\r\n  } else {\r\n    needleType = NumberType;\r\n  }\r\n\r\n  const args = new Array(haystack.length);\r\n  for (let i = 0; i < args.length; i++) {\r\n    try {\r\n      const arg = parse(haystack[i], needleType, context);\r\n      args[i] = arg;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse haystack item ${i} for \"in\" expression: ${err.message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  const needle = parse(encoded[1], needleType, context);\r\n  return [needle, ...args];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withPaletteArgs(encoded, returnType, context) {\r\n  let index;\r\n  try {\r\n    index = parse(encoded[1], NumberType, context);\r\n  } catch (err) {\r\n    throw new Error(\r\n      `failed to parse first argument in palette expression: ${err.message}`,\r\n    );\r\n  }\r\n  const colors = encoded[2];\r\n  if (!Array.isArray(colors)) {\r\n    throw new Error('the second argument of palette must be an array');\r\n  }\r\n  const parsedColors = new Array(colors.length);\r\n  for (let i = 0; i < parsedColors.length; i++) {\r\n    let color;\r\n    try {\r\n      color = parse(colors[i], ColorType, context);\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse color at index ${i} in palette expression: ${err.message}`,\r\n      );\r\n    }\r\n    if (!(color instanceof LiteralExpression)) {\r\n      throw new Error(\r\n        `the palette color at index ${i} must be a literal value`,\r\n      );\r\n    }\r\n    parsedColors[i] = color;\r\n  }\r\n  return [index, ...parsedColors];\r\n}\r\n\r\n/**\r\n * @param {Array<ArgValidator>} validators A chain of argument validators.  The last validator is expected\r\n * to return the parsed arguments.\r\n * @return {Parser} The parser.\r\n */\r\nfunction createCallExpressionParser(...validators) {\r\n  return function (encoded, returnType, context) {\r\n    const operator = encoded[0];\r\n\r\n    /**\r\n     * @type {Array<Expression>}\r\n     */\r\n    let args;\r\n    for (let i = 0; i < validators.length; i++) {\r\n      const parsed = validators[i](encoded, returnType, context);\r\n      if (i == validators.length - 1) {\r\n        if (!parsed) {\r\n          throw new Error(\r\n            'expected last argument validator to return the parsed args',\r\n          );\r\n        }\r\n        args = parsed;\r\n      }\r\n    }\r\n    return new CallExpression(returnType, operator, ...args);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {Array} encoded The encoded expression.\r\n * @param {number} returnType The expected return type of the call expression.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {Expression} The parsed expression.\r\n */\r\nfunction parseCallExpression(encoded, returnType, context) {\r\n  const operator = encoded[0];\r\n\r\n  const parser = parsers[operator];\r\n  if (!parser) {\r\n    throw new Error(`unknown operator: ${operator}`);\r\n  }\r\n  return parser(encoded, returnType, context);\r\n}\r\n\r\n/**\r\n * Returns a simplified geometry type suited for the `geometry-type` operator\r\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\r\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\r\n */\r\nexport function computeGeometryType(geometry) {\r\n  if (!geometry) {\r\n    return '';\r\n  }\r\n  const type = geometry.getType();\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'LineString':\r\n    case 'Polygon':\r\n      return type;\r\n    case 'MultiPoint':\r\n    case 'MultiLineString':\r\n    case 'MultiPolygon':\r\n      return /** @type {'Point'|'LineString'|'Polygon'} */ (type.substring(5));\r\n    case 'Circle':\r\n      return 'Polygon';\r\n    case 'GeometryCollection':\r\n      return computeGeometryType(\r\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries()[0],\r\n      );\r\n    default:\r\n      return '';\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/webgl/PaletteTexture\r\n */\r\n\r\nclass PaletteTexture {\r\n  /**\r\n   * @param {string} name The name of the texture.\r\n   * @param {Uint8Array} data The texture data.\r\n   */\r\n  constructor(name, data) {\r\n    this.name = name;\r\n    this.data = data;\r\n\r\n    /**\r\n     * @type {WebGLTexture|null}\r\n     * @private\r\n     */\r\n    this.texture_ = null;\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} gl Rendering context.\r\n   * @return {WebGLTexture} The texture.\r\n   */\r\n  getTexture(gl) {\r\n    if (!this.texture_) {\r\n      const texture = gl.createTexture();\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        0,\r\n        gl.RGBA,\r\n        this.data.length / 4,\r\n        1,\r\n        0,\r\n        gl.RGBA,\r\n        gl.UNSIGNED_BYTE,\r\n        this.data,\r\n      );\r\n      this.texture_ = texture;\r\n    }\r\n    return this.texture_;\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} gl Rendering context.\r\n   */\r\n  delete(gl) {\r\n    if (this.texture_) {\r\n      gl.deleteTexture(this.texture_);\r\n    }\r\n    this.texture_ = null;\r\n  }\r\n}\r\n\r\nexport default PaletteTexture;\r\n","/**\r\n * @module CME2D/expr/gpu\r\n */\r\nimport PaletteTexture from '../webgl/PaletteTexture.js';\r\nimport {\r\n  BooleanType,\r\n  CallExpression,\r\n  ColorType,\r\n  NumberArrayType,\r\n  NumberType,\r\n  Ops,\r\n  SizeType,\r\n  StringType,\r\n  computeGeometryType,\r\n  parse,\r\n  typeName,\r\n} from './expression.js';\r\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\r\nimport {asArray} from '../color.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @param {string} operator Operator\r\n * @param {CompilationContext} context Compilation context\r\n * @return {string} A function name based on the operator, unique in the given context\r\n */\r\nfunction computeOperatorFunctionName(operator, context) {\r\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\r\n}\r\n\r\n/**\r\n * Will return the number as a float with a dot separator, which is required by GLSL.\r\n * @param {number} v Numerical value.\r\n * @return {string} The value as string.\r\n */\r\nexport function numberToGlsl(v) {\r\n  const s = v.toString();\r\n  return s.includes('.') ? s : s + '.0';\r\n}\r\n\r\n/**\r\n * Will return the number array as a float with a dot separator, concatenated with ', '.\r\n * @param {Array<number>} array Numerical values array.\r\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\r\n */\r\nexport function arrayToGlsl(array) {\r\n  if (array.length < 2 || array.length > 4) {\r\n    throw new Error(\r\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.',\r\n    );\r\n  }\r\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\r\n}\r\n\r\n/**\r\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\r\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\r\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\r\n * Note that the final array will always have 4 components.\r\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\r\n */\r\nexport function colorToGlsl(color) {\r\n  const array = asArray(color);\r\n  const alpha = array.length > 3 ? array[3] : 1;\r\n  return arrayToGlsl([array[0] / 255, array[1] / 255, array[2] / 255, alpha]);\r\n}\r\n\r\n/**\r\n * Normalizes and converts a number or array toa `vec2` array compatible with GLSL.\r\n * @param {number|import('../size.js').Size} size Size.\r\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\r\n */\r\nexport function sizeToGlsl(size) {\r\n  const array = toSize(size);\r\n  return arrayToGlsl(array);\r\n}\r\n\r\n/** @type {Object<string, number>} */\r\nconst stringToFloatMap = {};\r\nlet stringToFloatCounter = 0;\r\n\r\n/**\r\n * Returns a stable equivalent number for the string literal.\r\n * @param {string} string String literal value\r\n * @return {number} Number equivalent\r\n */\r\nexport function getStringNumberEquivalent(string) {\r\n  if (!(string in stringToFloatMap)) {\r\n    stringToFloatMap[string] = stringToFloatCounter++;\r\n  }\r\n  return stringToFloatMap[string];\r\n}\r\n\r\n/**\r\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\r\n * converted to be a GLSL-compatible string.\r\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\r\n * @param {string} string String literal value\r\n * @return {string} GLSL-compatible string containing a number\r\n */\r\nexport function stringToGlsl(string) {\r\n  return numberToGlsl(getStringNumberEquivalent(string));\r\n}\r\n\r\n/**\r\n * Get the uniform name given a variable name.\r\n * @param {string} variableName The variable name.\r\n * @return {string} The uniform name.\r\n */\r\nexport function uniformNameForVariable(variableName) {\r\n  return 'u_var_' + variableName;\r\n}\r\n\r\n/**\r\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\r\n */\r\n/**\r\n *\r\n * @typedef {import(\"./expression.js\").Expression} Expression\r\n */\r\n/**\r\n *\r\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompilationContextProperty\r\n * @property {string} name Name\r\n * @property {number} type Resolved property type\r\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompilationContextVariable\r\n * @property {string} name Name\r\n * @property {number} type Resolved variable type\r\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompilationContext\r\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\r\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\r\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\r\n * @property {Object<string, string>} functions Lookup of functions used by the style.\r\n * @property {number} [bandCount] Number of bands per pixel.\r\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\r\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\r\n */\r\n\r\n/**\r\n * @return {CompilationContext} A new compilation context.\r\n */\r\nexport function newCompilationContext() {\r\n  return {\r\n    inFragmentShader: false,\r\n    variables: {},\r\n    properties: {},\r\n    functions: {},\r\n    bandCount: 0,\r\n    style: {},\r\n  };\r\n}\r\n\r\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\r\n\r\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\r\n\r\n/**\r\n * @typedef {string} CompiledExpression\r\n */\r\n\r\n/**\r\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\r\n * Third argument is the expected value types\r\n */\r\n\r\n/**\r\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\r\n * @param {number} type The expected type.\r\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\r\n * @param {CompilationContext} compilationContext An existing compilation context\r\n * @return {CompiledExpression} The compiled expression.\r\n */\r\nexport function buildExpression(\r\n  encoded,\r\n  type,\r\n  parsingContext,\r\n  compilationContext,\r\n) {\r\n  const expression = parse(encoded, type, parsingContext);\r\n  return compile(expression, type, compilationContext);\r\n}\r\n\r\n/**\r\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\r\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\r\n */\r\nfunction createCompiler(output) {\r\n  return (context, expression, type) => {\r\n    const length = expression.args.length;\r\n    const args = new Array(length);\r\n    for (let i = 0; i < length; ++i) {\r\n      args[i] = compile(expression.args[i], type, context);\r\n    }\r\n    return output(args, context);\r\n  };\r\n}\r\n\r\n/**\r\n * @type {Object<string, Compiler>}\r\n */\r\nconst compilers = {\r\n  [Ops.Get]: (context, expression) => {\r\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\r\n    const propName = /** @type {string} */ (firstArg.value);\r\n    const isExisting = propName in context.properties;\r\n    if (!isExisting) {\r\n      context.properties[propName] = {\r\n        name: propName,\r\n        type: expression.type,\r\n      };\r\n    }\r\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\r\n    return prefix + propName;\r\n  },\r\n  [Ops.GeometryType]: (context, expression, type) => {\r\n    const propName = 'geometryType';\r\n    const isExisting = propName in context.properties;\r\n    if (!isExisting) {\r\n      context.properties[propName] = {\r\n        name: propName,\r\n        type: StringType,\r\n        evaluator: (feature) => {\r\n          return computeGeometryType(feature.getGeometry());\r\n        },\r\n      };\r\n    }\r\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\r\n    return prefix + propName;\r\n  },\r\n  [Ops.LineMetric]: () => 'currentLineMetric', // this variable is assumed to always be present in shaders, default is 0.\r\n  [Ops.Var]: (context, expression) => {\r\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\r\n    const varName = /** @type {string} */ (firstArg.value);\r\n    const isExisting = varName in context.variables;\r\n    if (!isExisting) {\r\n      context.variables[varName] = {\r\n        name: varName,\r\n        type: expression.type,\r\n      };\r\n    }\r\n    return uniformNameForVariable(varName);\r\n  },\r\n  [Ops.Resolution]: () => 'u_resolution',\r\n  [Ops.Zoom]: () => 'u_zoom',\r\n  [Ops.Time]: () => 'u_time',\r\n  [Ops.Any]: createCompiler((compiledArgs) => `(${compiledArgs.join(` || `)})`),\r\n  [Ops.All]: createCompiler((compiledArgs) => `(${compiledArgs.join(` && `)})`),\r\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\r\n  [Ops.Equal]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`,\r\n  ),\r\n  [Ops.NotEqual]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`,\r\n  ),\r\n  [Ops.GreaterThan]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`,\r\n  ),\r\n  [Ops.GreaterThanOrEqualTo]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`,\r\n  ),\r\n  [Ops.LessThan]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`,\r\n  ),\r\n  [Ops.LessThanOrEqualTo]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`,\r\n  ),\r\n  [Ops.Multiply]: createCompiler(\r\n    (compiledArgs) => `(${compiledArgs.join(' * ')})`,\r\n  ),\r\n  [Ops.Divide]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`,\r\n  ),\r\n  [Ops.Add]: createCompiler((compiledArgs) => `(${compiledArgs.join(' + ')})`),\r\n  [Ops.Subtract]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`,\r\n  ),\r\n  [Ops.Clamp]: createCompiler(\r\n    ([value, min, max]) => `clamp(${value}, ${min}, ${max})`,\r\n  ),\r\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\r\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\r\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\r\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\r\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\r\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\r\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\r\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\r\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\r\n    return secondValue !== undefined\r\n      ? `atan(${firstValue}, ${secondValue})`\r\n      : `atan(${firstValue})`;\r\n  }),\r\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\r\n  [Ops.Match]: createCompiler((compiledArgs) => {\r\n    const input = compiledArgs[0];\r\n    const fallback = compiledArgs[compiledArgs.length - 1];\r\n    let result = null;\r\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\r\n      const match = compiledArgs[i];\r\n      const output = compiledArgs[i + 1];\r\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\r\n    }\r\n    return result;\r\n  }),\r\n  [Ops.Between]: createCompiler(\r\n    ([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`,\r\n  ),\r\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\r\n    let result = '';\r\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\r\n      const stop1 = compiledArgs[i];\r\n      const output1 = result || compiledArgs[i + 1];\r\n      const stop2 = compiledArgs[i + 2];\r\n      const output2 = compiledArgs[i + 3];\r\n      let ratio;\r\n      if (exponent === numberToGlsl(1)) {\r\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\r\n      } else {\r\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\r\n      }\r\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\r\n    }\r\n    return result;\r\n  }),\r\n  [Ops.Case]: createCompiler((compiledArgs) => {\r\n    const fallback = compiledArgs[compiledArgs.length - 1];\r\n    let result = null;\r\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\r\n      const condition = compiledArgs[i];\r\n      const output = compiledArgs[i + 1];\r\n      result = `(${condition} ? ${output} : ${result || fallback})`;\r\n    }\r\n    return result;\r\n  }),\r\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\r\n    const funcName = computeOperatorFunctionName('in', context);\r\n    const tests = [];\r\n    for (let i = 0; i < haystack.length; i += 1) {\r\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\r\n    }\r\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\r\n${tests.join('\\n')}\r\n  return false;\r\n}`;\r\n    return `${funcName}(${needle})`;\r\n  }),\r\n  [Ops.Array]: createCompiler(\r\n    (args) => `vec${args.length}(${args.join(', ')})`,\r\n  ),\r\n  [Ops.Color]: createCompiler((compiledArgs) => {\r\n    if (compiledArgs.length === 1) {\r\n      //grayscale\r\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), 1.0)`;\r\n    }\r\n    if (compiledArgs.length === 2) {\r\n      //grayscale with alpha\r\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), ${compiledArgs[1]})`;\r\n    }\r\n    const rgb = compiledArgs.slice(0, 3).map((color) => `${color} / 255.0`);\r\n    if (compiledArgs.length === 3) {\r\n      return `vec4(${rgb.join(', ')}, 1.0)`;\r\n    }\r\n    const alpha = compiledArgs[3];\r\n    return `vec4(${rgb.join(', ')}, ${alpha})`;\r\n  }),\r\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\r\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\r\n      let ifBlocks = '';\r\n      const bandCount = context.bandCount || 1;\r\n      for (let i = 0; i < bandCount; i++) {\r\n        const colorIndex = Math.floor(i / 4);\r\n        let bandIndex = i % 4;\r\n        if (i === bandCount - 1 && bandIndex === 1) {\r\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\r\n          bandIndex = 3;\r\n        }\r\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\r\n        ifBlocks += `  if (band == ${i + 1}.0) {\r\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\r\n  }\r\n`;\r\n      }\r\n\r\n      context.functions[GET_BAND_VALUE_FUNC] =\r\n        `float getBandValue(float band, float xOffset, float yOffset) {\r\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\r\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\r\n${ifBlocks}\r\n}`;\r\n    }\r\n\r\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${\r\n      yOffset ?? '0.0'\r\n    })`;\r\n  }),\r\n  [Ops.Palette]: (context, expression) => {\r\n    const [index, ...colors] = expression.args;\r\n    const numColors = colors.length;\r\n    const palette = new Uint8Array(numColors * 4);\r\n    for (let i = 0; i < colors.length; i++) {\r\n      const parsedValue = /** @type {string | Array<number>} */ (\r\n        /** @type {LiteralExpression} */ (colors[i]).value\r\n      );\r\n      const color = asArray(parsedValue);\r\n      const offset = i * 4;\r\n      palette[offset] = color[0];\r\n      palette[offset + 1] = color[1];\r\n      palette[offset + 2] = color[2];\r\n      palette[offset + 3] = color[3] * 255;\r\n    }\r\n    if (!context.paletteTextures) {\r\n      context.paletteTextures = [];\r\n    }\r\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\r\n    const paletteTexture = new PaletteTexture(paletteName, palette);\r\n    context.paletteTextures.push(paletteTexture);\r\n    const compiledIndex = compile(index, NumberType, context);\r\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\r\n  },\r\n  // TODO: unimplemented\r\n  // Ops.Number\r\n  // Ops.String\r\n  // Ops.Coalesce\r\n  // Ops.Concat\r\n  // Ops.ToString\r\n};\r\n\r\n/**\r\n * @param {Expression} expression The expression.\r\n * @param {number} returnType The expected return type.\r\n * @param {CompilationContext} context The compilation context.\r\n * @return {CompiledExpression} The compiled expression\r\n */\r\nfunction compile(expression, returnType, context) {\r\n  // operator\r\n  if (expression instanceof CallExpression) {\r\n    const compiler = compilers[expression.operator];\r\n    if (compiler === undefined) {\r\n      throw new Error(\r\n        `No compiler defined for this operator: ${JSON.stringify(\r\n          expression.operator,\r\n        )}`,\r\n      );\r\n    }\r\n    return compiler(context, expression, returnType);\r\n  }\r\n\r\n  if ((expression.type & NumberType) > 0) {\r\n    return numberToGlsl(/** @type {number} */ (expression.value));\r\n  }\r\n\r\n  if ((expression.type & BooleanType) > 0) {\r\n    return expression.value.toString();\r\n  }\r\n\r\n  if ((expression.type & StringType) > 0) {\r\n    return stringToGlsl(expression.value.toString());\r\n  }\r\n\r\n  if ((expression.type & ColorType) > 0) {\r\n    return colorToGlsl(\r\n      /** @type {Array<number> | string} */ (expression.value),\r\n    );\r\n  }\r\n\r\n  if ((expression.type & NumberArrayType) > 0) {\r\n    return arrayToGlsl(/** @type {Array<number>} */ (expression.value));\r\n  }\r\n\r\n  if ((expression.type & SizeType) > 0) {\r\n    return sizeToGlsl(\r\n      /** @type {number|import('../size.js').Size} */ (expression.value),\r\n    );\r\n  }\r\n\r\n  throw new Error(\r\n    `Unexpected expression ${expression.value} (expected type ${typeName(\r\n      returnType,\r\n    )})`,\r\n  );\r\n}\r\n","/**\r\n * Utilities for parsing literal style objects\r\n * @module CME2D/webgl/styleparser\r\n */\r\nimport {\r\n  BooleanType,\r\n  ColorType,\r\n  NumberArrayType,\r\n  NumberType,\r\n  SizeType,\r\n  StringType,\r\n  newParsingContext,\r\n} from '../expr/expression.js';\r\nimport {ShaderBuilder} from './ShaderBuilder.js';\r\nimport {asArray} from '../color.js';\r\nimport {\r\n  buildExpression,\r\n  getStringNumberEquivalent,\r\n  stringToGlsl,\r\n  uniformNameForVariable,\r\n} from '../expr/gpu.js';\r\n\r\n/**\r\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\r\n * will be read and modified during the parsing operation.\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\r\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\r\n * @param {number} [expectedType] Expected final type (can be several types combined)\r\n * @return {string} GLSL-compatible output\r\n */\r\nexport function expressionToGlsl(compilationContext, value, expectedType) {\r\n  const parsingContext = newParsingContext();\r\n  return buildExpression(\r\n    value,\r\n    expectedType,\r\n    parsingContext,\r\n    compilationContext,\r\n  );\r\n}\r\n\r\n/**\r\n * Packs all components of a color into a two-floats array\r\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\r\n * @return {Array<number>} Vec2 array containing the color in compressed form\r\n */\r\nexport function packColor(color) {\r\n  const array = asArray(color);\r\n  const r = array[0] * 256;\r\n  const g = array[1];\r\n  const b = array[2] * 256;\r\n  const a = Math.round(array[3] * 255);\r\n  return [r + g, b + a];\r\n}\r\n\r\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\r\n  return vec4(\r\n    fract(floor(packedColor[0] / 256.0) / 256.0),\r\n    fract(packedColor[0] / 256.0),\r\n    fract(floor(packedColor[1] / 256.0) / 256.0),\r\n    fract(packedColor[1] / 256.0)\r\n  );\r\n}`;\r\n\r\n/**\r\n * @param {number} type Value type\r\n * @return {1|2|3|4} The amount of components for this value\r\n */\r\nfunction getGlslSizeFromType(type) {\r\n  if (type === ColorType || type === SizeType) {\r\n    return 2;\r\n  }\r\n  if (type === NumberArrayType) {\r\n    return 4;\r\n  }\r\n  return 1;\r\n}\r\n\r\n/**\r\n * @param {number} type Value type\r\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\r\n */\r\nfunction getGlslTypeFromType(type) {\r\n  const size = getGlslSizeFromType(type);\r\n  if (size > 1) {\r\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\r\n  }\r\n  return 'float';\r\n}\r\n\r\n/**\r\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\n * @param {Object|string} input The hash input, either an object or string\r\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\r\n */\r\nexport function computeHash(input) {\r\n  const hash = JSON.stringify(input)\r\n    .split('')\r\n    .reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\r\n  return (hash >>> 0).toString();\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\r\n */\r\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\r\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\r\n    let radius = expressionToGlsl(\r\n      vertContext,\r\n      style[`${prefix}radius`],\r\n      NumberType,\r\n    );\r\n    if (`${prefix}radius2` in style) {\r\n      const radius2 = expressionToGlsl(\r\n        vertContext,\r\n        style[`${prefix}radius2`],\r\n        NumberType,\r\n      );\r\n      radius = `max(${radius}, ${radius2})`;\r\n    }\r\n    if (`${prefix}stroke-width` in style) {\r\n      radius = `(${radius} + ${expressionToGlsl(\r\n        vertContext,\r\n        style[`${prefix}stroke-width`],\r\n        NumberType,\r\n      )} * 0.5)`;\r\n    }\r\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\r\n  }\r\n  if (`${prefix}scale` in style) {\r\n    const scale = expressionToGlsl(\r\n      vertContext,\r\n      style[`${prefix}scale`],\r\n      SizeType,\r\n    );\r\n    builder.setSymbolSizeExpression(\r\n      `${builder.getSymbolSizeExpression()} * ${scale}`,\r\n    );\r\n  }\r\n  if (`${prefix}displacement` in style) {\r\n    builder.setSymbolOffsetExpression(\r\n      expressionToGlsl(\r\n        vertContext,\r\n        style[`${prefix}displacement`],\r\n        NumberArrayType,\r\n      ),\r\n    );\r\n  }\r\n  if (`${prefix}rotation` in style) {\r\n    builder.setSymbolRotationExpression(\r\n      expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType),\r\n    );\r\n  }\r\n  if (`${prefix}rotate-with-view` in style) {\r\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} distanceField The distance field expression\r\n * @param {string|null} fillColor The fill color expression; null if no fill\r\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\r\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\r\n * @param {string|null} opacity The opacity expression; null if no stroke\r\n * @return {string} The final color expression, based on the distance field and given params\r\n */\r\nfunction getColorFromDistanceField(\r\n  distanceField,\r\n  fillColor,\r\n  strokeColor,\r\n  strokeWidth,\r\n  opacity,\r\n) {\r\n  let color = 'vec4(0.)';\r\n  if (fillColor !== null) {\r\n    color = fillColor;\r\n  }\r\n  if (strokeColor !== null && strokeWidth !== null) {\r\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\r\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\r\n  }\r\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\r\n  let result = `${color} * vec4(1.0, 1.0, 1.0, ${shapeOpacity})`;\r\n  if (opacity !== null) {\r\n    result = `${result} * vec4(1.0, 1.0, 1.0, ${opacity})`;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * This will parse an image property provided by `<prefix>-src`\r\n * The image size expression in GLSL will be returned\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\r\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\r\n * @return {string} The image size expression\r\n */\r\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\r\n  const image = new Image();\r\n  image.crossOrigin =\r\n    style[`${prefix}cross-origin`] === undefined\r\n      ? 'anonymous'\r\n      : style[`${prefix}cross-origin`];\r\n  image.src = style[`${prefix}src`];\r\n\r\n  // the size is provided asynchronously using a uniform\r\n  uniforms[`u_texture${textureId}_size`] = () => {\r\n    return image.complete ? [image.width, image.height] : [0, 0];\r\n  };\r\n  builder.addUniform(`vec2 u_texture${textureId}_size`);\r\n  const size = `u_texture${textureId}_size`;\r\n\r\n  uniforms[`u_texture${textureId}`] = image;\r\n  builder.addUniform(`sampler2D u_texture${textureId}`);\r\n  return size;\r\n}\r\n\r\n/**\r\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\r\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\r\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\r\n * @return {string} The offset expression\r\n */\r\nfunction parseImageOffsetProperties(\r\n  style,\r\n  prefix,\r\n  context,\r\n  imageSize,\r\n  sampleSize,\r\n) {\r\n  let offsetExpression = expressionToGlsl(\r\n    context,\r\n    style[`${prefix}offset`],\r\n    NumberArrayType,\r\n  );\r\n  if (`${prefix}offset-origin` in style) {\r\n    switch (style[`${prefix}offset-origin`]) {\r\n      case 'top-right':\r\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\r\n        break;\r\n      case 'bottom-left':\r\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\r\n        break;\r\n      case 'bottom-right':\r\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\r\n        break;\r\n      default: // pass\r\n    }\r\n  }\r\n  return offsetExpression;\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseCircleProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  // this function takes in screen coordinates in pixels and returns the signed distance field\r\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\r\n  fragContext.functions['circleDistanceField'] =\r\n    `float circleDistanceField(vec2 point, float radius) {\r\n  return length(point) - radius;\r\n}`;\r\n\r\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\r\n\r\n  // OPACITY\r\n  let opacity = null;\r\n  if ('circle-opacity' in style) {\r\n    opacity = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-opacity'],\r\n      NumberType,\r\n    );\r\n  }\r\n\r\n  // SCALE\r\n  let currentPoint = 'coordsPx';\r\n  if ('circle-scale' in style) {\r\n    const scale = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-scale'],\r\n      SizeType,\r\n    );\r\n    currentPoint = `coordsPx / ${scale}`;\r\n  }\r\n\r\n  // FILL COLOR\r\n  let fillColor = null;\r\n  if ('circle-fill-color' in style) {\r\n    fillColor = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-fill-color'],\r\n      ColorType,\r\n    );\r\n  }\r\n\r\n  // STROKE COLOR\r\n  let strokeColor = null;\r\n  if ('circle-stroke-color' in style) {\r\n    strokeColor = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-stroke-color'],\r\n      ColorType,\r\n    );\r\n  }\r\n\r\n  // RADIUS\r\n  let radius = expressionToGlsl(\r\n    fragContext,\r\n    style['circle-radius'],\r\n    NumberType,\r\n  );\r\n\r\n  // STROKE WIDTH\r\n  let strokeWidth = null;\r\n  if ('circle-stroke-width' in style) {\r\n    strokeWidth = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-stroke-width'],\r\n      NumberType,\r\n    );\r\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\r\n  }\r\n\r\n  // FINAL COLOR\r\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\r\n  const colorExpression = getColorFromDistanceField(\r\n    distanceField,\r\n    fillColor,\r\n    strokeColor,\r\n    strokeWidth,\r\n    opacity,\r\n  );\r\n  builder.setSymbolColorExpression(colorExpression);\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseShapeProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  fragContext.functions['round'] = `float round(float v) {\r\n  return sign(v) * floor(abs(v) + 0.5);\r\n}`;\r\n\r\n  // these functions take in screen coordinates in pixels and returns the signed distance field\r\n  // (0 on the boundary, negative inside the polygon, positive outside, values in pixels)\r\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\r\n  fragContext.functions['starDistanceField'] =\r\n    `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {\r\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\r\n  float c = cos(startAngle);\r\n  float s = sin(startAngle);\r\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\r\n  float alpha = TWO_PI / numPoints; // the angle of one sector\r\n  float beta = atan(pointRotated.y, pointRotated.x);\r\n  float gamma = round(beta / alpha) * alpha; // angle in sector\r\n  c = cos(-gamma);\r\n  s = sin(-gamma);\r\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\r\n  vec2 tipToPoint = inSector + vec2(-radius, 0.);\r\n  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);\r\n  return dot(normalize(edgeNormal), tipToPoint);\r\n}`;\r\n  fragContext.functions['regularDistanceField'] =\r\n    `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\r\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\r\n  float c = cos(startAngle);\r\n  float s = sin(startAngle);\r\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\r\n  float alpha = TWO_PI / numPoints; // the angle of one sector\r\n  float radiusIn = radius * cos(PI / numPoints);\r\n  float beta = atan(pointRotated.y, pointRotated.x);\r\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\r\n  c = cos(-gamma);\r\n  s = sin(-gamma);\r\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\r\n  return inSector.x - radiusIn;\r\n}`;\r\n\r\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\r\n\r\n  // OPACITY\r\n  let opacity = null;\r\n  if ('shape-opacity' in style) {\r\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\r\n  }\r\n\r\n  // SCALE\r\n  let currentPoint = 'coordsPx';\r\n  if ('shape-scale' in style) {\r\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], SizeType);\r\n    currentPoint = `coordsPx / ${scale}`;\r\n  }\r\n\r\n  // FILL COLOR\r\n  let fillColor = null;\r\n  if ('shape-fill-color' in style) {\r\n    fillColor = expressionToGlsl(\r\n      fragContext,\r\n      style['shape-fill-color'],\r\n      ColorType,\r\n    );\r\n  }\r\n\r\n  // STROKE COLOR\r\n  let strokeColor = null;\r\n  if ('shape-stroke-color' in style) {\r\n    strokeColor = expressionToGlsl(\r\n      fragContext,\r\n      style['shape-stroke-color'],\r\n      ColorType,\r\n    );\r\n  }\r\n\r\n  // STROKE WIDTH\r\n  let strokeWidth = null;\r\n  if ('shape-stroke-width' in style) {\r\n    strokeWidth = expressionToGlsl(\r\n      fragContext,\r\n      style['shape-stroke-width'],\r\n      NumberType,\r\n    );\r\n  }\r\n\r\n  // SHAPE TYPE\r\n  const numPoints = expressionToGlsl(\r\n    fragContext,\r\n    style['shape-points'],\r\n    NumberType,\r\n  );\r\n  let angle = '0.';\r\n  if ('shape-angle' in style) {\r\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\r\n  }\r\n  let shapeField;\r\n  let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\r\n  if (strokeWidth !== null) {\r\n    radius = `${radius} + ${strokeWidth} * 0.5`;\r\n  }\r\n  if ('shape-radius2' in style) {\r\n    let radius2 = expressionToGlsl(\r\n      fragContext,\r\n      style['shape-radius2'],\r\n      NumberType,\r\n    );\r\n    if (strokeWidth !== null) {\r\n      radius2 = `${radius2} + ${strokeWidth} * 0.5`;\r\n    }\r\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${radius2}, ${angle})`;\r\n  } else {\r\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\r\n  }\r\n\r\n  // FINAL COLOR\r\n  const colorExpression = getColorFromDistanceField(\r\n    shapeField,\r\n    fillColor,\r\n    strokeColor,\r\n    strokeWidth,\r\n    opacity,\r\n  );\r\n  builder.setSymbolColorExpression(colorExpression);\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseIconProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  // COLOR\r\n  let color = 'vec4(1.0)';\r\n  if ('icon-color' in style) {\r\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\r\n  }\r\n\r\n  // OPACITY\r\n  if ('icon-opacity' in style) {\r\n    color = `${color} * vec4(1.0, 1.0, 1.0, ${expressionToGlsl(\r\n      fragContext,\r\n      style['icon-opacity'],\r\n      NumberType,\r\n    )})`;\r\n  }\r\n\r\n  // IMAGE & SIZE\r\n  const textureId = computeHash(style['icon-src']);\r\n  const sizeExpression = parseImageProperties(\r\n    style,\r\n    builder,\r\n    uniforms,\r\n    'icon-',\r\n    textureId,\r\n  );\r\n  builder\r\n    .setSymbolColorExpression(\r\n      `${color} * texture2D(u_texture${textureId}, v_texCoord)`,\r\n    )\r\n    .setSymbolSizeExpression(sizeExpression);\r\n\r\n  // override size if width/height were specified\r\n  if ('icon-width' in style && 'icon-height' in style) {\r\n    builder.setSymbolSizeExpression(\r\n      `vec2(${expressionToGlsl(\r\n        vertContext,\r\n        style['icon-width'],\r\n        NumberType,\r\n      )}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`,\r\n    );\r\n  }\r\n\r\n  // tex coord\r\n  if ('icon-offset' in style && 'icon-size' in style) {\r\n    const sampleSize = expressionToGlsl(\r\n      vertContext,\r\n      style['icon-size'],\r\n      NumberArrayType,\r\n    );\r\n    const fullsize = builder.getSymbolSizeExpression();\r\n    builder.setSymbolSizeExpression(sampleSize);\r\n    const offset = parseImageOffsetProperties(\r\n      style,\r\n      'icon-',\r\n      vertContext,\r\n      'v_quadSizePx',\r\n      sampleSize,\r\n    );\r\n    builder.setTextureCoordinateExpression(\r\n      `(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`,\r\n    );\r\n  }\r\n\r\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\r\n\r\n  if ('icon-anchor' in style) {\r\n    const anchor = expressionToGlsl(\r\n      vertContext,\r\n      style['icon-anchor'],\r\n      NumberArrayType,\r\n    );\r\n    let scale = `1.0`;\r\n    if (`icon-scale` in style) {\r\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], SizeType);\r\n    }\r\n    let shiftPx;\r\n    if (\r\n      style['icon-anchor-x-units'] === 'pixels' &&\r\n      style['icon-anchor-y-units'] === 'pixels'\r\n    ) {\r\n      shiftPx = `${anchor} * ${scale}`;\r\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\r\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\r\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\r\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\r\n    } else {\r\n      shiftPx = `${anchor} * v_quadSizePx`;\r\n    }\r\n    // default origin is top-left\r\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\r\n    if ('icon-anchor-origin' in style) {\r\n      switch (style['icon-anchor-origin']) {\r\n        case 'top-right':\r\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\r\n          break;\r\n        case 'bottom-left':\r\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\r\n          break;\r\n        case 'bottom-right':\r\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\r\n          break;\r\n        default: // pass\r\n      }\r\n    }\r\n    builder.setSymbolOffsetExpression(\r\n      `${builder.getSymbolOffsetExpression()} + ${offsetPx}`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader Builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseStrokeProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  if ('stroke-color' in style) {\r\n    builder.setStrokeColorExpression(\r\n      expressionToGlsl(fragContext, style['stroke-color'], ColorType),\r\n    );\r\n  }\r\n  if ('stroke-pattern-src' in style) {\r\n    const textureId = computeHash(style['stroke-pattern-src']);\r\n    const sizeExpression = parseImageProperties(\r\n      style,\r\n      builder,\r\n      uniforms,\r\n      'stroke-pattern-',\r\n      textureId,\r\n    );\r\n    let sampleSizeExpression = sizeExpression;\r\n    let offsetExpression = 'vec2(0.)';\r\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\r\n      sampleSizeExpression = expressionToGlsl(\r\n        fragContext,\r\n        style[`stroke-pattern-size`],\r\n        NumberArrayType,\r\n      );\r\n      offsetExpression = parseImageOffsetProperties(\r\n        style,\r\n        'stroke-pattern-',\r\n        fragContext,\r\n        sizeExpression,\r\n        sampleSizeExpression,\r\n      );\r\n    }\r\n    let spacingExpression = '0.';\r\n    if ('stroke-pattern-spacing' in style) {\r\n      spacingExpression = expressionToGlsl(\r\n        fragContext,\r\n        style['stroke-pattern-spacing'],\r\n        NumberType,\r\n      );\r\n    }\r\n    fragContext.functions['sampleStrokePattern'] =\r\n      `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {\r\n  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;\r\n  float spacingScaled = spacingPx * sampleSize.y / lineWidth;\r\n  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\r\n  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\r\n  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);\r\n  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\r\n  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\r\n  return texture2D(texture, texCoord);\r\n}`;\r\n    const textureName = `u_texture${textureId}`;\r\n    let tintExpression = '1.';\r\n    if ('stroke-color' in style) {\r\n      tintExpression = builder.getStrokeColorExpression();\r\n    }\r\n    builder.setStrokeColorExpression(\r\n      `${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio, v_width)`,\r\n    );\r\n  }\r\n\r\n  if ('stroke-width' in style) {\r\n    builder.setStrokeWidthExpression(\r\n      expressionToGlsl(vertContext, style['stroke-width'], NumberType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-offset' in style) {\r\n    builder.setStrokeOffsetExpression(\r\n      expressionToGlsl(vertContext, style['stroke-offset'], NumberType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-line-cap' in style) {\r\n    builder.setStrokeCapExpression(\r\n      expressionToGlsl(vertContext, style['stroke-line-cap'], StringType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-line-join' in style) {\r\n    builder.setStrokeJoinExpression(\r\n      expressionToGlsl(vertContext, style['stroke-line-join'], StringType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-miter-limit' in style) {\r\n    builder.setStrokeMiterLimitExpression(\r\n      expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-line-dash' in style) {\r\n    fragContext.functions['getSingleDashDistance'] =\r\n      `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\r\n  float localDistance = mod(distance, dashLengthTotal);\r\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\r\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\r\n  if (capType == ${stringToGlsl('square')}) {\r\n    distanceSegment -= v_width * 0.5;\r\n  } else if (capType == ${stringToGlsl('round')}) {\r\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\r\n  }\r\n  return distanceSegment;\r\n}`;\r\n\r\n    let dashPattern = style['stroke-line-dash'].map((v) =>\r\n      expressionToGlsl(fragContext, v, NumberType),\r\n    );\r\n    // if pattern has odd length, concatenate it with itself to be even\r\n    if (dashPattern.length % 2 === 1) {\r\n      dashPattern = [...dashPattern, ...dashPattern];\r\n    }\r\n\r\n    let offsetExpression = '0.';\r\n    if ('stroke-line-dash-offset' in style) {\r\n      offsetExpression = expressionToGlsl(\r\n        vertContext,\r\n        style['stroke-line-dash-offset'],\r\n        NumberType,\r\n      );\r\n    }\r\n\r\n    // define a function for this dash specifically\r\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\r\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\r\n\r\n    const dashLengthsDef = dashPattern.map(\r\n      (v, i) => `float dashLength${i} = ${v};`,\r\n    );\r\n    const totalLengthDef = dashPattern\r\n      .map((v, i) => `dashLength${i}`)\r\n      .join(' + ');\r\n    let currentDashOffset = '0.';\r\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\r\n    for (let i = 2; i < dashPattern.length; i += 2) {\r\n      currentDashOffset = `${currentDashOffset} + dashLength${\r\n        i - 2\r\n      } + dashLength${i - 1}`;\r\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\r\n    }\r\n\r\n    fragContext.functions[dashFunctionName] =\r\n      `float ${dashFunctionName}(float distance, float radius, float capType) {\r\n  ${dashLengthsDef.join('\\n  ')}\r\n  float totalDashLength = ${totalLengthDef};\r\n  return ${distanceExpression};\r\n}`;\r\n    builder.setStrokeDistanceFieldExpression(\r\n      `${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader Builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseFillProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  if ('fill-color' in style) {\r\n    builder.setFillColorExpression(\r\n      expressionToGlsl(fragContext, style['fill-color'], ColorType),\r\n    );\r\n  }\r\n  if ('fill-pattern-src' in style) {\r\n    const textureId = computeHash(style['fill-pattern-src']);\r\n    const sizeExpression = parseImageProperties(\r\n      style,\r\n      builder,\r\n      uniforms,\r\n      'fill-pattern-',\r\n      textureId,\r\n    );\r\n    let sampleSizeExpression = sizeExpression;\r\n    let offsetExpression = 'vec2(0.)';\r\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\r\n      sampleSizeExpression = expressionToGlsl(\r\n        fragContext,\r\n        style[`fill-pattern-size`],\r\n        NumberArrayType,\r\n      );\r\n      offsetExpression = parseImageOffsetProperties(\r\n        style,\r\n        'fill-pattern-',\r\n        fragContext,\r\n        sizeExpression,\r\n        sampleSizeExpression,\r\n      );\r\n    }\r\n    fragContext.functions['sampleFillPattern'] =\r\n      `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\r\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\r\n  vec2 pxRelativePos = pxPosition - pxOrigin;\r\n  // rotate the relative position from origin by the current view rotation\r\n  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));\r\n  // sample position is computed according to the sample offset & size\r\n  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);\r\n  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\r\n  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));\r\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\r\n  return texture2D(texture, (samplePos + textureOffset) / textureSize);\r\n}`;\r\n    const textureName = `u_texture${textureId}`;\r\n    let tintExpression = '1.';\r\n    if ('fill-color' in style) {\r\n      tintExpression = builder.getFillColorExpression();\r\n    }\r\n    builder.setFillColorExpression(\r\n      `${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} StyleParseResult\r\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\r\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\r\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\r\n */\r\n\r\n/**\r\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\r\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\r\n * arrays to be fed to the `WebGLPointsRenderer` class.\r\n *\r\n * Also returns `uniforms` and `attributes` properties as expected by the\r\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\r\n *\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\r\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\r\n */\r\nexport function parseLiteralStyle(style) {\r\n  /**\r\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\r\n   */\r\n  const vertContext = {\r\n    inFragmentShader: false,\r\n    properties: {},\r\n    variables: {},\r\n    functions: {},\r\n    style,\r\n  };\r\n\r\n  /**\r\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\r\n   */\r\n  const fragContext = {\r\n    inFragmentShader: true,\r\n    variables: vertContext.variables,\r\n    properties: {},\r\n    functions: {},\r\n    style,\r\n  };\r\n\r\n  const builder = new ShaderBuilder();\r\n\r\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\r\n  const uniforms = {};\r\n\r\n  if ('icon-src' in style) {\r\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\r\n  } else if ('shape-points' in style) {\r\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\r\n  } else if ('circle-radius' in style) {\r\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\r\n  }\r\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\r\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\r\n\r\n  if (style.filter) {\r\n    const parsedFilter = expressionToGlsl(\r\n      fragContext,\r\n      style.filter,\r\n      BooleanType,\r\n    );\r\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\r\n  }\r\n\r\n  // define one uniform per variable\r\n  for (const varName in fragContext.variables) {\r\n    const variable = fragContext.variables[varName];\r\n    const uniformName = uniformNameForVariable(variable.name);\r\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\r\n\r\n    uniforms[uniformName] = () => {\r\n      const value = style.variables[variable.name];\r\n      if (typeof value === 'number') {\r\n        return value;\r\n      }\r\n      if (typeof value === 'boolean') {\r\n        return value ? 1 : 0;\r\n      }\r\n      if (variable.type === ColorType) {\r\n        return packColor([...asArray(value || '#eee')]);\r\n      }\r\n      if (typeof value === 'string') {\r\n        return getStringNumberEquivalent(value);\r\n      }\r\n      return value;\r\n    };\r\n  }\r\n\r\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\r\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\r\n  for (const propName in fragContext.properties) {\r\n    const property = fragContext.properties[propName];\r\n    if (!vertContext.properties[propName]) {\r\n      vertContext.properties[propName] = property;\r\n    }\r\n    let type = getGlslTypeFromType(property.type);\r\n    let expression = `a_prop_${property.name}`;\r\n    if (property.type === ColorType) {\r\n      type = 'vec4';\r\n      expression = `unpackColor(${expression})`;\r\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\r\n    }\r\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\r\n  }\r\n\r\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\r\n  for (const propName in vertContext.properties) {\r\n    const property = vertContext.properties[propName];\r\n    builder.addAttribute(\r\n      `${getGlslTypeFromType(property.type)} a_prop_${property.name}`,\r\n    );\r\n  }\r\n\r\n  // add functions that were collected in the compilation contexts\r\n  for (const functionName in vertContext.functions) {\r\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\r\n  }\r\n  for (const functionName in fragContext.functions) {\r\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\r\n  }\r\n\r\n  /**\r\n   * @type {import('../render/webgl/VectorStyleRenderer.js').AttributeDefinitions}\r\n   */\r\n  const attributes = {};\r\n  for (const propName in vertContext.properties) {\r\n    const property = vertContext.properties[propName];\r\n    let callback;\r\n    if (property.evaluator) {\r\n      callback = property.evaluator;\r\n    } else {\r\n      callback = (feature) => {\r\n        const value = feature.get(property.name);\r\n        if (property.type === ColorType) {\r\n          return packColor([...asArray(value || '#eee')]);\r\n        }\r\n        if (typeof value === 'string') {\r\n          return getStringNumberEquivalent(value);\r\n        }\r\n        if (typeof value === 'boolean') {\r\n          return value ? 1 : 0;\r\n        }\r\n        return value;\r\n      };\r\n    }\r\n\r\n    attributes[property.name] = {\r\n      size: getGlslSizeFromType(property.type),\r\n      callback,\r\n    };\r\n  }\r\n\r\n  return {builder, attributes, uniforms};\r\n}\r\n","/**\r\n * @module CME2D/layer/WebGLTile\r\n */\r\nimport BaseTileLayer from './BaseTile.js';\r\nimport LayerProperty from '../layer/Property.js';\r\nimport WebGLTileLayerRenderer, {\r\n  Attributes,\r\n  Uniforms,\r\n} from '../renderer/webgl/TileLayer.js';\r\nimport {ColorType, NumberType} from '../expr/expression.js';\r\nimport {\r\n  PALETTE_TEXTURE_ARRAY,\r\n  getStringNumberEquivalent,\r\n  newCompilationContext,\r\n  uniformNameForVariable,\r\n} from '../expr/gpu.js';\r\nimport {expressionToGlsl} from '../webgl/styleparser.js';\r\n\r\n/**\r\n * @typedef {import(\"../source/DataTile.js\").default<import(\"../DataTile.js\").default|import(\"../ImageTile.js\").default>} SourceType\r\n */\r\n\r\n/**\r\n * @typedef {Object} Style\r\n * Translates tile data to rendered pixels.\r\n *\r\n * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These\r\n * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`\r\n * {@link import(\"../expr/expression.js\").ExpressionValue expressions}, using the `['var', 'varName']` operator.\r\n * To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [color] An expression applied to color values.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [brightness=0] Value used to decrease or increase\r\n * the layer brightness.  Values range from -1 to 1.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [contrast=0] Value used to decrease or increase\r\n * the layer contrast.  Values range from -1 to 1.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [exposure=0] Value used to decrease or increase\r\n * the layer exposure.  Values range from -1 to 1.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [saturation=0] Value used to decrease or increase\r\n * the layer saturation.  Values range from -1 to 1.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.\r\n * Values range from 0 to infinity.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Style} [style] Style to apply to the layer.\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\r\n * means no preloading.\r\n * @property {SourceType} [source] Source for this layer.\r\n * @property {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>} [sources] Array\r\n * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that\r\n * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See\r\n * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a\r\n * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link module:ol/Map~Map#addLayer}.\r\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\r\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\r\n * two zoom levels worth of tiles.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ParsedStyle\r\n * @property {string} vertexShader The vertex shader.\r\n * @property {string} fragmentShader The fragment shader.\r\n * @property {Object<string,import(\"../webgl/Helper.js\").UniformValue>} uniforms Uniform definitions.\r\n * @property {Array<import(\"../webgl/PaletteTexture.js\").default>} paletteTextures Palette textures.\r\n */\r\n\r\n/**\r\n * @param {Style} style The layer style.\r\n * @param {number} [bandCount] The number of bands.\r\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\r\n */\r\nfunction parseStyle(style, bandCount) {\r\n  const vertexShader = `\r\n    attribute vec2 ${Attributes.TEXTURE_COORD};\r\n    uniform mat4 ${Uniforms.TILE_TRANSFORM};\r\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\r\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\r\n    uniform float ${Uniforms.TEXTURE_RESOLUTION};\r\n    uniform float ${Uniforms.TEXTURE_ORIGIN_X};\r\n    uniform float ${Uniforms.TEXTURE_ORIGIN_Y};\r\n    uniform float ${Uniforms.DEPTH};\r\n\r\n    varying vec2 v_textureCoord;\r\n    varying vec2 v_mapCoord;\r\n\r\n    void main() {\r\n      v_textureCoord = ${Attributes.TEXTURE_COORD};\r\n      v_mapCoord = vec2(\r\n        ${Uniforms.TEXTURE_ORIGIN_X} + ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\r\n        ${Uniforms.TEXTURE_ORIGIN_Y} - ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\r\n      );\r\n      gl_Position = ${Uniforms.TILE_TRANSFORM} * vec4(${Attributes.TEXTURE_COORD}, ${Uniforms.DEPTH}, 1.0);\r\n    }\r\n  `;\r\n\r\n  /**\r\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\r\n   */\r\n  const context = {\r\n    ...newCompilationContext(),\r\n    inFragmentShader: true,\r\n    bandCount: bandCount,\r\n    style: style,\r\n  };\r\n\r\n  const pipeline = [];\r\n\r\n  if (style.color !== undefined) {\r\n    const color = expressionToGlsl(context, style.color, ColorType);\r\n    pipeline.push(`color = ${color};`);\r\n  }\r\n\r\n  if (style.contrast !== undefined) {\r\n    const contrast = expressionToGlsl(context, style.contrast, NumberType);\r\n    pipeline.push(\r\n      `color.rgb = clamp((${contrast} + 1.0) * color.rgb - (${contrast} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\r\n    );\r\n  }\r\n\r\n  if (style.exposure !== undefined) {\r\n    const exposure = expressionToGlsl(context, style.exposure, NumberType);\r\n    pipeline.push(\r\n      `color.rgb = clamp((${exposure} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\r\n    );\r\n  }\r\n\r\n  if (style.saturation !== undefined) {\r\n    const saturation = expressionToGlsl(context, style.saturation, NumberType);\r\n    pipeline.push(`\r\n      float saturation = ${saturation} + 1.0;\r\n      float sr = (1.0 - saturation) * 0.2126;\r\n      float sg = (1.0 - saturation) * 0.7152;\r\n      float sb = (1.0 - saturation) * 0.0722;\r\n      mat3 saturationMatrix = mat3(\r\n        sr + saturation, sr, sr,\r\n        sg, sg + saturation, sg,\r\n        sb, sb, sb + saturation\r\n      );\r\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\r\n    `);\r\n  }\r\n\r\n  if (style.gamma !== undefined) {\r\n    const gamma = expressionToGlsl(context, style.gamma, NumberType);\r\n    pipeline.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${gamma}));`);\r\n  }\r\n\r\n  if (style.brightness !== undefined) {\r\n    const brightness = expressionToGlsl(context, style.brightness, NumberType);\r\n    pipeline.push(\r\n      `color.rgb = clamp(color.rgb + ${brightness}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\r\n    );\r\n  }\r\n\r\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\r\n  const uniforms = {};\r\n\r\n  const numVariables = Object.keys(context.variables).length;\r\n  if (numVariables > 1 && !style.variables) {\r\n    throw new Error(\r\n      `Missing variables in style (expected ${context.variables})`,\r\n    );\r\n  }\r\n\r\n  for (let i = 0; i < numVariables; ++i) {\r\n    const variable = context.variables[Object.keys(context.variables)[i]];\r\n    if (!(variable.name in style.variables)) {\r\n      throw new Error(`Missing '${variable.name}' in style variables`);\r\n    }\r\n    const uniformName = uniformNameForVariable(variable.name);\r\n    uniforms[uniformName] = function () {\r\n      let value = style.variables[variable.name];\r\n      if (typeof value === 'string') {\r\n        value = getStringNumberEquivalent(value);\r\n      }\r\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\r\n    };\r\n  }\r\n\r\n  const uniformDeclarations = Object.keys(uniforms).map(function (name) {\r\n    return `uniform float ${name};`;\r\n  });\r\n\r\n  const textureCount = Math.ceil(bandCount / 4);\r\n  uniformDeclarations.push(\r\n    `uniform sampler2D ${Uniforms.TILE_TEXTURE_ARRAY}[${textureCount}];`,\r\n  );\r\n\r\n  if (context.paletteTextures) {\r\n    uniformDeclarations.push(\r\n      `uniform sampler2D ${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}];`,\r\n    );\r\n  }\r\n\r\n  const functionDefintions = Object.keys(context.functions).map(\r\n    function (name) {\r\n      return context.functions[name];\r\n    },\r\n  );\r\n\r\n  const fragmentShader = `\r\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\r\n    precision highp float;\r\n    #else\r\n    precision mediump float;\r\n    #endif\r\n\r\n    varying vec2 v_textureCoord;\r\n    varying vec2 v_mapCoord;\r\n    uniform vec4 ${Uniforms.RENDER_EXTENT};\r\n    uniform float ${Uniforms.TRANSITION_ALPHA};\r\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\r\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\r\n    uniform float ${Uniforms.RESOLUTION};\r\n    uniform float ${Uniforms.ZOOM};\r\n\r\n    ${uniformDeclarations.join('\\n')}\r\n\r\n    ${functionDefintions.join('\\n')}\r\n\r\n    void main() {\r\n      if (\r\n        v_mapCoord[0] < ${Uniforms.RENDER_EXTENT}[0] ||\r\n        v_mapCoord[1] < ${Uniforms.RENDER_EXTENT}[1] ||\r\n        v_mapCoord[0] > ${Uniforms.RENDER_EXTENT}[2] ||\r\n        v_mapCoord[1] > ${Uniforms.RENDER_EXTENT}[3]\r\n      ) {\r\n        discard;\r\n      }\r\n\r\n      vec4 color = texture2D(${\r\n        Uniforms.TILE_TEXTURE_ARRAY\r\n      }[0],  v_textureCoord);\r\n\r\n      ${pipeline.join('\\n')}\r\n\r\n      gl_FragColor = color;\r\n      gl_FragColor.rgb *= gl_FragColor.a;\r\n      gl_FragColor *= ${Uniforms.TRANSITION_ALPHA};\r\n    }`;\r\n\r\n  return {\r\n    vertexShader: vertexShader,\r\n    fragmentShader: fragmentShader,\r\n    uniforms: uniforms,\r\n    paletteTextures: context.paletteTextures,\r\n  };\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>\r\n * @fires import(\"../render/Event.js\").RenderEvent\r\n * @api\r\n */\r\nclass WebGLTileLayer extends BaseTileLayer {\r\n  /**\r\n   * @param {Options} options Tile layer options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? Object.assign({}, options) : {};\r\n\r\n    const style = options.style || {};\r\n    delete options.style;\r\n\r\n    super(options);\r\n\r\n    /**\r\n     * @type {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>}\r\n     * @private\r\n     */\r\n    this.sources_ = options.sources;\r\n\r\n    /**\r\n     * @type {SourceType|null}\r\n     * @private\r\n     */\r\n    this.renderedSource_ = null;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.renderedResolution_ = NaN;\r\n\r\n    /**\r\n     * @type {Style}\r\n     * @private\r\n     */\r\n    this.style_ = style;\r\n\r\n    /**\r\n     * @type {Object<string, (string|number)>}\r\n     * @private\r\n     */\r\n    this.styleVariables_ = this.style_.variables || {};\r\n\r\n    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);\r\n  }\r\n\r\n  /**\r\n   * Gets the sources for this layer, for a given extent and resolution.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @return {Array<SourceType>} Sources.\r\n   */\r\n  getSources(extent, resolution) {\r\n    const source = this.getSource();\r\n    return this.sources_\r\n      ? typeof this.sources_ === 'function'\r\n        ? this.sources_(extent, resolution)\r\n        : this.sources_\r\n      : source\r\n        ? [source]\r\n        : [];\r\n  }\r\n\r\n  /**\r\n   * @return {SourceType} The source being rendered.\r\n   * @override\r\n   */\r\n  getRenderSource() {\r\n    return this.renderedSource_ || this.getSource();\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../source/Source.js\").State} Source state.\r\n   * @override\r\n   */\r\n  getSourceState() {\r\n    const source = this.getRenderSource();\r\n    return source ? source.getState() : 'undefined';\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleSourceUpdate_() {\r\n    if (this.hasRenderer()) {\r\n      this.getRenderer().clearCache();\r\n    }\r\n    if (this.getSource()) {\r\n      this.setStyle(this.style_);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @return {number} The number of source bands.\r\n   */\r\n  getSourceBandCount_() {\r\n    const max = Number.MAX_SAFE_INTEGER;\r\n    const sources = this.getSources([-max, -max, max, max], max);\r\n    return sources && sources.length && 'bandCount' in sources[0]\r\n      ? sources[0].bandCount\r\n      : 4;\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  createRenderer() {\r\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\r\n\r\n    return new WebGLTileLayerRenderer(this, {\r\n      vertexShader: parsedStyle.vertexShader,\r\n      fragmentShader: parsedStyle.fragmentShader,\r\n      uniforms: parsedStyle.uniforms,\r\n      cacheSize: this.getCacheSize(),\r\n      paletteTextures: parsedStyle.paletteTextures,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map\").FrameState} frameState Frame state.\r\n   * @param {Array<SourceType>} sources Sources.\r\n   * @return {HTMLElement} Canvas.\r\n   */\r\n  renderSources(frameState, sources) {\r\n    const layerRenderer = this.getRenderer();\r\n    let canvas;\r\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\r\n      this.renderedSource_ = sources[i];\r\n      if (layerRenderer.prepareFrame(frameState)) {\r\n        canvas = layerRenderer.renderFrame(frameState);\r\n      }\r\n    }\r\n    return canvas;\r\n  }\r\n\r\n  /**\r\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\r\n   * for rendering its content.\r\n   * @return {HTMLElement} The rendered element.\r\n   * @override\r\n   */\r\n  render(frameState, target) {\r\n    this.rendered = true;\r\n    const viewState = frameState.viewState;\r\n    const sources = this.getSources(frameState.extent, viewState.resolution);\r\n    let ready = true;\r\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\r\n      const source = sources[i];\r\n      const sourceState = source.getState();\r\n      if (sourceState == 'loading') {\r\n        const onChange = () => {\r\n          if (source.getState() == 'ready') {\r\n            source.removeEventListener('change', onChange);\r\n            this.changed();\r\n          }\r\n        };\r\n        source.addEventListener('change', onChange);\r\n      }\r\n      ready = ready && sourceState == 'ready';\r\n    }\r\n    const canvas = this.renderSources(frameState, sources);\r\n    if (this.getRenderer().renderComplete && ready) {\r\n      // Fully rendered, done.\r\n      this.renderedResolution_ = viewState.resolution;\r\n      return canvas;\r\n    }\r\n    // Render sources from previously fully rendered frames\r\n    if (this.renderedResolution_ > 0.5 * viewState.resolution) {\r\n      const altSources = this.getSources(\r\n        frameState.extent,\r\n        this.renderedResolution_,\r\n      ).filter((source) => !sources.includes(source));\r\n      if (altSources.length > 0) {\r\n        return this.renderSources(frameState, altSources);\r\n      }\r\n    }\r\n    return canvas;\r\n  }\r\n\r\n  /**\r\n   * Update the layer style.  The `updateStyleVariables` function is a more efficient\r\n   * way to update layer rendering.  In cases where the whole style needs to be updated,\r\n   * this method may be called instead.  Note that calling this method will also replace\r\n   * any previously set variables, so the new style also needs to include new variables,\r\n   * if needed.\r\n   * @param {Style} style The new style.\r\n   */\r\n  setStyle(style) {\r\n    this.styleVariables_ = style.variables || {};\r\n    this.style_ = style;\r\n    if (this.hasRenderer()) {\r\n      const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\r\n      const renderer = this.getRenderer();\r\n      renderer.reset({\r\n        vertexShader: parsedStyle.vertexShader,\r\n        fragmentShader: parsedStyle.fragmentShader,\r\n        uniforms: parsedStyle.uniforms,\r\n        paletteTextures: parsedStyle.paletteTextures,\r\n      });\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update any variables used by the layer style and trigger a re-render.\r\n   * @param {Object<string, number>} variables Variables to update.\r\n   * @api\r\n   */\r\n  updateStyleVariables(variables) {\r\n    Object.assign(this.styleVariables_, variables);\r\n    this.changed();\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up underlying WebGL resources.\r\n * @function\r\n * @api\r\n */\r\nWebGLTileLayer.prototype.dispose;\r\n\r\nexport default WebGLTileLayer;\r\n","/**\r\n * @module CME2D/CME2DCore/layer/common/commonLayerUnit\r\n */\r\n//  /**\r\n//      * xy\r\n//      *\r\n//      * @param {Object} map - \r\n//      * @param {number} x - x\r\n//      * @param {number} y - y\r\n//      */\r\nimport commonStyle from \"../../style/commonStyle.js\";\r\n\r\nfunction PanByPixel(map, x, y) {\r\n  // console.log(\"map.getView\", map.getView);\r\n  // console.log(\"map.getView()\", map.getView());\r\n  // if( !map.getView())\r\n  //   return;\r\n\r\n  const map_center = map.getView().getCenter(); //\r\n  const centerPixel = map.getPixelFromCoordinate(map_center); //\r\n  const newX = centerPixel[0] - x; //\r\n  const newY = centerPixel[1] - y; //\r\n  map.getView().animate({\r\n    center: map.getCoordinateFromPixel([newX, newY]), //\r\n    duration: 1000,\r\n    zoom: map.getView().getZoom(), //\r\n  }); //setCentersetZoom\r\n}\r\n\r\nfunction handlerColor(legend, scala, radio) {\r\n\r\n  let color1 = [\"case\", [\"!=\", [\"band\", 2], 0]];\r\n  let color = [\"interpolate\", [\"linear\"],\r\n    [\"band\", 1]\r\n  ];\r\n  if (legend == null) {\r\n    return null;\r\n  }\r\n  if (radio == 1) {\r\n\r\n\r\n    for (let i = 0; i < legend.length; i++) {\r\n      color = color.concat([legend[i][0] * scala, legend[i][1]]); // //console.log(legend[i]);\r\n    }\r\n    color1.push(color);\r\n    color1.push([\"color\", 0, 0, 0, 0]);\r\n    console.log(\"------------------\");\r\n    // console.log(color);\r\n    console.log(JSON.stringify(color1));\r\n    //  color = color.concat([legend[i][0] * scala, legend[i][1]]); // //console.log(legend[i]);\r\n  } else {\r\n\r\n    const resultArray = [\r\n      \"case\",\r\n      [\"==\", [\"band\", 2], 0],\r\n      [\"color\", 0, 0, 0, 0], // \r\n      [\"<=\", [\"band\", 1], legend[0][0] * scala],\r\n      [\"color\", ...legend[0][1]],\r\n    ];\r\n    // for (let i = 0; i < legend.length; i++) {\r\n    for (let i = 0; i < legend.length; i++) {\r\n      const [value, color] = legend[i];\r\n      const [value1, color1] =\r\n      i >= legend.length - 1 ? legend[i] : legend[i + 1];\r\n      resultArray.push([\"between\", [\"band\", 1], value * scala, value1 * scala]);\r\n      // resultArray.push([\"color\", ...color1]);\r\n      resultArray.push([\"color\", ...color]);\r\n    }\r\n    resultArray[resultArray.length] = [\r\n      \"color\",\r\n      ...legend[legend.length - 1][1],\r\n    ];\r\n    color1 = resultArray;\r\n  }\r\n  console.log(\"JSON.stringify(color1)\");\r\n  console.log(JSON.stringify(color1) );\r\n  return color1;\r\n}\r\n\r\nfunction addCommonStyle(style, styleCommon) {\r\n  style = [];\r\n\r\n  // let styleCollection = [];\r\n  for (let key in styleCommon) {\r\n\r\n    style[key] = commonStyle(styleCommon[key]);\r\n  }\r\n  return style;\r\n}\r\n\r\n// function getLayerStyle(options) {\r\n//   let style = options.style; //cogtifLayer\r\n//   if (options.style) {\r\n//     // cogtifLayer\r\n//     if (options.source) {\r\n//       if (!options.source.normalize) {\r\n//         let bandsNumber = style.bandsNumber;\r\n//       let offset=Number(style.offset) ||0; \r\n\r\n//         let color = [];\r\n//         // uv \r\n//         if (bandsNumber == 2) {\r\n//           let value1 = ['-',  [\"band\", 1], offset];\r\n//           let value2 = ['-',  [\"band\", 2], offset];\r\n//           let n1 = [\r\n//             \"+\",\r\n//             [\"*\", value1,value1],\r\n//             [\"*\", value2, value2],\r\n//           ];\r\n//            color = handlerColor(style.color, style.scala, style.radio);\r\n\r\n//            if (style.radio == 1) {\r\n//             let colorGradient = color[2];\r\n\r\n//             colorGradient[2]=[\"sqrt\", n1]\r\n\r\n//            } \r\n//            else {\r\n\r\n//             for (let i = 3; i < color.length-1; i=i+2) {\r\n//               color[i][1] = [\"sqrt\", n1];\r\n//             }\r\n//            }\r\n\r\n//         } else {\r\n//           color = handlerColor(style.color, style.scala, style.radio);\r\n//         }\r\n\r\n//         // color = handlerColor(style.color, style.scala, style.radio);\r\n//         options.style.color = color;\r\n//       } else {\r\n//         options.style = null;\r\n//       }\r\n//     } else {\r\n//       options.style = null;\r\n//     }\r\n//   }\r\n//   return options;\r\n// }\r\n\r\n/**\r\n * \r\n *\r\n * @param {object} options - \r\n * @return {object} \r\n */\r\nfunction getLayerStyle(options) {\r\n  let style = options.style; //cogtifLayer\r\n  // this.layerConfig = JSON.parse(JSON.stringify(options))\r\n  if (options.style) {\r\n    // cogtifLayer\r\n    if (options.source) {\r\n      if (!options.source.normalize) {\r\n        // this.scala = style.scala;\r\n        let bandsNumber = style.bandsNumber;\r\n        let offset = Number(style.offset) || 0;\r\n        let color = [];\r\n        // uv \r\n        if (bandsNumber == 2) {\r\n\r\n          let value1 = ['-', [\"band\", 1], offset];\r\n          let value2 = ['-', [\"band\", 2], offset];\r\n          let n1 = [\r\n            \"+\",\r\n            [\"*\", value1, value1],\r\n            [\"*\", value2, value2],\r\n          ];\r\n          color = handlerColor(style.color, style.scala, style.radio);\r\n          if (style.radio == 1) {\r\n            let colorGradient = color[2];\r\n            colorGradient[2] = [\"sqrt\", n1]\r\n          } else {\r\n            for (let i = 3; i < color.length - 1; i = i + 2) {\r\n              color[i][1] = [\"sqrt\", n1];\r\n            }\r\n          }\r\n          // console.log(\"color-------------------\");\r\n          // console.log(JSON.stringify(color));\r\n        } else if (bandsNumber == 1) {\r\n\r\n          if (style.unit == \"K\") {\r\n\r\n            color = handlerColor(style.color, style.scala, style.radio);\r\n\r\n          } else if (style.unit == \"\") {\r\n\r\n            let value1 = ['/', [\"band\", 1], style.scala];\r\n            let n1 = ['-', value1, 273.15];\r\n\r\n\r\n            color = handlerColor(style.color, style.scala / 10, style.radio);\r\n            if (style.radio == 1) {\r\n              color[2][2] = n1\r\n            } else {\r\n              for (let i = 3; i < color.length - 1; i = i + 2) {\r\n                color[i][1] = n1;\r\n              }\r\n            }\r\n          } else {\r\n            color = handlerColor(style.color, style.scala, style.radio);\r\n          }\r\n        } else {\r\n          color = handlerColor(style.color, style.scala, style.radio);\r\n        }\r\n\r\n        // color = handlerColor(style.color, style.scala, style.radio);\r\n        options.style.color = color;\r\n      } else {\r\n        options.style = null;\r\n      }\r\n    } else {\r\n      options.style = null;\r\n    }\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction getUpdateLayerStyle(options) {\r\n\r\n  // this.scala = 1; //cogtifLayerscala \r\n  // this.map = options.map; //map\r\n  let style = options.style; //cogtifLayer\r\n  // this.layerConfig = JSON.parse(JSON.stringify(options))\r\n  if (options.style) {\r\n    options.style.color = handlerColor(style.color, style.scala, style.radio);\r\n\r\n    // console.log(JSON.stringify(options.style.color))\r\n\r\n  }\r\n  return options;\r\n}\r\n\r\n/**\r\n * \r\n * \r\n * \r\n * \r\n *\r\n * @param {Object} obj1 - \r\n * @param {Object} obj2 - \r\n * @return {Object} \r\n */\r\n// function mergeObjects(obj1, obj2) {\r\n//   // \r\n//   const mergedObj = {};\r\n//   // \r\n//   for (let prop in obj1) {\r\n//     // mergeObjects\r\n//     if (typeof obj1[prop] === 'object' && typeof obj2[prop] === 'object') {\r\n//       mergedObj[prop] = mergeObjects(obj1[prop], obj2[prop]);\r\n//     } else {\r\n//       mergedObj[prop] = obj1[prop];\r\n//     }\r\n//   }\r\n\r\n//   // \r\n//   for (let prop in obj2) {\r\n//     // \r\n//     if (typeof obj2[prop] === 'object' && !obj1[prop]) {\r\n//       mergedObj[prop] = obj2[prop];\r\n//     } else {\r\n//       // mergedObjobj2\r\n//       // mergedObj[prop] = obj2[prop];\r\n//       mergedObj[prop] = Object.assign({},  mergedObj[prop], obj2[prop])\r\n//     }\r\n//   }\r\n//   return mergedObj;\r\n// }\r\n\r\nfunction mergeObjects(obj1, obj2) {\r\n  const mergedObj = {};\r\n\r\n  // obj1\r\n  for (let prop in obj1) {\r\n    if (obj1.hasOwnProperty(prop)) {\r\n      // \r\n      if (typeof obj1[prop] === 'object' && obj1[prop] !== null) {\r\n        mergedObj[prop] = Object.assign({}, obj1[prop]);\r\n      } else {\r\n        mergedObj[prop] = obj1[prop];\r\n      }\r\n    }\r\n  }\r\n\r\n  // obj2\r\n  for (let prop in obj2) {\r\n    if (obj2.hasOwnProperty(prop)) {\r\n      // mergedObjObject.assign()\r\n      if (mergedObj.hasOwnProperty(prop) && typeof mergedObj[prop] === 'object' && mergedObj[prop] !== null) {\r\n        mergedObj[prop] = Object.assign({}, mergedObj[prop], obj2[prop]);\r\n      } else {\r\n        // \r\n        mergedObj[prop] = obj2[prop];\r\n      }\r\n    }\r\n  }\r\n\r\n  return mergedObj;\r\n}\r\n\r\n\r\n// // function calculateWindDirection(du, dv) {\r\n// //   const u = parseFloat(du);\r\n// //   const v = parseFloat(dv);\r\n// //   if (u === 0 && v === 0) {\r\n// //       return 999.9;\r\n// //   }\r\n// //   let fx = 0;\r\n// //   if (u > 0 && v > 0) {\r\n// //       fx = 270 * Math.atan(v / u) * (180 / Math.PI);\r\n// //   } else if (u < 0 && v > 0) {\r\n// //       fx = 90 - Math.atan(v / u) * 180 / Math.PI;\r\n// //   } else if (u < 0 && v < 0) {\r\n// //       fx = 90 * Math.atan(v / u) * (180 / Math.PI);\r\n// //   } else if (u > 0 && v < 0) {\r\n// //       fx = 270 * Math.atan(v / u) * (180 / Math.PI);\r\n// //   } else if (u === 0 && v > 0) {\r\n// //       fx = 180;\r\n// //   } else if (u === 0 && v < 0) {\r\n// //       fx = 0;\r\n// //   } else if (u > 0 && v === 0) {\r\n// //       fx = 270;\r\n// //   } else if (u < 0 && v === 0) {\r\n// //       fx = 90;\r\n// //   } else {\r\n// //       fx = 0;\r\n// //   }\r\n\r\n// //   return fx;\r\n// // }\r\n\r\n\r\n// // \r\n// // /**\r\n//  * uv\r\n//  *\r\n//  * @param {number} u - u\r\n//  * @param {number} v - v\r\n//  * @return {object} \r\n//  */\r\nfunction getWindSpeedAndDirection(u, v) {\r\n  let data = {}\r\n  const speed = Math.sqrt(u * u + v * v)\r\n  let dir = 270.0 - Math.atan2(v, u) * 180.0 / Math.PI\r\n  if (dir >= 360) dir = dir - 360\r\n  data.speed = speed;\r\n  data.direction = dir.toString();\r\n  return data;\r\n};\r\n\r\n// // // /**\r\n// //  * uv\r\n// //  *\r\n// //  * @param {number} du - u\r\n// //  * @param {number} dv - v\r\n// //  * @return {object} \r\n// //  */\r\n// function getWindSpeedAndDirection(du, dv) {\r\n//   const u = parseFloat(du);\r\n//   const v = parseFloat(dv);\r\n//   const data = {};\r\n//   const speed = Math.sqrt(u * u + v * v);\r\n//   // let dir=0;\r\n//   let fx = 0;\r\n//   if (u === 0 && v === 0) {\r\n//       // return 999.9;\r\n//       fx=999.9\r\n//   }\r\n//   if (u > 0 && v > 0) {\r\n//       fx = 270 * Math.atan(v / u) * (180 / Math.PI);\r\n//   } else if (u < 0 && v > 0) {\r\n//       fx = 90 - Math.atan(v / u) * 180 / Math.PI;\r\n//   } else if (u < 0 && v < 0) {\r\n//       fx = 90 * Math.atan(v / u) * (180 / Math.PI);\r\n//   } else if (u > 0 && v < 0) {\r\n//       fx = 270 * Math.atan(v / u) * (180 / Math.PI);\r\n//   } else if (u === 0 && v > 0) {\r\n//       fx = 180;\r\n//   } else if (u === 0 && v < 0) {\r\n//       fx = 0;\r\n//   } else if (u > 0 && v === 0) {\r\n//       fx = 270;\r\n//   } else if (u < 0 && v === 0) {\r\n//       fx = 90;\r\n//   } else {\r\n//       fx = 0;\r\n//   }\r\n\r\n//   data.speed = speed;\r\n//   data.direction = fx.toString();\r\n//   return data;\r\n//   // return fx;\r\n// }\r\n\r\nexport {\r\n  PanByPixel,\r\n  handlerColor,\r\n  getLayerStyle,\r\n  addCommonStyle,\r\n  getUpdateLayerStyle,\r\n  mergeObjects,\r\n  getWindSpeedAndDirection\r\n};","// @ts-ignore\r\n/**\r\n * @module CME2D/source/cme_GeoTIFFSource\r\n */\r\n// import DataTile from '../../DataTile.js';\r\nimport GeoTIFF from './../../source/GeoTIFF.js';\r\nimport { TileGrid } from './../../tilegrid.js';\r\nimport { toUserCoordinate, toUserExtent } from './../../proj.js';\r\nimport { getCenter, getIntersection } from './../../extent.js';\r\n\r\n/**\r\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\r\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\r\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\r\n * @param {string} message The error message.\r\n * @param {function(Error):void} rejector A function to be called with any error.\r\n */\r\nfunction assertEqual(expected, got, tolerance, message, rejector) {\r\n  if (Array.isArray(expected)) {\r\n    const length = expected.length;\r\n    if (!Array.isArray(got) || length != got.length) {\r\n      const error = new Error(message);\r\n      rejector(error);\r\n      throw error;\r\n    }\r\n    for (let i = 0; i < length; ++i) {\r\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\r\n    }\r\n    return;\r\n  }\r\n\r\n  got = /** @type {number} */ (got);\r\n  if (Math.abs(expected - got) > tolerance * expected) {\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\n/**\r\n * Determine if an image type is a mask.\r\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} image The image.\r\n * @return {boolean} The image is a mask.\r\n */\r\nfunction isMask(image) {\r\n  const fileDirectory = image.fileDirectory;\r\n  const type = fileDirectory.NewSubfileType || 0;\r\n  return (type & 4) === 4;\r\n}\r\n\r\n/**\r\n * Get the bounding box of an image.  If the image does not have an affine transform,\r\n * the pixel bounds are returned.\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} image The image.\r\n * @return {Array<number>} The image bounding box.\r\n */\r\nfunction getBoundingBox(image) {\r\n  try {\r\n    return image.getBoundingBox();\r\n  } catch (_) {\r\n    return [0, 0, image.getWidth(), image.getHeight()];\r\n  }\r\n}\r\n\r\n/**\r\n * Get the origin of an image.  If the image does not have an affine transform,\r\n * the top-left corner of the pixel bounds is returned.\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} image The image.\r\n * @return {Array<number>} The image origin.\r\n */\r\nfunction getOrigin(image) {\r\n  try {\r\n    return image.getOrigin().slice(0, 2);\r\n  } catch (_) {\r\n    return [0, image.getHeight()];\r\n  }\r\n}\r\n\r\n/**\r\n * Get the resolution of an image.  If the image does not have an affine transform,\r\n * the width of the image is compared with the reference image.\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} image The image.\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} referenceImage The reference image.\r\n * @return {Array<number>} The map x and y units per pixel.\r\n */\r\nfunction getResolutions(image, referenceImage) {\r\n  try {\r\n    return image.getResolution(referenceImage);\r\n  } catch (_) {\r\n    return [\r\n      referenceImage.getWidth() / image.getWidth(),\r\n      referenceImage.getHeight() / image.getHeight(),\r\n    ];\r\n  }\r\n}\r\n\r\n// xml\r\nfunction parseXML(xmlString) {\r\n  //  DOMParser  XML  DOM \r\n  const parser = new DOMParser();\r\n  const xmlDoc = parser.parseFromString(xmlString, \"text/xml\");\r\n  //  GDALMetadata  Item \r\n  const itemElements = xmlDoc.querySelectorAll(\"GDALMetadata Item\");\r\n\r\n  // \r\n  const parsedData = {};\r\n\r\n  //  Item \r\n  itemElements.forEach((item) => {\r\n    const name = item.getAttribute(\"name\");\r\n    const value = item.textContent.trim();\r\n    parsedData[name] = value;\r\n  });\r\n\r\n  // console.log(parsedData);\r\n\r\n  return parsedData;\r\n  // this.items = items;\r\n}\r\n\r\nconst defaultTileSize = 256;\r\n\r\n/**\r\n * @typedef {Object} GeoTIFFSourceOptions\r\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\r\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\r\n * @property {string} [credentials] How credentials shall be handled. See\r\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\r\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\r\n * By default only a single range is used.\r\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\r\n * requested. Only use this when you know the source image to be small enough to fit in memory.\r\n * @property {number} [blockSize=65536] The block size to use.\r\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Array<import('../../source/ogcTileUtil.js').SourceInfo>} sources List of information about GeoTIFF sources.\r\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\r\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\r\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\r\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\r\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\r\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\r\n * band from the first source, and 1 band from the second source.\r\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\r\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\r\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\r\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\r\n * CIELab, and ICCLab images will automatically be converted to RGB.\r\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\r\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\r\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\r\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\r\n * @property {boolean} [opaque=false] Whether the layer is opaque.\r\n * @property {import(\"../../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\r\n * will be read for projection information.\r\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\r\n * To disable the opacity transition, pass `transition: 0`.\r\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A source for working with GeoTIFF data.\r\n * **Note for users of the full build**: The `GeoTIFF` source requires the\r\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\r\n *\r\n * @api\r\n */\r\n// @ts-ignore\r\nclass cme_GeoTIFFSource extends GeoTIFF {\r\n  /**\r\n   * @param {Options} options Data tile options.\r\n   */\r\n  constructor(options) {\r\n    super(options);\r\n    this.gdalMetaDatas = {};\r\n    this.extremums = [];\r\n  }\r\n\r\n  parseXMLMetas(sources) {\r\n    if (!sources?.length) return;\r\n    const xmlDataStr = sources[0].fileDirectory?.GDAL_METADATA;\r\n    if (xmlDataStr) {\r\n      this.gdalMetaDatas = parseXML(xmlDataStr);\r\n    }\r\n    // this.getExtremums(sources).then(values => {\r\n    //   console.log('getExtremums =>', values);\r\n    //   this.extremums = values;\r\n    // })\r\n  }\r\n\r\n  getExtremums(sources) {\r\n    return sources[0].readRasters().then(datas => {\r\n      const extremums = datas.map(list => {\r\n        const minValue = list.reduce((v1, v2) => Math.min(v1, v2), 0);\r\n        const maxValue = list.reduce((v1, v2) => Math.max(v1, v2), 0);\r\n        return { minValue, maxValue };\r\n      });\r\n      return extremums;\r\n    });\r\n  }\r\n\r\n  getMetaDatas() {\r\n    // @ts-ignore\r\n    const { metadata_, normalize_, nodataValues_, bandCount, addAlpha_ } = this;\r\n    // @ts-ignore\r\n    const { extent_ } = this.tileGrid;\r\n    // @ts-ignore\r\n    const { code_ } = this.getProjection();\r\n    return {\r\n      metadata: metadata_[0][0],\r\n      nodata: nodataValues_[0][0],\r\n      normalize: normalize_,\r\n      extent: extent_,\r\n      proj: code_,\r\n      // @ts-ignore\r\n      bandCount: bandCount - (addAlpha_ ? 1 : 0),\r\n      ...this.gdalMetaDatas\r\n    };\r\n  }\r\n\r\n  configure_(sources) {\r\n    let extent;\r\n    let origin;\r\n    let commonRenderTileSizes;\r\n    let commonSourceTileSizes;\r\n    let resolutions;\r\n    const samplesPerPixel = new Array(sources.length);\r\n    const nodataValues = new Array(sources.length);\r\n    const metadata = new Array(sources.length);\r\n    let minZoom = 0;\r\n    const sourceCount = sources.length;\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      const images = [];\r\n      const masks = [];\r\n      sources[sourceIndex].forEach((item) => {\r\n        if (isMask(item)) {\r\n          masks.push(item);\r\n        } else {\r\n          images.push(item);\r\n        }\r\n      });\r\n\r\n      const imageCount = images.length;\r\n      if (masks.length > 0 && masks.length !== imageCount) {\r\n        throw new Error(\r\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`,\r\n        );\r\n      }\r\n\r\n      let sourceExtent;\r\n      let sourceOrigin;\r\n      const sourceTileSizes = new Array(imageCount);\r\n      const renderTileSizes = new Array(imageCount);\r\n      const sourceResolutions = new Array(imageCount);\r\n\r\n      nodataValues[sourceIndex] = new Array(imageCount);\r\n      metadata[sourceIndex] = new Array(imageCount);\r\n\r\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\r\n        const image = images[imageIndex];\r\n        const nodataValue = image.getGDALNoData();\r\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\r\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\r\n\r\n        // @ts-ignore\r\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\r\n        samplesPerPixel[sourceIndex] = wantedSamples\r\n          ? wantedSamples.length\r\n          : image.getSamplesPerPixel();\r\n        const level = imageCount - (imageIndex + 1);\r\n\r\n        if (!sourceExtent) {\r\n          sourceExtent = getBoundingBox(image);\r\n        }\r\n\r\n        if (!sourceOrigin) {\r\n          sourceOrigin = getOrigin(image);\r\n        }\r\n\r\n        const imageResolutions = getResolutions(image, images[0]);\r\n        sourceResolutions[level] = imageResolutions[0];\r\n\r\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\r\n\r\n        // request larger blocks for untiled layouts\r\n        if (\r\n          sourceTileSize[0] !== sourceTileSize[1] &&\r\n          sourceTileSize[1] < defaultTileSize\r\n        ) {\r\n          sourceTileSize[0] = defaultTileSize;\r\n          sourceTileSize[1] = defaultTileSize;\r\n        }\r\n\r\n        sourceTileSizes[level] = sourceTileSize;\r\n\r\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\r\n        renderTileSizes[level] = [\r\n          sourceTileSize[0],\r\n          sourceTileSize[1] / aspectRatio,\r\n        ];\r\n      }\r\n\r\n      if (!extent) {\r\n        extent = sourceExtent;\r\n      } else {\r\n        getIntersection(extent, sourceExtent, extent);\r\n      }\r\n\r\n      if (!origin) {\r\n        origin = sourceOrigin;\r\n      } else {\r\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\r\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\r\n      }\r\n\r\n      if (!resolutions) {\r\n        resolutions = sourceResolutions;\r\n        // @ts-ignore\r\n        this.resolutionFactors_[sourceIndex] = 1;\r\n      } else {\r\n        if (resolutions.length - minZoom > sourceResolutions.length) {\r\n          minZoom = resolutions.length - sourceResolutions.length;\r\n        }\r\n        const resolutionFactor =\r\n          resolutions[resolutions.length - 1] /\r\n          sourceResolutions[sourceResolutions.length - 1];\r\n        // @ts-ignore\r\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\r\n        const scaledSourceResolutions = sourceResolutions.map(\r\n          (resolution) => (resolution *= resolutionFactor),\r\n        );\r\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\r\n        assertEqual(\r\n          resolutions.slice(minZoom, resolutions.length),\r\n          scaledSourceResolutions,\r\n          0.02,\r\n          message,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      if (!commonRenderTileSizes) {\r\n        commonRenderTileSizes = renderTileSizes;\r\n      } else {\r\n        assertEqual(\r\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\r\n          renderTileSizes,\r\n          0.01,\r\n          `Tile size mismatch for source ${sourceIndex}`,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      if (!commonSourceTileSizes) {\r\n        commonSourceTileSizes = sourceTileSizes;\r\n      } else {\r\n        assertEqual(\r\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\r\n          sourceTileSizes,\r\n          0,\r\n          `Tile size mismatch for source ${sourceIndex}`,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n      // @ts-ignore\r\n      this.sourceImagery_[sourceIndex] = images.reverse();\r\n      // @ts-ignore\r\n      this.sourceMasks_[sourceIndex] = masks.reverse();\r\n    }\r\n    Promise.resolve().then(() => this.parseXMLMetas(sources[0]));\r\n    // @ts-ignore\r\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\r\n      // @ts-ignore\r\n      const sourceImagery = this.sourceImagery_[i];\r\n      while (sourceImagery.length < resolutions.length) {\r\n        sourceImagery.unshift(undefined);\r\n      }\r\n    }\r\n\r\n    if (!this.getProjection()) {\r\n      this.determineProjection(sources);\r\n    }\r\n\r\n    // @ts-ignore\r\n    this.samplesPerPixel_ = samplesPerPixel;\r\n    // @ts-ignore\r\n    this.nodataValues_ = nodataValues;\r\n    // @ts-ignore\r\n    this.metadata_ = metadata;\r\n\r\n    // decide if we need to add an alpha band to handle nodata\r\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      // option 1: source is configured with a nodata value\r\n      // @ts-ignore\r\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\r\n        // @ts-ignore\r\n        this.addAlpha_ = true;\r\n        break;\r\n      }\r\n      // @ts-ignore\r\n      if (this.sourceMasks_[sourceIndex].length) {\r\n        // @ts-ignore\r\n        this.addAlpha_ = true;\r\n        break;\r\n      }\r\n\r\n      const values = nodataValues[sourceIndex];\r\n\r\n      // option 2: check image metadata for limited bands\r\n      // @ts-ignore\r\n      const bands = this.sourceInfo_[sourceIndex].bands;\r\n      if (bands) {\r\n        for (let i = 0; i < bands.length; ++i) {\r\n          if (values[bands[i] - 1] !== null) {\r\n            // @ts-ignore\r\n            this.addAlpha_ = true;\r\n            break outer;\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // option 3: check image metadata for all bands\r\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\r\n        if (values[imageIndex] !== null) {\r\n          // @ts-ignore\r\n          this.addAlpha_ = true;\r\n          break outer;\r\n        }\r\n      }\r\n    }\r\n\r\n    // @ts-ignore\r\n    let bandCount = this.addAlpha_ ? 1 : 0;\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      bandCount += samplesPerPixel[sourceIndex];\r\n    }\r\n    this.bandCount = bandCount;\r\n    const tileGrid = new TileGrid({\r\n      extent: extent,\r\n      minZoom: minZoom,\r\n      origin: origin,\r\n      resolutions: resolutions,\r\n      tileSizes: commonRenderTileSizes,\r\n    });\r\n\r\n    this.tileGrid = tileGrid;\r\n    this.setTileSizes(commonSourceTileSizes);\r\n\r\n    // @ts-ignore\r\n    this.setLoader(this.loadTile_.bind(this));\r\n    this.setState('ready');\r\n\r\n    const zoom = 1;\r\n    if (resolutions.length === 2) {\r\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\r\n    } else if (resolutions.length === 1) {\r\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\r\n    }\r\n\r\n    this.viewResolver({\r\n      showFullExtent: true,\r\n      projection: this.projection,\r\n      resolutions: resolutions,\r\n      center: toUserCoordinate(getCenter(extent), this.projection),\r\n      extent: toUserExtent(extent, this.projection),\r\n      zoom: zoom,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Get a promise for view properties based on the source.  Use the result of this function\r\n * as the `view` option in a map constructor.\r\n *\r\n *     const source = new GeoTIFF(options);\r\n *\r\n *     const map = new Map({\r\n *       target: 'map',\r\n *       layers: [\r\n *         new TileLayer({\r\n *           source: source,\r\n *         }),\r\n *       ],\r\n *       view: source.getView(),\r\n *     });\r\n *\r\n * @function\r\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\r\n * @api\r\n *\r\n */\r\ncme_GeoTIFFSource.prototype.getView;\r\n\r\nexport default cme_GeoTIFFSource;\r\n","/**\r\n * @module CME2D/CME2DCore/layer/cme_cogtifLayer/cme_cogtifLayer2\r\n */\r\nimport GeoTIFF from '../../source/GeoTIFF.js'; // source/GeoTIFF.js';\r\nimport TileLayer from '../../../layer/WebGLTile.js';\r\n\r\n// import { transform } from \"../../../proj.js\";\r\n\r\n// \r\nimport { getLayerStyle, mergeObjects } from \"../common/commonLayerUnit.js\";\r\n\r\n// import { getCofTifData } from \"./cogtifWorld.js\"\r\n// import GeoTIFF from '../../../source/GeoTIFF.js';\r\n// import TileLayer from '../../../layer/WebGLTile.js';\r\n// import { transform } from \"../../../proj.js\";\r\n// import { fromUrl, Pool } from \"geotiff\";\r\n// import { fromUrl, Pool } from \"geotiff\";\r\nvar cme_cogtifLayer2 = class cogtifLayerClass2 extends TileLayer {\r\n  constructor() {\r\n    let options = {};\r\n    super(options);\r\n    this.legendLimit = 250;\r\n  }\r\n  /**\r\n   * truePromise\r\n   *\r\n   * @param {Object} options - \r\n   * @return {Promise} truePromise\r\n   */\r\n  _render(parfams) {\r\n    let options = JSON.parse(JSON.stringify(parfams));\r\n    let that = this;\r\n    // if (Array.isArray(options?.style?.color)) {\r\n    //   options.style.color.splice(this.legendLimit);\r\n    // }\r\n    if (options.Greater) {\r\n      options.style = this.getStyleOpactiy(options.Greater, options.style)\r\n    }\r\n    if (options.style) {\r\n      if (options.style.color) {\r\n        options.orignColor = JSON.parse(JSON.stringify(options.style.color));\r\n      } else {\r\n        options.orignColor = {};\r\n      }\r\n    }\r\n    if (!options.style) {\r\n      throw Error('\"options.style\"');\r\n    }\r\n    options.CustomStyle = options.style;\r\n    if (!options.source) {\r\n      throw Error('\"options.source\"');\r\n    }\r\n    return new Promise((resolve) => {\r\n      const sourceObj = new GeoTIFF(options.source);\r\n      sourceObj.getView().then((viewConfig) => {\r\n        const metas = sourceObj.getMetaDatas();\r\n        const { scale, scala, offset, unit } = options.style;\r\n        const proj = {\r\n          extent: metas.extent,\r\n          projection: metas.proj || \"EPSG:4326\",\r\n          unit: unit || metas.unit || ''\r\n        };\r\n        Object.assign(options.style, {\r\n          bandsNumber: +metas.bandCount || 1,\r\n          offset: offset || +metas.offset || 0,\r\n          scala: scale || scala || +metas.scale || 1,\r\n          unit: unit || metas.unit || ''\r\n        });\r\n        options.proj = proj;\r\n        // @ts-ignore\r\n        if (options.style.color) {\r\n          options = getLayerStyle(options);\r\n        }\r\n        that.options = JSON.parse(JSON.stringify(options));// options;\r\n        that.style_ = options.style;\r\n        // \r\n        sourceObj.values_ = options.source;\r\n        that.setProperties({ ...options, source: sourceObj });\r\n        that.once('postrender', () => resolve(metas));\r\n\r\n        // //  that.once('sourceready', function (event) {})\r\n        // //postcompose\r\n        // //rendercomplete\r\n        // that.once(\"postcompose\", function (event) {\r\n\r\n        //   resolve(true);\r\n        // })\r\n\r\n        // that.setSource(options.source)\r\n        // that.setProperties({ CustomStyle: optionsStr.CustomStyle });\r\n        // that.updateStyleVariables({ style: optionsStr.CustomStyle })\r\n      })\r\n    }\r\n    )\r\n  }\r\n\r\n  /**\r\n   * \r\n   *\r\n   * @param {type} paramName - \r\n   * @return {type} \r\n   */\r\n  _setSource(options) {\r\n    let params = JSON.parse(JSON.stringify(options))\r\n    let that = this;\r\n    if (params.source == null) {\r\n      return new Promise((resolve) => {\r\n        resolve(true);\r\n      });\r\n    }\r\n    return new Promise((resolve) => {\r\n      if (params.source) {\r\n        params.source = new GeoTIFF(params.source);\r\n      } else {\r\n        params.source = new GeoTIFF();\r\n      }\r\n      params.source.getView().then((viewConfig) => {\r\n\r\n        let projCode = \"EPSG:4326\";\r\n        if (viewConfig.projection) {\r\n          projCode = viewConfig.projection.getCode()\r\n\r\n        }\r\n        //   // projCode=viewConfig.projection.getCode()\r\n        // let proj={\r\n        //   extent:viewConfig.extent,\r\n        //   projection: projCode,//viewConfig.projection.getCode(),\r\n        // }\r\n        // // let proj = {\r\n        // //   extent: viewConfig.extent,\r\n        // //   projection: viewConfig.projection.getCode(),\r\n        // // };\r\n        // that.setProperties({\r\n        //   proj: proj\r\n        // });\r\n\r\n\r\n        that.once(\"sourceready\", function (event) {\r\n          resolve(true);\r\n        });\r\n        that.setSource(params.source);\r\n      });\r\n    });\r\n  }\r\n\r\n\r\n  _setSourceMap(map, options) {\r\n    // return this.setTempLayer(map).then((viewConfig) => {\r\n\r\n    console.log(\"CME2D\")\r\n    // console.log(options.source.sources[0].url);\r\n    let params = JSON.parse(JSON.stringify(options));\r\n    console.log(params.source.sources[0].url);\r\n\r\n    let that = this;\r\n    if (params.source == null) {\r\n      return new Promise((resolve) => {\r\n        resolve(true);\r\n      });\r\n    }\r\n    return new Promise((resolve) => {\r\n      if (params.source) {\r\n\r\n        params.source = new GeoTIFF(params.source);\r\n      } else {\r\n        params.source = new GeoTIFF();\r\n      }\r\n      params.source.getView().then((viewConfig) => {\r\n\r\n        let projCode = \"EPSG:4326\";\r\n        if (viewConfig.projection) {\r\n          projCode = viewConfig.projection.getCode()\r\n\r\n        }\r\n        map.once(\"rendercomplete\", function () {\r\n          // that.cogtifLayer.setOpacity(0);\r\n          // console.log(\"source\")\r\n          resolve(true);\r\n        });\r\n        that.setSource(params.source);\r\n      });\r\n    });\r\n    // });\r\n  }\r\n  /**\r\n   * \r\n   *\r\n   * @param {type} paramName - \r\n   * @return {type} \r\n   */\r\n  _setStyle(options) {\r\n    // if (Array.isArray(options?.style?.color)) {\r\n    //   options.style.color.splice(this.legendLimit);\r\n    // }\r\n    if (options.Greater) {\r\n      options.style = this.getStyleOpactiy(options.Greater, options.style)\r\n    }\r\n    if (options.style) {\r\n      if (options.style.color) {\r\n        this.options.orignColor = options.style.color;\r\n      } else {\r\n        options.style.color = JSON.parse(JSON.stringify(this.options.orignColor));\r\n      }\r\n    } else {\r\n      options.style.color = JSON.parse(JSON.stringify(this.options.orignColor));\r\n    }\r\n    return new Promise((resolve) => {\r\n      if (options.source && (\"interpolate\" in options.source)) {\r\n        const source = this.getSource();\r\n        const properties = source.getProperties();\r\n        if (properties.interpolate != options.source.interpolate) {\r\n          source.set(\"interpolate\", options.source.interpolate);\r\n          let properties = JSON.parse(JSON.stringify(properties));\r\n          // properties.source.interpolate = options.source.interpolate;\r\n          this.setSource(new GeoTIFF(properties));\r\n          source.setProperties(properties)\r\n        }\r\n      }\r\n      this.options = getLayerStyle(mergeObjects(this.options, options));\r\n      this.style_ = this.options.style;\r\n      this.options.CustomStyle = this.options.style; //    options.style;\r\n      const newStyle = JSON.parse(JSON.stringify(this.options.style));\r\n      this.setStyle(newStyle);\r\n      resolve(true);\r\n    });\r\n  }\r\n\r\n  getStyleOpactiy(params, _style) {\r\n    let style = JSON.parse(JSON.stringify(_style))\r\n    if (params) {\r\n      if (params[0] == 0) {\r\n        let minValue = style.color[0][0];\r\n        minValue = minValue - 0.1;\r\n        style.color.unshift([minValue, [0, 0, 0, 0]]);\r\n        style.color.unshift([-9999, [0, 0, 0, 0]]);\r\n      }\r\n      //  else if(options.params[0]==0){\r\n\r\n      //  }\r\n      if (params[1] == 0) {\r\n\r\n        let maxValue = style.color[style.color.length - 1][0];\r\n        maxValue = maxValue + 0.1;\r\n        style.color.push([maxValue, [0, 0, 0, 0]]);\r\n      }\r\n    }\r\n\r\n    return style;\r\n\r\n  }\r\n\r\n  /**\r\n   * \r\n   *\r\n   */\r\n  _remove() {\r\n    this.dispose();\r\n    // \r\n  }\r\n\r\n  computedNewExtent(extent, worldNumber) {\r\n    let mixLng = extent[0] + 360 * worldNumber;\r\n    let maxLng = extent[2] + 360 * worldNumber;\r\n    return [mixLng, extent[1], maxLng, extent[3]];\r\n  }\r\n  getSourceProperties(options) {\r\n\r\n    let sourceOpitions = this.options.source.values_;\r\n    for (let key in sourceOpitions) {\r\n      if (sourceOpitions.hasOwnProperty(key)) { // key\r\n        for (let newKey in options.source) {\r\n          if (options.source.hasOwnProperty(newKey)) {\r\n            if (key == newKey)\r\n              sourceOpitions[key] = options.source[newKey];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    let sourceCollection = []\r\n    for (let newKey in sourceOpitions.sources) {\r\n      if (sourceOpitions.sources.hasOwnProperty(newKey)) {\r\n        sourceCollection.push(sourceOpitions.sources[newKey]);\r\n\r\n      }\r\n    }\r\n    sourceOpitions.sources = sourceCollection;\r\n    return sourceOpitions;\r\n  }\r\n}\r\n\r\nexport default cme_cogtifLayer2\r\n","/**\r\n * @module CME2D/render/canvas/ZIndexContext\r\n */\r\n\r\nimport {getSharedCanvasContext2D} from '../../dom.js';\r\n\r\n/** @typedef {CanvasRenderingContext2D & {globalAlpha: any}} ZIndexContextProxy */\r\n\r\n/**\r\n * @extends {CanvasRenderingContext2D}\r\n */\r\nclass ZIndexContext {\r\n  constructor() {\r\n    /**\r\n     * @private\r\n     * @type {Array<Array<*>>}\r\n     */\r\n    this.instructions_ = [];\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.zIndex = 0;\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.offset_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {ZIndexContextProxy}\r\n     */\r\n    this.context_ = /** @type {ZIndexContextProxy} */ (\r\n      new Proxy(getSharedCanvasContext2D(), {\r\n        get: (target, property) => {\r\n          if (\r\n            typeof (/** @type {*} */ (getSharedCanvasContext2D())[property]) !==\r\n            'function'\r\n          ) {\r\n            // we only accept calling functions on the proxy, not accessing properties\r\n            return undefined;\r\n          }\r\n          if (!this.instructions_[this.zIndex + this.offset_]) {\r\n            this.instructions_[this.zIndex + this.offset_] = [];\r\n          }\r\n          this.instructions_[this.zIndex + this.offset_].push(property);\r\n          return this.pushMethodArgs_;\r\n        },\r\n        set: (target, property, value) => {\r\n          if (!this.instructions_[this.zIndex + this.offset_]) {\r\n            this.instructions_[this.zIndex + this.offset_] = [];\r\n          }\r\n          this.instructions_[this.zIndex + this.offset_].push(property, value);\r\n          return true;\r\n        },\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {...*} args Args.\r\n   * @return {ZIndexContext} This.\r\n   */\r\n  pushMethodArgs_ = (...args) => {\r\n    this.instructions_[this.zIndex + this.offset_].push(args);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Push a function that renders to the context directly.\r\n   * @param {function(CanvasRenderingContext2D): void} render Function.\r\n   */\r\n  pushFunction(render) {\r\n    this.instructions_[this.zIndex + this.offset_].push(render);\r\n  }\r\n\r\n  /**\r\n   * Get a proxy for CanvasRenderingContext2D which does not support getting state\r\n   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a\r\n   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,\r\n   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.\r\n   * @return {ZIndexContextProxy} Context.\r\n   */\r\n  getContext() {\r\n    return this.context_;\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   */\r\n  draw(context) {\r\n    this.instructions_.forEach((instructionsAtIndex) => {\r\n      for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {\r\n        const property = instructionsAtIndex[i];\r\n        if (typeof property === 'function') {\r\n          property(context);\r\n          continue;\r\n        }\r\n        const instructionAtIndex = instructionsAtIndex[++i];\r\n        if (typeof (/** @type {*} */ (context)[property]) === 'function') {\r\n          /** @type {*} */ (context)[property](...instructionAtIndex);\r\n        } else {\r\n          if (typeof instructionAtIndex === 'function') {\r\n            /** @type {*} */ (context)[property] = instructionAtIndex(context);\r\n            continue;\r\n          }\r\n          /** @type {*} */ (context)[property] = instructionAtIndex;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  clear() {\r\n    this.instructions_.length = 0;\r\n    this.zIndex = 0;\r\n    this.offset_ = 0;\r\n  }\r\n\r\n  /**\r\n   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to\r\n   * avoid conflicting context.clip() or context.save()/restore() calls.\r\n   */\r\n  offset() {\r\n    this.offset_ = this.instructions_.length;\r\n    this.zIndex = 0;\r\n  }\r\n}\r\n\r\nexport default ZIndexContext;\r\n","/**\r\n * @module CME2D/renderer/canvas/Layer\r\n */\r\nimport LayerRenderer from '../Layer.js';\r\nimport RenderEvent from '../../render/Event.js';\r\nimport RenderEventType from '../../render/EventType.js';\r\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n  makeInverse,\r\n  toString as toTransformString,\r\n} from '../../transform.js';\r\nimport {asArray} from '../../color.js';\r\nimport {createCanvasContext2D} from '../../dom.js';\r\nimport {equals} from '../../array.js';\r\nimport {\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getHeight,\r\n  getTopLeft,\r\n  getTopRight,\r\n  getWidth,\r\n} from '../../extent.js';\r\n\r\n/**\r\n * @type {Array<HTMLCanvasElement>}\r\n */\r\nexport const canvasPool = [];\r\n\r\n/**\r\n * @type {CanvasRenderingContext2D}\r\n */\r\nlet pixelContext = null;\r\n\r\nfunction createPixelContext() {\r\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\r\n    willReadFrequently: true,\r\n  });\r\n}\r\n\r\n/**\r\n * @abstract\r\n * @template {import(\"../../layer/Layer.js\").default} LayerType\r\n * @extends {LayerRenderer<LayerType>}\r\n */\r\nclass CanvasLayerRenderer extends LayerRenderer {\r\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   */\r\n  constructor(layer) {\r\n    super(layer);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {HTMLElement}\r\n     */\r\n    this.container = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.renderedResolution;\r\n\r\n    /**\r\n     * A temporary transform.  The values in this transform should only be used in a\r\n     * function that sets the values.\r\n     * @protected\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.tempTransform = createTransform();\r\n\r\n    /**\r\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\r\n     * be set when rendering a frame and may be used by other functions after rendering.\r\n     * @protected\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.pixelTransform = createTransform();\r\n\r\n    /**\r\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\r\n     * be set when rendering a frame and may be used by other functions after rendering.\r\n     * @protected\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.inversePixelTransform = createTransform();\r\n\r\n    /**\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    this.context = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {ZIndexContext}\r\n     */\r\n    this.deferredContext_ = null;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.containerReused = false;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../Map.js\").FrameState|null}\r\n     */\r\n    this.frameState = null;\r\n  }\r\n\r\n  /**\r\n   * @param {import('../../DataTile.js').ImageLike} image Image.\r\n   * @param {number} col The column index.\r\n   * @param {number} row The row index.\r\n   * @return {Uint8ClampedArray|null} The image data.\r\n   */\r\n  getImageData(image, col, row) {\r\n    if (!pixelContext) {\r\n      createPixelContext();\r\n    }\r\n    pixelContext.clearRect(0, 0, 1, 1);\r\n\r\n    let data;\r\n    try {\r\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\r\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\r\n    } catch (err) {\r\n      pixelContext = null;\r\n      return null;\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\r\n   * @return {string} Background color.\r\n   */\r\n  getBackground(frameState) {\r\n    const layer = this.getLayer();\r\n    let background = layer.getBackground();\r\n    if (typeof background === 'function') {\r\n      background = background(frameState.viewState.resolution);\r\n    }\r\n    return background || undefined;\r\n  }\r\n\r\n  /**\r\n   * Get a rendering container from an existing target, if compatible.\r\n   * @param {HTMLElement} target Potential render target.\r\n   * @param {string} transform CSS Transform.\r\n   * @param {string} [backgroundColor] Background color.\r\n   */\r\n  useContainer(target, transform, backgroundColor) {\r\n    const layerClassName = this.getLayer().getClassName();\r\n    let container, context;\r\n    if (\r\n      target &&\r\n      target.className === layerClassName &&\r\n      (!backgroundColor ||\r\n        (target &&\r\n          target.style.backgroundColor &&\r\n          equals(\r\n            asArray(target.style.backgroundColor),\r\n            asArray(backgroundColor),\r\n          )))\r\n    ) {\r\n      const canvas = target.firstElementChild;\r\n      if (canvas instanceof HTMLCanvasElement) {\r\n        context = canvas.getContext('2d');\r\n      }\r\n    }\r\n    if (context && context.canvas.style.transform === transform) {\r\n      // Container of the previous layer renderer can be used.\r\n      this.container = target;\r\n      this.context = context;\r\n      this.containerReused = true;\r\n    } else if (this.containerReused) {\r\n      // Previously reused container cannot be used any more.\r\n      this.container = null;\r\n      this.context = null;\r\n      this.containerReused = false;\r\n    } else if (this.container) {\r\n      this.container.style.backgroundColor = null;\r\n    }\r\n    if (!this.container) {\r\n      container = document.createElement('div');\r\n      container.className = layerClassName;\r\n      let style = container.style;\r\n      style.position = 'absolute';\r\n      style.width = '100%';\r\n      style.height = '100%';\r\n      context = createCanvasContext2D();\r\n      const canvas = context.canvas;\r\n      container.appendChild(canvas);\r\n      style = canvas.style;\r\n      style.position = 'absolute';\r\n      style.left = '0';\r\n      style.transformOrigin = 'top left';\r\n      this.container = container;\r\n      this.context = context;\r\n    }\r\n    if (\r\n      !this.containerReused &&\r\n      backgroundColor &&\r\n      !this.container.style.backgroundColor\r\n    ) {\r\n      this.container.style.backgroundColor = backgroundColor;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\r\n   * @protected\r\n   */\r\n  clipUnrotated(context, frameState, extent) {\r\n    const topLeft = getTopLeft(extent);\r\n    const topRight = getTopRight(extent);\r\n    const bottomRight = getBottomRight(extent);\r\n    const bottomLeft = getBottomLeft(extent);\r\n\r\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\r\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\r\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\r\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\r\n\r\n    const inverted = this.inversePixelTransform;\r\n    applyTransform(inverted, topLeft);\r\n    applyTransform(inverted, topRight);\r\n    applyTransform(inverted, bottomRight);\r\n    applyTransform(inverted, bottomLeft);\r\n\r\n    context.save();\r\n    context.beginPath();\r\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\r\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\r\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\r\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\r\n    context.clip();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @protected\r\n   */\r\n  prepareContainer(frameState, target) {\r\n    const extent = frameState.extent;\r\n    const resolution = frameState.viewState.resolution;\r\n    const rotation = frameState.viewState.rotation;\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\r\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\r\n    // set forward and inverse pixel transforms\r\n    composeTransform(\r\n      this.pixelTransform,\r\n      frameState.size[0] / 2,\r\n      frameState.size[1] / 2,\r\n      1 / pixelRatio,\r\n      1 / pixelRatio,\r\n      rotation,\r\n      -width / 2,\r\n      -height / 2,\r\n    );\r\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\r\n\r\n    const canvasTransform = toTransformString(this.pixelTransform);\r\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\r\n\r\n    if (!this.containerReused) {\r\n      const canvas = this.context.canvas;\r\n      if (canvas.width != width || canvas.height != height) {\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n      } else {\r\n        this.context.clearRect(0, 0, width, height);\r\n      }\r\n      if (canvasTransform !== canvas.style.transform) {\r\n        canvas.style.transform = canvasTransform;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @private\r\n   */\r\n  dispatchRenderEvent_(type, context, frameState) {\r\n    const layer = this.getLayer();\r\n    if (layer.hasListener(type)) {\r\n      const event = new RenderEvent(\r\n        type,\r\n        this.inversePixelTransform,\r\n        frameState,\r\n        context,\r\n      );\r\n      layer.dispatchEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  preRender(context, frameState) {\r\n    this.frameState = frameState;\r\n    if (frameState.declutter) {\r\n      return;\r\n    }\r\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  postRender(context, frameState) {\r\n    if (frameState.declutter) {\r\n      return;\r\n    }\r\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   */\r\n  renderDeferredInternal(frameState) {}\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.\r\n   */\r\n  getRenderContext(frameState) {\r\n    if (frameState.declutter && !this.deferredContext_) {\r\n      this.deferredContext_ = new ZIndexContext();\r\n    }\r\n    return frameState.declutter\r\n      ? this.deferredContext_.getContext()\r\n      : this.context;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @override\r\n   */\r\n  renderDeferred(frameState) {\r\n    if (!frameState.declutter) {\r\n      return;\r\n    }\r\n    this.dispatchRenderEvent_(\r\n      RenderEventType.PRERENDER,\r\n      this.context,\r\n      frameState,\r\n    );\r\n    if (frameState.declutter && this.deferredContext_) {\r\n      this.deferredContext_.draw(this.context);\r\n      this.deferredContext_.clear();\r\n    }\r\n    this.renderDeferredInternal(frameState);\r\n    this.dispatchRenderEvent_(\r\n      RenderEventType.POSTRENDER,\r\n      this.context,\r\n      frameState,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Creates a transform for rendering to an element that will be rotated after rendering.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} rotation Rotation.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {number} width Width of the rendered element (in pixels).\r\n   * @param {number} height Height of the rendered element (in pixels).\r\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\r\n   * @protected\r\n   * @return {!import(\"../../transform.js\").Transform} Transform.\r\n   */\r\n  getRenderTransform(\r\n    center,\r\n    resolution,\r\n    rotation,\r\n    pixelRatio,\r\n    width,\r\n    height,\r\n    offsetX,\r\n  ) {\r\n    const dx1 = width / 2;\r\n    const dy1 = height / 2;\r\n    const sx = pixelRatio / resolution;\r\n    const sy = -sx;\r\n    const dx2 = -center[0] + offsetX;\r\n    const dy2 = -center[1];\r\n    return composeTransform(\r\n      this.tempTransform,\r\n      dx1,\r\n      dy1,\r\n      sx,\r\n      sy,\r\n      -rotation,\r\n      dx2,\r\n      dy2,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    delete this.frameState;\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default CanvasLayerRenderer;\r\n","/**\r\n * @module CME2D/resolution\r\n */\r\n\r\n/**\r\n * @typedef {number|Array<number>} ResolutionLike\r\n */\r\n\r\n/**\r\n * @param {ResolutionLike} resolution Resolution.\r\n * @return {number} Resolution.\r\n */\r\nexport function fromResolutionLike(resolution) {\r\n  if (Array.isArray(resolution)) {\r\n    return Math.min(...resolution);\r\n  }\r\n  return resolution;\r\n}\r\n","/**\r\n * @module CME2D/reproj/Image\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport EventType from '../events/EventType.js';\r\nimport ImageState from '../ImageState.js';\r\nimport ImageWrapper from '../Image.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {\r\n  calculateSourceResolution,\r\n  render as renderReprojected,\r\n} from '../reproj.js';\r\nimport {fromResolutionLike} from '../resolution.js';\r\nimport {\r\n  getCenter,\r\n  getHeight,\r\n  getIntersection,\r\n  getWidth,\r\n  isEmpty,\r\n} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {function(import(\"../extent.js\").Extent, number, number) : import(\"../Image.js\").default} FunctionType\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected image.\r\n * See {@link module:ol/source/Image~ImageSource}.\r\n */\r\nclass ReprojImage extends ImageWrapper {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection (of the data).\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent.\r\n   * @param {number} targetResolution Target resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {FunctionType} getImageFunction\r\n   *     Function returning source images (extent, resolution, pixelRatio).\r\n   * @param {boolean} interpolate Use linear interpolation when resampling.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    targetProj,\r\n    targetExtent,\r\n    targetResolution,\r\n    pixelRatio,\r\n    getImageFunction,\r\n    interpolate,\r\n  ) {\r\n    let maxSourceExtent = sourceProj.getExtent();\r\n    if (maxSourceExtent && sourceProj.canWrapX()) {\r\n      maxSourceExtent = maxSourceExtent.slice();\r\n      maxSourceExtent[0] = -Infinity;\r\n      maxSourceExtent[2] = Infinity;\r\n    }\r\n    let maxTargetExtent = targetProj.getExtent();\r\n    if (maxTargetExtent && targetProj.canWrapX()) {\r\n      maxTargetExtent = maxTargetExtent.slice();\r\n      maxTargetExtent[0] = -Infinity;\r\n      maxTargetExtent[2] = Infinity;\r\n    }\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    const targetCenter = getCenter(limitedTargetExtent);\r\n    const sourceResolution = calculateSourceResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      targetCenter,\r\n      targetResolution,\r\n    );\r\n\r\n    const errorThresholdInPixels = ERROR_THRESHOLD;\r\n\r\n    const triangulation = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution,\r\n    );\r\n\r\n    const sourceExtent = triangulation.calculateSourceExtent();\r\n    const sourceImage = isEmpty(sourceExtent)\r\n      ? null\r\n      : getImageFunction(sourceExtent, sourceResolution, pixelRatio);\r\n    const state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;\r\n    const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;\r\n\r\n    super(targetExtent, targetResolution, sourcePixelRatio, state);\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     */\r\n    this.targetProj_ = targetProj;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.maxSourceExtent_ = maxSourceExtent;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = triangulation;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.targetResolution_ = targetResolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.targetExtent_ = targetExtent;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../Image.js\").default}\r\n     */\r\n    this.sourceImage_ = sourceImage;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourcePixelRatio_ = sourcePixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.interpolate_ = interpolate;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.sourceListenerKey_ = null;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    if (this.state == ImageState.LOADING) {\r\n      this.unlistenSource_();\r\n    }\r\n    super.disposeInternal();\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Image.\r\n   * @override\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../proj/Projection.js\").default} Projection.\r\n   */\r\n  getProjection() {\r\n    return this.targetProj_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const sourceState = this.sourceImage_.getState();\r\n    if (sourceState == ImageState.LOADED) {\r\n      const width = getWidth(this.targetExtent_) / this.targetResolution_;\r\n      const height = getHeight(this.targetExtent_) / this.targetResolution_;\r\n      this.canvas_ = renderReprojected(\r\n        width,\r\n        height,\r\n        this.sourcePixelRatio_,\r\n        fromResolutionLike(this.sourceImage_.getResolution()),\r\n        this.maxSourceExtent_,\r\n        this.targetResolution_,\r\n        this.targetExtent_,\r\n        this.triangulation_,\r\n        [\r\n          {\r\n            extent: this.sourceImage_.getExtent(),\r\n            image: this.sourceImage_.getImage(),\r\n          },\r\n        ],\r\n        0,\r\n        undefined,\r\n        this.interpolate_,\r\n        true,\r\n      );\r\n    }\r\n    this.state = sourceState;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state == ImageState.IDLE) {\r\n      this.state = ImageState.LOADING;\r\n      this.changed();\r\n\r\n      const sourceState = this.sourceImage_.getState();\r\n      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\r\n        this.reproject_();\r\n      } else {\r\n        this.sourceListenerKey_ = listen(\r\n          this.sourceImage_,\r\n          EventType.CHANGE,\r\n          (e) => {\r\n            const sourceState = this.sourceImage_.getState();\r\n            if (\r\n              sourceState == ImageState.LOADED ||\r\n              sourceState == ImageState.ERROR\r\n            ) {\r\n              this.unlistenSource_();\r\n              this.reproject_();\r\n            }\r\n          },\r\n        );\r\n        this.sourceImage_.load();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSource_() {\r\n    unlistenByKey(\r\n      /** @type {!import(\"../events.js\").EventsKey} */ (\r\n        this.sourceListenerKey_\r\n      ),\r\n    );\r\n    this.sourceListenerKey_ = null;\r\n  }\r\n}\r\n\r\nexport default ReprojImage;\r\n","/**\r\n * @module CME2D/source/common\r\n */\r\n\r\n/**\r\n * Default WMS version.\r\n * @type {string}\r\n */\r\nexport const DEFAULT_WMS_VERSION = '1.3.0';\r\n\r\n/**\r\n * Number of decimal digits to consider in integer values when rounding.\r\n * @type {number}\r\n */\r\nexport const DECIMALS = 4;\r\n","/**\r\n * @module CME2D/source/Image\r\n */\r\nimport Event from '../events/Event.js';\r\nimport EventType from '../events/EventType.js';\r\nimport ImageState from '../ImageState.js';\r\nimport ImageWrapper from '../Image.js';\r\nimport ReprojImage from '../reproj/Image.js';\r\nimport Source from './Source.js';\r\nimport {DECIMALS} from './common.js';\r\nimport {ceil} from '../math.js';\r\nimport {\r\n  containsExtent,\r\n  equals,\r\n  getCenter,\r\n  getForViewAndSize,\r\n  getHeight,\r\n  getWidth,\r\n} from '../extent.js';\r\nimport {equivalent} from '../proj.js';\r\nimport {fromResolutionLike} from '../resolution.js';\r\nimport {linearFindNearest} from '../array.js';\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport const ImageSourceEventType = {\r\n  /**\r\n   * Triggered when an image starts loading.\r\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart\r\n   * @api\r\n   */\r\n  IMAGELOADSTART: 'imageloadstart',\r\n\r\n  /**\r\n   * Triggered when an image finishes loading.\r\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadend\r\n   * @api\r\n   */\r\n  IMAGELOADEND: 'imageloadend',\r\n\r\n  /**\r\n   * Triggered if image loading results in an error.\r\n   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror\r\n   * @api\r\n   */\r\n  IMAGELOADERROR: 'imageloaderror',\r\n};\r\n\r\n/**\r\n * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this\r\n * type.\r\n */\r\nexport class ImageSourceEvent extends Event {\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../Image.js\").default} image The image.\r\n   */\r\n  constructor(type, image) {\r\n    super(type);\r\n\r\n    /**\r\n     * The image related to the event.\r\n     * @type {import(\"../Image.js\").default}\r\n     * @api\r\n     */\r\n    this.image = image;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\r\n *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\r\n * @property {import(\"../Image.js\").Loader} [loader] Loader. Can either be a custom loader, or one of the\r\n * loaders created with a `createLoader()` function ({@link module:ol/source/wms.createLoader wms},\r\n * {@link module:ol/source/arcgisRest.createLoader arcgisRest}, {@link module:ol/source/mapguide.createLoader mapguide},\r\n * {@link module:ol/source/static.createLoader static}).\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\r\n * @property {Array<number>} [resolutions] Resolutions.\r\n * @property {import(\"./Source.js\").State} [state] State.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for sources providing a single image.\r\n * @fires module:ol/source/Image.ImageSourceEvent\r\n * @api\r\n */\r\nclass ImageSource extends Source {\r\n  /**\r\n   * @param {Options} options Single image source options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      interpolate:\r\n        options.interpolate !== undefined ? options.interpolate : true,\r\n    });\r\n\r\n    /***\r\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {ImageSourceOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Image.js\").Loader}\r\n     */\r\n    this.loader = options.loader || null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>|null}\r\n     */\r\n    this.resolutions_ =\r\n      options.resolutions !== undefined ? options.resolutions : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../reproj/Image.js\").default}\r\n     */\r\n    this.reprojectedImage_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.reprojectedRevision_ = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Image.js\").default}\r\n     */\r\n    this.image = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.wantedExtent_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.wantedResolution_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.static_ = options.loader ? options.loader.length === 0 : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     */\r\n    this.wantedProjection_ = null;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>|null} Resolutions.\r\n   * @override\r\n   */\r\n  getResolutions() {\r\n    return this.resolutions_;\r\n  }\r\n\r\n  /**\r\n   * @param {Array<number>|null} resolutions Resolutions.\r\n   */\r\n  setResolutions(resolutions) {\r\n    this.resolutions_ = resolutions;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {number} resolution Resolution.\r\n   * @return {number} Resolution.\r\n   */\r\n  findNearestResolution(resolution) {\r\n    const resolutions = this.getResolutions();\r\n    if (resolutions) {\r\n      const idx = linearFindNearest(resolutions, resolution, 0);\r\n      resolution = resolutions[idx];\r\n    }\r\n    return resolution;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../Image.js\").default} Single image.\r\n   */\r\n  getImage(extent, resolution, pixelRatio, projection) {\r\n    const sourceProjection = this.getProjection();\r\n    if (\r\n      !sourceProjection ||\r\n      !projection ||\r\n      equivalent(sourceProjection, projection)\r\n    ) {\r\n      if (sourceProjection) {\r\n        projection = sourceProjection;\r\n      }\r\n\r\n      return this.getImageInternal(extent, resolution, pixelRatio, projection);\r\n    }\r\n    if (this.reprojectedImage_) {\r\n      if (\r\n        this.reprojectedRevision_ == this.getRevision() &&\r\n        equivalent(this.reprojectedImage_.getProjection(), projection) &&\r\n        this.reprojectedImage_.getResolution() == resolution &&\r\n        equals(this.reprojectedImage_.getExtent(), extent)\r\n      ) {\r\n        return this.reprojectedImage_;\r\n      }\r\n      this.reprojectedImage_.dispose();\r\n      this.reprojectedImage_ = null;\r\n    }\r\n\r\n    this.reprojectedImage_ = new ReprojImage(\r\n      sourceProjection,\r\n      projection,\r\n      extent,\r\n      resolution,\r\n      pixelRatio,\r\n      (extent, resolution, pixelRatio) =>\r\n        this.getImageInternal(extent, resolution, pixelRatio, sourceProjection),\r\n      this.getInterpolate(),\r\n    );\r\n    this.reprojectedRevision_ = this.getRevision();\r\n\r\n    return this.reprojectedImage_;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../Image.js\").default} Single image.\r\n   * @protected\r\n   */\r\n  getImageInternal(extent, resolution, pixelRatio, projection) {\r\n    if (this.loader) {\r\n      const requestExtent = getRequestExtent(extent, resolution, pixelRatio, 1);\r\n      const requestResolution = this.findNearestResolution(resolution);\r\n      if (\r\n        this.image &&\r\n        (this.static_ ||\r\n          (this.wantedProjection_ === projection &&\r\n            ((this.wantedExtent_ &&\r\n              containsExtent(this.wantedExtent_, requestExtent)) ||\r\n              containsExtent(this.image.getExtent(), requestExtent)) &&\r\n            ((this.wantedResolution_ &&\r\n              fromResolutionLike(this.wantedResolution_) ===\r\n                requestResolution) ||\r\n              fromResolutionLike(this.image.getResolution()) ===\r\n                requestResolution)))\r\n      ) {\r\n        return this.image;\r\n      }\r\n      this.wantedProjection_ = projection;\r\n      this.wantedExtent_ = requestExtent;\r\n      this.wantedResolution_ = requestResolution;\r\n      this.image = new ImageWrapper(\r\n        requestExtent,\r\n        requestResolution,\r\n        pixelRatio,\r\n        this.loader,\r\n      );\r\n      this.image.addEventListener(\r\n        EventType.CHANGE,\r\n        this.handleImageChange.bind(this),\r\n      );\r\n    }\r\n    return this.image;\r\n  }\r\n\r\n  /**\r\n   * Handle image change events.\r\n   * @param {import(\"../events/Event.js\").default} event Event.\r\n   * @protected\r\n   */\r\n  handleImageChange(event) {\r\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\r\n    let type;\r\n    switch (image.getState()) {\r\n      case ImageState.LOADING:\r\n        this.loading = true;\r\n        type = ImageSourceEventType.IMAGELOADSTART;\r\n        break;\r\n      case ImageState.LOADED:\r\n        this.loading = false;\r\n        type = ImageSourceEventType.IMAGELOADEND;\r\n        break;\r\n      case ImageState.ERROR:\r\n        this.loading = false;\r\n        type = ImageSourceEventType.IMAGELOADERROR;\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n    if (this.hasListener(type)) {\r\n      this.dispatchEvent(new ImageSourceEvent(type, image));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Default image load function for image sources that use import(\"../Image.js\").Image image\r\n * instances.\r\n * @param {import(\"../Image.js\").default} image Image.\r\n * @param {string} src Source.\r\n */\r\nexport function defaultImageLoadFunction(image, src) {\r\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (image.getImage()).src = src;\r\n}\r\n\r\n/**\r\n * Adjusts the extent so it aligns with pixel boundaries.\r\n * @param {import(\"../extent.js\").Extent} extent Extent.\r\n * @param {number} resolution Reolution.\r\n * @param {number} pixelRatio Pixel ratio.\r\n * @param {number} ratio Ratio between request size and view size.\r\n * @return {import(\"../extent.js\").Extent} Request extent.\r\n */\r\nexport function getRequestExtent(extent, resolution, pixelRatio, ratio) {\r\n  const imageResolution = resolution / pixelRatio;\r\n  const center = getCenter(extent);\r\n  const viewWidth = ceil(getWidth(extent) / imageResolution, DECIMALS);\r\n  const viewHeight = ceil(getHeight(extent) / imageResolution, DECIMALS);\r\n  const marginWidth = ceil(((ratio - 1) * viewWidth) / 2, DECIMALS);\r\n  const requestWidth = viewWidth + 2 * marginWidth;\r\n  const marginHeight = ceil(((ratio - 1) * viewHeight) / 2, DECIMALS);\r\n  const requestHeight = viewHeight + 2 * marginHeight;\r\n  return getForViewAndSize(center, imageResolution, 0, [\r\n    requestWidth,\r\n    requestHeight,\r\n  ]);\r\n}\r\n\r\nexport default ImageSource;\r\n","/**\r\n * @module CME2D/ImageCanvas\r\n */\r\nimport ImageState from './ImageState.js';\r\nimport ImageWrapper from './Image.js';\r\n\r\n/**\r\n * A function that is called to trigger asynchronous canvas drawing.  It is\r\n * called with a \"done\" callback that should be called when drawing is done.\r\n * If any error occurs during drawing, the \"done\" callback should be called with\r\n * that error.\r\n *\r\n * @typedef {function(function(Error=): void): void} Loader\r\n */\r\n\r\nclass ImageCanvas extends ImageWrapper {\r\n  /**\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {HTMLCanvasElement} canvas Canvas.\r\n   * @param {Loader} [loader] Optional loader function to\r\n   *     support asynchronous canvas drawing.\r\n   */\r\n  constructor(extent, resolution, pixelRatio, canvas, loader) {\r\n    const state = loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\r\n\r\n    super(extent, resolution, pixelRatio, state);\r\n\r\n    /**\r\n     * Optional canvas loader function.\r\n     * @type {?Loader}\r\n     * @private\r\n     */\r\n    this.loader_ = loader !== undefined ? loader : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = canvas;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Error}\r\n     */\r\n    this.error_ = null;\r\n  }\r\n\r\n  /**\r\n   * Get any error associated with asynchronous rendering.\r\n   * @return {?Error} Any error that occurred during rendering.\r\n   */\r\n  getError() {\r\n    return this.error_;\r\n  }\r\n\r\n  /**\r\n   * Handle async drawing complete.\r\n   * @param {Error} [err] Any error during drawing.\r\n   * @private\r\n   */\r\n  handleLoad_(err) {\r\n    if (err) {\r\n      this.error_ = err;\r\n      this.state = ImageState.ERROR;\r\n    } else {\r\n      this.state = ImageState.LOADED;\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state == ImageState.IDLE) {\r\n      this.state = ImageState.LOADING;\r\n      this.changed();\r\n      this.loader_(this.handleLoad_.bind(this));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Canvas element.\r\n   * @override\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n}\r\n\r\nexport default ImageCanvas;\r\n","/**\r\n * @module CME2D/source/ImageCanvas\r\n */\r\n\r\nimport ImageCanvas from '../ImageCanvas.js';\r\nimport ImageSource from './Image.js';\r\nimport {\r\n  containsExtent,\r\n  getHeight,\r\n  getWidth,\r\n  scaleFromCenter,\r\n} from '../extent.js';\r\n\r\n/**\r\n * A function returning the canvas element (`{HTMLCanvasElement}`)\r\n * used by the source as an image. The arguments passed to the function are:\r\n * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,\r\n * `{number}` the pixel ratio of the map, {@link module:ol/size~Size} the image size,\r\n * and {@link module:ol/proj/Projection~Projection} the image projection. The canvas returned by\r\n * this function is cached by the source. The this keyword inside the function\r\n * references the {@link module:ol/source/ImageCanvas~ImageCanvasSource}.\r\n *\r\n * @typedef {function(this:import(\"../ImageCanvas.js\").default, import(\"../extent.js\").Extent, number,\r\n *     number, import(\"../size.js\").Size, import(\"../proj/Projection.js\").default): HTMLCanvasElement} FunctionType\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {FunctionType} [canvasFunction] Canvas function.\r\n * The function returning the canvas element used by the source\r\n * as an image. The arguments passed to the function are: {@link import(\"../extent.js\").Extent} the\r\n * image extent, `{number}` the image resolution, `{number}` the pixel ratio of the map,\r\n * {@link import(\"../size.js\").Size} the image size, and {@link import(\"../proj/Projection.js\").default} the image\r\n * projection. The canvas returned by this function is cached by the source. If\r\n * the value returned by the function is later changed then\r\n * `changed` should be called on the source for the source to\r\n * invalidate the current cached image. See: {@link module:ol/Observable~Observable#changed}\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\r\n * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the\r\n * width and height of the map viewport, and so on. Must be `1` or higher.\r\n * @property {Array<number>} [resolutions] Resolutions.\r\n * If specified, new canvases will be created for these resolutions\r\n * @property {import(\"./Source.js\").State} [state] Source state.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for image sources where a canvas element is the image.\r\n * @api\r\n */\r\nclass ImageCanvasSource extends ImageSource {\r\n  /**\r\n   * @param {Options} [options] ImageCanvas options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    super({\r\n      attributions: options.attributions,\r\n      interpolate: options.interpolate,\r\n      projection: options.projection,\r\n      resolutions: options.resolutions,\r\n      state: options.state,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {FunctionType}\r\n     */\r\n    this.canvasFunction_ = options.canvasFunction;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../ImageCanvas.js\").default}\r\n     */\r\n    this.canvas_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.renderedRevision_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\r\n   * @override\r\n   */\r\n  getImageInternal(extent, resolution, pixelRatio, projection) {\r\n    resolution = this.findNearestResolution(resolution);\r\n\r\n    let canvas = this.canvas_;\r\n    if (\r\n      canvas &&\r\n      this.renderedRevision_ == this.getRevision() &&\r\n      canvas.getResolution() == resolution &&\r\n      canvas.getPixelRatio() == pixelRatio &&\r\n      containsExtent(canvas.getExtent(), extent)\r\n    ) {\r\n      return canvas;\r\n    }\r\n\r\n    extent = extent.slice();\r\n    scaleFromCenter(extent, this.ratio_);\r\n    const width = getWidth(extent) / resolution;\r\n    const height = getHeight(extent) / resolution;\r\n    const size = [width * pixelRatio, height * pixelRatio];\r\n\r\n    const canvasElement = this.canvasFunction_.call(\r\n      this,\r\n      extent,\r\n      resolution,\r\n      pixelRatio,\r\n      size,\r\n      projection,\r\n    );\r\n    if (canvasElement) {\r\n      canvas = new ImageCanvas(extent, resolution, pixelRatio, canvasElement);\r\n    }\r\n    this.canvas_ = canvas;\r\n    this.renderedRevision_ = this.getRevision();\r\n\r\n    return canvas;\r\n  }\r\n}\r\n\r\nexport default ImageCanvasSource;\r\n","/**\r\n * @module CME2D/layer/BaseImage\r\n */\r\nimport Layer from './Layer.js';\r\n\r\n/**\r\n * @template {import(\"../source/Image.js\").default} ImageSourceType\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\r\n * @property {ImageSourceType} [source] Source for this layer.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Server-rendered images that are available for arbitrary extents and\r\n * resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Image.js\").default} ImageSourceType\r\n * @template {import(\"../renderer/Layer.js\").default} RendererType\r\n * @extends {Layer<ImageSourceType, RendererType>}\r\n * @api\r\n */\r\nclass BaseImageLayer extends Layer {\r\n  /**\r\n   * @param {Options<ImageSourceType>} [options] Layer options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n    super(options);\r\n  }\r\n}\r\n\r\nexport default BaseImageLayer;\r\n","/**\r\n * @module CME2D/renderer/canvas/ImageLayer\r\n */\r\nimport CanvasLayerRenderer from './Layer.js';\r\nimport ImageState from '../../ImageState.js';\r\nimport ViewHint from '../../ViewHint.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n} from '../../transform.js';\r\nimport {\r\n  containsCoordinate,\r\n  containsExtent,\r\n  getHeight,\r\n  getIntersection,\r\n  getWidth,\r\n  intersects as intersectsExtent,\r\n  isEmpty,\r\n} from '../../extent.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\n\r\n/**\r\n * @classdesc\r\n * Canvas renderer for image layers.\r\n * @api\r\n */\r\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\r\n  /**\r\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\r\n   */\r\n  constructor(imageLayer) {\r\n    super(imageLayer);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {?import(\"../../Image.js\").default}\r\n     */\r\n    this.image = null;\r\n  }\r\n\r\n  /**\r\n   * @return {import('../../DataTile.js').ImageLike} Image.\r\n   */\r\n  getImage() {\r\n    return !this.image ? null : this.image.getImage();\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   * @override\r\n   */\r\n  prepareFrame(frameState) {\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const viewState = frameState.viewState;\r\n    const viewResolution = viewState.resolution;\r\n\r\n    const imageSource = this.getLayer().getSource();\r\n\r\n    const hints = frameState.viewHints;\r\n\r\n    let renderedExtent = frameState.extent;\r\n    if (layerState.extent !== undefined) {\r\n      renderedExtent = getIntersection(\r\n        renderedExtent,\r\n        fromUserExtent(layerState.extent, viewState.projection),\r\n      );\r\n    }\r\n\r\n    if (\r\n      !hints[ViewHint.ANIMATING] &&\r\n      !hints[ViewHint.INTERACTING] &&\r\n      !isEmpty(renderedExtent)\r\n    ) {\r\n      if (imageSource) {\r\n        const projection = viewState.projection;\r\n        const image = imageSource.getImage(\r\n          renderedExtent,\r\n          viewResolution,\r\n          pixelRatio,\r\n          projection,\r\n        );\r\n        if (image) {\r\n          if (this.loadImage(image)) {\r\n            this.image = image;\r\n          } else if (image.getState() === ImageState.EMPTY) {\r\n            this.image = null;\r\n          }\r\n        }\r\n      } else {\r\n        this.image = null;\r\n      }\r\n    }\r\n\r\n    return !!this.image;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray} Data at the pixel location.\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    const frameState = this.frameState;\r\n    if (!frameState) {\r\n      return null;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const coordinate = applyTransform(\r\n      frameState.pixelToCoordinateTransform,\r\n      pixel.slice(),\r\n    );\r\n\r\n    const layerExtent = layer.getExtent();\r\n    if (layerExtent) {\r\n      if (!containsCoordinate(layerExtent, coordinate)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    const imageExtent = this.image.getExtent();\r\n    const img = this.image.getImage();\r\n\r\n    const imageMapWidth = getWidth(imageExtent);\r\n    const col = Math.floor(\r\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth),\r\n    );\r\n    if (col < 0 || col >= img.width) {\r\n      return null;\r\n    }\r\n\r\n    const imageMapHeight = getHeight(imageExtent);\r\n    const row = Math.floor(\r\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight),\r\n    );\r\n    if (row < 0 || row >= img.height) {\r\n      return null;\r\n    }\r\n\r\n    return this.getImageData(img, col, row);\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @return {HTMLElement} The rendered element.\r\n   * @override\r\n   */\r\n  renderFrame(frameState, target) {\r\n    const image = this.image;\r\n    const imageExtent = image.getExtent();\r\n    const imageResolution = image.getResolution();\r\n    const [imageResolutionX, imageResolutionY] = Array.isArray(imageResolution)\r\n      ? imageResolution\r\n      : [imageResolution, imageResolution];\r\n    const imagePixelRatio = image.getPixelRatio();\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const viewState = frameState.viewState;\r\n    const viewCenter = viewState.center;\r\n    const viewResolution = viewState.resolution;\r\n    const scaleX =\r\n      (pixelRatio * imageResolutionX) / (viewResolution * imagePixelRatio);\r\n    const scaleY =\r\n      (pixelRatio * imageResolutionY) / (viewResolution * imagePixelRatio);\r\n\r\n    this.prepareContainer(frameState, target);\r\n\r\n    // desired dimensions of the canvas in pixels\r\n    const width = this.context.canvas.width;\r\n    const height = this.context.canvas.height;\r\n\r\n    const context = this.getRenderContext(frameState);\r\n\r\n    // clipped rendering if layer extent is set\r\n    let clipped = false;\r\n    let render = true;\r\n    if (layerState.extent) {\r\n      const layerExtent = fromUserExtent(\r\n        layerState.extent,\r\n        viewState.projection,\r\n      );\r\n      render = intersectsExtent(layerExtent, frameState.extent);\r\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\r\n      if (clipped) {\r\n        this.clipUnrotated(context, frameState, layerExtent);\r\n      }\r\n    }\r\n\r\n    const img = image.getImage();\r\n\r\n    const transform = composeTransform(\r\n      this.tempTransform,\r\n      width / 2,\r\n      height / 2,\r\n      scaleX,\r\n      scaleY,\r\n      0,\r\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolutionX,\r\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolutionY,\r\n    );\r\n\r\n    this.renderedResolution = (imageResolutionY * pixelRatio) / imagePixelRatio;\r\n\r\n    const dw = img.width * transform[0];\r\n    const dh = img.height * transform[3];\r\n\r\n    if (!this.getLayer().getSource().getInterpolate()) {\r\n      context.imageSmoothingEnabled = false;\r\n    }\r\n\r\n    this.preRender(context, frameState);\r\n    if (render && dw >= 0.5 && dh >= 0.5) {\r\n      const dx = transform[4];\r\n      const dy = transform[5];\r\n      const opacity = layerState.opacity;\r\n      if (opacity !== 1) {\r\n        context.save();\r\n        context.globalAlpha = opacity;\r\n      }\r\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\r\n      if (opacity !== 1) {\r\n        context.restore();\r\n      }\r\n    }\r\n    this.postRender(this.context, frameState);\r\n\r\n    if (clipped) {\r\n      context.restore();\r\n    }\r\n    context.imageSmoothingEnabled = true;\r\n\r\n    return this.container;\r\n  }\r\n}\r\n\r\nexport default CanvasImageLayerRenderer;\r\n","/**\r\n * @module CME2D/layer/Image\r\n */\r\nimport BaseImageLayer from './BaseImage.js';\r\nimport CanvasImageLayerRenderer from '../renderer/canvas/ImageLayer.js';\r\n\r\n/**\r\n * @classdesc\r\n * Server-rendered images that are available for arbitrary extents and\r\n * resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Image.js\").default} ImageSourceType\r\n * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}\r\n * @api\r\n */\r\nclass ImageLayer extends BaseImageLayer {\r\n  /**\r\n   * @param {import(\"./BaseImage.js\").Options<ImageSourceType>} [options] Layer options.\r\n   */\r\n  constructor(options) {\r\n    super(options);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  createRenderer() {\r\n    return new CanvasImageLayerRenderer(this);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the\r\n   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the\r\n   * source's `crossOrigin` property is set.\r\n   *\r\n   * ```js\r\n   * // display layer data on every pointer move\r\n   * map.on('pointermove', (event) => {\r\n   *   console.log(layer.getData(event.pixel));\r\n   * });\r\n   * ```\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   * @api\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    return super.getData(pixel);\r\n  }\r\n}\r\n\r\nexport default ImageLayer;\r\n","// canvas\r\nexport function getCanvasExtent(map, extent, padding) {\r\n  const [xmin, ymin] = map.getPixelFromCoordinate([extent[0], extent[3]]);\r\n  const [xmax, ymax] = map.getPixelFromCoordinate([extent[2], extent[1]]);\r\n  const newExtent = [xmin, ymin, xmax, ymax];\r\n  if (!padding) return newExtent;\r\n  return newExtent.map((v, i) => v + (i < 2 ? padding : -padding));\r\n}\r\n\r\nexport function mergeObject(object1, object2) {\r\n  Object.keys(object2).forEach(name => {\r\n    if (object1[name] === null || typeof object1[name] !== 'object') {\r\n      object1[name] = object2[name];\r\n      return;\r\n    }\r\n    mergeObject(object1[name], object2[name]);\r\n  });\r\n  return object1;\r\n}\r\n\r\n// \r\nexport function setArrowOffset(params) {\r\n  if (!params) return null;\r\n  if (params.type == \"arrow\") {\r\n    params.picOffset = 150;\r\n    return params;\r\n  }\r\n  params.picOffset = 84;\r\n  switch (params.typeColor) {\r\n    case \"white\":\r\n      params.picOffset = 20;\r\n      break;\r\n    case \"black\":\r\n      params.picOffset = 52;\r\n      break;\r\n    case \"blue\":\r\n      params.picOffset = 84;\r\n      break;\r\n    case \"orange\":\r\n      params.picOffset = 116;\r\n      break;\r\n    default:\r\n      params.picOffset = 52;\r\n      break;\r\n  }\r\n  return params;\r\n}\r\n\r\n// pextent\r\nfunction isInExtent(extent, p) {\r\n  const [x0, y0, x1, y1] = extent;\r\n  return p[0] >= x0 && p[0] <= x1 && p[1] >= y0 && p[1] <= y1;\r\n}\r\n\r\n// canvas\r\nexport function getGridPoints(extent, distance, outExtent, padding) {\r\n  const xyList = [];\r\n  const dx = extent[0] < 0 ? distance - Math.abs(extent[0] % distance) : 0;\r\n  const dy = extent[1] < 0 ? distance - Math.abs(extent[1] % distance) : 0;\r\n  const xMin = Math.max(extent[0], outExtent[0]) + dx;\r\n  const yMin = Math.max(extent[1], outExtent[1]) + dy;\r\n  const xMax = Math.min(extent[2], outExtent[2]);\r\n  const yMax = Math.min(extent[3], outExtent[3]);\r\n  for (let x = xMin; x <= xMax; x += distance) {\r\n    for (let y = yMin; y <= yMax; y += distance) {\r\n      if (!isInExtent(outExtent, [x, y])) continue;\r\n      xyList.push([x, y]);\r\n    }\r\n  }\r\n  return xyList;\r\n}\r\n\r\n\r\n","/**\r\n * @module CME2D/CME2DCore/layer/cme_gridValueLayer/gridNumberSource\r\n */\r\nimport ImageCanvasSource from \"../../../source/ImageCanvas.js\";\r\nimport { getCanvasExtent, getGridPoints, mergeObject } from \"./../cme_gridArrowLayer/gridHelper.js\";\r\n// import {\r\n//     transform\r\n// } from \"../../../proj.js\";\r\n// import {\r\n//     Point\r\n// } from \"../../../geom.js\";\r\n// import Feature from \"../../../Feature.js\";\r\nimport {\r\n    transformExtent\r\n} from '../../../proj.js';\r\n\r\nimport {\r\n    getWindSpeedAndDirection\r\n} from \"../common/commonLayerUnit.js\";\r\n\r\nclass gridNumberSource {\r\n    constructor(map) {\r\n        this.options = null; //params.params;\r\n        this.map = map; //params.this.map;\r\n        this.padding = 10;\r\n        this.canvas = document.createElement('canvas');\r\n    }\r\n\r\n    /**\r\n     * WebGL\r\n     * WebGL\r\n     * \r\n     * \r\n     * \r\n     *\r\n     * @param {Object} params - WebGL\r\n     * @return {ImageCanvasSource} WebGL\r\n     */\r\n    InitWebGLFunctionSingle(params) {\r\n        this.options = params;\r\n        const unitList = ['', 'C'];\r\n        function inRange(val, range) {\r\n            return val >= range.min && val <= range.max;\r\n        }\r\n        const canvasSource = new ImageCanvasSource({\r\n            ratio: 1,\r\n            projection: this.map.getView().getProjection().getCode(), //'EPSG:4326',\r\n            /**\r\n             * \r\n             *\r\n             * @param {type} extent - \r\n             * @param {type} resolution - \r\n             * @param {type} pixelRatio - \r\n             * @param {type} size - \r\n             * @param {type} projection - \r\n             * @return {type} \r\n             */\r\n            canvasFunction: (extent, resolution, pixelRatio, size, projection) => {\r\n                const params = this.options;\r\n                const { distanceArrow, fixedPixel, layer, showTextRange, precision } = params;\r\n                const _precision = precision || 1;\r\n                const style = layer.style_;\r\n                const source = layer.getSource();\r\n                const _resolutions = source.getResolutions();\r\n                const rawResolution = _resolutions.slice(-1)[0];\r\n                let _bandCount = 0;\r\n                if (source.getMetaDatas) {\r\n                    const { bandCount } = source.getMetaDatas();\r\n                    _bandCount = bandCount;\r\n                } else {\r\n                    _bandCount = style.bandsNumber || 0;\r\n                }\r\n                const range = Object.assign({ min: -9999, max: 9999 }, showTextRange);\r\n                var canvas = this.canvas;\r\n                canvas.width = size[0];\r\n                canvas.height = size[1];\r\n                var context = canvas.getContext(\"2d\");\r\n                context.scale(pixelRatio, pixelRatio);\r\n                let textSymbol = { //\r\n                    font: \"14px Calibri,sans-serif\", //\r\n                    // textBaseline: \"middle\",//\r\n                    fill: { //\r\n                        color: \"#000\", //\r\n                    },\r\n                    stroke: { //\r\n                        color: \"#fff\", //\r\n                        width: 4, //\r\n                    },\r\n                };\r\n                // \r\n                if (params.textStyle) {\r\n                    mergeObject(textSymbol, params.textStyle);\r\n                }\r\n                context.fillStyle = '#00000000';\r\n                context.fillRect(0, 0, size[0], size[1]);\r\n                context.fillStyle = textSymbol.fill?.color || '#000000ff';\r\n                if (textSymbol.stroke) {\r\n                    context.strokeStyle = textSymbol.stroke.strokeStyle || \"#ffffff\"; // \r\n                    context.lineWidth = textSymbol.stroke.lineWidth || 1; // \r\n                }\r\n                //1. `font`\r\n                context.font = textSymbol.font; //\"14px blod serif\";\r\n                context.textAlign = \"center\";\r\n                let mapProject = projection.getCode();\r\n                let proj = layer.getProperties().proj;\r\n                let projCode = proj.projection;\r\n                let offsetNumber = proj.offsetNumber || 0;\r\n                let unit = proj.unit;\r\n                var newExtent = proj.extent;\r\n                if (projCode != mapProject) {\r\n                    newExtent = transformExtent(proj.extent, projCode, mapProject);\r\n                }\r\n                let distance = +distanceArrow || 80;\r\n                if (fixedPixel) {\r\n                    distance = Math.max((rawResolution / resolution), distance);\r\n                }\r\n                this.padding = Math.ceil(distance / 5);\r\n                // canvas\r\n                const outExtent = getCanvasExtent(this.map, extent);\r\n                // canvas\r\n                const extent1 = getCanvasExtent(this.map, newExtent, this.padding);\r\n                const xyList = getGridPoints(extent1, distance, outExtent, this.padding);\r\n                const { scala, scale, offset } = style;\r\n                const _scale = scale || scala;\r\n                for (let idx = 0; idx < xyList.length; idx++) {\r\n                    let data = layer.getData(xyList[idx]);\r\n                    if (!(data && data.length)) continue;\r\n                    let drawNum = (data[0] - offset) / _scale;\r\n                    if (_bandCount >= 2) {\r\n                        let uv = getWindSpeedAndDirection(drawNum, (data[1] - offset) / _scale);\r\n                        drawNum = uv.speed; //\r\n                    } else if (unitList.includes(unit)) {\r\n                        drawNum -= 273.15;\r\n                    }\r\n                    if (!inRange(drawNum, range)) continue;\r\n                    drawNum = drawNum.toFixed(_precision);\r\n                    let xPixel = xyList[idx][0] - offsetNumber;\r\n                    let yPixel = xyList[idx][1] - offsetNumber;\r\n                    if (textSymbol.stroke) {\r\n                        context.strokeText(drawNum, xPixel, yPixel);\r\n                    }\r\n                    context.fillText(drawNum, xPixel, yPixel);\r\n                    context.fill(); // \r\n                }\r\n                return canvas;\r\n            }\r\n        });\r\n        return canvasSource;\r\n    }\r\n\r\n    setOptions(options) {\r\n        this.options = options;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport { gridNumberSource }","/**  this.canvasSource\r\n * @module CME2D/CME2DCore/layer/cme_gridValueLayer/cme_gridValueLayer\r\n */\r\n\r\nimport ImageLayer from \"../../../layer/Image.js\";\r\nimport {\r\n  gridNumberSource\r\n} from \"./gridNumberSource.js\"\r\nimport {\r\n  PanByPixel,\r\n  mergeObjects\r\n} from \"../common/commonLayerUnit.js\";\r\nvar cme_gridValueLayer = class gridNumberClass extends ImageLayer {\r\n  /**\r\n   * \r\n   *\r\n   * @param {type} options - \r\n   * @return {type} \r\n   */\r\n  constructor() {\r\n\r\n    super({});\r\n    this.canvasSource = null;\r\n    this.gridSource = null;\r\n    this.options = null;\r\n\r\n  }\r\n  /**\r\n   * truePromise\r\n   *\r\n   * @param {Object} options - \r\n   * @return {Promise} truePromise\r\n   */\r\n  _render(options) {\r\n    if (!options.params?.layer) {\r\n      throw Error('options\"params.layer\"');\r\n    }\r\n    this.gridSource = new gridNumberSource(options.map);\r\n    this.options = options;\r\n    let that = this;\r\n    return new Promise((resolve) => {\r\n      that.canvasSource = that.gridSource.InitWebGLFunctionSingle(options.params);\r\n      that.setSource(that.canvasSource)\r\n      for (let key in options.params) {\r\n        const value = options.params[key];\r\n        that.set(key, value)\r\n      }\r\n\r\n\r\n      that.setProperties(options.params)\r\n      that.set(\"params\", options.params)\r\n\r\n      //  that.once('sourceready', function (event) {\r\n      options.map.once(\"rendercomplete\", function () {\r\n        that.canvasSource.changed()\r\n        // PanByPixel(options.map, 0.1, 0.1);\r\n        resolve(true);\r\n      });\r\n    })\r\n\r\n\r\n  }\r\n\r\n  /**\r\n   * \r\n   *\r\n   * @param {type} paramName - \r\n   * @return {type} \r\n   */\r\n  _setSource(layer) {\r\n    this.options.params.layer = layer;\r\n    let that = this;\r\n    return new Promise((resolve) => {\r\n      // that.canvasSource = new InitWebGLFunctionSingle(this.options);\r\n\r\n      that.canvasSource = that.gridSource.InitWebGLFunctionSingle(that.options.params);\r\n      that.setSource(that.canvasSource)\r\n\r\n      // // that.once('postcompose', function (event) {\r\n      //   // that.once('postrender', function (event) {\r\n      //   that.once('sourceready', function (event) {\r\n      //   that.canvasSource.changed()\r\n      //   PanByPixel(that.options.map, 1, 1);\r\n\r\n      //   resolve(true);\r\n      // })\r\n      that.once('sourceready', function (event) {\r\n\r\n        that.once('postrender', function (event) {\r\n          that.canvasSource.changed()\r\n          // PanByPixel(that.options.map, 0.1, 0.1);\r\n          resolve(true);\r\n        })\r\n\r\n      })\r\n\r\n    })\r\n\r\n\r\n  }\r\n  /**\r\n   * \r\n   *\r\n   * @param {type} paramName - \r\n   * @return {type} \r\n   */\r\n  _setStyle(options) {\r\n\r\n    let tempStyle = {}\r\n    let tempObject = this.values_ || {};\r\n    for (let key in tempObject) {\r\n      const value = tempObject[key];\r\n      if (key != \"layer\") {\r\n        tempStyle[key] = value;\r\n      }\r\n    }\r\n\r\n    let styleobject = mergeObjects(tempStyle, options.params);\r\n    for (let key in styleobject) {\r\n      const value = styleobject[key];\r\n      this.set(key, value)\r\n    }\r\n    // let  styleobject = Object.assign({},  this.getProperties()[\"params\"], options.params);\r\n    this.options.params = styleobject;\r\n    styleobject.layer = tempObject.layer;\r\n    // this.set(\"params\", styleobject);\r\n    this.gridSource.setOptions(styleobject);\r\n    this.canvasSource.changed();\r\n    return Promise.resolve(styleobject);\r\n  }\r\n\r\n  getSource() {\r\n    return this.canvasSource;\r\n  }\r\n  /**\r\n   * \r\n   *\r\n   */\r\n  _remove() {\r\n    this.dispose();\r\n    // \r\n  }\r\n}\r\nexport default cme_gridValueLayer","<!--\r\n * @Author: sjz 15103288529@163.com\r\n * @Date: 2024-03-16 15:52:15\r\n * @LastEditors: sjz 15103288529@163.com\r\n * @LastEditTime: 2024-05-27 19:57:25\r\n * @FilePath: \\cme\\src\\components\\cme-application\\RasterRender\\index.vue\r\n * @Description: /\r\n-->\r\n<script>\r\nimport {\r\n  cme_gridValueLayer,\r\n  cme_cogtifLayer2,\r\n// } from \"CME2D/CME2DCore/index.js\";\r\n} from \"E://0509/cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore\";\r\n\r\n\r\nimport { defineComponent } from \"vue\";\r\n// import { getCofTifData } from \"./cogtifWorld.js\";\r\nexport default defineComponent({\r\n  setup() {\r\n    let layerdata = null;\r\n    let mapRef = null;\r\n    const layerRef = { tifLayer: null, textLayer: null };\r\n    const CogTifInfo = {};\r\n    /**\r\n     * @description: /\r\n     * @param {object} map - \r\n     * @param {string} url - url\r\n     * @param {object} data - \r\n     * @return {*}\r\n     */\r\n    let addLayer = (map, url, data) => {\r\n      mapRef = map;\r\n      // CogTifInfo.value = res\r\n      CogTifInfo.configUnit = data?.configUnit\r\n      // let bandsNumber = data.bandsNumber || 1; //UV\r\n      layerdata = data; //\r\n\r\n\r\n      \r\n      let sources = []; //\r\n      if (data.normalize) {\r\n          // \r\n          sources = [\r\n            {\r\n              url: url, //tif\r\n            \r\n            },\r\n          ];\r\n\r\n        } else {\r\n          // \r\n          sources = [\r\n            {\r\n              url: url, //tif\r\n              min: -9999,\r\n               max: 9999 \r\n            },\r\n          ];\r\n        }\r\n\r\n      // \r\n      let config = {\r\n        layerName: data.id,\r\n        type: 'grid',\r\n        zIndex: data.zIndex ?? 1,\r\n        source: {\r\n          //\r\n          normalize: data.normalize ?? false, // true false\r\n          // sources: [{ url, min: -9999, max: 9999 }], // tif\r\n\r\n          sources:sources, // tif\r\n          wrapX: data.wrapX ?? true,\r\n          interpolate: data?.interpolate ?? true,  // \r\n        },\r\n        style: {\r\n          //\r\n          color: data.legendData?.legend ?? [], //\r\n          radio: +data.radio || 2, // 12\r\n          scale: +(data.scale || data.scala) , // data.legendData?.scala ?? 0,//\r\n          offset: +data.offset || 0,\r\n          unit: data.unit ?? ''\r\n        },\r\n        opacity: data.opacity ?? 0.78, //\r\n        sourceOptions: {\r\n          allowFullFile: false,\r\n        },\r\n        mapproj: map.getView().getProjection().getCode()\r\n      };\r\n      // let layer = new cme_cogtifLayer(config); //\r\n      let layer = new cme_cogtifLayer2(); //\r\n      map.addLayer(layer);\r\n      layerRef.tifLayer = layer;\r\n      return layer._render(config).then((meta) => {\r\n        if (data.showText) {\r\n          addTextLayer(map, layer, data); //\r\n        }\r\n        return Promise.resolve(layerRef, meta); // \r\n      });\r\n    };\r\n\r\n    /**\r\n     * @description: \r\n     * @param {*} map - \r\n     * @param {Object} layer - \r\n     * @param {Object} data - \r\n     * @return {*}\r\n     */\r\n    let addTextLayer = (map, layer, data) => {\r\n      const range = { min: -9999, max: 9999 };\r\n      const legend = (data?.legendData?.legend || []).map(v => v[0]);\r\n      if (legend.length) {\r\n        range.min = legend.reduce((v1, v2) => Math.min(v1, v2), 0) - 10;\r\n        range.max = legend.reduce((v1, v2) => Math.max(v1, v2), 0) + 10;\r\n      }\r\n      let config = {\r\n        map: map, //\r\n        params: {\r\n          type: 'grid',\r\n          layer: layer, //\r\n          layerName: data.textId ?? data.id, //,id_Text\r\n          precision: 1, //\r\n          opacity: 1, //\r\n          maxZoom: 15, // \r\n          zIndex: Number(data.zIndex) + 1 ?? 2, //\r\n          showTextRange: range,\r\n          distanceArrow: data.distanceArrow ?? 80, //\r\n          textStyle: data.textStyle ?? {\r\n            //\r\n            font: \"11px Calibri,sans-serif\", //\r\n            fill: {\r\n              color: \"#000000\", //\r\n            },\r\n            stroke: {\r\n              // strokeStyle:'white',\r\n              lineWidth: 5\r\n            }\r\n          },\r\n        },\r\n      };\r\n      let lyr = new cme_gridValueLayer(); //\r\n      map.addLayer(lyr); //\r\n      lyr._render(config); //\r\n      layerRef.tifLayer = lyr;\r\n    };\r\n\r\n    const getData = (pixel, layer) => {\r\n      let res = layer.getData(pixel)\r\n      let { scale = 1, unit, offset = 0, nodata, configUnit } = CogTifInfo\r\n      let params = {\r\n        value: null\r\n      }\r\n      if (res !== nodata) {\r\n        try {\r\n          if (configUnit && configUnit === 'k') {\r\n            params.value = (res[0] / scale) + offset\r\n          }\r\n          else if (unit === 'K') {\r\n            if (res[0] === 0) {\r\n              params.value = 0\r\n            }\r\n            else {\r\n              params.value = offset + (res[0] / scale) - 273.15\r\n            }\r\n          }\r\n          else {\r\n            params.value = (res[0] / scale) + offset\r\n          }\r\n        }\r\n        catch (err) {\r\n        }\r\n        return params\r\n      }\r\n      return ''\r\n    };\r\n\r\n    function removeLayer() {\r\n      Object.values(layerRef).forEach(layer => {\r\n        if (!layer) return;\r\n        mapRef && mapRef.removeLayer(layer);\r\n      });\r\n    }\r\n\r\n    return {\r\n      getData,\r\n      addLayer,\r\n      removeLayer\r\n    };\r\n  },\r\n});\r\n</script>\r\n","import GridRender from \"./index.vue\";\r\n// \r\nGridRender.install = function (Vue) {\r\n  Vue.component(\"CME-GridRender\", GridRender);\r\n};\r\nexport { GridRender };\r\n"],"names":["Disposable","BaseEvent","type","ascending","a","b","descending","linearFindNearest","arr","target","direction","i","candidate","extend","data","extension","length","equals","arr1","arr2","len1","isSorted","func","strict","compare","currentVal","index","res","VOID","memoizeOne","fn","lastResult","lastArgs","lastThis","nextArgs","arrayEquals","toPromise","getter","promiseGetter","value","err","clear","object","property","isEmpty","Target","listener","listeners","listenersForType","event","isString","evt","Event","dispatching","pendingRemovals","propagate","ii","pr","EventType","TileState","abstract","uidCounter_","getUid","obj","easeIn","t","easeOut","inAndOut","Tile","EventTarget","tileCoord","state","options","id","time","start","delta","ua","SAFARI","SAFARI_BUG_237906","WORKER_OFFSCREEN_CANVAS","IMAGE_DECODE","passive","createCanvasContext2D","width","height","canvasPool","settings","canvas","sharedCanvasContext","getSharedCanvasContext2D","releaseCanvas","context","asImageLike","asArrayLike","disposedError","sharedContext","toArray","image","defaultSize","DataTile","imageData","self","error","ERROR_THRESHOLD","Relationship","boundingExtent","coordinates","extent","createEmpty","extendCoordinate","_boundingExtentXYs","xs","ys","dest","minX","minY","maxX","maxY","createOrUpdate","closestSquaredDistanceXY","x","y","dx","dy","containsCoordinate","coordinate","containsXY","containsExtent","extent1","extent2","coordinateRelationship","relationship","createOrUpdateEmpty","createOrUpdateFromCoordinate","createOrUpdateFromFlatCoordinates","flatCoordinates","offset","end","stride","extendFlatCoordinates","extendXY","forEachCorner","callback","val","getBottomLeft","getBottomRight","getTopRight","getTopLeft","getArea","area","getWidth","getHeight","getCenter","getCorner","corner","getForViewAndSize","center","resolution","rotation","size","x0","y0","x1","y1","x2","y2","x3","y3","getRotatedViewport","cosRotation","sinRotation","xCos","xSin","yCos","ySin","getIntersection","intersection","intersects","returnOrUpdate","scaleFromCenter","deltaX","deltaY","intersectsSegment","startRel","endRel","startX","startY","endX","endY","slope","applyTransform","transformFn","stops","wrapX","projection","projectionExtent","worldWidth","wrapAndSliceX","multiWorld","unitByCode","fromCode","code","METERS_PER_UNIT","Projection","global","tileGrid","worldExtent","RADIUS","HALF_SIZE","EXTENT","WORLD_EXTENT","MAX_SAFE_Y","EPSG3857Projection","point","PROJECTIONS","fromEPSG4326","input","output","dimension","toEPSG4326","EPSG4326Projection","axisOrientation","cache","get","add","transforms","source","destination","sourceCode","destinationCode","transform","clamp","min","max","squaredSegmentDistance","squaredDistance","solveLinearSystem","mat","n","maxRow","maxEl","r","absValue","tmp","j","coef","k","l","m","toRadians","angleInDegrees","modulo","lerp","toFixed","decimals","factor","floor","ceil","coordinate1","coordinate2","rotate","angle","cosAngle","sinAngle","DEFAULT_RADIUS","getDistance","c1","c2","radius","lat1","lat2","deltaLatBy2","deltaLonBy2","warn","args","showCoordinateWarning","disableCoordinateWarning","disable","cloneTransform","identityTransform","addProjection","addProj","addTransformFunc","addProjections","projections","projectionLike","getProj","getPointResolution","units","pointResolution","metersPerUnit","projUnits","getTransformFromProjections","vertices","addEquivalentProjections","addEquivalentTransforms","projections1","projections2","forwardTransform","inverseTransform","projection1","projection2","createProjection","defaultCode","equivalent","equalUnits","sourceProjection","destinationProjection","transformFunc","getTransformFunc","getTransform","transformExtent","toUserCoordinate","fromUserCoordinate","destProjection","toUserExtent","fromUserExtent","addCommon","EPSG3857_PROJECTIONS","EPSG4326_PROJECTIONS","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","destinationResolution","transformInvCache","transformInv","c","key","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","leftBound","triangle","newTriangle","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","targetQuadExtent","isNotFinite","centerSrc","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","src","brokenDiagonalRendering_","drawTestTriangle","ctx","u1","v1","u2","v2","verifyBrokenDiagonalRendering","isBrokenDiagonalRendering","calculateSourceResolution","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","sourceMetersPerUnit","sourceExtent","compensationFactor","calculateSourceExtentResolution","render","pixelRatio","triangulation","sources","gutter","renderEdges","interpolate","drawSingle","clipExtent","pixelRound","sourceDataExtent","stitchContext","stitchScale","inverseScale","xPos","yPos","srcWidth","srcHeight","targetTopLeft","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","steps","ud","vd","step","listen","thisArg","once","originalListener","eventsKey","listenOnce","unlistenByKey","ReprojDataTile","sourceProjExtent","sourceTileGridExtent","maxTargetExtent","limitedTargetExtent","errorThresholdInPixels","worldsAway","sourceRange","getTile","srcX","srcY","tile","dataSources","imageLike","tileData","arrayData","pixelSize","isFloat","pixelCount","DataType","tileDataR","bytesPerElement","bytesPerPixel","bytesPerRow","bandCount","packedLength","packedData","dataIndex","rowOffset","colCount","rowIndex","colIndex","_a","z","targetWidth","targetHeight","dataR","dataU","reprojs","reproj","len","dataSource","buffer","renderReprojected","leftToLoad","sourceListenKey","assert","assertion","errorMessage","LRUCache","highWaterMark","keep","f","entry","keys","values","getKeyZXY","getKey","fromKey","withinExtentAndZ","tileRange","TileCache","usedTiles","TileEventType","ObjectEventType","Observable","unByKey","ObjectEvent","oldValue","BaseObject","eventType","silent","Source","getProjection","adaptAttributions","resolve","reject","attributions","attributionLike","frameState","TileRange","DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","forEach","ret","linearRingContainsExtent","linearRingContainsXY","wn","linearRingsContainsXY","ends","intersectsLineString","coordinatesExtent","forEachSegment","point1","point2","intersectsLinearRing","intersectsLinearRingArray","scale","ratio","toSize","tmpTileCoord","DECIMALS","TileGrid","zoomFactor","restrictedTileRange","zoom","jj","tempTileRange","tempExtent","tileCoordExtent","createOrUpdateTileRange","tileCoordZ","tileCoordX","tileCoordY","origin","tileSize","opt_tileCoord","reverseIntersectionPolicy","createOrUpdateTileCoord","opt_direction","viewport","fullTileRanges","getForProjection","createForProjection","extentFromProjection","createForExtent","maxZoom","resolutions","resolutionsFromExtent","createXYZ","xyzOptions","gridOptions","maxResolution","half","TileSource","tileCache","getTileGridForProjection","tilePixelRatio","scaleSize","TileSourceEvent","DataTileSource","tileSizes","thisProj","loader","tileCoordKey","reprojTilePixelRatio","textureSize","sourceTileGrid","targetTileGrid","wrappedTileCoord","newTile","sourceLoader","controller","loaderOptions","requestZ","requestX","requestY","uid","tileState","projKey","tilegrid","proj","usedTileCache","uncurryThis","ReflectApply","uncurryThisGetter","ReflectGetOwnPropertyDescriptor","ReflectConstruct","ReflectDefineProperty","ReflectGet","ReflectGetPrototypeOf","ReflectHas","ReflectOwnKeys","ReflectSet","ReflectSetPrototypeOf","SymbolIterator","SymbolSpecies","SymbolToStringTag","SymbolFor","NativeObject","ObjectCreate","ObjectDefineProperty","ObjectFreeze","ObjectIs","NativeArray","ArrayPrototype","NativeArrayPrototypeSymbolIterator","ArrayPrototypeSymbolIterator","NativeArrayBuffer","ArrayBufferPrototype","NativeSharedArrayBuffer","TypedArray","TypedArrayPrototype","NativeUint8Array","NativeUint16Array","NativeUint32Array","NativeFloat32Array","ArrayIteratorPrototype","ArrayIteratorPrototypeNext","GeneratorPrototypeNext","IteratorPrototype","DataViewPrototype","DataViewPrototypeGetUint16","NativeWeakMap","WeakMapPrototype","WeakMapPrototypeGet","WeakMapPrototypeSet","arrayIterators","SafeIteratorPrototype","arrayIterator","safeIfNeeded","array","safe","generators","DummyArrayIteratorPrototype","generator","floatView","uint32View","baseTable","shiftTable","mantissaTable","e","exponentTable","offsetTable","convertToNumber","float16bits","getFloat16","dataView","byteOffset","opts","getAttribute","tag","attributeName","debug","xml","opening","quotechars","char","pattern","match","getAttributeModule","indexOfMatch","startIndex","indexOfMatchModule","indexOfMatchEnd","indexOfMatchEndModule","countSubstring","string","substring","countSubstringModule","require$$0","require$$1","require$$2","findTagByName","tagName","nested","afterStart","relativeEnd","selfClosing","openings","closings","clip","outer","inner","findTagByNameModule","findTagsByName","tags","findTagsByNameModule","fieldTagNames","fieldTags","arrayFields","fieldTypeNames","fieldTypes","photometricInterpretations","ExtraSamplesValues","LercParameters","LercAddCompression","geoKeyNames","fromWhiteIsZero","raster","rgbRaster","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","fromYCbCr","yCbCrRaster","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","registry","addDecoder","cases","importFn","getDecoder","fileDirectory","Decoder","copyNewSize","samplesPerPixel","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","newArray","cy","cx","resampleBilinear","rawY","yl","yh","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","s","arrayForType","format","bitsPerSample","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","outSize","samplesToTransfer","outArray","bitMask","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","innerBitOffset","raw","GeoTIFFImage","geoKeys","littleEndian","bytes","sampleIndex","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","tiles","byteCount","slice","request","sampleFormat","imageWindow","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","srcSampleOffsets","sampleReaders","promises","yTile","xTile","getPromise","si","promise","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","windowCoordinate","resampled","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","window","enableAlpha","pi","subOptions","red","green","blue","tiePoints","metadata","items","item","modelTransformation","referenceImage","modelPixelScale","refResX","refResY","refResZ","g","h","projected","I","J","pt","DataView64","arrayBuffer","left","right","combined","isNegative","carrying","byte","DataSlice","sliceOffset","bigTiff","defaultPoolSize","Pool","createWorker","module","create","decoder","worker","onMessage","CRLFCRLF","itemsToObject","parseHeaders","text","line","kv","str","parseContentType","rawContentType","rawParams","paramsItems","param","parseContentRange","rawContentRange","total","parseByteRanges","responseArrayBuffer","boundary","out","startBoundary","endBoundary","innerText","endOfHeaders","headers","startOfData","BaseSource","slices","QuickLRU","maxAge","expiry","deleted","newSize","removeCount","oldCacheSize","callbackFunction","thisArgument","wait","milliseconds","zip","A","B","AbortError","params","CustomAggregateError","errors","message","AggregateError","Block","BlockGroup","blockIds","BlockedSource","blockSize","cacheSize","blockId","block","blockRequests","missingBlockIds","allBlockIds","top","fileSize","firstBlockOffset","current","missingRequests","abortedBlockRequests","abortedBlockIds","blocks","failedBlocks","requiredBlocks","groups","groupRequests","groupIndex","group","response","blockOffset","o","sortedBlockIds","lastBlockId","blockIdLow","blockIdHigh","sliceData","sliceView","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView","BaseResponse","headerName","BaseClient","url","FetchResponse","name","FetchClient","credentials","XHRResponse","xhr","XHRClient","fs","HttpResponse","dataPromise","HttpClient","urlMod","http","resolveData","chunks","chunk","RemoteSource","client","maxRanges","allowFullFile","byteRanges","first","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","FileReaderSource","file","blob","makeFileReaderSource","getFieldTypeLength","fieldType","parseGeoKeyDirectory","rawGeoKeyDirectory","geoKeyDirectory","location","count","getValues","dataSlice","readMethod","fieldTypeLength","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","resX","resY","bbox","firstImage","usedImage","imageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","subfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","fallbackSize","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","previousIfd","ifd","hasNext","detectionString","heuristicAreaSize","metadataSize","fullString","headerData","BOM","magicNumber","MultiGeoTIFF","mainFile","overviewFiles","requests","visited","relativeIndex","imageFile","ifds","fromUrl","fromBlob","fromUrls","mainUrl","overviewUrls","isMask","readRGB","preference","interpretation","interpretations","geotiffGlobals.photometricInterpretations","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","getBoundingBox","getOrigin","getResolutions","getCachedProjection","unitsFromCode","getImagesForTIFF","tiff","getImagesForSource","tiffFromBlob","tiffFromUrls","tiffFromUrl","assertEqual","expected","got","tolerance","rejector","getMinForDataType","getMaxForDataType","GeoTIFFSource","numSources","logError","firstSource","commonRenderTileSizes","commonSourceTileSizes","nodataValues","minZoom","sourceCount","sourceIndex","images","masks","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","wantedSamples","level","imageResolutions","sourceTileSize","aspectRatio","resolutionFactor","scaledSourceResolutions","sourceImagery","bands","sourceInfo","pixelBounds","bandNumber","readOptions","maskIndex","mask","sourceSamples","normalize","addAlpha","dataLength","pixelIndex","transparent","gain","bias","stats","sourceValue","nodata","bandIndex","nodataIsNaN","LayerProperty","BaseLayer","properties","managed","zIndex","states","background","minResolution","opacity","visible","zindex","RenderEventType","ViewHint","ViewProperty","createExtent","onlyCenter","smooth","isMoving","centerShift","viewWidth","viewHeight","shiftX","shiftY","none","getViewportClampedResolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","getSmoothClampedResolution","result","createSnapToResolutions","cappedMaxRes","capped","createSnapToPower","power","minZoomLevel","cappedZoomLevel","zoomLevel","newResolution","createMinMaxResolution","createSnapToN","theta","createSnapToZero","tmp_","reset","set","multiply","transform1","transform2","a1","b1","d1","e1","f1","a2","b2","d2","e2","f2","apply","cos","sin","translate","compose","dx1","dy1","sx","sy","dx2","dy2","makeInverse","det","determinant","matrixPrecision","toString","transform2D","destinationStride","anchor","anchorX","anchorY","tmpTransform","createTransform","Geometry","revision","squaredTolerance","clone","closestPoint","minSquaredDistance","coord","inCoordinates","outCoordinates","pixelExtent","projectedExtent","composeTransform","SimpleGeometry","simplifiedGeometry","layout","getStrideForLayout","nesting","getLayoutForStride","assignClosest","offset1","offset2","maxSquaredDelta","squaredDelta","squaredDx","arrayMaxSquaredDelta","assignClosestPoint","maxDelta","isRing","tmpPoint","assignClosestArrayPoint","deflateCoordinate","deflateCoordinates","deflateCoordinatesArray","coordinatess","douglasPeucker","simplifiedFlatCoordinates","simplifiedOffset","markers","stack","last","maxSquaredDistance","snap","quantize","quantizeArray","simplifiedEnds","inflateCoordinates","inflateCoordinatesArray","linearRing","twiceArea","linearRings","LinearRing","linearRingArea","Point","getInteriorPointOfArray","flatCenters","flatCentersOffset","intersections","rr","pointX","maxSegmentLength","segmentLength","linearRingIsClockwise","edge","linearRingsAreOriented","isClockwise","orientLinearRings","reverseCoordinates","Polygon","polygon","linearRingsArea","flatCenter","fromExtent","DEFAULT_MIN_ZOOM","View","resolutionConstraintInfo","createResolutionConstraint","centerConstraint","createCenterConstraint","resolutionConstraint","rotationConstraint","createRotationConstraint","padding","oldPadding","newPadding","offsetX","offsetY","newOptions","var_args","animationCount","animationCallback","series","animation","isNoopAnimation","now","more","seriesComplete","elapsed","fraction","progress","constrainedResolution","constrainedRotation","currentCenter","rotateCoordinate","addCoordinate","currentResolution","w","hints","enabled","logPower","reducedSize","calculateCenterOn","nearest","baseLevel","geometryOrExtent","geometry","polygonFromExtent","coords","minRotX","minRotY","maxRotX","maxRotY","rotX","rotY","rotatedExtent","centerRot","centerX","centerY","position","shiftedCenter","deltaCoordinates","newRotation","hint","doNotCancelAnims","forceMoving","newCenter","duration","resolutionDirection","targetZoom","targetRes","returnValue","centerNone","projExtent","constrainOnlyCenter","defaultMaxResolution","defaultMinResolution","constrainRotation","rotationNone","coordinatesEqual","Layer","baseOptions","pixel","map","layerState","layerExtent","inView","getAttributions","layerRenderer","layerStatesArray","arrayLayerState","viewState","TileProperty","BaseTileLayer","preload","useInterimTilesOnError","ReprojTile","getTileFunction","ImageState","ImageWrapper","stateOrLoader","requestResolution","listenImage","loadHandler","errorHandler","img","listening","decoding","loaded","listenerKeys","ImageTile","crossOrigin","tileLoadFunction","element","getBlankImage","BaseTileRepresentation","helper","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","STREAM_DRAW","STATIC_DRAW","DYNAMIC_DRAW","UNSIGNED_BYTE","UNSIGNED_SHORT","UNSIGNED_INT","FLOAT","CONTEXT_IDS","getContext","attributes","BufferUsage","WebGLArrayBuffer","usage","getArrayClassForType","ArrayType","bindAndConfigure","gl","texture","resampleFilter","uploadImageTexture","uploadDataTexture","textureType","canInterpolate","unpackAlignment","oldUnpackAlignment","pixelContext","createPixelContext","TileTexture","textureCount","textureDataArrays","textureIndex","dataValue","textureData","textureBandIndex","renderCol","renderRow","renderWidth","renderHeight","sourceWidth","sourceHeight","sourceWidthWithoutGutter","sourceHeightWithoutGutter","sourceCol","sourceRow","sourceSize","maxStaleKeys","LayerRenderer","layer","hitTolerance","matches","imageState","RenderEvent","inversePixelTransform","ContextEventType","DEFAULT_VERTEX_SHADER","DEFAULT_FRAGMENT_SHADER","WebGLPostProcessingPass","vertexShader","fragmentShader","verticesArray","internalFormat","border","nextPass","preCompose","postCompose","canvasId","textureSlot","uniform","fromTransform","mat4","DefaultUniform","AttributeType","canvasCache","getSharedCanvasCacheKey","uniqueCanvasCacheKeyCount","getUniqueCanvasCacheKey","getOrCreateContext","cacheItem","WebGLHelper","uniforms","canvasCacheKey","bufferKey","bufferCache","webGlBuffer","buf","disableAlphaBlend","enableDepth","frameBuffer","slot","uniformName","renderTarget","elementType","elementSize","numItems","offsetInBytes","loc","imageReady","program","shader","fragmentShaderSource","vertexShaderSource","programUid","attribName","computeAttributesStride","attr","getByteSizeFromType","filter","WebGLLayerRenderer","incrementGroup","groupNumber","className","renderer","layerClassName","Uniforms","empty","depthForZ","newTileRepresentationLookup","lookupHasTile","tileRepresentationLookup","addTileRepresentationToLookup","tileRepresentation","representationsByZ","getRenderExtent","gridExtent","getCacheKey","getTileCoordKey","WebGLBaseTileLayerRenderer","tileLayer","createMat4","createTileCoord","initialZ","tileSource","tileSourceKey","wantedTiles","tileRepresentationCache","minZ","tileResolution","cacheKey","tileQueueKey","tilesWithAlpha","tileTransform","renderExtent","tileOrigin","tileExtent","depth","alpha","tileZ","alphaLookup","tileWidthWithGutter","tileHeightWithGutter","centerI","centerJ","tileScale","tileCenterI","tileCenterJ","resetTransform","scaleTransform","rotateTransform","translateTransform","targetZ","nextExtent","blend","parentZ","zs","postRenderFunction","altZ","covered","BaseUniforms","Attributes","attributeDescriptions","WebGLTileLayerRenderer","paletteTexture","tileTexture","paletteIndex","mat4FromTransform","gutterExtent","tileTextureCache","col","row","rgb","xyz","_xyz","white","luv","arg","_u","_v","u","v","xn","yn","zn","un","vn","yr","hr","names","baseHues","parse","cstr","parts","space","base","isShort","dims","_b","hsl","t1","t2","t3","rgba","color","parsed","NO_COLOR","MAX_CACHE_SIZE","fromString","parseRgba","asArray","numTypes","BooleanType","NumberType","StringType","ColorType","NumberArrayType","SizeType","AnyType","typeNames","namedTypes","isSpecific","typeName","namedType","includesType","broad","specific","isType","LiteralExpression","CallExpression","operator","newParsingContext","encoded","expectedType","colorFromString","parseCallExpression","Ops","parsers","createCallExpressionParser","hasArgsCount","withGetArgs","withVarArgs","usesFeatureId","withNoArgs","withArgsOfType","usesGeometryType","withArgsOfReturnType","hasEvenArgs","withMatchArgs","withInterpolateArgs","hasOddArgs","withCaseArgs","withInArgs","withPaletteArgs","returnType","argsCount","operation","minArgs","maxArgs","argCount","plural","range","expression","argType","inputType","fallback","interpolationType","interpolation","stop","condition","haystack","needleType","colors","parsedColors","validators","parser","computeGeometryType","PaletteTexture","computeOperatorFunctionName","numberToGlsl","arrayToGlsl","colorToGlsl","sizeToGlsl","stringToFloatMap","stringToFloatCounter","getStringNumberEquivalent","stringToGlsl","uniformNameForVariable","variableName","newCompilationContext","GET_BAND_VALUE_FUNC","PALETTE_TEXTURE_ARRAY","buildExpression","parsingContext","compilationContext","compile","createCompiler","compilers","propName","feature","varName","compiledArgs","firstValue","secondValue","exponent","stop1","output1","stop2","output2","needle","funcName","tests","band","xOffset","yOffset","ifBlocks","colorIndex","textureName","numColors","palette","parsedValue","paletteName","compiledIndex","compiler","expressionToGlsl","parseStyle","style","pipeline","contrast","exposure","saturation","gamma","brightness","numVariables","variable","uniformDeclarations","functionDefintions","WebGLTileLayer","parsedStyle","ready","sourceState","onChange","altSources","variables","TileLayer","handlerColor","legend","scala","radio","color1","resultArray","value1","getLayerStyle","bandsNumber","value2","n1","colorGradient","mergeObjects","obj1","obj2","mergedObj","prop","getWindSpeedAndDirection","speed","dir","parseXML","xmlString","itemElements","parsedData","cme_GeoTIFFSource","xmlDataStr","datas","list","minValue","maxValue","metadata_","normalize_","nodataValues_","addAlpha_","extent_","code_","cme_cogtifLayer2","parfams","that","sourceObj","viewConfig","metas","unit","newStyle","_style","worldNumber","mixLng","maxLng","sourceOpitions","newKey","sourceCollection","ZIndexContext","__publicField","instructionsAtIndex","instructionAtIndex","CanvasLayerRenderer","backgroundColor","container","topLeft","topRight","bottomRight","bottomLeft","inverted","canvasTransform","toTransformString","fromResolutionLike","ReprojImage","getImageFunction","sourceImage","sourcePixelRatio","ImageSourceEventType","ImageSourceEvent","ImageSource","idx","requestExtent","getRequestExtent","imageResolution","marginWidth","requestWidth","marginHeight","requestHeight","ImageCanvas","ImageCanvasSource","canvasElement","BaseImageLayer","CanvasImageLayerRenderer","imageLayer","viewResolution","imageSource","renderedExtent","imageExtent","imageMapWidth","imageMapHeight","imageResolutionX","imageResolutionY","imagePixelRatio","viewCenter","scaleX","scaleY","clipped","intersectsExtent","dw","dh","ImageLayer","ImageLayer$1","getCanvasExtent","xmin","ymin","newExtent","mergeObject","object1","object2","isInExtent","p","getGridPoints","distance","outExtent","xyList","xMin","yMin","xMax","yMax","gridNumberSource","unitList","inRange","distanceArrow","fixedPixel","showTextRange","precision","_precision","rawResolution","_bandCount","textSymbol","mapProject","projCode","offsetNumber","_scale","drawNum","xPixel","yPixel","cme_gridValueLayer","tempStyle","tempObject","styleobject","_sfc_main","defineComponent","mapRef","layerRef","CogTifInfo","addLayer","config","meta","addTextLayer","lyr","getData","configUnit","removeLayer","GridRender","Vue"],"mappings":"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EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA;AAAA,EAGR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA;AAAA,EAGR,KAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA,EACR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AACV,GAEaC,KAAY,CAAA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","x_google_ignoreList":[51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,78,79,80,81,127,128,129,130,131,132,133,134]}