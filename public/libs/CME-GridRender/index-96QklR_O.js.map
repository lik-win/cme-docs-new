{"version":3,"file":"index-96QklR_O.js","sources":["../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Disposable.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/events/Event.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/array.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/functions.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/obj.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/events/Target.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/events/EventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/TileState.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/util.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/easing.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Tile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/has.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/dom.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/DataTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/common.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/extent/Relationship.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/extent.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/Units.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/Projection.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/epsg3857.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/epsg4326.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/projections.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj/transforms.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/math.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/coordinate.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/sphere.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/console.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/proj.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/Triangulation.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/events.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/DataTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/asserts.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/structs/LRUCache.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/tilecoord.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/TileCache.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/TileEventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ObjectEventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Observable.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Object.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/Source.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/TileRange.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/tilegrid/common.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/segments.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/contains.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/intersectsextent.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/size.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/tilegrid/TileGrid.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/tilegrid.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/Tile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/DataTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/@petamoriken/float16/src/_util/primordials.mjs","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/@petamoriken/float16/src/_util/converter.mjs","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/@petamoriken/float16/src/DataView.mjs","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/get-attribute.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/index-of-match.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/index-of-match-end.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/count-substring.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/find-tag-by-name.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/xml-utils/find-tags-by-name.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/globals.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/rgb.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/compression/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/resample.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/geotiffimage.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/dataview64.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/dataslice.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/pool.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/httputils.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/basesource.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/quick-lru/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/utils.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/blockedsource.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/client/base.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/client/fetch.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/client/xhr.js","../../__vite-browser-external","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/client/http.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/remote.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/source/filereader.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/geotiff/dist-module/geotiff.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/GeoTIFF.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/Property.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/Base.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/render/EventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ViewHint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ViewProperty.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/centerconstraint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/resolutionconstraint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/rotationconstraint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/transform.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/transform.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/Geometry.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/SimpleGeometry.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/closest.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/deflate.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/simplify.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/inflate.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/area.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/LinearRing.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/Point.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/interiorpoint.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/reverse.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/flat/orient.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/geom/Polygon.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/View.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/Layer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/TileProperty.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/BaseTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/Tile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ImageState.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/Image.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ImageTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/BaseTileRepresentation.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/Buffer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/TileTexture.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/Layer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/render/Event.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/ContextEventType.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/PostProcessingPass.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/vec/mat4.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/Helper.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/webgl/Layer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/webgl/TileLayerBase.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/webgl/TileLayer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/rgb.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/xyz.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/luv.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/lchuv.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-name/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-parse/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-space/hsl.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/node_modules/color-rgba/index.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/color.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/expr/expression.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/PaletteTexture.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/expr/gpu.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/webgl/styleparser.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/WebGLTile.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/common/commonLayerUnit.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/source/GeoTIFF.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/cme_cogtifLayer/cme_cogtifLayer2.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/render/canvas/ZIndexContext.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/canvas/Layer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/resolution.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/reproj/Image.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/common.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/Image.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/ImageCanvas.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/source/ImageCanvas.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/BaseImage.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/renderer/canvas/ImageLayer.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/layer/Image.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/cme_gridArrowLayer/gridHelper.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/cme_gridValueLayer/gridNumberSource.js","../../../cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore/layer/cme_gridValueLayer/cme_gridValueLayer.js","../../src/components/cme-application/GridRender/index.vue","../../src/components/cme-application/GridRender/index.js"],"sourcesContent":["/**\r\n * @module CME2D/Disposable\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Objects that need to clean up after themselves.\r\n */\r\nclass Disposable {\r\n  constructor() {\r\n    /**\r\n     * The object has already been disposed.\r\n     * @type {boolean}\r\n     * @protected\r\n     */\r\n    this.disposed = false;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   */\r\n  dispose() {\r\n    if (!this.disposed) {\r\n      this.disposed = true;\r\n      this.disposeInternal();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extension point for disposable objects.\r\n   * @protected\r\n   */\r\n  disposeInternal() {}\r\n}\r\n\r\nexport default Disposable;\r\n","/**\r\n * @module CME2D/events/Event\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Stripped down implementation of the W3C DOM Level 2 Event interface.\r\n * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.\r\n *\r\n * This implementation only provides `type` and `target` properties, and\r\n * `stopPropagation` and `preventDefault` methods. It is meant as base class\r\n * for higher level events defined in the library, and works with\r\n * {@link module:ol/events/Target~Target}.\r\n */\r\nclass BaseEvent {\r\n  /**\r\n   * @param {string} type Type.\r\n   */\r\n  constructor(type) {\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.propagationStopped;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.defaultPrevented;\r\n\r\n    /**\r\n     * The event type.\r\n     * @type {string}\r\n     * @api\r\n     */\r\n    this.type = type;\r\n\r\n    /**\r\n     * The event target.\r\n     * @type {Object}\r\n     * @api\r\n     */\r\n    this.target = null;\r\n  }\r\n\r\n  /**\r\n   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events\r\n   * will be fired.\r\n   * @api\r\n   */\r\n  preventDefault() {\r\n    this.defaultPrevented = true;\r\n  }\r\n\r\n  /**\r\n   * Stop event propagation.\r\n   * @api\r\n   */\r\n  stopPropagation() {\r\n    this.propagationStopped = true;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Event|import(\"./Event.js\").default} evt Event\r\n */\r\nexport function stopPropagation(evt) {\r\n  evt.stopPropagation();\r\n}\r\n\r\n/**\r\n * @param {Event|import(\"./Event.js\").default} evt Event\r\n */\r\nexport function preventDefault(evt) {\r\n  evt.preventDefault();\r\n}\r\n\r\nexport default BaseEvent;\r\n","/**\r\n * @module CME2D/array\r\n */\r\n\r\n/**\r\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\r\n * https://github.com/darkskyapp/binary-search\r\n *\r\n * @param {Array<*>} haystack Items to search through.\r\n * @param {*} needle The item to look for.\r\n * @param {Function} [comparator] Comparator function.\r\n * @return {number} The index of the item if found, -1 if not.\r\n */\r\nexport function binarySearch(haystack, needle, comparator) {\r\n  let mid, cmp;\r\n  comparator = comparator || ascending;\r\n  let low = 0;\r\n  let high = haystack.length;\r\n  let found = false;\r\n\r\n  while (low < high) {\r\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\r\n     * to double (which gives the wrong results). */\r\n    mid = low + ((high - low) >> 1);\r\n    cmp = +comparator(haystack[mid], needle);\r\n\r\n    if (cmp < 0.0) {\r\n      /* Too low. */\r\n      low = mid + 1;\r\n    } else {\r\n      /* Key found or too high */\r\n      high = mid;\r\n      found = !cmp;\r\n    }\r\n  }\r\n\r\n  /* Key not found. */\r\n  return found ? low : ~low;\r\n}\r\n\r\n/**\r\n * Compare function sorting arrays in ascending order.  Safe to use for numeric values.\r\n * @param {*} a The first object to be compared.\r\n * @param {*} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is less than, equal to, or greater than the second.\r\n */\r\nexport function ascending(a, b) {\r\n  return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n\r\n/**\r\n * Compare function sorting arrays in descending order.  Safe to use for numeric values.\r\n * @param {*} a The first object to be compared.\r\n * @param {*} b The second object to be compared.\r\n * @return {number} A negative number, zero, or a positive number as the first\r\n *     argument is greater than, equal to, or less than the second.\r\n */\r\nexport function descending(a, b) {\r\n  return a < b ? 1 : a > b ? -1 : 0;\r\n}\r\n\r\n/**\r\n * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function\r\n * of this type to determine which nearest resolution to use.\r\n *\r\n * This function takes a `{number}` representing a value between two array entries,\r\n * a `{number}` representing the value of the nearest higher entry and\r\n * a `{number}` representing the value of the nearest lower entry\r\n * as arguments and returns a `{number}`. If a negative number or zero is returned\r\n * the lower value will be used, if a positive number is returned the higher value\r\n * will be used.\r\n * @typedef {function(number, number, number): number} NearestDirectionFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @param {Array<number>} arr Array in descending order.\r\n * @param {number} target Target.\r\n * @param {number|NearestDirectionFunction} direction\r\n *    0 means return the nearest,\r\n *    > 0 means return the largest nearest,\r\n *    < 0 means return the smallest nearest.\r\n * @return {number} Index.\r\n */\r\nexport function linearFindNearest(arr, target, direction) {\r\n  if (arr[0] <= target) {\r\n    return 0;\r\n  }\r\n\r\n  const n = arr.length;\r\n  if (target <= arr[n - 1]) {\r\n    return n - 1;\r\n  }\r\n\r\n  if (typeof direction === 'function') {\r\n    for (let i = 1; i < n; ++i) {\r\n      const candidate = arr[i];\r\n      if (candidate === target) {\r\n        return i;\r\n      }\r\n      if (candidate < target) {\r\n        if (direction(target, arr[i - 1], candidate) > 0) {\r\n          return i - 1;\r\n        }\r\n        return i;\r\n      }\r\n    }\r\n    return n - 1;\r\n  }\r\n\r\n  if (direction > 0) {\r\n    for (let i = 1; i < n; ++i) {\r\n      if (arr[i] < target) {\r\n        return i - 1;\r\n      }\r\n    }\r\n    return n - 1;\r\n  }\r\n\r\n  if (direction < 0) {\r\n    for (let i = 1; i < n; ++i) {\r\n      if (arr[i] <= target) {\r\n        return i;\r\n      }\r\n    }\r\n    return n - 1;\r\n  }\r\n\r\n  for (let i = 1; i < n; ++i) {\r\n    if (arr[i] == target) {\r\n      return i;\r\n    }\r\n    if (arr[i] < target) {\r\n      if (arr[i - 1] - target < target - arr[i]) {\r\n        return i - 1;\r\n      }\r\n      return i;\r\n    }\r\n  }\r\n  return n - 1;\r\n}\r\n\r\n/**\r\n * @param {Array<*>} arr Array.\r\n * @param {number} begin Begin index.\r\n * @param {number} end End index.\r\n */\r\nexport function reverseSubArray(arr, begin, end) {\r\n  while (begin < end) {\r\n    const tmp = arr[begin];\r\n    arr[begin] = arr[end];\r\n    arr[end] = tmp;\r\n    ++begin;\r\n    --end;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<VALUE>} arr The array to modify.\r\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\r\n * @template VALUE\r\n */\r\nexport function extend(arr, data) {\r\n  const extension = Array.isArray(data) ? data : [data];\r\n  const length = extension.length;\r\n  for (let i = 0; i < length; i++) {\r\n    arr[arr.length] = extension[i];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<VALUE>} arr The array to modify.\r\n * @param {VALUE} obj The element to remove.\r\n * @template VALUE\r\n * @return {boolean} If the element was removed.\r\n */\r\nexport function remove(arr, obj) {\r\n  const i = arr.indexOf(obj);\r\n  const found = i > -1;\r\n  if (found) {\r\n    arr.splice(i, 1);\r\n  }\r\n  return found;\r\n}\r\n\r\n/**\r\n * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.\r\n * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.\r\n * @return {boolean} Whether the two arrays are equal.\r\n */\r\nexport function equals(arr1, arr2) {\r\n  const len1 = arr1.length;\r\n  if (len1 !== arr2.length) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < len1; i++) {\r\n    if (arr1[i] !== arr2[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Sort the passed array such that the relative order of equal elements is preserved.\r\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\r\n * @param {Array<*>} arr The array to sort (modifies original).\r\n * @param {!function(*, *): number} compareFnc Comparison function.\r\n * @api\r\n */\r\nexport function stableSort(arr, compareFnc) {\r\n  const length = arr.length;\r\n  const tmp = Array(arr.length);\r\n  let i;\r\n  for (i = 0; i < length; i++) {\r\n    tmp[i] = {index: i, value: arr[i]};\r\n  }\r\n  tmp.sort(function (a, b) {\r\n    return compareFnc(a.value, b.value) || a.index - b.index;\r\n  });\r\n  for (i = 0; i < arr.length; i++) {\r\n    arr[i] = tmp[i].value;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array<*>} arr The array to test.\r\n * @param {Function} [func] Comparison function.\r\n * @param {boolean} [strict] Strictly sorted (default false).\r\n * @return {boolean} Return index.\r\n */\r\nexport function isSorted(arr, func, strict) {\r\n  const compare = func || ascending;\r\n  return arr.every(function (currentVal, index) {\r\n    if (index === 0) {\r\n      return true;\r\n    }\r\n    const res = compare(arr[index - 1], currentVal);\r\n    return !(res > 0 || (strict && res === 0));\r\n  });\r\n}\r\n","/**\r\n * @module CME2D/functions\r\n */\r\n\r\nimport {equals as arrayEquals} from './array.js';\r\n\r\n/**\r\n * Always returns true.\r\n * @return {boolean} true.\r\n */\r\nexport function TRUE() {\r\n  return true;\r\n}\r\n\r\n/**\r\n * Always returns false.\r\n * @return {boolean} false.\r\n */\r\nexport function FALSE() {\r\n  return false;\r\n}\r\n\r\n/**\r\n * A reusable function, used e.g. as a default for callbacks.\r\n *\r\n * @return {void} Nothing.\r\n */\r\nexport function VOID() {}\r\n\r\n/**\r\n * Wrap a function in another function that remembers the last return.  If the\r\n * returned function is called twice in a row with the same arguments and the same\r\n * this object, it will return the value from the first call in the second call.\r\n *\r\n * @param {function(...any): ReturnType} fn The function to memoize.\r\n * @return {function(...any): ReturnType} The memoized function.\r\n * @template ReturnType\r\n */\r\nexport function memoizeOne(fn) {\r\n  /** @type {ReturnType} */\r\n  let lastResult;\r\n\r\n  /** @type {Array<any>|undefined} */\r\n  let lastArgs;\r\n\r\n  let lastThis;\r\n\r\n  /**\r\n   * @this {*} Only need to know if `this` changed, don't care what type\r\n   * @return {ReturnType} Memoized value\r\n   */\r\n  return function () {\r\n    const nextArgs = Array.prototype.slice.call(arguments);\r\n    if (!lastArgs || this !== lastThis || !arrayEquals(nextArgs, lastArgs)) {\r\n      lastThis = this;\r\n      lastArgs = nextArgs;\r\n      lastResult = fn.apply(this, arguments);\r\n    }\r\n    return lastResult;\r\n  };\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.\r\n * @return {Promise<T>} A promise for the value.\r\n */\r\nexport function toPromise(getter) {\r\n  function promiseGetter() {\r\n    let value;\r\n    try {\r\n      value = getter();\r\n    } catch (err) {\r\n      return Promise.reject(err);\r\n    }\r\n    if (value instanceof Promise) {\r\n      return value;\r\n    }\r\n    return Promise.resolve(value);\r\n  }\r\n  return promiseGetter();\r\n}\r\n","/**\r\n * @module CME2D/obj\r\n */\r\n\r\n/**\r\n * Removes all properties from an object.\r\n * @param {Object<string, unknown>} object The object to clear.\r\n */\r\nexport function clear(object) {\r\n  for (const property in object) {\r\n    delete object[property];\r\n  }\r\n}\r\n\r\n/**\r\n * Determine if an object has any properties.\r\n * @param {Object} object The object to check.\r\n * @return {boolean} The object is empty.\r\n */\r\nexport function isEmpty(object) {\r\n  let property;\r\n  for (property in object) {\r\n    return false;\r\n  }\r\n  return !property;\r\n}\r\n","/**\r\n * @module CME2D/events/Target\r\n */\r\nimport Disposable from '../Disposable.js';\r\nimport Event from './Event.js';\r\nimport {VOID} from '../functions.js';\r\nimport {clear} from '../obj.js';\r\n\r\n/**\r\n * @typedef {EventTarget|Target} EventTargetLike\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\r\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\r\n *\r\n * There are two important simplifications compared to the specification:\r\n *\r\n * 1. The handling of `useCapture` in `addEventListener` and\r\n *    `removeEventListener`. There is no real capture model.\r\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\r\n *    There is no event target hierarchy. When a listener calls\r\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\r\n *    more listeners after this one will be called. Same as when the listener\r\n *    returns false.\r\n */\r\nclass Target extends Disposable {\r\n  /**\r\n   * @param {*} [target] Default event target for dispatched events.\r\n   */\r\n  constructor(target) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {*}\r\n     */\r\n    this.eventTarget_ = target;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, number>|null}\r\n     */\r\n    this.pendingRemovals_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, number>|null}\r\n     */\r\n    this.dispatching_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>|null}\r\n     */\r\n    this.listeners_ = null;\r\n  }\r\n\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../events.js\").Listener} listener Listener.\r\n   */\r\n  addEventListener(type, listener) {\r\n    if (!type || !listener) {\r\n      return;\r\n    }\r\n    const listeners = this.listeners_ || (this.listeners_ = {});\r\n    const listenersForType = listeners[type] || (listeners[type] = []);\r\n    if (!listenersForType.includes(listener)) {\r\n      listenersForType.push(listener);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispatches an event and calls all listeners listening for events\r\n   * of this type. The event parameter can either be a string or an\r\n   * Object with a `type` property.\r\n   *\r\n   * @param {import(\"./Event.js\").default|string} event Event object.\r\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\r\n   *     event object or if any of the listeners returned false.\r\n   * @api\r\n   */\r\n  dispatchEvent(event) {\r\n    const isString = typeof event === 'string';\r\n    const type = isString ? event : event.type;\r\n    const listeners = this.listeners_ && this.listeners_[type];\r\n    if (!listeners) {\r\n      return;\r\n    }\r\n\r\n    const evt = isString ? new Event(event) : /** @type {Event} */ (event);\r\n    if (!evt.target) {\r\n      evt.target = this.eventTarget_ || this;\r\n    }\r\n    const dispatching = this.dispatching_ || (this.dispatching_ = {});\r\n    const pendingRemovals =\r\n      this.pendingRemovals_ || (this.pendingRemovals_ = {});\r\n    if (!(type in dispatching)) {\r\n      dispatching[type] = 0;\r\n      pendingRemovals[type] = 0;\r\n    }\r\n    ++dispatching[type];\r\n    let propagate;\r\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\r\n      if ('handleEvent' in listeners[i]) {\r\n        propagate = /** @type {import(\"../events.js\").ListenerObject} */ (\r\n          listeners[i]\r\n        ).handleEvent(evt);\r\n      } else {\r\n        propagate = /** @type {import(\"../events.js\").ListenerFunction} */ (\r\n          listeners[i]\r\n        ).call(this, evt);\r\n      }\r\n      if (propagate === false || evt.propagationStopped) {\r\n        propagate = false;\r\n        break;\r\n      }\r\n    }\r\n    if (--dispatching[type] === 0) {\r\n      let pr = pendingRemovals[type];\r\n      delete pendingRemovals[type];\r\n      while (pr--) {\r\n        this.removeEventListener(type, VOID);\r\n      }\r\n      delete dispatching[type];\r\n    }\r\n    return propagate;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    this.listeners_ && clear(this.listeners_);\r\n  }\r\n\r\n  /**\r\n   * Get the listeners for a specified event type. Listeners are returned in the\r\n   * order that they will be called in.\r\n   *\r\n   * @param {string} type Type.\r\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\r\n   */\r\n  getListeners(type) {\r\n    return (this.listeners_ && this.listeners_[type]) || undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {string} [type] Type. If not provided,\r\n   *     `true` will be returned if this event target has any listeners.\r\n   * @return {boolean} Has listeners.\r\n   */\r\n  hasListener(type) {\r\n    if (!this.listeners_) {\r\n      return false;\r\n    }\r\n    return type\r\n      ? type in this.listeners_\r\n      : Object.keys(this.listeners_).length > 0;\r\n  }\r\n\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../events.js\").Listener} listener Listener.\r\n   */\r\n  removeEventListener(type, listener) {\r\n    if (!this.listeners_) {\r\n      return;\r\n    }\r\n    const listeners = this.listeners_[type];\r\n    if (!listeners) {\r\n      return;\r\n    }\r\n    const index = listeners.indexOf(listener);\r\n    if (index !== -1) {\r\n      if (this.pendingRemovals_ && type in this.pendingRemovals_) {\r\n        // make listener a no-op, and remove later in #dispatchEvent()\r\n        listeners[index] = VOID;\r\n        ++this.pendingRemovals_[type];\r\n      } else {\r\n        listeners.splice(index, 1);\r\n        if (listeners.length === 0) {\r\n          delete this.listeners_[type];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Target;\r\n","/**\r\n * @module CME2D/events/EventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n * @const\r\n */\r\nexport default {\r\n  /**\r\n   * Generic change event. Triggered when the revision counter is increased.\r\n   * @event module:ol/events/Event~BaseEvent#change\r\n   * @api\r\n   */\r\n  CHANGE: 'change',\r\n\r\n  /**\r\n   * Generic error event. Triggered when an error occurs.\r\n   * @event module:ol/events/Event~BaseEvent#error\r\n   * @api\r\n   */\r\n  ERROR: 'error',\r\n\r\n  BLUR: 'blur',\r\n  CLEAR: 'clear',\r\n  CONTEXTMENU: 'contextmenu',\r\n  CLICK: 'click',\r\n  DBLCLICK: 'dblclick',\r\n  DRAGENTER: 'dragenter',\r\n  DRAGOVER: 'dragover',\r\n  DROP: 'drop',\r\n  FOCUS: 'focus',\r\n  KEYDOWN: 'keydown',\r\n  KEYPRESS: 'keypress',\r\n  LOAD: 'load',\r\n  RESIZE: 'resize',\r\n  TOUCHMOVE: 'touchmove',\r\n  WHEEL: 'wheel',\r\n};\r\n","/**\r\n * @module CME2D/TileState\r\n */\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nexport default {\r\n  IDLE: 0,\r\n  LOADING: 1,\r\n  LOADED: 2,\r\n  /**\r\n   * Indicates that tile loading failed\r\n   * @type {number}\r\n   */\r\n  ERROR: 3,\r\n  EMPTY: 4,\r\n};\r\n","/**\r\n * @module CME2D/util\r\n */\r\n\r\n/**\r\n * @return {never} Any return.\r\n */\r\nexport function abstract() {\r\n  throw new Error('Unimplemented abstract method.');\r\n}\r\n\r\n/**\r\n * Counter for getUid.\r\n * @type {number}\r\n * @private\r\n */\r\nlet uidCounter_ = 0;\r\n\r\n/**\r\n * Gets a unique ID for an object. This mutates the object so that further calls\r\n * with the same object as a parameter returns the same value. Unique IDs are generated\r\n * as a strictly increasing sequence. Adapted from goog.getUid.\r\n *\r\n * @param {Object} obj The object to get the unique ID for.\r\n * @return {string} The unique ID for the object.\r\n * @api\r\n */\r\nexport function getUid(obj) {\r\n  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\r\n}\r\n\r\n/**\r\n * OpenLayers version.\r\n * @type {string}\r\n */\r\nexport const VERSION = 'latest';\r\n","/**\r\n * @module CME2D/easing\r\n */\r\n\r\n/**\r\n * Start slow and speed up.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function easeIn(t) {\r\n  return Math.pow(t, 3);\r\n}\r\n\r\n/**\r\n * Start fast and slow down.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function easeOut(t) {\r\n  return 1 - easeIn(1 - t);\r\n}\r\n\r\n/**\r\n * Start slow, speed up, and then slow down again.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function inAndOut(t) {\r\n  return 3 * t * t - 2 * t * t * t;\r\n}\r\n\r\n/**\r\n * Maintain a constant speed over time.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function linear(t) {\r\n  return t;\r\n}\r\n\r\n/**\r\n * Start slow, speed up, and at the very end slow down again.  This has the\r\n * same general behavior as {@link module:ol/easing.inAndOut}, but the final\r\n * slowdown is delayed.\r\n * @param {number} t Input between 0 and 1.\r\n * @return {number} Output between 0 and 1.\r\n * @api\r\n */\r\nexport function upAndDown(t) {\r\n  if (t < 0.5) {\r\n    return inAndOut(2 * t);\r\n  }\r\n  return 1 - inAndOut(2 * (t - 0.5));\r\n}\r\n","/**\r\n * @module CME2D/Tile\r\n */\r\nimport EventTarget from './events/Target.js';\r\nimport EventType from './events/EventType.js';\r\nimport TileState from './TileState.js';\r\nimport {abstract} from './util.js';\r\nimport {easeIn} from './easing.js';\r\n\r\n/**\r\n * A function that takes a {@link module:ol/Tile~Tile} for the tile and a\r\n * `{string}` for the url as arguments. The default is\r\n * ```js\r\n * source.setTileLoadFunction(function(tile, src) {\r\n *   tile.getImage().src = src;\r\n * });\r\n * ```\r\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\r\n * error handling:\r\n *\r\n * ```js\r\n * import TileState from 'ol/TileState.js';\r\n *\r\n * source.setTileLoadFunction(function(tile, src) {\r\n *   const xhr = new XMLHttpRequest();\r\n *   xhr.responseType = 'blob';\r\n *   xhr.addEventListener('loadend', function (evt) {\r\n *     const data = this.response;\r\n *     if (data !== undefined) {\r\n *       tile.getImage().src = URL.createObjectURL(data);\r\n *     } else {\r\n *       tile.setState(TileState.ERROR);\r\n *     }\r\n *   });\r\n *   xhr.addEventListener('error', function () {\r\n *     tile.setState(TileState.ERROR);\r\n *   });\r\n *   xhr.open('GET', src);\r\n *   xhr.send();\r\n * });\r\n * ```\r\n *\r\n * @typedef {function(Tile, string): void} LoadFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\r\n * the url that provides a tile for a given tile coordinate.\r\n *\r\n * This function takes a {@link module:ol/tilecoord~TileCoord} for the tile\r\n * coordinate, a `{number}` representing the pixel ratio and a\r\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\r\n * and returns a `{string}` representing the tile URL, or undefined if no tile\r\n * should be requested for the passed tile coordinate.\r\n *\r\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\r\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @api\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for tiles.\r\n *\r\n * @abstract\r\n */\r\nclass Tile extends EventTarget {\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {Options} [options] Tile options.\r\n   */\r\n  constructor(tileCoord, state, options) {\r\n    super();\r\n\r\n    options = options ? options : {};\r\n\r\n    /**\r\n     * @type {import(\"./tilecoord.js\").TileCoord}\r\n     */\r\n    this.tileCoord = tileCoord;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./TileState.js\").default}\r\n     */\r\n    this.state = state;\r\n\r\n    /**\r\n     * A key assigned to the tile. This is used in conjunction with a source key\r\n     * to determine if a cached version of this tile may be used by the renderer.\r\n     * @type {string}\r\n     */\r\n    this.key = '';\r\n\r\n    /**\r\n     * The duration for the opacity transition.\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.transition_ =\r\n      options.transition === undefined ? 250 : options.transition;\r\n\r\n    /**\r\n     * Lookup of start times for rendering transitions.  If the start time is\r\n     * equal to -1, the transition is complete.\r\n     * @private\r\n     * @type {Object<string, number>}\r\n     */\r\n    this.transitionStarts_ = {};\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.interpolate = !!options.interpolate;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  changed() {\r\n    this.dispatchEvent(EventType.CHANGE);\r\n  }\r\n\r\n  /**\r\n   * Called by the tile cache when the tile is removed from the cache due to expiry\r\n   */\r\n  release() {\r\n    if (this.state === TileState.ERROR) {\r\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\r\n      this.setState(TileState.EMPTY);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {string} Key.\r\n   */\r\n  getKey() {\r\n    return this.key + '/' + this.tileCoord;\r\n  }\r\n\r\n  /**\r\n   * Get the tile coordinate for this tile.\r\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoord() {\r\n    return this.tileCoord;\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./TileState.js\").default} State.\r\n   */\r\n  getState() {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\r\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\r\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\r\n   * the tile queue and will block other requests.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @api\r\n   */\r\n  setState(state) {\r\n    if (this.state !== TileState.ERROR && this.state > state) {\r\n      throw new Error('Tile load sequence violation');\r\n    }\r\n    this.state = state;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load the image or retry if loading previously failed.\r\n   * Loading is taken care of by the tile queue, and calling this method is\r\n   * only needed for preloading or for reloading in case of an error.\r\n   * @abstract\r\n   * @api\r\n   */\r\n  load() {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Get the alpha value for rendering.\r\n   * @param {string} id An id for the renderer.\r\n   * @param {number} time The render frame time.\r\n   * @return {number} A number between 0 and 1.\r\n   */\r\n  getAlpha(id, time) {\r\n    if (!this.transition_) {\r\n      return 1;\r\n    }\r\n\r\n    let start = this.transitionStarts_[id];\r\n    if (!start) {\r\n      start = time;\r\n      this.transitionStarts_[id] = start;\r\n    } else if (start === -1) {\r\n      return 1;\r\n    }\r\n\r\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\r\n    if (delta >= this.transition_) {\r\n      return 1;\r\n    }\r\n    return easeIn(delta / this.transition_);\r\n  }\r\n\r\n  /**\r\n   * Determine if a tile is in an alpha transition.  A tile is considered in\r\n   * transition if tile.getAlpha() has not yet been called or has been called\r\n   * and returned 1.\r\n   * @param {string} id An id for the renderer.\r\n   * @return {boolean} The tile is in transition.\r\n   */\r\n  inTransition(id) {\r\n    if (!this.transition_) {\r\n      return false;\r\n    }\r\n    return this.transitionStarts_[id] !== -1;\r\n  }\r\n\r\n  /**\r\n   * Mark a transition as complete.\r\n   * @param {string} id An id for the renderer.\r\n   */\r\n  endTransition(id) {\r\n    if (this.transition_) {\r\n      this.transitionStarts_[id] = -1;\r\n    }\r\n  }\r\n}\r\n\r\nexport default Tile;\r\n","/**\r\n * @module CME2D/has\r\n */\r\n\r\nconst ua =\r\n  typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'\r\n    ? navigator.userAgent.toLowerCase()\r\n    : '';\r\n\r\n/**\r\n * User agent string says we are dealing with Firefox as browser.\r\n * @type {boolean}\r\n */\r\nexport const FIREFOX = ua.includes('firefox');\r\n\r\n/**\r\n * User agent string says we are dealing with Safari as browser.\r\n * @type {boolean}\r\n */\r\nexport const SAFARI = ua.includes('safari') && !ua.includes('chrom');\r\n\r\n/**\r\n * https://bugs.webkit.org/show_bug.cgi?id=237906\r\n * @type {boolean}\r\n */\r\nexport const SAFARI_BUG_237906 =\r\n  SAFARI &&\r\n  (ua.includes('version/15.4') ||\r\n    /cpu (os|iphone os) 15_4 like mac os x/.test(ua));\r\n\r\n/**\r\n * User agent string says we are dealing with a WebKit engine.\r\n * @type {boolean}\r\n */\r\nexport const WEBKIT = ua.includes('webkit') && !ua.includes('edge');\r\n\r\n/**\r\n * User agent string says we are dealing with a Mac as platform.\r\n * @type {boolean}\r\n */\r\nexport const MAC = ua.includes('macintosh');\r\n\r\n/**\r\n * The ratio between physical pixels and device-independent pixels\r\n * (dips) on the device (`window.devicePixelRatio`).\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const DEVICE_PIXEL_RATIO =\r\n  typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;\r\n\r\n/**\r\n * The execution context is a worker with OffscreenCanvas available.\r\n * @const\r\n * @type {boolean}\r\n */\r\nexport const WORKER_OFFSCREEN_CANVAS =\r\n  typeof WorkerGlobalScope !== 'undefined' &&\r\n  typeof OffscreenCanvas !== 'undefined' &&\r\n  self instanceof WorkerGlobalScope; //eslint-disable-line\r\n\r\n/**\r\n * Image.prototype.decode() is supported.\r\n * @type {boolean}\r\n */\r\nexport const IMAGE_DECODE =\r\n  typeof Image !== 'undefined' && Image.prototype.decode;\r\n\r\n/**\r\n * createImageBitmap() is supported.\r\n * @type {boolean}\r\n */\r\nexport const CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';\r\n\r\n/**\r\n * @type {boolean}\r\n */\r\nexport const PASSIVE_EVENT_LISTENERS = (function () {\r\n  let passive = false;\r\n  try {\r\n    const options = Object.defineProperty({}, 'passive', {\r\n      get: function () {\r\n        passive = true;\r\n      },\r\n    });\r\n\r\n    // @ts-ignore Ignore invalid event type '_'\r\n    window.addEventListener('_', null, options);\r\n    // @ts-ignore Ignore invalid event type '_'\r\n    window.removeEventListener('_', null, options);\r\n  } catch (error) {\r\n    // passive not supported\r\n  }\r\n  return passive;\r\n})();\r\n","import {WORKER_OFFSCREEN_CANVAS} from './has.js';\r\n\r\n/**\r\n * @module CME2D/dom\r\n */\r\n\r\n//FIXME Move this function to the canvas module\r\n/**\r\n * Create an html canvas element and returns its 2d context.\r\n * @param {number} [width] Canvas width.\r\n * @param {number} [height] Canvas height.\r\n * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.\r\n * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings\r\n * @return {CanvasRenderingContext2D} The context.\r\n */\r\nexport function createCanvasContext2D(width, height, canvasPool, settings) {\r\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\r\n  let canvas;\r\n  if (canvasPool && canvasPool.length) {\r\n    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());\r\n  } else if (WORKER_OFFSCREEN_CANVAS) {\r\n    canvas = new OffscreenCanvas(width || 300, height || 300);\r\n  } else {\r\n    canvas = document.createElement('canvas');\r\n  }\r\n  if (width) {\r\n    canvas.width = width;\r\n  }\r\n  if (height) {\r\n    canvas.height = height;\r\n  }\r\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\r\n  return /** @type {CanvasRenderingContext2D} */ (\r\n    canvas.getContext('2d', settings)\r\n  );\r\n}\r\n\r\n/** @type {CanvasRenderingContext2D} */\r\nlet sharedCanvasContext;\r\n\r\n/**\r\n * @return {CanvasRenderingContext2D} Shared canvas context.\r\n */\r\nexport function getSharedCanvasContext2D() {\r\n  if (!sharedCanvasContext) {\r\n    sharedCanvasContext = createCanvasContext2D(1, 1);\r\n  }\r\n  return sharedCanvasContext;\r\n}\r\n\r\n/**\r\n * Releases canvas memory to avoid exceeding memory limits in Safari.\r\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\r\n * @param {CanvasRenderingContext2D} context Context.\r\n */\r\nexport function releaseCanvas(context) {\r\n  const canvas = context.canvas;\r\n  canvas.width = 1;\r\n  canvas.height = 1;\r\n  context.clearRect(0, 0, 1, 1);\r\n}\r\n\r\n/**\r\n * Get the current computed width for the given element including margin,\r\n * padding and border.\r\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\r\n * @param {!HTMLElement} element Element.\r\n * @return {number} The width.\r\n */\r\nexport function outerWidth(element) {\r\n  let width = element.offsetWidth;\r\n  const style = getComputedStyle(element);\r\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\r\n\r\n  return width;\r\n}\r\n\r\n/**\r\n * Get the current computed height for the given element including margin,\r\n * padding and border.\r\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\r\n * @param {!HTMLElement} element Element.\r\n * @return {number} The height.\r\n */\r\nexport function outerHeight(element) {\r\n  let height = element.offsetHeight;\r\n  const style = getComputedStyle(element);\r\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\r\n\r\n  return height;\r\n}\r\n\r\n/**\r\n * @param {Node} newNode Node to replace old node\r\n * @param {Node} oldNode The node to be replaced\r\n */\r\nexport function replaceNode(newNode, oldNode) {\r\n  const parent = oldNode.parentNode;\r\n  if (parent) {\r\n    parent.replaceChild(newNode, oldNode);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node} node The node to remove the children from.\r\n */\r\nexport function removeChildren(node) {\r\n  while (node.lastChild) {\r\n    node.lastChild.remove();\r\n  }\r\n}\r\n\r\n/**\r\n * Transform the children of a parent node so they match the\r\n * provided list of children.  This function aims to efficiently\r\n * remove, add, and reorder child nodes while maintaining a simple\r\n * implementation (it is not guaranteed to minimize DOM operations).\r\n * @param {Node} node The parent node whose children need reworking.\r\n * @param {Array<Node>} children The desired children.\r\n */\r\nexport function replaceChildren(node, children) {\r\n  const oldChildren = node.childNodes;\r\n\r\n  for (let i = 0; true; ++i) {\r\n    const oldChild = oldChildren[i];\r\n    const newChild = children[i];\r\n\r\n    // check if our work is done\r\n    if (!oldChild && !newChild) {\r\n      break;\r\n    }\r\n\r\n    // check if children match\r\n    if (oldChild === newChild) {\r\n      continue;\r\n    }\r\n\r\n    // check if a new child needs to be added\r\n    if (!oldChild) {\r\n      node.appendChild(newChild);\r\n      continue;\r\n    }\r\n\r\n    // check if an old child needs to be removed\r\n    if (!newChild) {\r\n      node.removeChild(oldChild);\r\n      --i;\r\n      continue;\r\n    }\r\n\r\n    // reorder\r\n    node.insertBefore(newChild, oldChild);\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/DataTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport TileState from './TileState.js';\r\nimport {createCanvasContext2D} from './dom.js';\r\n\r\n/**\r\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\r\n */\r\n\r\n/**\r\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\r\n */\r\n\r\n/**\r\n * Data that can be used with a DataTile.\r\n * @typedef {ArrayLike|ImageLike} Data\r\n */\r\n\r\n/**\r\n * @param {Data} data Tile data.\r\n * @return {ImageLike|null} The image-like data.\r\n */\r\nexport function asImageLike(data) {\r\n  return data instanceof Image ||\r\n    data instanceof HTMLCanvasElement ||\r\n    data instanceof HTMLVideoElement ||\r\n    data instanceof ImageBitmap\r\n    ? data\r\n    : null;\r\n}\r\n\r\n/**\r\n * @param {Data} data Tile data.\r\n * @return {ArrayLike|null} The array-like data.\r\n */\r\nexport function asArrayLike(data) {\r\n  return data instanceof Uint8Array ||\r\n    data instanceof Uint8ClampedArray ||\r\n    data instanceof Float32Array ||\r\n    data instanceof DataView\r\n    ? data\r\n    : null;\r\n}\r\n\r\n/**\r\n * This is set as the cancellation reason when a tile is disposed.\r\n */\r\nexport const disposedError = new Error('disposed');\r\n\r\n/**\r\n * @type {CanvasRenderingContext2D|null}\r\n */\r\nlet sharedContext = null;\r\n\r\n/**\r\n * @param {ImageLike} image The image.\r\n * @return {Uint8ClampedArray} The data.\r\n */\r\nexport function toArray(image) {\r\n  if (!sharedContext) {\r\n    sharedContext = createCanvasContext2D(\r\n      image.width,\r\n      image.height,\r\n      undefined,\r\n      {willReadFrequently: true},\r\n    );\r\n  }\r\n  const canvas = sharedContext.canvas;\r\n  const width = image.width;\r\n  if (canvas.width !== width) {\r\n    canvas.width = width;\r\n  }\r\n  const height = image.height;\r\n  if (canvas.height !== height) {\r\n    canvas.height = height;\r\n  }\r\n  sharedContext.clearRect(0, 0, width, height);\r\n  sharedContext.drawImage(image, 0, 0);\r\n  return sharedContext.getImageData(0, 0, width, height).data;\r\n}\r\n\r\n/**\r\n * @type {import('./size.js').Size}\r\n */\r\nconst defaultSize = [256, 256];\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\r\n * the promise should not resolve until the image is loaded.\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\r\n * @property {AbortController} [controller] An abort controller.\r\n * @api\r\n */\r\n\r\nclass DataTile extends Tile {\r\n  /**\r\n   * @param {Options} options Tile options.\r\n   */\r\n  constructor(options) {\r\n    const state = TileState.IDLE;\r\n\r\n    super(options.tileCoord, state, {\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n    });\r\n\r\n    /**\r\n     * @type {function(): Promise<Data>}\r\n     * @private\r\n     */\r\n    this.loader_ = options.loader;\r\n\r\n    /**\r\n     * @type {Data}\r\n     * @private\r\n     */\r\n    this.data_ = null;\r\n\r\n    /**\r\n     * @type {Error}\r\n     * @private\r\n     */\r\n    this.error_ = null;\r\n\r\n    /**\r\n     * @type {import('./size.js').Size|null}\r\n     * @private\r\n     */\r\n    this.size_ = options.size || null;\r\n\r\n    /**\r\n     * @type {AbortController|null}\r\n     * @private\r\n     */\r\n    this.controller_ = options.controller || null;\r\n  }\r\n\r\n  /**\r\n   * Get the tile size.\r\n   * @return {import('./size.js').Size} Tile size.\r\n   */\r\n  getSize() {\r\n    if (this.size_) {\r\n      return this.size_;\r\n    }\r\n    const imageData = asImageLike(this.data_);\r\n    if (imageData) {\r\n      return [imageData.width, imageData.height];\r\n    }\r\n    return defaultSize;\r\n  }\r\n\r\n  /**\r\n   * Get the data for the tile.\r\n   * @return {Data} Tile data.\r\n   * @api\r\n   */\r\n  getData() {\r\n    return this.data_;\r\n  }\r\n\r\n  /**\r\n   * Get any loading error.\r\n   * @return {Error} Loading error.\r\n   * @api\r\n   */\r\n  getError() {\r\n    return this.error_;\r\n  }\r\n\r\n  /**\r\n   * Load the tile data.\r\n   * @api\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\r\n      return;\r\n    }\r\n    this.state = TileState.LOADING;\r\n    this.changed();\r\n\r\n    const self = this;\r\n    this.loader_()\r\n      .then(function (data) {\r\n        self.data_ = data;\r\n        self.state = TileState.LOADED;\r\n        self.changed();\r\n      })\r\n      .catch(function (error) {\r\n        self.error_ = error;\r\n        self.state = TileState.ERROR;\r\n        self.changed();\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    if (this.controller_) {\r\n      this.controller_.abort(disposedError);\r\n      this.controller_ = null;\r\n    }\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default DataTile;\r\n","/**\r\n * @module CME2D/reproj/common\r\n */\r\n\r\n/**\r\n * Default maximum allowed threshold  (in pixels) for reprojection\r\n * triangulation.\r\n * @type {number}\r\n */\r\nexport const ERROR_THRESHOLD = 0.5;\r\n","/**\r\n * @module CME2D/extent/Relationship\r\n */\r\n\r\n/**\r\n * Relationship to an extent.\r\n * @enum {number}\r\n */\r\nexport default {\r\n  UNKNOWN: 0,\r\n  INTERSECTING: 1,\r\n  ABOVE: 2,\r\n  RIGHT: 4,\r\n  BELOW: 8,\r\n  LEFT: 16,\r\n};\r\n","/**\r\n * @module CME2D/extent\r\n */\r\nimport Relationship from './extent/Relationship.js';\r\n\r\n/**\r\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\r\n * @typedef {Array<number>} Extent\r\n * @api\r\n */\r\n\r\n/**\r\n * Extent corner.\r\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\r\n */\r\n\r\n/**\r\n * Build an extent that includes all given coordinates.\r\n *\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @return {Extent} Bounding extent.\r\n * @api\r\n */\r\nexport function boundingExtent(coordinates) {\r\n  const extent = createEmpty();\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    extendCoordinate(extent, coordinates[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} xs Xs.\r\n * @param {Array<number>} ys Ys.\r\n * @param {Extent} [dest] Destination extent.\r\n * @private\r\n * @return {Extent} Extent.\r\n */\r\nfunction _boundingExtentXYs(xs, ys, dest) {\r\n  const minX = Math.min.apply(null, xs);\r\n  const minY = Math.min.apply(null, ys);\r\n  const maxX = Math.max.apply(null, xs);\r\n  const maxY = Math.max.apply(null, ys);\r\n  return createOrUpdate(minX, minY, maxX, maxY, dest);\r\n}\r\n\r\n/**\r\n * Return extent increased by the provided value.\r\n * @param {Extent} extent Extent.\r\n * @param {number} value The amount by which the extent should be buffered.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n * @api\r\n */\r\nexport function buffer(extent, value, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0] - value;\r\n    dest[1] = extent[1] - value;\r\n    dest[2] = extent[2] + value;\r\n    dest[3] = extent[3] + value;\r\n    return dest;\r\n  }\r\n  return [\r\n    extent[0] - value,\r\n    extent[1] - value,\r\n    extent[2] + value,\r\n    extent[3] + value,\r\n  ];\r\n}\r\n\r\n/**\r\n * Creates a clone of an extent.\r\n *\r\n * @param {Extent} extent Extent to clone.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} The clone.\r\n */\r\nexport function clone(extent, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0];\r\n    dest[1] = extent[1];\r\n    dest[2] = extent[2];\r\n    dest[3] = extent[3];\r\n    return dest;\r\n  }\r\n  return extent.slice();\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {number} Closest squared distance.\r\n */\r\nexport function closestSquaredDistanceXY(extent, x, y) {\r\n  let dx, dy;\r\n  if (x < extent[0]) {\r\n    dx = extent[0] - x;\r\n  } else if (extent[2] < x) {\r\n    dx = x - extent[2];\r\n  } else {\r\n    dx = 0;\r\n  }\r\n  if (y < extent[1]) {\r\n    dy = extent[1] - y;\r\n  } else if (extent[3] < y) {\r\n    dy = y - extent[3];\r\n  } else {\r\n    dy = 0;\r\n  }\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Check if the passed coordinate is contained or on the edge of the extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @return {boolean} The coordinate is contained in the extent.\r\n * @api\r\n */\r\nexport function containsCoordinate(extent, coordinate) {\r\n  return containsXY(extent, coordinate[0], coordinate[1]);\r\n}\r\n\r\n/**\r\n * Check if one extent contains another.\r\n *\r\n * An extent is deemed contained if it lies completely within the other extent,\r\n * including if they share one or more edges.\r\n *\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {boolean} The second extent is contained by or on the edge of the\r\n *     first.\r\n * @api\r\n */\r\nexport function containsExtent(extent1, extent2) {\r\n  return (\r\n    extent1[0] <= extent2[0] &&\r\n    extent2[2] <= extent1[2] &&\r\n    extent1[1] <= extent2[1] &&\r\n    extent2[3] <= extent1[3]\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the passed coordinate is contained or on the edge of the extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X coordinate.\r\n * @param {number} y Y coordinate.\r\n * @return {boolean} The x, y values are contained in the extent.\r\n * @api\r\n */\r\nexport function containsXY(extent, x, y) {\r\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\r\n}\r\n\r\n/**\r\n * Get the relationship between a coordinate and extent.\r\n * @param {Extent} extent The extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\r\n *     import(\"./extent/Relationship.js\").Relationship).\r\n */\r\nexport function coordinateRelationship(extent, coordinate) {\r\n  const minX = extent[0];\r\n  const minY = extent[1];\r\n  const maxX = extent[2];\r\n  const maxY = extent[3];\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  let relationship = Relationship.UNKNOWN;\r\n  if (x < minX) {\r\n    relationship = relationship | Relationship.LEFT;\r\n  } else if (x > maxX) {\r\n    relationship = relationship | Relationship.RIGHT;\r\n  }\r\n  if (y < minY) {\r\n    relationship = relationship | Relationship.BELOW;\r\n  } else if (y > maxY) {\r\n    relationship = relationship | Relationship.ABOVE;\r\n  }\r\n  if (relationship === Relationship.UNKNOWN) {\r\n    relationship = Relationship.INTERSECTING;\r\n  }\r\n  return relationship;\r\n}\r\n\r\n/**\r\n * Create an empty extent.\r\n * @return {Extent} Empty extent.\r\n * @api\r\n */\r\nexport function createEmpty() {\r\n  return [Infinity, Infinity, -Infinity, -Infinity];\r\n}\r\n\r\n/**\r\n * Create a new extent or update the provided extent.\r\n * @param {number} minX Minimum X.\r\n * @param {number} minY Minimum Y.\r\n * @param {number} maxX Maximum X.\r\n * @param {number} maxY Maximum Y.\r\n * @param {Extent} [dest] Destination extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdate(minX, minY, maxX, maxY, dest) {\r\n  if (dest) {\r\n    dest[0] = minX;\r\n    dest[1] = minY;\r\n    dest[2] = maxX;\r\n    dest[3] = maxY;\r\n    return dest;\r\n  }\r\n  return [minX, minY, maxX, maxY];\r\n}\r\n\r\n/**\r\n * Create a new empty extent or make the provided one empty.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateEmpty(dest) {\r\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromCoordinate(coordinate, dest) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  return createOrUpdate(x, y, x, y, dest);\r\n}\r\n\r\n/**\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromCoordinates(coordinates, dest) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendCoordinates(extent, coordinates);\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromFlatCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  dest,\r\n) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\r\n}\r\n\r\n/**\r\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromRings(rings, dest) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendRings(extent, rings);\r\n}\r\n\r\n/**\r\n * Determine if two extents are equivalent.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {boolean} The two extents are equivalent.\r\n * @api\r\n */\r\nexport function equals(extent1, extent2) {\r\n  return (\r\n    extent1[0] == extent2[0] &&\r\n    extent1[2] == extent2[2] &&\r\n    extent1[1] == extent2[1] &&\r\n    extent1[3] == extent2[3]\r\n  );\r\n}\r\n\r\n/**\r\n * Determine if two extents are approximately equivalent.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @param {number} tolerance Tolerance in extent coordinate units.\r\n * @return {boolean} The two extents differ by less than the tolerance.\r\n */\r\nexport function approximatelyEquals(extent1, extent2, tolerance) {\r\n  return (\r\n    Math.abs(extent1[0] - extent2[0]) < tolerance &&\r\n    Math.abs(extent1[2] - extent2[2]) < tolerance &&\r\n    Math.abs(extent1[1] - extent2[1]) < tolerance &&\r\n    Math.abs(extent1[3] - extent2[3]) < tolerance\r\n  );\r\n}\r\n\r\n/**\r\n * Modify an extent to include another extent.\r\n * @param {Extent} extent1 The extent to be modified.\r\n * @param {Extent} extent2 The extent that will be included in the first.\r\n * @return {Extent} A reference to the first (extended) extent.\r\n * @api\r\n */\r\nexport function extend(extent1, extent2) {\r\n  if (extent2[0] < extent1[0]) {\r\n    extent1[0] = extent2[0];\r\n  }\r\n  if (extent2[2] > extent1[2]) {\r\n    extent1[2] = extent2[2];\r\n  }\r\n  if (extent2[1] < extent1[1]) {\r\n    extent1[1] = extent2[1];\r\n  }\r\n  if (extent2[3] > extent1[3]) {\r\n    extent1[3] = extent2[3];\r\n  }\r\n  return extent1;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n */\r\nexport function extendCoordinate(extent, coordinate) {\r\n  if (coordinate[0] < extent[0]) {\r\n    extent[0] = coordinate[0];\r\n  }\r\n  if (coordinate[0] > extent[2]) {\r\n    extent[2] = coordinate[0];\r\n  }\r\n  if (coordinate[1] < extent[1]) {\r\n    extent[1] = coordinate[1];\r\n  }\r\n  if (coordinate[1] > extent[3]) {\r\n    extent[3] = coordinate[1];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendCoordinates(extent, coordinates) {\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    extendCoordinate(extent, coordinates[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendFlatCoordinates(\r\n  extent,\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n) {\r\n  for (; offset < end; offset += stride) {\r\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendRings(extent, rings) {\r\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\r\n    extendCoordinates(extent, rings[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n */\r\nexport function extendXY(extent, x, y) {\r\n  extent[0] = Math.min(extent[0], x);\r\n  extent[1] = Math.min(extent[1], y);\r\n  extent[2] = Math.max(extent[2], x);\r\n  extent[3] = Math.max(extent[3], y);\r\n}\r\n\r\n/**\r\n * This function calls `callback` for each corner of the extent. If the\r\n * callback returns a truthy value the function returns that value\r\n * immediately. Otherwise the function returns `false`.\r\n * @param {Extent} extent Extent.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\r\n * @return {S|boolean} Value.\r\n * @template S\r\n */\r\nexport function forEachCorner(extent, callback) {\r\n  let val;\r\n  val = callback(getBottomLeft(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getBottomRight(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getTopRight(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getTopLeft(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get the size of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Area.\r\n * @api\r\n */\r\nexport function getArea(extent) {\r\n  let area = 0;\r\n  if (!isEmpty(extent)) {\r\n    area = getWidth(extent) * getHeight(extent);\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * Get the bottom left coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\r\n * @api\r\n */\r\nexport function getBottomLeft(extent) {\r\n  return [extent[0], extent[1]];\r\n}\r\n\r\n/**\r\n * Get the bottom right coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\r\n * @api\r\n */\r\nexport function getBottomRight(extent) {\r\n  return [extent[2], extent[1]];\r\n}\r\n\r\n/**\r\n * Get the center coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Center.\r\n * @api\r\n */\r\nexport function getCenter(extent) {\r\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\r\n}\r\n\r\n/**\r\n * Get a corner coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @param {Corner} corner Corner.\r\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\r\n */\r\nexport function getCorner(extent, corner) {\r\n  let coordinate;\r\n  if (corner === 'bottom-left') {\r\n    coordinate = getBottomLeft(extent);\r\n  } else if (corner === 'bottom-right') {\r\n    coordinate = getBottomRight(extent);\r\n  } else if (corner === 'top-left') {\r\n    coordinate = getTopLeft(extent);\r\n  } else if (corner === 'top-right') {\r\n    coordinate = getTopRight(extent);\r\n  } else {\r\n    throw new Error('Invalid corner');\r\n  }\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {number} Enlarged area.\r\n */\r\nexport function getEnlargedArea(extent1, extent2) {\r\n  const minX = Math.min(extent1[0], extent2[0]);\r\n  const minY = Math.min(extent1[1], extent2[1]);\r\n  const maxX = Math.max(extent1[2], extent2[2]);\r\n  const maxY = Math.max(extent1[3], extent2[3]);\r\n  return (maxX - minX) * (maxY - minY);\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @param {import(\"./size.js\").Size} size Size.\r\n * @param {Extent} [dest] Destination extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function getForViewAndSize(center, resolution, rotation, size, dest) {\r\n  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(\r\n    center,\r\n    resolution,\r\n    rotation,\r\n    size,\r\n  );\r\n  return createOrUpdate(\r\n    Math.min(x0, x1, x2, x3),\r\n    Math.min(y0, y1, y2, y3),\r\n    Math.max(x0, x1, x2, x3),\r\n    Math.max(y0, y1, y2, y3),\r\n    dest,\r\n  );\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @param {import(\"./size.js\").Size} size Size.\r\n * @return {Array<number>} Linear ring representing the viewport.\r\n */\r\nexport function getRotatedViewport(center, resolution, rotation, size) {\r\n  const dx = (resolution * size[0]) / 2;\r\n  const dy = (resolution * size[1]) / 2;\r\n  const cosRotation = Math.cos(rotation);\r\n  const sinRotation = Math.sin(rotation);\r\n  const xCos = dx * cosRotation;\r\n  const xSin = dx * sinRotation;\r\n  const yCos = dy * cosRotation;\r\n  const ySin = dy * sinRotation;\r\n  const x = center[0];\r\n  const y = center[1];\r\n  return [\r\n    x - xCos + ySin,\r\n    y - xSin - yCos,\r\n    x - xCos - ySin,\r\n    y - xSin + yCos,\r\n    x + xCos - ySin,\r\n    y + xSin + yCos,\r\n    x + xCos + ySin,\r\n    y + xSin - yCos,\r\n    x - xCos + ySin,\r\n    y - xSin - yCos,\r\n  ];\r\n}\r\n\r\n/**\r\n * Get the height of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Height.\r\n * @api\r\n */\r\nexport function getHeight(extent) {\r\n  return extent[3] - extent[1];\r\n}\r\n\r\n/**\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {number} Intersection area.\r\n */\r\nexport function getIntersectionArea(extent1, extent2) {\r\n  const intersection = getIntersection(extent1, extent2);\r\n  return getArea(intersection);\r\n}\r\n\r\n/**\r\n * Get the intersection of two extents.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @param {Extent} [dest] Optional extent to populate with intersection.\r\n * @return {Extent} Intersecting extent.\r\n * @api\r\n */\r\nexport function getIntersection(extent1, extent2, dest) {\r\n  const intersection = dest ? dest : createEmpty();\r\n  if (intersects(extent1, extent2)) {\r\n    if (extent1[0] > extent2[0]) {\r\n      intersection[0] = extent1[0];\r\n    } else {\r\n      intersection[0] = extent2[0];\r\n    }\r\n    if (extent1[1] > extent2[1]) {\r\n      intersection[1] = extent1[1];\r\n    } else {\r\n      intersection[1] = extent2[1];\r\n    }\r\n    if (extent1[2] < extent2[2]) {\r\n      intersection[2] = extent1[2];\r\n    } else {\r\n      intersection[2] = extent2[2];\r\n    }\r\n    if (extent1[3] < extent2[3]) {\r\n      intersection[3] = extent1[3];\r\n    } else {\r\n      intersection[3] = extent2[3];\r\n    }\r\n  } else {\r\n    createOrUpdateEmpty(intersection);\r\n  }\r\n  return intersection;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @return {number} Margin.\r\n */\r\nexport function getMargin(extent) {\r\n  return getWidth(extent) + getHeight(extent);\r\n}\r\n\r\n/**\r\n * Get the size (width, height) of an extent.\r\n * @param {Extent} extent The extent.\r\n * @return {import(\"./size.js\").Size} The extent size.\r\n * @api\r\n */\r\nexport function getSize(extent) {\r\n  return [extent[2] - extent[0], extent[3] - extent[1]];\r\n}\r\n\r\n/**\r\n * Get the top left coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\r\n * @api\r\n */\r\nexport function getTopLeft(extent) {\r\n  return [extent[0], extent[3]];\r\n}\r\n\r\n/**\r\n * Get the top right coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\r\n * @api\r\n */\r\nexport function getTopRight(extent) {\r\n  return [extent[2], extent[3]];\r\n}\r\n\r\n/**\r\n * Get the width of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Width.\r\n * @api\r\n */\r\nexport function getWidth(extent) {\r\n  return extent[2] - extent[0];\r\n}\r\n\r\n/**\r\n * Determine if one extent intersects another.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent.\r\n * @return {boolean} The two extents intersect.\r\n * @api\r\n */\r\nexport function intersects(extent1, extent2) {\r\n  return (\r\n    extent1[0] <= extent2[2] &&\r\n    extent1[2] >= extent2[0] &&\r\n    extent1[1] <= extent2[3] &&\r\n    extent1[3] >= extent2[1]\r\n  );\r\n}\r\n\r\n/**\r\n * Determine if an extent is empty.\r\n * @param {Extent} extent Extent.\r\n * @return {boolean} Is empty.\r\n * @api\r\n */\r\nexport function isEmpty(extent) {\r\n  return extent[2] < extent[0] || extent[3] < extent[1];\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function returnOrUpdate(extent, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0];\r\n    dest[1] = extent[1];\r\n    dest[2] = extent[2];\r\n    dest[3] = extent[3];\r\n    return dest;\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} value Value.\r\n */\r\nexport function scaleFromCenter(extent, value) {\r\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\r\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\r\n  extent[0] -= deltaX;\r\n  extent[2] += deltaX;\r\n  extent[1] -= deltaY;\r\n  extent[3] += deltaY;\r\n}\r\n\r\n/**\r\n * Determine if the segment between two coordinates intersects (crosses,\r\n * touches, or is contained by) the provided extent.\r\n * @param {Extent} extent The extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\r\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\r\n * @return {boolean} The segment intersects the extent.\r\n */\r\nexport function intersectsSegment(extent, start, end) {\r\n  let intersects = false;\r\n  const startRel = coordinateRelationship(extent, start);\r\n  const endRel = coordinateRelationship(extent, end);\r\n  if (\r\n    startRel === Relationship.INTERSECTING ||\r\n    endRel === Relationship.INTERSECTING\r\n  ) {\r\n    intersects = true;\r\n  } else {\r\n    const minX = extent[0];\r\n    const minY = extent[1];\r\n    const maxX = extent[2];\r\n    const maxY = extent[3];\r\n    const startX = start[0];\r\n    const startY = start[1];\r\n    const endX = end[0];\r\n    const endY = end[1];\r\n    const slope = (endY - startY) / (endX - startX);\r\n    let x, y;\r\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\r\n      // potentially intersects top\r\n      x = endX - (endY - maxY) / slope;\r\n      intersects = x >= minX && x <= maxX;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.RIGHT) &&\r\n      !(startRel & Relationship.RIGHT)\r\n    ) {\r\n      // potentially intersects right\r\n      y = endY - (endX - maxX) * slope;\r\n      intersects = y >= minY && y <= maxY;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.BELOW) &&\r\n      !(startRel & Relationship.BELOW)\r\n    ) {\r\n      // potentially intersects bottom\r\n      x = endX - (endY - minY) / slope;\r\n      intersects = x >= minX && x <= maxX;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.LEFT) &&\r\n      !(startRel & Relationship.LEFT)\r\n    ) {\r\n      // potentially intersects left\r\n      y = endY - (endX - minX) * slope;\r\n      intersects = y >= minY && y <= maxY;\r\n    }\r\n  }\r\n  return intersects;\r\n}\r\n\r\n/**\r\n * Apply a transform function to the extent.\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\r\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\r\n * @param {Extent} [dest] Destination extent.\r\n * @param {number} [stops] Number of stops per side used for the transform.\r\n * By default only the corners are used.\r\n * @return {Extent} Extent.\r\n * @api\r\n */\r\nexport function applyTransform(extent, transformFn, dest, stops) {\r\n  if (isEmpty(extent)) {\r\n    return createOrUpdateEmpty(dest);\r\n  }\r\n  let coordinates = [];\r\n  if (stops > 1) {\r\n    const width = extent[2] - extent[0];\r\n    const height = extent[3] - extent[1];\r\n    for (let i = 0; i < stops; ++i) {\r\n      coordinates.push(\r\n        extent[0] + (width * i) / stops,\r\n        extent[1],\r\n        extent[2],\r\n        extent[1] + (height * i) / stops,\r\n        extent[2] - (width * i) / stops,\r\n        extent[3],\r\n        extent[0],\r\n        extent[3] - (height * i) / stops,\r\n      );\r\n    }\r\n  } else {\r\n    coordinates = [\r\n      extent[0],\r\n      extent[1],\r\n      extent[2],\r\n      extent[1],\r\n      extent[2],\r\n      extent[3],\r\n      extent[0],\r\n      extent[3],\r\n    ];\r\n  }\r\n  transformFn(coordinates, coordinates, 2);\r\n  const xs = [];\r\n  const ys = [];\r\n  for (let i = 0, l = coordinates.length; i < l; i += 2) {\r\n    xs.push(coordinates[i]);\r\n    ys.push(coordinates[i + 1]);\r\n  }\r\n  return _boundingExtentXYs(xs, ys, dest);\r\n}\r\n\r\n/**\r\n * Modifies the provided extent in-place to be within the real world\r\n * extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection\r\n * @return {Extent} The extent within the real world extent.\r\n */\r\nexport function wrapX(extent, projection) {\r\n  const projectionExtent = projection.getExtent();\r\n  const center = getCenter(extent);\r\n  if (\r\n    projection.canWrapX() &&\r\n    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])\r\n  ) {\r\n    const worldWidth = getWidth(projectionExtent);\r\n    const worldsAway = Math.floor(\r\n      (center[0] - projectionExtent[0]) / worldWidth,\r\n    );\r\n    const offset = worldsAway * worldWidth;\r\n    extent[0] -= offset;\r\n    extent[2] -= offset;\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * Fits the extent to the real world\r\n *\r\n * If the extent does not cross the anti meridian, this will return the extent in an array\r\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\r\n * real world\r\n *\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection\r\n * @param {boolean} [multiWorld] Return all worlds\r\n * @return {Array<Extent>} The extent within the real world extent.\r\n */\r\nexport function wrapAndSliceX(extent, projection, multiWorld) {\r\n  if (projection.canWrapX()) {\r\n    const projectionExtent = projection.getExtent();\r\n\r\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\r\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\r\n    }\r\n\r\n    wrapX(extent, projection);\r\n    const worldWidth = getWidth(projectionExtent);\r\n\r\n    if (getWidth(extent) > worldWidth && !multiWorld) {\r\n      // the extent wraps around on itself\r\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\r\n    }\r\n    if (extent[0] < projectionExtent[0]) {\r\n      // the extent crosses the anti meridian, so it needs to be sliced\r\n      return [\r\n        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\r\n        [projectionExtent[0], extent[1], extent[2], extent[3]],\r\n      ];\r\n    }\r\n    if (extent[2] > projectionExtent[2]) {\r\n      // the extent crosses the anti meridian, so it needs to be sliced\r\n      return [\r\n        [extent[0], extent[1], projectionExtent[2], extent[3]],\r\n        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\r\n      ];\r\n    }\r\n  }\r\n\r\n  return [extent];\r\n}\r\n","/**\r\n * @module CME2D/proj/Units\r\n */\r\n\r\n/**\r\n * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units\r\n * Projection units.\r\n */\r\n\r\n/**\r\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\r\n * @type {Object<number, Units>}\r\n */\r\nconst unitByCode = {\r\n  '9001': 'm',\r\n  '9002': 'ft',\r\n  '9003': 'us-ft',\r\n  '9101': 'radians',\r\n  '9102': 'degrees',\r\n};\r\n\r\n/**\r\n * @param {number} code Unit code.\r\n * @return {Units} Units.\r\n */\r\nexport function fromCode(code) {\r\n  return unitByCode[code];\r\n}\r\n\r\n/**\r\n * @typedef {Object} MetersPerUnitLookup\r\n * @property {number} radians Radians\r\n * @property {number} degrees Degrees\r\n * @property {number} ft  Feet\r\n * @property {number} m Meters\r\n * @property {number} us-ft US feet\r\n */\r\n\r\n/**\r\n * Meters per unit lookup table.\r\n * @const\r\n * @type {MetersPerUnitLookup}\r\n * @api\r\n */\r\nexport const METERS_PER_UNIT = {\r\n  // use the radius of the Normal sphere\r\n  'radians': 6370997 / (2 * Math.PI),\r\n  'degrees': (2 * Math.PI * 6370997) / 360,\r\n  'ft': 0.3048,\r\n  'm': 1,\r\n  'us-ft': 1200 / 3937,\r\n};\r\n","/**\r\n * @module CME2D/proj/Projection\r\n */\r\nimport {METERS_PER_UNIT} from './Units.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\r\n * @property {import(\"./Units.js\").Units} [units] Units. Required unless a\r\n * proj4 projection is defined for `code`.\r\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\r\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\r\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\r\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\r\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\r\n * lookup table.\r\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\r\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\r\n * Function to determine resolution at a point. The function is called with a\r\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\r\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\r\n * the default {@link module:ol/proj.getPointResolution} function will be used.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Projection definition class. One of these is created for each projection\r\n * supported in the application and stored in the {@link module:ol/proj} namespace.\r\n * You can use these in applications, but this is not required, as API params\r\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\r\n * code will suffice.\r\n *\r\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\r\n * projection.\r\n *\r\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\r\n * with the following aliases:\r\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\r\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\r\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\r\n *     urn:x-ogc:def:crs:EPSG:4326\r\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\r\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\r\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\r\n *\r\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\r\n * be added using `proj4.defs()`. After all required projection definitions are\r\n * added, call the {@link module:ol/proj/proj4.register} function.\r\n *\r\n * @api\r\n */\r\nclass Projection {\r\n  /**\r\n   * @param {Options} options Projection options.\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.code_ = options.code;\r\n\r\n    /**\r\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\r\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\r\n     * tile.\r\n     * @private\r\n     * @type {import(\"./Units.js\").Units}\r\n     */\r\n    this.units_ = /** @type {import(\"./Units.js\").Units} */ (options.units);\r\n\r\n    /**\r\n     * Validity extent of the projection in projected coordinates. For projections\r\n     * with `TILE_PIXELS` units, this is the extent of the tile in\r\n     * tile pixel space.\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = options.extent !== undefined ? options.extent : null;\r\n\r\n    /**\r\n     * Extent of the world in EPSG:4326. For projections with\r\n     * `TILE_PIXELS` units, this is the extent of the tile in\r\n     * projected coordinate space.\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.worldExtent_ =\r\n      options.worldExtent !== undefined ? options.worldExtent : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.axisOrientation_ =\r\n      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.global_ = options.global !== undefined ? options.global : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.canWrapX_ = !!(this.global_ && this.extent_);\r\n\r\n    /**\r\n     * @private\r\n     * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\r\n     */\r\n    this.getPointResolutionFunc_ = options.getPointResolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.defaultTileGrid_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.metersPerUnit_ = options.metersPerUnit;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} The projection is suitable for wrapping the x-axis\r\n   */\r\n  canWrapX() {\r\n    return this.canWrapX_;\r\n  }\r\n\r\n  /**\r\n   * Get the code for this projection, e.g. 'EPSG:4326'.\r\n   * @return {string} Code.\r\n   * @api\r\n   */\r\n  getCode() {\r\n    return this.code_;\r\n  }\r\n\r\n  /**\r\n   * Get the validity extent for this projection.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return this.extent_;\r\n  }\r\n\r\n  /**\r\n   * Get the units of this projection.\r\n   * @return {import(\"./Units.js\").Units} Units.\r\n   * @api\r\n   */\r\n  getUnits() {\r\n    return this.units_;\r\n  }\r\n\r\n  /**\r\n   * Get the amount of meters per unit of this projection.  If the projection is\r\n   * not configured with `metersPerUnit` or a units identifier, the return is\r\n   * `undefined`.\r\n   * @return {number|undefined} Meters.\r\n   * @api\r\n   */\r\n  getMetersPerUnit() {\r\n    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\r\n  }\r\n\r\n  /**\r\n   * Get the world extent for this projection.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getWorldExtent() {\r\n    return this.worldExtent_;\r\n  }\r\n\r\n  /**\r\n   * Get the axis orientation of this projection.\r\n   * Example values are:\r\n   * enu - the default easting, northing, elevation.\r\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\r\n   *     or south orientated transverse mercator.\r\n   * wnu - westing, northing, up - some planetary coordinate systems have\r\n   *     \"west positive\" coordinate systems\r\n   * @return {string} Axis orientation.\r\n   * @api\r\n   */\r\n  getAxisOrientation() {\r\n    return this.axisOrientation_;\r\n  }\r\n\r\n  /**\r\n   * Is this projection a global projection which spans the whole world?\r\n   * @return {boolean} Whether the projection is global.\r\n   * @api\r\n   */\r\n  isGlobal() {\r\n    return this.global_;\r\n  }\r\n\r\n  /**\r\n   * Set if the projection is a global projection which spans the whole world\r\n   * @param {boolean} global Whether the projection is global.\r\n   * @api\r\n   */\r\n  setGlobal(global) {\r\n    this.global_ = global;\r\n    this.canWrapX_ = !!(global && this.extent_);\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\r\n   */\r\n  getDefaultTileGrid() {\r\n    return this.defaultTileGrid_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\r\n   */\r\n  setDefaultTileGrid(tileGrid) {\r\n    this.defaultTileGrid_ = tileGrid;\r\n  }\r\n\r\n  /**\r\n   * Set the validity extent for this projection.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @api\r\n   */\r\n  setExtent(extent) {\r\n    this.extent_ = extent;\r\n    this.canWrapX_ = !!(this.global_ && extent);\r\n  }\r\n\r\n  /**\r\n   * Set the world extent for this projection.\r\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\r\n   *     [minlon, minlat, maxlon, maxlat].\r\n   * @api\r\n   */\r\n  setWorldExtent(worldExtent) {\r\n    this.worldExtent_ = worldExtent;\r\n  }\r\n\r\n  /**\r\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\r\n   * for this projection.\r\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\r\n   * @api\r\n   */\r\n  setGetPointResolution(func) {\r\n    this.getPointResolutionFunc_ = func;\r\n  }\r\n\r\n  /**\r\n   * Get the custom point resolution function for this projection (if set).\r\n   * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\r\n   * resolution function (if set).\r\n   */\r\n  getPointResolutionFunc() {\r\n    return this.getPointResolutionFunc_;\r\n  }\r\n}\r\n\r\nexport default Projection;\r\n","/**\r\n * @module CME2D/proj/epsg3857\r\n */\r\nimport Projection from './Projection.js';\r\n\r\n/**\r\n * Radius of WGS84 sphere\r\n *\r\n * @const\r\n * @type {number}\r\n */\r\nexport const RADIUS = 6378137;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const HALF_SIZE = Math.PI * RADIUS;\r\n\r\n/**\r\n * @const\r\n * @type {import(\"../extent.js\").Extent}\r\n */\r\nexport const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\r\n\r\n/**\r\n * @const\r\n * @type {import(\"../extent.js\").Extent}\r\n */\r\nexport const WORLD_EXTENT = [-180, -85, 180, 85];\r\n\r\n/**\r\n * Maximum safe value in y direction\r\n * @const\r\n * @type {number}\r\n */\r\nexport const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\r\n\r\n/**\r\n * @classdesc\r\n * Projection object for web/spherical Mercator (EPSG:3857).\r\n */\r\nclass EPSG3857Projection extends Projection {\r\n  /**\r\n   * @param {string} code Code.\r\n   */\r\n  constructor(code) {\r\n    super({\r\n      code: code,\r\n      units: 'm',\r\n      extent: EXTENT,\r\n      global: true,\r\n      worldExtent: WORLD_EXTENT,\r\n      getPointResolution: function (resolution, point) {\r\n        return resolution / Math.cosh(point[1] / RADIUS);\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Projections equal to EPSG:3857.\r\n *\r\n * @const\r\n * @type {Array<import(\"./Projection.js\").default>}\r\n */\r\nexport const PROJECTIONS = [\r\n  new EPSG3857Projection('EPSG:3857'),\r\n  new EPSG3857Projection('EPSG:102100'),\r\n  new EPSG3857Projection('EPSG:102113'),\r\n  new EPSG3857Projection('EPSG:900913'),\r\n  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),\r\n  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),\r\n];\r\n\r\n/**\r\n * Transformation from EPSG:4326 to EPSG:3857.\r\n *\r\n * @param {Array<number>} input Input array of coordinate values.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @param {number} [dimension] Dimension (default is `2`).\r\n * @param {number} [stride] Stride (default is `dimension`).\r\n * @return {Array<number>} Output array of coordinate values.\r\n */\r\nexport function fromEPSG4326(input, output, dimension, stride) {\r\n  const length = input.length;\r\n  dimension = dimension > 1 ? dimension : 2;\r\n  stride = stride ?? dimension;\r\n  if (output === undefined) {\r\n    if (dimension > 2) {\r\n      // preserve values beyond second dimension\r\n      output = input.slice();\r\n    } else {\r\n      output = new Array(length);\r\n    }\r\n  }\r\n  for (let i = 0; i < length; i += stride) {\r\n    output[i] = (HALF_SIZE * input[i]) / 180;\r\n    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\r\n    if (y > MAX_SAFE_Y) {\r\n      y = MAX_SAFE_Y;\r\n    } else if (y < -MAX_SAFE_Y) {\r\n      y = -MAX_SAFE_Y;\r\n    }\r\n    output[i + 1] = y;\r\n  }\r\n  return output;\r\n}\r\n\r\n/**\r\n * Transformation from EPSG:3857 to EPSG:4326.\r\n *\r\n * @param {Array<number>} input Input array of coordinate values.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @param {number} [dimension] Dimension (default is `2`).\r\n * @param {number} [stride] Stride (default is `dimension`).\r\n * @return {Array<number>} Output array of coordinate values.\r\n */\r\nexport function toEPSG4326(input, output, dimension, stride) {\r\n  const length = input.length;\r\n  dimension = dimension > 1 ? dimension : 2;\r\n  stride = stride ?? dimension;\r\n  if (output === undefined) {\r\n    if (dimension > 2) {\r\n      // preserve values beyond second dimension\r\n      output = input.slice();\r\n    } else {\r\n      output = new Array(length);\r\n    }\r\n  }\r\n  for (let i = 0; i < length; i += stride) {\r\n    output[i] = (180 * input[i]) / HALF_SIZE;\r\n    output[i + 1] =\r\n      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\r\n  }\r\n  return output;\r\n}\r\n","/**\r\n * @module CME2D/proj/epsg4326\r\n */\r\nimport Projection from './Projection.js';\r\n\r\n/**\r\n * Semi-major radius of the WGS84 ellipsoid.\r\n *\r\n * @const\r\n * @type {number}\r\n */\r\nexport const RADIUS = 6378137;\r\n\r\n/**\r\n * Extent of the EPSG:4326 projection which is the whole world.\r\n *\r\n * @const\r\n * @type {import(\"../extent.js\").Extent}\r\n */\r\nexport const EXTENT = [-180, -90, 180, 90];\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;\r\n\r\n/**\r\n * @classdesc\r\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\r\n *\r\n * Note that OpenLayers does not strictly comply with the EPSG definition.\r\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\r\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\r\n */\r\nclass EPSG4326Projection extends Projection {\r\n  /**\r\n   * @param {string} code Code.\r\n   * @param {string} [axisOrientation] Axis orientation.\r\n   */\r\n  constructor(code, axisOrientation) {\r\n    super({\r\n      code: code,\r\n      units: 'degrees',\r\n      extent: EXTENT,\r\n      axisOrientation: axisOrientation,\r\n      global: true,\r\n      metersPerUnit: METERS_PER_UNIT,\r\n      worldExtent: EXTENT,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Projections equal to EPSG:4326.\r\n *\r\n * @const\r\n * @type {Array<import(\"./Projection.js\").default>}\r\n */\r\nexport const PROJECTIONS = [\r\n  new EPSG4326Projection('CRS:84'),\r\n  new EPSG4326Projection('EPSG:4326', 'neu'),\r\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\r\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\r\n  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),\r\n  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\r\n  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),\r\n];\r\n","/**\r\n * @module CME2D/proj/projections\r\n */\r\n\r\n/**\r\n * @type {Object<string, import(\"./Projection.js\").default>}\r\n */\r\nlet cache = {};\r\n\r\n/**\r\n * Clear the projections cache.\r\n */\r\nexport function clear() {\r\n  cache = {};\r\n}\r\n\r\n/**\r\n * Get a cached projection by code.\r\n * @param {string} code The code for the projection.\r\n * @return {import(\"./Projection.js\").default} The projection (if cached).\r\n */\r\nexport function get(code) {\r\n  return (\r\n    cache[code] ||\r\n    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] ||\r\n    null\r\n  );\r\n}\r\n\r\n/**\r\n * Add a projection to the cache.\r\n * @param {string} code The projection code.\r\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\r\n */\r\nexport function add(code, projection) {\r\n  cache[code] = projection;\r\n}\r\n","/**\r\n * @module CME2D/proj/transforms\r\n */\r\nimport {isEmpty} from '../obj.js';\r\n\r\n/**\r\n * @private\r\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\r\n */\r\nlet transforms = {};\r\n\r\n/**\r\n * Clear the transform cache.\r\n */\r\nexport function clear() {\r\n  transforms = {};\r\n}\r\n\r\n/**\r\n * Registers a conversion function to convert coordinates from the source\r\n * projection to the destination projection.\r\n *\r\n * @param {import(\"./Projection.js\").default} source Source.\r\n * @param {import(\"./Projection.js\").default} destination Destination.\r\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\r\n */\r\nexport function add(source, destination, transformFn) {\r\n  const sourceCode = source.getCode();\r\n  const destinationCode = destination.getCode();\r\n  if (!(sourceCode in transforms)) {\r\n    transforms[sourceCode] = {};\r\n  }\r\n  transforms[sourceCode][destinationCode] = transformFn;\r\n}\r\n\r\n/**\r\n * Unregisters the conversion function to convert coordinates from the source\r\n * projection to the destination projection.  This method is used to clean up\r\n * cached transforms during testing.\r\n *\r\n * @param {import(\"./Projection.js\").default} source Source projection.\r\n * @param {import(\"./Projection.js\").default} destination Destination projection.\r\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\r\n */\r\nexport function remove(source, destination) {\r\n  const sourceCode = source.getCode();\r\n  const destinationCode = destination.getCode();\r\n  const transform = transforms[sourceCode][destinationCode];\r\n  delete transforms[sourceCode][destinationCode];\r\n  if (isEmpty(transforms[sourceCode])) {\r\n    delete transforms[sourceCode];\r\n  }\r\n  return transform;\r\n}\r\n\r\n/**\r\n * Get a transform given a source code and a destination code.\r\n * @param {string} sourceCode The code for the source projection.\r\n * @param {string} destinationCode The code for the destination projection.\r\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\r\n */\r\nexport function get(sourceCode, destinationCode) {\r\n  let transform;\r\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\r\n    transform = transforms[sourceCode][destinationCode];\r\n  }\r\n  return transform;\r\n}\r\n","/**\r\n * @module CME2D/math\r\n */\r\n\r\n/**\r\n * Takes a number and clamps it to within the provided bounds.\r\n * @param {number} value The input number.\r\n * @param {number} min The minimum value to return.\r\n * @param {number} max The maximum value to return.\r\n * @return {number} The input number if it is within bounds, or the nearest\r\n *     number within the bounds.\r\n */\r\nexport function clamp(value, min, max) {\r\n  return Math.min(Math.max(value, min), max);\r\n}\r\n\r\n/**\r\n * Returns the square of the closest distance between the point (x, y) and the\r\n * line segment (x1, y1) to (x2, y2).\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {number} x1 X1.\r\n * @param {number} y1 Y1.\r\n * @param {number} x2 X2.\r\n * @param {number} y2 Y2.\r\n * @return {number} Squared distance.\r\n */\r\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  if (dx !== 0 || dy !== 0) {\r\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\r\n    if (t > 1) {\r\n      x1 = x2;\r\n      y1 = y2;\r\n    } else if (t > 0) {\r\n      x1 += dx * t;\r\n      y1 += dy * t;\r\n    }\r\n  }\r\n  return squaredDistance(x, y, x1, y1);\r\n}\r\n\r\n/**\r\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\r\n * @param {number} x1 X1.\r\n * @param {number} y1 Y1.\r\n * @param {number} x2 X2.\r\n * @param {number} y2 Y2.\r\n * @return {number} Squared distance.\r\n */\r\nexport function squaredDistance(x1, y1, x2, y2) {\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Solves system of linear equations using Gaussian elimination method.\r\n *\r\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\r\n *                                     in row-major order.\r\n * @return {Array<number>|null} The resulting vector.\r\n */\r\nexport function solveLinearSystem(mat) {\r\n  const n = mat.length;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    // Find max in the i-th column (ignoring i - 1 first rows)\r\n    let maxRow = i;\r\n    let maxEl = Math.abs(mat[i][i]);\r\n    for (let r = i + 1; r < n; r++) {\r\n      const absValue = Math.abs(mat[r][i]);\r\n      if (absValue > maxEl) {\r\n        maxEl = absValue;\r\n        maxRow = r;\r\n      }\r\n    }\r\n\r\n    if (maxEl === 0) {\r\n      return null; // matrix is singular\r\n    }\r\n\r\n    // Swap max row with i-th (current) row\r\n    const tmp = mat[maxRow];\r\n    mat[maxRow] = mat[i];\r\n    mat[i] = tmp;\r\n\r\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\r\n    for (let j = i + 1; j < n; j++) {\r\n      const coef = -mat[j][i] / mat[i][i];\r\n      for (let k = i; k < n + 1; k++) {\r\n        if (i == k) {\r\n          mat[j][k] = 0;\r\n        } else {\r\n          mat[j][k] += coef * mat[i][k];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Solve Ax=b for upper triangular matrix A (mat)\r\n  const x = new Array(n);\r\n  for (let l = n - 1; l >= 0; l--) {\r\n    x[l] = mat[l][n] / mat[l][l];\r\n    for (let m = l - 1; m >= 0; m--) {\r\n      mat[m][n] -= mat[m][l] * x[l];\r\n    }\r\n  }\r\n  return x;\r\n}\r\n\r\n/**\r\n * Converts radians to to degrees.\r\n *\r\n * @param {number} angleInRadians Angle in radians.\r\n * @return {number} Angle in degrees.\r\n */\r\nexport function toDegrees(angleInRadians) {\r\n  return (angleInRadians * 180) / Math.PI;\r\n}\r\n\r\n/**\r\n * Converts degrees to radians.\r\n *\r\n * @param {number} angleInDegrees Angle in degrees.\r\n * @return {number} Angle in radians.\r\n */\r\nexport function toRadians(angleInDegrees) {\r\n  return (angleInDegrees * Math.PI) / 180;\r\n}\r\n\r\n/**\r\n * Returns the modulo of a / b, depending on the sign of b.\r\n *\r\n * @param {number} a Dividend.\r\n * @param {number} b Divisor.\r\n * @return {number} Modulo.\r\n */\r\nexport function modulo(a, b) {\r\n  const r = a % b;\r\n  return r * b < 0 ? r + b : r;\r\n}\r\n\r\n/**\r\n * Calculates the linearly interpolated value of x between a and b.\r\n *\r\n * @param {number} a Number\r\n * @param {number} b Number\r\n * @param {number} x Value to be interpolated.\r\n * @return {number} Interpolated value.\r\n */\r\nexport function lerp(a, b, x) {\r\n  return a + x * (b - a);\r\n}\r\n\r\n/**\r\n * Returns a number with a limited number of decimal digits.\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The input number with a limited number of decimal digits.\r\n */\r\nexport function toFixed(n, decimals) {\r\n  const factor = Math.pow(10, decimals);\r\n  return Math.round(n * factor) / factor;\r\n}\r\n\r\n/**\r\n * Rounds a number to the nearest integer value considering only the given number\r\n * of decimal digits (with rounding on the final digit).\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The nearest integer.\r\n */\r\nexport function round(n, decimals) {\r\n  return Math.round(toFixed(n, decimals));\r\n}\r\n\r\n/**\r\n * Rounds a number to the next smaller integer considering only the given number\r\n * of decimal digits (with rounding on the final digit).\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The next smaller integer.\r\n */\r\nexport function floor(n, decimals) {\r\n  return Math.floor(toFixed(n, decimals));\r\n}\r\n\r\n/**\r\n * Rounds a number to the next bigger integer considering only the given number\r\n * of decimal digits (with rounding on the final digit).\r\n * @param {number} n The input number.\r\n * @param {number} decimals The maximum number of decimal digits.\r\n * @return {number} The next bigger integer.\r\n */\r\nexport function ceil(n, decimals) {\r\n  return Math.ceil(toFixed(n, decimals));\r\n}\r\n","/**\r\n * @module CME2D/coordinate\r\n */\r\nimport {getWidth} from './extent.js';\r\nimport {modulo, toFixed} from './math.js';\r\nimport {padNumber} from './string.js';\r\n\r\n/**\r\n * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.\r\n * Example: `[16, 48]`.\r\n * @typedef {Array<number>} Coordinate\r\n * @api\r\n */\r\n\r\n/**\r\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\r\n * transforms it into a `{string}`.\r\n *\r\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\r\n * @api\r\n */\r\n\r\n/**\r\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\r\n * by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {add} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     add(coord, [-2, 4]);\r\n *     // coord is now [5.85, 51.983333]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {Coordinate} delta Delta.\r\n * @return {Coordinate} The input coordinate adjusted by\r\n * the given delta.\r\n * @api\r\n */\r\nexport function add(coordinate, delta) {\r\n  coordinate[0] += +delta[0];\r\n  coordinate[1] += +delta[1];\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Calculates the point closest to the passed coordinate on the passed circle.\r\n *\r\n * @param {Coordinate} coordinate The coordinate.\r\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\r\n * @return {Coordinate} Closest point on the circumference.\r\n */\r\nexport function closestOnCircle(coordinate, circle) {\r\n  const r = circle.getRadius();\r\n  const center = circle.getCenter();\r\n  const x0 = center[0];\r\n  const y0 = center[1];\r\n  const x1 = coordinate[0];\r\n  const y1 = coordinate[1];\r\n\r\n  let dx = x1 - x0;\r\n  const dy = y1 - y0;\r\n  if (dx === 0 && dy === 0) {\r\n    dx = 1;\r\n  }\r\n  const d = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  const x = x0 + (r * dx) / d;\r\n  const y = y0 + (r * dy) / d;\r\n\r\n  return [x, y];\r\n}\r\n\r\n/**\r\n * Calculates the point closest to the passed coordinate on the passed segment.\r\n * This is the foot of the perpendicular of the coordinate to the segment when\r\n * the foot is on the segment, or the closest segment coordinate when the foot\r\n * is outside the segment.\r\n *\r\n * @param {Coordinate} coordinate The coordinate.\r\n * @param {Array<Coordinate>} segment The two coordinates\r\n * of the segment.\r\n * @return {Coordinate} The foot of the perpendicular of\r\n * the coordinate to the segment.\r\n */\r\nexport function closestOnSegment(coordinate, segment) {\r\n  const x0 = coordinate[0];\r\n  const y0 = coordinate[1];\r\n  const start = segment[0];\r\n  const end = segment[1];\r\n  const x1 = start[0];\r\n  const y1 = start[1];\r\n  const x2 = end[0];\r\n  const y2 = end[1];\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  const along =\r\n    dx === 0 && dy === 0\r\n      ? 0\r\n      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\r\n  let x, y;\r\n  if (along <= 0) {\r\n    x = x1;\r\n    y = y1;\r\n  } else if (along >= 1) {\r\n    x = x2;\r\n    y = y2;\r\n  } else {\r\n    x = x1 + along * dx;\r\n    y = y1 + along * dy;\r\n  }\r\n  return [x, y];\r\n}\r\n\r\n/**\r\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\r\n * used to format\r\n * a {Coordinate} to a string.\r\n *\r\n * Example without specifying the fractional digits:\r\n *\r\n *     import {createStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const stringifyFunc = createStringXY();\r\n *     const out = stringifyFunc(coord);\r\n *     // out is now '8, 48'\r\n *\r\n * Example with explicitly specifying 2 fractional digits:\r\n *\r\n *     import {createStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const stringifyFunc = createStringXY(2);\r\n *     const out = stringifyFunc(coord);\r\n *     // out is now '7.85, 47.98'\r\n *\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {CoordinateFormat} Coordinate format.\r\n * @api\r\n */\r\nexport function createStringXY(fractionDigits) {\r\n  return (\r\n    /**\r\n     * @param {Coordinate} coordinate Coordinate.\r\n     * @return {string} String XY.\r\n     */\r\n    function (coordinate) {\r\n      return toStringXY(coordinate, fractionDigits);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {string} hemispheres Hemispheres.\r\n * @param {number} degrees Degrees.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} String.\r\n */\r\nexport function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\r\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\r\n  const x = Math.abs(3600 * normalizedDegrees);\r\n  const decimals = fractionDigits || 0;\r\n\r\n  let deg = Math.floor(x / 3600);\r\n  let min = Math.floor((x - deg * 3600) / 60);\r\n  let sec = toFixed(x - deg * 3600 - min * 60, decimals);\r\n\r\n  if (sec >= 60) {\r\n    sec = 0;\r\n    min += 1;\r\n  }\r\n\r\n  if (min >= 60) {\r\n    min = 0;\r\n    deg += 1;\r\n  }\r\n\r\n  let hdms = deg + '\\u00b0';\r\n  if (min !== 0 || sec !== 0) {\r\n    hdms += ' ' + padNumber(min, 2) + '\\u2032';\r\n  }\r\n  if (sec !== 0) {\r\n    hdms += ' ' + padNumber(sec, 2, decimals) + '\\u2033';\r\n  }\r\n  if (normalizedDegrees !== 0) {\r\n    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\r\n  }\r\n\r\n  return hdms;\r\n}\r\n\r\n/**\r\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\r\n * using the given string template. The strings `{x}` and `{y}` in the template\r\n * will be replaced with the first and second coordinate values respectively.\r\n *\r\n * Example without specifying the fractional digits:\r\n *\r\n *     import {format} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const template = 'Coordinate is ({x}|{y}).';\r\n *     const out = format(coord, template);\r\n *     // out is now 'Coordinate is (8|48).'\r\n *\r\n * Example explicitly specifying the fractional digits:\r\n *\r\n *     import {format} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const template = 'Coordinate is ({x}|{y}).';\r\n *     const out = format(coord, template, 2);\r\n *     // out is now 'Coordinate is (7.85|47.98).'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {string} template A template string with `{x}` and `{y}` placeholders\r\n *     that will be replaced by first and second coordinate values.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} Formatted coordinate.\r\n * @api\r\n */\r\nexport function format(coordinate, template, fractionDigits) {\r\n  if (coordinate) {\r\n    return template\r\n      .replace('{x}', coordinate[0].toFixed(fractionDigits))\r\n      .replace('{y}', coordinate[1].toFixed(fractionDigits));\r\n  }\r\n  return '';\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coordinate1 First coordinate.\r\n * @param {Coordinate} coordinate2 Second coordinate.\r\n * @return {boolean} The two coordinates are equal.\r\n */\r\nexport function equals(coordinate1, coordinate2) {\r\n  let equals = true;\r\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\r\n    if (coordinate1[i] != coordinate2[i]) {\r\n      equals = false;\r\n      break;\r\n    }\r\n  }\r\n  return equals;\r\n}\r\n\r\n/**\r\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\r\n * returned by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {rotate} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const rotateRadians = Math.PI / 2; // 90 degrees\r\n *     rotate(coord, rotateRadians);\r\n *     // coord is now [-47.983333, 7.85]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} angle Angle in radian.\r\n * @return {Coordinate} Coordinate.\r\n * @api\r\n */\r\nexport function rotate(coordinate, angle) {\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\r\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\r\n  coordinate[0] = x;\r\n  coordinate[1] = y;\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\r\n * by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {scale as scaleCoordinate} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const scale = 1.2;\r\n *     scaleCoordinate(coord, scale);\r\n *     // coord is now [9.42, 57.5799996]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} scale Scale factor.\r\n * @return {Coordinate} Coordinate.\r\n */\r\nexport function scale(coordinate, scale) {\r\n  coordinate[0] *= scale;\r\n  coordinate[1] *= scale;\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coord1 First coordinate.\r\n * @param {Coordinate} coord2 Second coordinate.\r\n * @return {number} Squared distance between coord1 and coord2.\r\n */\r\nexport function squaredDistance(coord1, coord2) {\r\n  const dx = coord1[0] - coord2[0];\r\n  const dy = coord1[1] - coord2[1];\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coord1 First coordinate.\r\n * @param {Coordinate} coord2 Second coordinate.\r\n * @return {number} Distance between coord1 and coord2.\r\n */\r\nexport function distance(coord1, coord2) {\r\n  return Math.sqrt(squaredDistance(coord1, coord2));\r\n}\r\n\r\n/**\r\n * Calculate the squared distance from a coordinate to a line segment.\r\n *\r\n * @param {Coordinate} coordinate Coordinate of the point.\r\n * @param {Array<Coordinate>} segment Line segment (2\r\n * coordinates).\r\n * @return {number} Squared distance from the point to the line segment.\r\n */\r\nexport function squaredDistanceToSegment(coordinate, segment) {\r\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\r\n}\r\n\r\n/**\r\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\r\n * seconds.\r\n *\r\n * Example without specifying fractional digits:\r\n *\r\n *     import {toStringHDMS} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringHDMS(coord);\r\n *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'\r\n *\r\n * Example explicitly specifying 1 fractional digit:\r\n *\r\n *     import {toStringHDMS} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringHDMS(coord, 1);\r\n *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} Hemisphere, degrees, minutes and seconds.\r\n * @api\r\n */\r\nexport function toStringHDMS(coordinate, fractionDigits) {\r\n  if (coordinate) {\r\n    return (\r\n      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +\r\n      ' ' +\r\n      degreesToStringHDMS('EW', coordinate[0], fractionDigits)\r\n    );\r\n  }\r\n  return '';\r\n}\r\n\r\n/**\r\n * Format a coordinate as a comma delimited string.\r\n *\r\n * Example without specifying fractional digits:\r\n *\r\n *     import {toStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringXY(coord);\r\n *     // out is now '8, 48'\r\n *\r\n * Example explicitly specifying 1 fractional digit:\r\n *\r\n *     import {toStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringXY(coord, 1);\r\n *     // out is now '7.8, 48.0'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} XY.\r\n * @api\r\n */\r\nexport function toStringXY(coordinate, fractionDigits) {\r\n  return format(coordinate, '{x}, {y}', fractionDigits);\r\n}\r\n\r\n/**\r\n * Modifies the provided coordinate in-place to be within the real world\r\n * extent. The lower projection extent boundary is inclusive, the upper one\r\n * exclusive.\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {Coordinate} The coordinate within the real world extent.\r\n */\r\nexport function wrapX(coordinate, projection) {\r\n  if (projection.canWrapX()) {\r\n    const worldWidth = getWidth(projection.getExtent());\r\n    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\r\n    if (worldsAway) {\r\n      coordinate[0] -= worldsAway * worldWidth;\r\n    }\r\n  }\r\n  return coordinate;\r\n}\r\n/**\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @param {number} [sourceExtentWidth] Width of the source extent.\r\n * @return {number} Offset in world widths.\r\n */\r\nexport function getWorldsAway(coordinate, projection, sourceExtentWidth) {\r\n  const projectionExtent = projection.getExtent();\r\n  let worldsAway = 0;\r\n  if (\r\n    projection.canWrapX() &&\r\n    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])\r\n  ) {\r\n    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);\r\n    worldsAway = Math.floor(\r\n      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth,\r\n    );\r\n  }\r\n  return worldsAway;\r\n}\r\n","/**\r\n * @module CME2D/sphere\r\n */\r\nimport {toDegrees, toRadians} from './math.js';\r\n\r\n/**\r\n * Object literal with options for the {@link getLength} or {@link getArea}\r\n * functions.\r\n * @typedef {Object} SphereMetricOptions\r\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\r\n * Projection of the  geometry.  By default, the geometry is assumed to be in\r\n * Web Mercator.\r\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\r\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\r\n * for the WGS84 ellipsoid is used.\r\n */\r\n\r\n/**\r\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\r\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\r\n * @type {number}\r\n */\r\nexport const DEFAULT_RADIUS = 6371008.8;\r\n\r\n/**\r\n * Get the great circle distance (in meters) between two geographic coordinates.\r\n * @param {Array} c1 Starting coordinate.\r\n * @param {Array} c2 Ending coordinate.\r\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\r\n *     mean radius using the WGS84 ellipsoid.\r\n * @return {number} The great circle distance between the points (in meters).\r\n * @api\r\n */\r\nexport function getDistance(c1, c2, radius) {\r\n  radius = radius || DEFAULT_RADIUS;\r\n  const lat1 = toRadians(c1[1]);\r\n  const lat2 = toRadians(c2[1]);\r\n  const deltaLatBy2 = (lat2 - lat1) / 2;\r\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\r\n  const a =\r\n    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\r\n    Math.sin(deltaLonBy2) *\r\n      Math.sin(deltaLonBy2) *\r\n      Math.cos(lat1) *\r\n      Math.cos(lat2);\r\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n}\r\n\r\n/**\r\n * Get the cumulative great circle length of linestring coordinates (geographic).\r\n * @param {Array} coordinates Linestring coordinates.\r\n * @param {number} radius The sphere radius to use.\r\n * @return {number} The length (in meters).\r\n */\r\nfunction getLengthInternal(coordinates, radius) {\r\n  let length = 0;\r\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\r\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\r\n  }\r\n  return length;\r\n}\r\n\r\n/**\r\n * Get the spherical length of a geometry.  This length is the sum of the\r\n * great circle distances between coordinates.  For polygons, the length is\r\n * the sum of all rings.  For points, the length is zero.  For multi-part\r\n * geometries, the length is the sum of the length of each part.\r\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\r\n * @param {SphereMetricOptions} [options] Options for the\r\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\r\n * You can change this by providing a `projection` option.\r\n * @return {number} The spherical length (in meters).\r\n * @api\r\n */\r\nexport function getLength(geometry, options) {\r\n  options = options || {};\r\n  const radius = options.radius || DEFAULT_RADIUS;\r\n  const projection = options.projection || 'EPSG:3857';\r\n  const type = geometry.getType();\r\n  if (type !== 'GeometryCollection') {\r\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\r\n  }\r\n  let length = 0;\r\n  let coordinates, coords, i, ii, j, jj;\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint': {\r\n      break;\r\n    }\r\n    case 'LineString':\r\n    case 'LinearRing': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      length = getLengthInternal(coordinates, radius);\r\n      break;\r\n    }\r\n    case 'MultiLineString':\r\n    case 'Polygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        length += getLengthInternal(coordinates[i], radius);\r\n      }\r\n      break;\r\n    }\r\n    case 'MultiPolygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coords = coordinates[i];\r\n        for (j = 0, jj = coords.length; j < jj; ++j) {\r\n          length += getLengthInternal(coords[j], radius);\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 'GeometryCollection': {\r\n      const geometries =\r\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries();\r\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\r\n        length += getLength(geometries[i], options);\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error('Unsupported geometry type: ' + type);\r\n    }\r\n  }\r\n  return length;\r\n}\r\n\r\n/**\r\n * Returns the spherical area for a list of coordinates.\r\n *\r\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\r\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\r\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\r\n * Laboratory, Pasadena, CA, June 2007\r\n *\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\r\n * ring. If the ring is oriented clockwise, the area will be positive,\r\n * otherwise it will be negative.\r\n * @param {number} radius The sphere radius.\r\n * @return {number} Area (in square meters).\r\n */\r\nfunction getAreaInternal(coordinates, radius) {\r\n  let area = 0;\r\n  const len = coordinates.length;\r\n  let x1 = coordinates[len - 1][0];\r\n  let y1 = coordinates[len - 1][1];\r\n  for (let i = 0; i < len; i++) {\r\n    const x2 = coordinates[i][0];\r\n    const y2 = coordinates[i][1];\r\n    area +=\r\n      toRadians(x2 - x1) *\r\n      (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return (area * radius * radius) / 2.0;\r\n}\r\n\r\n/**\r\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\r\n * that polygon edges are segments of great circles on a sphere.\r\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\r\n * @param {SphereMetricOptions} [options] Options for the area\r\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\r\n *     You can change this by providing a `projection` option.\r\n * @return {number} The spherical area (in square meters).\r\n * @api\r\n */\r\nexport function getArea(geometry, options) {\r\n  options = options || {};\r\n  const radius = options.radius || DEFAULT_RADIUS;\r\n  const projection = options.projection || 'EPSG:3857';\r\n  const type = geometry.getType();\r\n  if (type !== 'GeometryCollection') {\r\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\r\n  }\r\n  let area = 0;\r\n  let coordinates, coords, i, ii, j, jj;\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n    case 'LineString':\r\n    case 'MultiLineString':\r\n    case 'LinearRing': {\r\n      break;\r\n    }\r\n    case 'Polygon': {\r\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\r\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\r\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\r\n      }\r\n      break;\r\n    }\r\n    case 'MultiPolygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coords = coordinates[i];\r\n        area += Math.abs(getAreaInternal(coords[0], radius));\r\n        for (j = 1, jj = coords.length; j < jj; ++j) {\r\n          area -= Math.abs(getAreaInternal(coords[j], radius));\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 'GeometryCollection': {\r\n      const geometries =\r\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries();\r\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\r\n        area += getArea(geometries[i], options);\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error('Unsupported geometry type: ' + type);\r\n    }\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * Returns the coordinate at the given distance and bearing from `c1`.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\r\n * @param {number} distance The great-circle distance between the origin\r\n *     point and the target point.\r\n * @param {number} bearing The bearing (in radians).\r\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\r\n *     mean radius using the WGS84 ellipsoid.\r\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\r\n */\r\nexport function offset(c1, distance, bearing, radius) {\r\n  radius = radius || DEFAULT_RADIUS;\r\n  const lat1 = toRadians(c1[1]);\r\n  const lon1 = toRadians(c1[0]);\r\n  const dByR = distance / radius;\r\n  const lat = Math.asin(\r\n    Math.sin(lat1) * Math.cos(dByR) +\r\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing),\r\n  );\r\n  const lon =\r\n    lon1 +\r\n    Math.atan2(\r\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\r\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat),\r\n    );\r\n  return [toDegrees(lon), toDegrees(lat)];\r\n}\r\n","/**\r\n * @module CME2D/console\r\n */\r\n\r\n/**\r\n * @typedef {'info'|'warn'|'error'|'none'} Level\r\n */\r\n\r\n/**\r\n * @type {Object<Level, number>}\r\n */\r\nconst levels = {\r\n  info: 1,\r\n  warn: 2,\r\n  error: 3,\r\n  none: 4,\r\n};\r\n\r\n/**\r\n * @type {number}\r\n */\r\nlet level = levels.info;\r\n\r\n/**\r\n * Set the logging level.  By default, the level is set to 'info' and all\r\n * messages will be logged.  Set to 'warn' to only display warnings and errors.\r\n * Set to 'error' to only display errors.  Set to 'none' to silence all messages.\r\n *\r\n * @param {Level} l The new level.\r\n */\r\nexport function setLevel(l) {\r\n  level = levels[l];\r\n}\r\n\r\n/**\r\n * @param  {...any} args Arguments to log\r\n */\r\nexport function log(...args) {\r\n  if (level > levels.info) {\r\n    return;\r\n  }\r\n  console.log(...args); // eslint-disable-line no-console\r\n}\r\n\r\n/**\r\n * @param  {...any} args Arguments to log\r\n */\r\nexport function warn(...args) {\r\n  if (level > levels.warn) {\r\n    return;\r\n  }\r\n  console.warn(...args); // eslint-disable-line no-console\r\n}\r\n\r\n/**\r\n * @param  {...any} args Arguments to log\r\n */\r\nexport function error(...args) {\r\n  if (level > levels.error) {\r\n    return;\r\n  }\r\n  console.error(...args); // eslint-disable-line no-console\r\n}\r\n","/**\r\n * @module CME2D/proj\r\n */\r\n\r\n/**\r\n * The ol/proj module stores:\r\n * * a list of {@link module:ol/proj/Projection~Projection}\r\n * objects, one for each projection supported by the application\r\n * * a list of transform functions needed to convert coordinates in one projection\r\n * into another.\r\n *\r\n * The static functions are the methods used to maintain these.\r\n * Each transform function can handle not only simple coordinate pairs, but also\r\n * large arrays of coordinates such as vector geometries.\r\n *\r\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\r\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\r\n * for example by Bing Maps or OpenStreetMap), together with the relevant\r\n * transform functions.\r\n *\r\n * Additional transforms may be added by using the http://proj4js.org/\r\n * library (version 2.2 or later). You can use the full build supplied by\r\n * Proj4js, or create a custom build to support those projections you need; see\r\n * the Proj4js website for how to do this. You also need the Proj4js definitions\r\n * for the required projections. These definitions can be obtained from\r\n * https://epsg.io/, and are a JS function, so can be loaded in a script\r\n * tag (as in the examples) or pasted into your application.\r\n *\r\n * After all required projection definitions are added to proj4's registry (by\r\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\r\n * package. Existing transforms are not changed by this function. See\r\n * examples/wms-image-custom-proj for an example of this.\r\n *\r\n * Additional projection definitions can be registered with `proj4.defs()` any\r\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\r\n * know in advance what projections are needed, you can initially load minimal\r\n * support and then load whichever are requested.\r\n *\r\n * Note that Proj4js does not support projection extents. If you want to add\r\n * one for creating default tile grids, you can add it after the Projection\r\n * object has been created with `setExtent`, for example,\r\n * `get('EPSG:1234').setExtent(extent)`.\r\n *\r\n * In addition to Proj4js support, any transform functions can be added with\r\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\r\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\r\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\r\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\r\n * examples/wms-custom-proj for an example of this.\r\n *\r\n * Note that if no transforms are needed and you only need to define the\r\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\r\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\r\n * this.\r\n */\r\nimport Projection from './proj/Projection.js';\r\nimport {\r\n  PROJECTIONS as EPSG3857_PROJECTIONS,\r\n  fromEPSG4326,\r\n  toEPSG4326,\r\n} from './proj/epsg3857.js';\r\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\r\nimport {METERS_PER_UNIT} from './proj/Units.js';\r\nimport {\r\n  add as addProj,\r\n  clear as clearProj,\r\n  get as getProj,\r\n} from './proj/projections.js';\r\nimport {\r\n  add as addTransformFunc,\r\n  clear as clearTransformFuncs,\r\n  get as getTransformFunc,\r\n} from './proj/transforms.js';\r\nimport {applyTransform, getWidth} from './extent.js';\r\nimport {clamp, modulo} from './math.js';\r\nimport {equals, getWorldsAway} from './coordinate.js';\r\nimport {getDistance} from './sphere.js';\r\nimport {warn} from './console.js';\r\n\r\n/**\r\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\r\n * string or undefined.\r\n * @typedef {Projection|string|undefined} ProjectionLike\r\n * @api\r\n */\r\n\r\n/**\r\n * A transform function accepts an array of input coordinate values, an optional\r\n * output array, and an optional dimension (default should be 2).  The function\r\n * transforms the input coordinate values, populates the output array, and\r\n * returns the output array.\r\n *\r\n * @typedef {function(Array<number>, Array<number>=, number=, number=): Array<number>} TransformFunction\r\n * @api\r\n */\r\n\r\nexport {METERS_PER_UNIT};\r\n\r\nexport {Projection};\r\n\r\nlet showCoordinateWarning = true;\r\n\r\n/**\r\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\r\n */\r\nexport function disableCoordinateWarning(disable) {\r\n  const hide = disable === undefined ? true : disable;\r\n  showCoordinateWarning = !hide;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} input Input coordinate array.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @return {Array<number>} Output coordinate array (new array, same coordinate\r\n *     values).\r\n */\r\nexport function cloneTransform(input, output) {\r\n  if (output !== undefined) {\r\n    for (let i = 0, ii = input.length; i < ii; ++i) {\r\n      output[i] = input[i];\r\n    }\r\n    output = output;\r\n  } else {\r\n    output = input.slice();\r\n  }\r\n  return output;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} input Input coordinate array.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @return {Array<number>} Input coordinate array (same array as input).\r\n */\r\nexport function identityTransform(input, output) {\r\n  if (output !== undefined && input !== output) {\r\n    for (let i = 0, ii = input.length; i < ii; ++i) {\r\n      output[i] = input[i];\r\n    }\r\n    input = output;\r\n  }\r\n  return input;\r\n}\r\n\r\n/**\r\n * Add a Projection object to the list of supported projections that can be\r\n * looked up by their code.\r\n *\r\n * @param {Projection} projection Projection instance.\r\n * @api\r\n */\r\nexport function addProjection(projection) {\r\n  addProj(projection.getCode(), projection);\r\n  addTransformFunc(projection, projection, cloneTransform);\r\n}\r\n\r\n/**\r\n * @param {Array<Projection>} projections Projections.\r\n */\r\nexport function addProjections(projections) {\r\n  projections.forEach(addProjection);\r\n}\r\n\r\n/**\r\n * Fetches a Projection object for the code specified.\r\n *\r\n * @param {ProjectionLike} projectionLike Either a code string which is\r\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\r\n *     existing projection object, or undefined.\r\n * @return {Projection|null} Projection object, or null if not in list.\r\n * @api\r\n */\r\nexport function get(projectionLike) {\r\n  return typeof projectionLike === 'string'\r\n    ? getProj(/** @type {string} */ (projectionLike))\r\n    : /** @type {Projection} */ (projectionLike) || null;\r\n}\r\n\r\n/**\r\n * Get the resolution of the point in degrees or distance units.\r\n * For projections with degrees as the unit this will simply return the\r\n * provided resolution. For other projections the point resolution is\r\n * by default estimated by transforming the `point` pixel to EPSG:4326,\r\n * measuring its width and height on the normal sphere,\r\n * and taking the average of the width and height.\r\n * A custom function can be provided for a specific projection, either\r\n * by setting the `getPointResolution` option in the\r\n * {@link module:ol/proj/Projection~Projection} constructor or by using\r\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\r\n * projection object.\r\n * @param {ProjectionLike} projection The projection.\r\n * @param {number} resolution Nominal resolution in projection units.\r\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\r\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\r\n * Default is the projection's units.\r\n * @return {number} Point resolution.\r\n * @api\r\n */\r\nexport function getPointResolution(projection, resolution, point, units) {\r\n  projection = get(projection);\r\n  let pointResolution;\r\n  const getter = projection.getPointResolutionFunc();\r\n  if (getter) {\r\n    pointResolution = getter(resolution, point);\r\n    if (units && units !== projection.getUnits()) {\r\n      const metersPerUnit = projection.getMetersPerUnit();\r\n      if (metersPerUnit) {\r\n        pointResolution =\r\n          (pointResolution * metersPerUnit) / METERS_PER_UNIT[units];\r\n      }\r\n    }\r\n  } else {\r\n    const projUnits = projection.getUnits();\r\n    if ((projUnits == 'degrees' && !units) || units == 'degrees') {\r\n      pointResolution = resolution;\r\n    } else {\r\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\r\n      // measuring its width and height on the normal sphere, and taking the\r\n      // average of the width and height.\r\n      const toEPSG4326 = getTransformFromProjections(\r\n        projection,\r\n        get('EPSG:4326'),\r\n      );\r\n      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {\r\n        // no transform is available\r\n        pointResolution = resolution * projection.getMetersPerUnit();\r\n      } else {\r\n        let vertices = [\r\n          point[0] - resolution / 2,\r\n          point[1],\r\n          point[0] + resolution / 2,\r\n          point[1],\r\n          point[0],\r\n          point[1] - resolution / 2,\r\n          point[0],\r\n          point[1] + resolution / 2,\r\n        ];\r\n        vertices = toEPSG4326(vertices, vertices, 2);\r\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\r\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\r\n        pointResolution = (width + height) / 2;\r\n      }\r\n      const metersPerUnit = units\r\n        ? METERS_PER_UNIT[units]\r\n        : projection.getMetersPerUnit();\r\n      if (metersPerUnit !== undefined) {\r\n        pointResolution /= metersPerUnit;\r\n      }\r\n    }\r\n  }\r\n  return pointResolution;\r\n}\r\n\r\n/**\r\n * Registers transformation functions that don't alter coordinates. Those allow\r\n * to transform between projections with equal meaning.\r\n *\r\n * @param {Array<Projection>} projections Projections.\r\n * @api\r\n */\r\nexport function addEquivalentProjections(projections) {\r\n  addProjections(projections);\r\n  projections.forEach(function (source) {\r\n    projections.forEach(function (destination) {\r\n      if (source !== destination) {\r\n        addTransformFunc(source, destination, cloneTransform);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Registers transformation functions to convert coordinates in any projection\r\n * in projection1 to any projection in projection2.\r\n *\r\n * @param {Array<Projection>} projections1 Projections with equal\r\n *     meaning.\r\n * @param {Array<Projection>} projections2 Projections with equal\r\n *     meaning.\r\n * @param {TransformFunction} forwardTransform Transformation from any\r\n *   projection in projection1 to any projection in projection2.\r\n * @param {TransformFunction} inverseTransform Transform from any projection\r\n *   in projection2 to any projection in projection1..\r\n */\r\nexport function addEquivalentTransforms(\r\n  projections1,\r\n  projections2,\r\n  forwardTransform,\r\n  inverseTransform,\r\n) {\r\n  projections1.forEach(function (projection1) {\r\n    projections2.forEach(function (projection2) {\r\n      addTransformFunc(projection1, projection2, forwardTransform);\r\n      addTransformFunc(projection2, projection1, inverseTransform);\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Clear all cached projections and transforms.\r\n */\r\nexport function clearAllProjections() {\r\n  clearProj();\r\n  clearTransformFuncs();\r\n}\r\n\r\n/**\r\n * @param {Projection|string|undefined} projection Projection.\r\n * @param {string} defaultCode Default code.\r\n * @return {Projection} Projection.\r\n */\r\nexport function createProjection(projection, defaultCode) {\r\n  if (!projection) {\r\n    return get(defaultCode);\r\n  }\r\n  if (typeof projection === 'string') {\r\n    return get(projection);\r\n  }\r\n  return /** @type {Projection} */ (projection);\r\n}\r\n\r\n/**\r\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\r\n * function.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\r\n *     transform.\r\n * @return {TransformFunction} Transform function.\r\n */\r\nexport function createTransformFromCoordinateTransform(coordTransform) {\r\n  return (\r\n    /**\r\n     * @param {Array<number>} input Input.\r\n     * @param {Array<number>} [output] Output.\r\n     * @param {number} [dimension] Dimensions that should be transformed.\r\n     * @param {number} [stride] Stride.\r\n     * @return {Array<number>} Output.\r\n     */\r\n    function (input, output, dimension, stride) {\r\n      const length = input.length;\r\n      dimension = dimension !== undefined ? dimension : 2;\r\n      stride = stride ?? dimension;\r\n      output = output !== undefined ? output : new Array(length);\r\n      for (let i = 0; i < length; i += stride) {\r\n        const point = coordTransform(input.slice(i, i + dimension));\r\n        const pointLength = point.length;\r\n        for (let j = 0, jj = stride; j < jj; ++j) {\r\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\r\n        }\r\n      }\r\n      return output;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Registers coordinate transform functions to convert coordinates between the\r\n * source projection and the destination projection.\r\n * The forward and inverse functions convert coordinate pairs; this function\r\n * converts these into the functions used internally which also handle\r\n * extents and coordinate arrays.\r\n *\r\n * @param {ProjectionLike} source Source projection.\r\n * @param {ProjectionLike} destination Destination projection.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\r\n *     function (that is, from the source projection to the destination\r\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\r\n *     the transformed {@link module:ol/coordinate~Coordinate}.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\r\n *     function (that is, from the destination projection to the source\r\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\r\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\r\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\r\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\r\n *     source.\r\n * @api\r\n */\r\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\r\n  const sourceProj = get(source);\r\n  const destProj = get(destination);\r\n  addTransformFunc(\r\n    sourceProj,\r\n    destProj,\r\n    createTransformFromCoordinateTransform(forward),\r\n  );\r\n  addTransformFunc(\r\n    destProj,\r\n    sourceProj,\r\n    createTransformFromCoordinateTransform(inverse),\r\n  );\r\n}\r\n\r\n/**\r\n * Transforms a coordinate from longitude/latitude to a different projection.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\r\n *     an array with longitude as 1st and latitude as 2nd element.\r\n * @param {ProjectionLike} [projection] Target projection. The\r\n *     default is Web Mercator, i.e. 'EPSG:3857'.\r\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\r\n * @api\r\n */\r\nexport function fromLonLat(coordinate, projection) {\r\n  disableCoordinateWarning();\r\n  return transform(\r\n    coordinate,\r\n    'EPSG:4326',\r\n    projection !== undefined ? projection : 'EPSG:3857',\r\n  );\r\n}\r\n\r\n/**\r\n * Transforms a coordinate to longitude/latitude.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\r\n * @param {ProjectionLike} [projection] Projection of the coordinate.\r\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\r\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\r\n *     with longitude as 1st and latitude as 2nd element.\r\n * @api\r\n */\r\nexport function toLonLat(coordinate, projection) {\r\n  const lonLat = transform(\r\n    coordinate,\r\n    projection !== undefined ? projection : 'EPSG:3857',\r\n    'EPSG:4326',\r\n  );\r\n  const lon = lonLat[0];\r\n  if (lon < -180 || lon > 180) {\r\n    lonLat[0] = modulo(lon + 180, 360) - 180;\r\n  }\r\n  return lonLat;\r\n}\r\n\r\n/**\r\n * Checks if two projections are the same, that is every coordinate in one\r\n * projection does represent the same geographic point as the same coordinate in\r\n * the other projection.\r\n *\r\n * @param {Projection} projection1 Projection 1.\r\n * @param {Projection} projection2 Projection 2.\r\n * @return {boolean} Equivalent.\r\n * @api\r\n */\r\nexport function equivalent(projection1, projection2) {\r\n  if (projection1 === projection2) {\r\n    return true;\r\n  }\r\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\r\n  if (projection1.getCode() === projection2.getCode()) {\r\n    return equalUnits;\r\n  }\r\n  const transformFunc = getTransformFromProjections(projection1, projection2);\r\n  return transformFunc === cloneTransform && equalUnits;\r\n}\r\n\r\n/**\r\n * Searches in the list of transform functions for the function for converting\r\n * coordinates from the source projection to the destination projection.\r\n *\r\n * @param {Projection} sourceProjection Source Projection object.\r\n * @param {Projection} destinationProjection Destination Projection\r\n *     object.\r\n * @return {TransformFunction} Transform function.\r\n */\r\nexport function getTransformFromProjections(\r\n  sourceProjection,\r\n  destinationProjection,\r\n) {\r\n  const sourceCode = sourceProjection.getCode();\r\n  const destinationCode = destinationProjection.getCode();\r\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\r\n  if (!transformFunc) {\r\n    transformFunc = identityTransform;\r\n  }\r\n  return transformFunc;\r\n}\r\n\r\n/**\r\n * Given the projection-like objects, searches for a transformation\r\n * function to convert a coordinates array from the source projection to the\r\n * destination projection.\r\n *\r\n * @param {ProjectionLike} source Source.\r\n * @param {ProjectionLike} destination Destination.\r\n * @return {TransformFunction} Transform function.\r\n * @api\r\n */\r\nexport function getTransform(source, destination) {\r\n  const sourceProjection = get(source);\r\n  const destinationProjection = get(destination);\r\n  return getTransformFromProjections(sourceProjection, destinationProjection);\r\n}\r\n\r\n/**\r\n * Transforms a coordinate from source projection to destination projection.\r\n * This returns a new coordinate (and does not modify the original).\r\n *\r\n * See {@link module:ol/proj.transformExtent} for extent transformation.\r\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\r\n * subclasses for geometry transforms.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {ProjectionLike} source Source projection-like.\r\n * @param {ProjectionLike} destination Destination projection-like.\r\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\r\n * @api\r\n */\r\nexport function transform(coordinate, source, destination) {\r\n  const transformFunc = getTransform(source, destination);\r\n  return transformFunc(coordinate, undefined, coordinate.length);\r\n}\r\n\r\n/**\r\n * Transforms an extent from source projection to destination projection.  This\r\n * returns a new extent (and does not modify the original).\r\n *\r\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\r\n * @param {ProjectionLike} source Source projection-like.\r\n * @param {ProjectionLike} destination Destination projection-like.\r\n * @param {number} [stops] Number of stops per side used for the transform.\r\n * By default only the corners are used.\r\n * @return {import(\"./extent.js\").Extent} The transformed extent.\r\n * @api\r\n */\r\nexport function transformExtent(extent, source, destination, stops) {\r\n  const transformFunc = getTransform(source, destination);\r\n  return applyTransform(extent, transformFunc, undefined, stops);\r\n}\r\n\r\n/**\r\n * Transforms the given point to the destination projection.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\r\n * @param {Projection} sourceProjection Source projection.\r\n * @param {Projection} destinationProjection Destination projection.\r\n * @return {import(\"./coordinate.js\").Coordinate} Point.\r\n */\r\nexport function transformWithProjections(\r\n  point,\r\n  sourceProjection,\r\n  destinationProjection,\r\n) {\r\n  const transformFunc = getTransformFromProjections(\r\n    sourceProjection,\r\n    destinationProjection,\r\n  );\r\n  return transformFunc(point);\r\n}\r\n\r\n/**\r\n * @type {Projection|null}\r\n */\r\nlet userProjection = null;\r\n\r\n/**\r\n * Set the projection for coordinates supplied from and returned by API methods.\r\n * This includes all API methods except for those interacting with tile grids,\r\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\r\n * @param {ProjectionLike} projection The user projection.\r\n * @api\r\n */\r\nexport function setUserProjection(projection) {\r\n  userProjection = get(projection);\r\n}\r\n\r\n/**\r\n * Clear the user projection if set.\r\n * @api\r\n */\r\nexport function clearUserProjection() {\r\n  userProjection = null;\r\n}\r\n\r\n/**\r\n * Get the projection for coordinates supplied from and returned by API methods.\r\n * @return {Projection|null} The user projection (or null if not set).\r\n * @api\r\n */\r\nexport function getUserProjection() {\r\n  return userProjection;\r\n}\r\n\r\n/**\r\n * Use geographic coordinates (WGS-84 datum) in API methods.\r\n * This includes all API methods except for those interacting with tile grids,\r\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\r\n * @api\r\n */\r\nexport function useGeographic() {\r\n  setUserProjection('EPSG:4326');\r\n}\r\n\r\n/**\r\n * Return a coordinate transformed into the user projection.  If no user projection\r\n * is set, the original coordinate is returned.\r\n * @param {Array<number>} coordinate Input coordinate.\r\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\r\n * @return {Array<number>} The input coordinate in the user projection.\r\n */\r\nexport function toUserCoordinate(coordinate, sourceProjection) {\r\n  if (!userProjection) {\r\n    return coordinate;\r\n  }\r\n  return transform(coordinate, sourceProjection, userProjection);\r\n}\r\n\r\n/**\r\n * Return a coordinate transformed from the user projection.  If no user projection\r\n * is set, the original coordinate is returned.\r\n * @param {Array<number>} coordinate Input coordinate.\r\n * @param {ProjectionLike} destProjection The destination projection.\r\n * @return {Array<number>} The input coordinate transformed.\r\n */\r\nexport function fromUserCoordinate(coordinate, destProjection) {\r\n  if (!userProjection) {\r\n    if (\r\n      showCoordinateWarning &&\r\n      !equals(coordinate, [0, 0]) &&\r\n      coordinate[0] >= -180 &&\r\n      coordinate[0] <= 180 &&\r\n      coordinate[1] >= -90 &&\r\n      coordinate[1] <= 90\r\n    ) {\r\n      showCoordinateWarning = false;\r\n      warn(\r\n        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.',\r\n      );\r\n    }\r\n    return coordinate;\r\n  }\r\n  return transform(coordinate, userProjection, destProjection);\r\n}\r\n\r\n/**\r\n * Return an extent transformed into the user projection.  If no user projection\r\n * is set, the original extent is returned.\r\n * @param {import(\"./extent.js\").Extent} extent Input extent.\r\n * @param {ProjectionLike} sourceProjection The input extent projection.\r\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\r\n */\r\nexport function toUserExtent(extent, sourceProjection) {\r\n  if (!userProjection) {\r\n    return extent;\r\n  }\r\n  return transformExtent(extent, sourceProjection, userProjection);\r\n}\r\n\r\n/**\r\n * Return an extent transformed from the user projection.  If no user projection\r\n * is set, the original extent is returned.\r\n * @param {import(\"./extent.js\").Extent} extent Input extent.\r\n * @param {ProjectionLike} destProjection The destination projection.\r\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\r\n */\r\nexport function fromUserExtent(extent, destProjection) {\r\n  if (!userProjection) {\r\n    return extent;\r\n  }\r\n  return transformExtent(extent, userProjection, destProjection);\r\n}\r\n\r\n/**\r\n * Return the resolution in user projection units per pixel. If no user projection\r\n * is set, or source or user projection are missing units, the original resolution\r\n * is returned.\r\n * @param {number} resolution Resolution in input projection units per pixel.\r\n * @param {ProjectionLike} sourceProjection The input projection.\r\n * @return {number} Resolution in user projection units per pixel.\r\n */\r\nexport function toUserResolution(resolution, sourceProjection) {\r\n  if (!userProjection) {\r\n    return resolution;\r\n  }\r\n  const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();\r\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\r\n  return sourceMetersPerUnit && userMetersPerUnit\r\n    ? (resolution * sourceMetersPerUnit) / userMetersPerUnit\r\n    : resolution;\r\n}\r\n\r\n/**\r\n * Return the resolution in user projection units per pixel. If no user projection\r\n * is set, or source or user projection are missing units, the original resolution\r\n * is returned.\r\n * @param {number} resolution Resolution in user projection units per pixel.\r\n * @param {ProjectionLike} destProjection The destination projection.\r\n * @return {number} Resolution in destination projection units per pixel.\r\n */\r\nexport function fromUserResolution(resolution, destProjection) {\r\n  if (!userProjection) {\r\n    return resolution;\r\n  }\r\n  const destMetersPerUnit = get(destProjection).getMetersPerUnit();\r\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\r\n  return destMetersPerUnit && userMetersPerUnit\r\n    ? (resolution * userMetersPerUnit) / destMetersPerUnit\r\n    : resolution;\r\n}\r\n\r\n/**\r\n * Creates a safe coordinate transform function from a coordinate transform function.\r\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\r\n * and that coordinates exceeding the source projection validity extent's range will be\r\n * clamped to the validity range.\r\n * @param {Projection} sourceProj Source projection.\r\n * @param {Projection} destProj Destination projection.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destination).\r\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destination).\r\n */\r\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\r\n  return function (coord) {\r\n    let transformed, worldsAway;\r\n    if (sourceProj.canWrapX()) {\r\n      const sourceExtent = sourceProj.getExtent();\r\n      const sourceExtentWidth = getWidth(sourceExtent);\r\n      coord = coord.slice(0);\r\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\r\n      if (worldsAway) {\r\n        // Move x to the real world\r\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\r\n      }\r\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\r\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\r\n      transformed = transform(coord);\r\n    } else {\r\n      transformed = transform(coord);\r\n    }\r\n    if (worldsAway && destProj.canWrapX()) {\r\n      // Move transformed coordinate back to the offset world\r\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\r\n    }\r\n    return transformed;\r\n  };\r\n}\r\n\r\n/**\r\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\r\n * by when this module is executed and should only need to be called again after\r\n * `clearAllProjections()` is called (e.g. in tests).\r\n */\r\nexport function addCommon() {\r\n  // Add transformations that don't alter coordinates to convert within set of\r\n  // projections with equal meaning.\r\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\r\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\r\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\r\n  // coordinates and back.\r\n  addEquivalentTransforms(\r\n    EPSG4326_PROJECTIONS,\r\n    EPSG3857_PROJECTIONS,\r\n    fromEPSG4326,\r\n    toEPSG4326,\r\n  );\r\n}\r\n\r\naddCommon();\r\n","/**\r\n * @module CME2D/reproj/Triangulation\r\n */\r\nimport {\r\n  boundingExtent,\r\n  createEmpty,\r\n  extendCoordinate,\r\n  getArea,\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getTopLeft,\r\n  getTopRight,\r\n  getWidth,\r\n  intersects,\r\n} from '../extent.js';\r\nimport {getTransform} from '../proj.js';\r\nimport {modulo} from '../math.js';\r\n\r\n/**\r\n * Single triangle; consists of 3 source points and 3 target points.\r\n * @typedef {Object} Triangle\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\r\n */\r\n\r\n/**\r\n * Maximum number of subdivision steps during raster reprojection triangulation.\r\n * Prevents high memory usage and large number of proj4 calls (for certain\r\n * transformations and areas). At most `2*(2^this)` triangles are created for\r\n * each triangulated extent (tile/image).\r\n * @type {number}\r\n */\r\nconst MAX_SUBDIVISION = 10;\r\n\r\n/**\r\n * Maximum allowed size of triangle relative to world width. When transforming\r\n * corners of world extent between certain projections, the resulting\r\n * triangulation seems to have zero error and no subdivision is performed. If\r\n * the triangle width is more than this (relative to world width; 0-1),\r\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\r\n * @type {number}\r\n */\r\nconst MAX_TRIANGLE_WIDTH = 0.25;\r\n\r\n/**\r\n * @classdesc\r\n * Class containing triangulation of the given target extent.\r\n * Used for determining source data and the reprojection itself.\r\n */\r\nclass Triangulation {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\r\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\r\n   * @param {number} errorThreshold Acceptable error (in source units).\r\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    targetProj,\r\n    targetExtent,\r\n    maxSourceExtent,\r\n    errorThreshold,\r\n    destinationResolution,\r\n  ) {\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.sourceProj_ = sourceProj;\r\n\r\n    /**\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     * @private\r\n     */\r\n    this.targetProj_ = targetProj;\r\n\r\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\r\n    let transformInvCache = {};\r\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\r\n\r\n    /**\r\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\r\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\r\n     * @private\r\n     */\r\n    this.transformInv_ = function (c) {\r\n      const key = c[0] + '/' + c[1];\r\n      if (!transformInvCache[key]) {\r\n        transformInvCache[key] = transformInv(c);\r\n      }\r\n      return transformInvCache[key];\r\n    };\r\n\r\n    /**\r\n     * @type {import(\"../extent.js\").Extent}\r\n     * @private\r\n     */\r\n    this.maxSourceExtent_ = maxSourceExtent;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\r\n\r\n    /**\r\n     * @type {Array<Triangle>}\r\n     * @private\r\n     */\r\n    this.triangles_ = [];\r\n\r\n    /**\r\n     * Indicates that the triangulation crosses edge of the source projection.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.wrapsXInSource_ = false;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.canWrapXInSource_ =\r\n      this.sourceProj_.canWrapX() &&\r\n      !!maxSourceExtent &&\r\n      !!this.sourceProj_.getExtent() &&\r\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\r\n      ? getWidth(this.sourceProj_.getExtent())\r\n      : null;\r\n\r\n    /**\r\n     * @type {?number}\r\n     * @private\r\n     */\r\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\r\n      ? getWidth(this.targetProj_.getExtent())\r\n      : null;\r\n\r\n    const destinationTopLeft = getTopLeft(targetExtent);\r\n    const destinationTopRight = getTopRight(targetExtent);\r\n    const destinationBottomRight = getBottomRight(targetExtent);\r\n    const destinationBottomLeft = getBottomLeft(targetExtent);\r\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\r\n    const sourceTopRight = this.transformInv_(destinationTopRight);\r\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\r\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\r\n\r\n    /*\r\n     * The maxSubdivision controls how many splittings of the target area can\r\n     * be done. The idea here is to do a linear mapping of the target areas\r\n     * but the actual overall reprojection (can be) extremely non-linear. The\r\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\r\n     * tile size. However this function is also called to remap canvas rendered\r\n     * layers which can be much larger. This calculation increases the maxSubdivision\r\n     * value by the right factor so that each 256x256 pixel area has\r\n     * MAX_SUBDIVISION divisions.\r\n     */\r\n    const maxSubdivision =\r\n      MAX_SUBDIVISION +\r\n      (destinationResolution\r\n        ? Math.max(\r\n            0,\r\n            Math.ceil(\r\n              Math.log2(\r\n                getArea(targetExtent) /\r\n                  (destinationResolution * destinationResolution * 256 * 256),\r\n              ),\r\n            ),\r\n          )\r\n        : 0);\r\n\r\n    this.addQuad_(\r\n      destinationTopLeft,\r\n      destinationTopRight,\r\n      destinationBottomRight,\r\n      destinationBottomLeft,\r\n      sourceTopLeft,\r\n      sourceTopRight,\r\n      sourceBottomRight,\r\n      sourceBottomLeft,\r\n      maxSubdivision,\r\n    );\r\n\r\n    if (this.wrapsXInSource_) {\r\n      let leftBound = Infinity;\r\n      this.triangles_.forEach(function (triangle, i, arr) {\r\n        leftBound = Math.min(\r\n          leftBound,\r\n          triangle.source[0][0],\r\n          triangle.source[1][0],\r\n          triangle.source[2][0],\r\n        );\r\n      });\r\n\r\n      // Shift triangles to be as close to `leftBound` as possible\r\n      // (if the distance is more than `worldWidth / 2` it can be closer.\r\n      this.triangles_.forEach((triangle) => {\r\n        if (\r\n          Math.max(\r\n            triangle.source[0][0],\r\n            triangle.source[1][0],\r\n            triangle.source[2][0],\r\n          ) -\r\n            leftBound >\r\n          this.sourceWorldWidth_ / 2\r\n        ) {\r\n          const newTriangle = [\r\n            [triangle.source[0][0], triangle.source[0][1]],\r\n            [triangle.source[1][0], triangle.source[1][1]],\r\n            [triangle.source[2][0], triangle.source[2][1]],\r\n          ];\r\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[0][0] -= this.sourceWorldWidth_;\r\n          }\r\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[1][0] -= this.sourceWorldWidth_;\r\n          }\r\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\r\n            newTriangle[2][0] -= this.sourceWorldWidth_;\r\n          }\r\n\r\n          // Rarely (if the extent contains both the dateline and prime meridian)\r\n          // the shift can in turn break some triangles.\r\n          // Detect this here and don't shift in such cases.\r\n          const minX = Math.min(\r\n            newTriangle[0][0],\r\n            newTriangle[1][0],\r\n            newTriangle[2][0],\r\n          );\r\n          const maxX = Math.max(\r\n            newTriangle[0][0],\r\n            newTriangle[1][0],\r\n            newTriangle[2][0],\r\n          );\r\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\r\n            triangle.source = newTriangle;\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    transformInvCache = {};\r\n  }\r\n\r\n  /**\r\n   * Adds triangle to the triangulation.\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @private\r\n   */\r\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\r\n    this.triangles_.push({\r\n      source: [aSrc, bSrc, cSrc],\r\n      target: [a, b, c],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds quad (points in clock-wise order) to the triangulation\r\n   * (and reprojects the vertices) if valid.\r\n   * Performs quad subdivision if needed to increase precision.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\r\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\r\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\r\n   * @private\r\n   */\r\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\r\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\r\n    const sourceCoverageX = this.sourceWorldWidth_\r\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\r\n      : null;\r\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\r\n\r\n    // when the quad is wrapped in the source projection\r\n    // it covers most of the projection extent, but not fully\r\n    const wrapsX =\r\n      this.sourceProj_.canWrapX() &&\r\n      sourceCoverageX > 0.5 &&\r\n      sourceCoverageX < 1;\r\n\r\n    let needsSubdivision = false;\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\r\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\r\n        const targetCoverageX =\r\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\r\n        needsSubdivision =\r\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\r\n        needsSubdivision =\r\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\r\n      }\r\n    }\r\n\r\n    if (!needsSubdivision && this.maxSourceExtent_) {\r\n      if (\r\n        isFinite(sourceQuadExtent[0]) &&\r\n        isFinite(sourceQuadExtent[1]) &&\r\n        isFinite(sourceQuadExtent[2]) &&\r\n        isFinite(sourceQuadExtent[3])\r\n      ) {\r\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\r\n          // whole quad outside source projection extent -> ignore\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    let isNotFinite = 0;\r\n\r\n    if (!needsSubdivision) {\r\n      if (\r\n        !isFinite(aSrc[0]) ||\r\n        !isFinite(aSrc[1]) ||\r\n        !isFinite(bSrc[0]) ||\r\n        !isFinite(bSrc[1]) ||\r\n        !isFinite(cSrc[0]) ||\r\n        !isFinite(cSrc[1]) ||\r\n        !isFinite(dSrc[0]) ||\r\n        !isFinite(dSrc[1])\r\n      ) {\r\n        if (maxSubdivision > 0) {\r\n          needsSubdivision = true;\r\n        } else {\r\n          // It might be the case that only 1 of the points is infinite. In this case\r\n          // we can draw a single triangle with the other three points\r\n          isNotFinite =\r\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\r\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\r\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\r\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\r\n          if (\r\n            isNotFinite != 1 &&\r\n            isNotFinite != 2 &&\r\n            isNotFinite != 4 &&\r\n            isNotFinite != 8\r\n          ) {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxSubdivision > 0) {\r\n      if (!needsSubdivision) {\r\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\r\n        const centerSrc = this.transformInv_(center);\r\n\r\n        let dx;\r\n        if (wrapsX) {\r\n          const centerSrcEstimX =\r\n            (modulo(aSrc[0], sourceWorldWidth) +\r\n              modulo(cSrc[0], sourceWorldWidth)) /\r\n            2;\r\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\r\n        } else {\r\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\r\n        }\r\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\r\n        const centerSrcErrorSquared = dx * dx + dy * dy;\r\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\r\n      }\r\n      if (needsSubdivision) {\r\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\r\n          // split horizontally (top & bottom)\r\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\r\n          const bcSrc = this.transformInv_(bc);\r\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\r\n          const daSrc = this.transformInv_(da);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            b,\r\n            bc,\r\n            da,\r\n            aSrc,\r\n            bSrc,\r\n            bcSrc,\r\n            daSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n          this.addQuad_(\r\n            da,\r\n            bc,\r\n            c,\r\n            d,\r\n            daSrc,\r\n            bcSrc,\r\n            cSrc,\r\n            dSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n        } else {\r\n          // split vertically (left & right)\r\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\r\n          const abSrc = this.transformInv_(ab);\r\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\r\n          const cdSrc = this.transformInv_(cd);\r\n\r\n          this.addQuad_(\r\n            a,\r\n            ab,\r\n            cd,\r\n            d,\r\n            aSrc,\r\n            abSrc,\r\n            cdSrc,\r\n            dSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n          this.addQuad_(\r\n            ab,\r\n            b,\r\n            c,\r\n            cd,\r\n            abSrc,\r\n            bSrc,\r\n            cSrc,\r\n            cdSrc,\r\n            maxSubdivision - 1,\r\n          );\r\n        }\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (wrapsX) {\r\n      if (!this.canWrapXInSource_) {\r\n        return;\r\n      }\r\n      this.wrapsXInSource_ = true;\r\n    }\r\n\r\n    // Exactly zero or one of *Src is not finite\r\n    // The triangles must have the diagonal line as the first side\r\n    // This is to allow easy code in reproj.s to make it straight for broken\r\n    // browsers that can't handle diagonal clipping\r\n    if ((isNotFinite & 0xb) == 0) {\r\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\r\n    }\r\n    if ((isNotFinite & 0xe) == 0) {\r\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\r\n    }\r\n    if (isNotFinite) {\r\n      // Try the other two triangles\r\n      if ((isNotFinite & 0xd) == 0) {\r\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\r\n      }\r\n      if ((isNotFinite & 0x7) == 0) {\r\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates extent of the `source` coordinates from all the triangles.\r\n   *\r\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\r\n   */\r\n  calculateSourceExtent() {\r\n    const extent = createEmpty();\r\n\r\n    this.triangles_.forEach(function (triangle, i, arr) {\r\n      const src = triangle.source;\r\n      extendCoordinate(extent, src[0]);\r\n      extendCoordinate(extent, src[1]);\r\n      extendCoordinate(extent, src[2]);\r\n    });\r\n\r\n    return extent;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<Triangle>} Array of the calculated triangles.\r\n   */\r\n  getTriangles() {\r\n    return this.triangles_;\r\n  }\r\n}\r\n\r\nexport default Triangulation;\r\n","/**\r\n * @module CME2D/reproj\r\n */\r\nimport {\r\n  containsCoordinate,\r\n  createEmpty,\r\n  extend,\r\n  forEachCorner,\r\n  getCenter,\r\n  getHeight,\r\n  getTopLeft,\r\n  getWidth,\r\n} from './extent.js';\r\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\r\nimport {getPointResolution, transform} from './proj.js';\r\nimport {solveLinearSystem} from './math.js';\r\n\r\nlet brokenDiagonalRendering_;\r\n\r\n/**\r\n * @type {Array<HTMLCanvasElement>}\r\n */\r\nexport const canvasPool = [];\r\n\r\n/**\r\n * This draws a small triangle into a canvas by setting the triangle as the clip region\r\n * and then drawing a (too large) rectangle\r\n *\r\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\r\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\r\n * @param {number} v1 The y-coordinate of the second point.\r\n * @param {number} u2 The x-coordinate of the third point.\r\n * @param {number} v2 The y-coordinate of the third point.\r\n */\r\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(0, 0);\r\n  ctx.lineTo(u1, v1);\r\n  ctx.lineTo(u2, v2);\r\n  ctx.closePath();\r\n  ctx.save();\r\n  ctx.clip();\r\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\r\n  ctx.restore();\r\n}\r\n\r\n/**\r\n * Given the data from getImageData, see if the right values appear at the provided offset.\r\n * Returns true if either the color or transparency is off\r\n *\r\n * @param {Uint8ClampedArray} data The data returned from getImageData\r\n * @param {number} offset The pixel offset from the start of data.\r\n * @return {boolean} true if the diagonal rendering is broken\r\n */\r\nfunction verifyBrokenDiagonalRendering(data, offset) {\r\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\r\n  return (\r\n    Math.abs(data[offset * 4] - 210) > 2 ||\r\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\r\n  );\r\n}\r\n\r\n/**\r\n * Determines if the current browser configuration can render triangular clip regions correctly.\r\n * This value is cached so the function is only expensive the first time called.\r\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\r\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\r\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\r\n * running, but lets hope not.\r\n *\r\n * @return {boolean} true if the Diagonal Rendering is broken.\r\n */\r\nfunction isBrokenDiagonalRendering() {\r\n  if (brokenDiagonalRendering_ === undefined) {\r\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\r\n    ctx.globalCompositeOperation = 'lighter';\r\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\r\n    drawTestTriangle(ctx, 4, 5, 4, 0);\r\n    drawTestTriangle(ctx, 4, 5, 0, 5);\r\n    const data = ctx.getImageData(0, 0, 3, 3).data;\r\n    brokenDiagonalRendering_ =\r\n      verifyBrokenDiagonalRendering(data, 0) ||\r\n      verifyBrokenDiagonalRendering(data, 4) ||\r\n      verifyBrokenDiagonalRendering(data, 8);\r\n    releaseCanvas(ctx);\r\n    canvasPool.push(ctx.canvas);\r\n  }\r\n\r\n  return brokenDiagonalRendering_;\r\n}\r\n\r\n/**\r\n * Calculates ideal resolution to use from the source in order to achieve\r\n * pixel mapping as close as possible to 1:1 during reprojection.\r\n * The resolution is calculated regardless of what resolutions\r\n * are actually available in the dataset (TileGrid, Image, ...).\r\n *\r\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\r\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\r\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\r\n * @param {number} targetResolution Target resolution.\r\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\r\n */\r\nexport function calculateSourceResolution(\r\n  sourceProj,\r\n  targetProj,\r\n  targetCenter,\r\n  targetResolution,\r\n) {\r\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\r\n\r\n  // calculate the ideal resolution of the source data\r\n  let sourceResolution = getPointResolution(\r\n    targetProj,\r\n    targetResolution,\r\n    targetCenter,\r\n  );\r\n\r\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\r\n  if (targetMetersPerUnit !== undefined) {\r\n    sourceResolution *= targetMetersPerUnit;\r\n  }\r\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\r\n  if (sourceMetersPerUnit !== undefined) {\r\n    sourceResolution /= sourceMetersPerUnit;\r\n  }\r\n\r\n  // Based on the projection properties, the point resolution at the specified\r\n  // coordinates may be slightly different. We need to reverse-compensate this\r\n  // in order to achieve optimal results.\r\n\r\n  const sourceExtent = sourceProj.getExtent();\r\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\r\n    const compensationFactor =\r\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\r\n      sourceResolution;\r\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\r\n      sourceResolution /= compensationFactor;\r\n    }\r\n  }\r\n\r\n  return sourceResolution;\r\n}\r\n\r\n/**\r\n * Calculates ideal resolution to use from the source in order to achieve\r\n * pixel mapping as close as possible to 1:1 during reprojection.\r\n * The resolution is calculated regardless of what resolutions\r\n * are actually available in the dataset (TileGrid, Image, ...).\r\n *\r\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\r\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\r\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\r\n * @param {number} targetResolution Target resolution.\r\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\r\n */\r\nexport function calculateSourceExtentResolution(\r\n  sourceProj,\r\n  targetProj,\r\n  targetExtent,\r\n  targetResolution,\r\n) {\r\n  const targetCenter = getCenter(targetExtent);\r\n  let sourceResolution = calculateSourceResolution(\r\n    sourceProj,\r\n    targetProj,\r\n    targetCenter,\r\n    targetResolution,\r\n  );\r\n\r\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n    forEachCorner(targetExtent, function (corner) {\r\n      sourceResolution = calculateSourceResolution(\r\n        sourceProj,\r\n        targetProj,\r\n        corner,\r\n        targetResolution,\r\n      );\r\n      return isFinite(sourceResolution) && sourceResolution > 0;\r\n    });\r\n  }\r\n\r\n  return sourceResolution;\r\n}\r\n\r\n/**\r\n * @typedef {Object} ImageExtent\r\n * @property {import(\"./extent.js\").Extent} extent Extent.\r\n * @property {import(\"./extent.js\").Extent} [clipExtent] Clip extent.\r\n * @property {import('./DataTile.js').ImageLike} image Image.\r\n */\r\n\r\n/**\r\n * Renders the source data into new canvas based on the triangulation.\r\n *\r\n * @param {number} width Width of the canvas.\r\n * @param {number} height Height of the canvas.\r\n * @param {number} pixelRatio Pixel ratio.\r\n * @param {number} sourceResolution Source resolution.\r\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\r\n * @param {number} targetResolution Target resolution.\r\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\r\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\r\n * @param {Array<ImageExtent>} sources Array of sources.\r\n * @param {number} gutter Gutter of the sources.\r\n * @param {boolean} [renderEdges] Render reprojection edges.\r\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\r\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\r\n * @param {boolean} [clipExtent] Clip stitchContext to sourceExtent.\r\n * @return {HTMLCanvasElement} Canvas with reprojected data.\r\n */\r\nexport function render(\r\n  width,\r\n  height,\r\n  pixelRatio,\r\n  sourceResolution,\r\n  sourceExtent,\r\n  targetResolution,\r\n  targetExtent,\r\n  triangulation,\r\n  sources,\r\n  gutter,\r\n  renderEdges,\r\n  interpolate,\r\n  drawSingle,\r\n  clipExtent,\r\n) {\r\n  const context = createCanvasContext2D(\r\n    Math.round(pixelRatio * width),\r\n    Math.round(pixelRatio * height),\r\n    canvasPool,\r\n  );\r\n\r\n  if (!interpolate) {\r\n    context.imageSmoothingEnabled = false;\r\n  }\r\n\r\n  if (sources.length === 0) {\r\n    return context.canvas;\r\n  }\r\n\r\n  context.scale(pixelRatio, pixelRatio);\r\n\r\n  function pixelRound(value) {\r\n    return Math.round(value * pixelRatio) / pixelRatio;\r\n  }\r\n\r\n  context.globalCompositeOperation = 'lighter';\r\n\r\n  const sourceDataExtent = createEmpty();\r\n  sources.forEach(function (src, i, arr) {\r\n    extend(sourceDataExtent, src.extent);\r\n  });\r\n\r\n  let stitchContext;\r\n  const stitchScale = pixelRatio / sourceResolution;\r\n  // Round up Float32 scale values to prevent interpolation in Firefox.\r\n  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;\r\n\r\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\r\n    stitchContext = createCanvasContext2D(\r\n      Math.round(getWidth(sourceDataExtent) * stitchScale),\r\n      Math.round(getHeight(sourceDataExtent) * stitchScale),\r\n      canvasPool,\r\n    );\r\n\r\n    if (!interpolate) {\r\n      stitchContext.imageSmoothingEnabled = false;\r\n    }\r\n    if (sourceExtent && clipExtent) {\r\n      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;\r\n      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;\r\n      const width = getWidth(sourceExtent) * stitchScale;\r\n      const height = getHeight(sourceExtent) * stitchScale;\r\n      stitchContext.rect(xPos, yPos, width, height);\r\n      stitchContext.clip();\r\n    }\r\n\r\n    sources.forEach(function (src, i, arr) {\r\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\r\n      if (src.image.width > 0 && src.image.height > 0) {\r\n        if (src.clipExtent) {\r\n          stitchContext.save();\r\n          const xPos = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;\r\n          const yPos = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;\r\n          const width = getWidth(src.clipExtent) * stitchScale;\r\n          const height = getHeight(src.clipExtent) * stitchScale;\r\n          stitchContext.rect(\r\n            interpolate ? xPos : Math.round(xPos),\r\n            interpolate ? yPos : Math.round(yPos),\r\n            interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\r\n            interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\r\n          );\r\n          stitchContext.clip();\r\n        }\r\n\r\n        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;\r\n        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;\r\n        const srcWidth = getWidth(src.extent) * stitchScale;\r\n        const srcHeight = getHeight(src.extent) * stitchScale;\r\n        stitchContext.drawImage(\r\n          src.image,\r\n          gutter,\r\n          gutter,\r\n          src.image.width - 2 * gutter,\r\n          src.image.height - 2 * gutter,\r\n          interpolate ? xPos : Math.round(xPos),\r\n          interpolate ? yPos : Math.round(yPos),\r\n          interpolate\r\n            ? srcWidth\r\n            : Math.round(xPos + srcWidth) - Math.round(xPos),\r\n          interpolate\r\n            ? srcHeight\r\n            : Math.round(yPos + srcHeight) - Math.round(yPos),\r\n        );\r\n\r\n        if (src.clipExtent) {\r\n          stitchContext.restore();\r\n        }\r\n      }\r\n    });\r\n  }\r\n  const targetTopLeft = getTopLeft(targetExtent);\r\n\r\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\r\n    /* Calculate affine transform (src -> dst)\r\n     * Resulting matrix can be used to transform coordinate\r\n     * from `sourceProjection` to destination pixels.\r\n     *\r\n     * To optimize number of context calls and increase numerical stability,\r\n     * we also do the following operations:\r\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\r\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\r\n     *\r\n     * Src points: xi, yi\r\n     * Dst points: ui, vi\r\n     * Affine coefficients: aij\r\n     *\r\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\r\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\r\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\r\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\r\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\r\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\r\n     */\r\n    const source = triangle.source;\r\n    const target = triangle.target;\r\n    let x0 = source[0][0],\r\n      y0 = source[0][1];\r\n    let x1 = source[1][0],\r\n      y1 = source[1][1];\r\n    let x2 = source[2][0],\r\n      y2 = source[2][1];\r\n    // Make sure that everything is on pixel boundaries\r\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\r\n    const v0 = pixelRound(\r\n      -(target[0][1] - targetTopLeft[1]) / targetResolution,\r\n    );\r\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\r\n    const v1 = pixelRound(\r\n      -(target[1][1] - targetTopLeft[1]) / targetResolution,\r\n    );\r\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\r\n    const v2 = pixelRound(\r\n      -(target[2][1] - targetTopLeft[1]) / targetResolution,\r\n    );\r\n\r\n    // Shift all the source points to improve numerical stability\r\n    // of all the subsequent calculations. The [x0, y0] is used here.\r\n    // This is also used to simplify the linear system.\r\n    const sourceNumericalShiftX = x0;\r\n    const sourceNumericalShiftY = y0;\r\n    x0 = 0;\r\n    y0 = 0;\r\n    x1 -= sourceNumericalShiftX;\r\n    y1 -= sourceNumericalShiftY;\r\n    x2 -= sourceNumericalShiftX;\r\n    y2 -= sourceNumericalShiftY;\r\n\r\n    const augmentedMatrix = [\r\n      [x1, y1, 0, 0, u1 - u0],\r\n      [x2, y2, 0, 0, u2 - u0],\r\n      [0, 0, x1, y1, v1 - v0],\r\n      [0, 0, x2, y2, v2 - v0],\r\n    ];\r\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\r\n    if (!affineCoefs) {\r\n      return;\r\n    }\r\n\r\n    context.save();\r\n    context.beginPath();\r\n\r\n    if (isBrokenDiagonalRendering() || !interpolate) {\r\n      // Make sure that all lines are horizontal or vertical\r\n      context.moveTo(u1, v1);\r\n      // This is the diagonal line. Do it in 4 steps\r\n      const steps = 4;\r\n      const ud = u0 - u1;\r\n      const vd = v0 - v1;\r\n      for (let step = 0; step < steps; step++) {\r\n        // Go horizontally\r\n        context.lineTo(\r\n          u1 + pixelRound(((step + 1) * ud) / steps),\r\n          v1 + pixelRound((step * vd) / (steps - 1)),\r\n        );\r\n        // Go vertically\r\n        if (step != steps - 1) {\r\n          context.lineTo(\r\n            u1 + pixelRound(((step + 1) * ud) / steps),\r\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1)),\r\n          );\r\n        }\r\n      }\r\n      // We are almost at u0r, v0r\r\n      context.lineTo(u2, v2);\r\n    } else {\r\n      context.moveTo(u1, v1);\r\n      context.lineTo(u0, v0);\r\n      context.lineTo(u2, v2);\r\n    }\r\n\r\n    context.clip();\r\n\r\n    context.transform(\r\n      affineCoefs[0],\r\n      affineCoefs[2],\r\n      affineCoefs[1],\r\n      affineCoefs[3],\r\n      u0,\r\n      v0,\r\n    );\r\n\r\n    context.translate(\r\n      sourceDataExtent[0] - sourceNumericalShiftX,\r\n      sourceDataExtent[3] - sourceNumericalShiftY,\r\n    );\r\n\r\n    let image;\r\n    if (stitchContext) {\r\n      image = stitchContext.canvas;\r\n      context.scale(inverseScale, -inverseScale);\r\n    } else {\r\n      const source = sources[0];\r\n      const extent = source.extent;\r\n      image = source.image;\r\n      context.scale(\r\n        getWidth(extent) / image.width,\r\n        -getHeight(extent) / image.height,\r\n      );\r\n    }\r\n\r\n    context.drawImage(image, 0, 0);\r\n    context.restore();\r\n  });\r\n\r\n  if (stitchContext) {\r\n    releaseCanvas(stitchContext);\r\n    canvasPool.push(stitchContext.canvas);\r\n  }\r\n\r\n  if (renderEdges) {\r\n    context.save();\r\n\r\n    context.globalCompositeOperation = 'source-over';\r\n    context.strokeStyle = 'black';\r\n    context.lineWidth = 1;\r\n\r\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\r\n      const target = triangle.target;\r\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\r\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\r\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\r\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\r\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\r\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\r\n\r\n      context.beginPath();\r\n      context.moveTo(u1, v1);\r\n      context.lineTo(u0, v0);\r\n      context.lineTo(u2, v2);\r\n      context.closePath();\r\n      context.stroke();\r\n    });\r\n\r\n    context.restore();\r\n  }\r\n  return context.canvas;\r\n}\r\n","/**\r\n * @module CME2D/events\r\n */\r\nimport {clear} from './obj.js';\r\n\r\n/**\r\n * Key to use with {@link module:ol/Observable.unByKey}.\r\n * @typedef {Object} EventsKey\r\n * @property {ListenerFunction} listener Listener.\r\n * @property {import(\"./events/Target.js\").EventTargetLike} target Target.\r\n * @property {string} type Type.\r\n * @api\r\n */\r\n\r\n/**\r\n * Listener function. This function is called with an event object as argument.\r\n * When the function returns `false`, event propagation will stop.\r\n *\r\n * @typedef {function((Event|import(\"./events/Event.js\").default)): (void|boolean)} ListenerFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {Object} ListenerObject\r\n * @property {ListenerFunction} handleEvent HandleEvent listener function.\r\n */\r\n\r\n/**\r\n * @typedef {ListenerFunction|ListenerObject} Listener\r\n */\r\n\r\n/**\r\n * Registers an event listener on an event target. Inspired by\r\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\r\n *\r\n * This function efficiently binds a `listener` to a `this` object, and returns\r\n * a key for use with {@link module:ol/events.unlistenByKey}.\r\n *\r\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\r\n * @param {string} type Event type.\r\n * @param {ListenerFunction} listener Listener.\r\n * @param {Object} [thisArg] Object referenced by the `this` keyword in the\r\n *     listener. Default is the `target`.\r\n * @param {boolean} [once] If true, add the listener as one-off listener.\r\n * @return {EventsKey} Unique key for the listener.\r\n */\r\nexport function listen(target, type, listener, thisArg, once) {\r\n  if (once) {\r\n    const originalListener = listener;\r\n    /**\r\n     * @this {typeof target}\r\n     */\r\n    listener = function () {\r\n      target.removeEventListener(type, listener);\r\n      originalListener.apply(thisArg ?? this, arguments);\r\n    };\r\n  } else if (thisArg && thisArg !== target) {\r\n    listener = listener.bind(thisArg);\r\n  }\r\n  const eventsKey = {\r\n    target: target,\r\n    type: type,\r\n    listener: listener,\r\n  };\r\n  target.addEventListener(type, listener);\r\n  return eventsKey;\r\n}\r\n\r\n/**\r\n * Registers a one-off event listener on an event target. Inspired by\r\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\r\n *\r\n * This function efficiently binds a `listener` as self-unregistering listener\r\n * to a `this` object, and returns a key for use with\r\n * {@link module:ol/events.unlistenByKey} in case the listener needs to be\r\n * unregistered before it is called.\r\n *\r\n * When {@link module:ol/events.listen} is called with the same arguments after this\r\n * function, the self-unregistering listener will be turned into a permanent\r\n * listener.\r\n *\r\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\r\n * @param {string} type Event type.\r\n * @param {ListenerFunction} listener Listener.\r\n * @param {Object} [thisArg] Object referenced by the `this` keyword in the\r\n *     listener. Default is the `target`.\r\n * @return {EventsKey} Key for unlistenByKey.\r\n */\r\nexport function listenOnce(target, type, listener, thisArg) {\r\n  return listen(target, type, listener, thisArg, true);\r\n}\r\n\r\n/**\r\n * Unregisters event listeners on an event target. Inspired by\r\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\r\n *\r\n * The argument passed to this function is the key returned from\r\n * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.\r\n *\r\n * @param {EventsKey} key The key.\r\n */\r\nexport function unlistenByKey(key) {\r\n  if (key && key.target) {\r\n    key.target.removeEventListener(key.type, key.listener);\r\n    clear(key);\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/reproj/DataTile\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\r\nimport EventType from '../events/EventType.js';\r\nimport TileState from '../TileState.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {\r\n  calculateSourceExtentResolution,\r\n  canvasPool,\r\n  render as renderReprojected,\r\n} from '../reproj.js';\r\nimport {clamp} from '../math.js';\r\nimport {createCanvasContext2D, releaseCanvas} from '../dom.js';\r\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\r\n */\r\n\r\n/**\r\n * @typedef {Object} TileOffset\r\n * @property {DataTile} tile Tile.\r\n * @property {number} offset Offset.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\r\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\r\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\r\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\r\n * @property {number} pixelRatio Pixel ratio.\r\n * @property {number} gutter Gutter of the source tiles.\r\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected data tile.\r\n * See {@link module:ol/source/DataTile~DataTileSource}.\r\n *\r\n */\r\nclass ReprojDataTile extends DataTile {\r\n  /**\r\n   * @param {Options} options Tile options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      tileCoord: options.tileCoord,\r\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\r\n      interpolate: options.interpolate,\r\n      transition: options.transition,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = options.pixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = options.gutter;\r\n\r\n    /**\r\n     * @type {import(\"../DataTile.js\").Data}\r\n     * @private\r\n     */\r\n    this.reprojData_ = null;\r\n\r\n    /**\r\n     * @type {Error}\r\n     * @private\r\n     */\r\n    this.reprojError_ = null;\r\n\r\n    /**\r\n     * @type {import('../size.js').Size}\r\n     * @private\r\n     */\r\n    this.reprojSize_ = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.sourceTileGrid_ = options.sourceTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.targetTileGrid_ = options.targetTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilecoord.js\").TileCoord}\r\n     */\r\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<TileOffset>}\r\n     */\r\n    this.sourceTiles_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.sourcesListenerKeys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourceZ_ = 0;\r\n\r\n    const sourceProj = options.sourceProj;\r\n    const sourceProjExtent = sourceProj.getExtent();\r\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.clipExtent_ = sourceProj.canWrapX()\r\n      ? sourceTileGridExtent\r\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\r\n        : sourceProjExtent\r\n      : sourceTileGridExtent;\r\n\r\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n      this.wrappedTileCoord_,\r\n    );\r\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\r\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    if (getArea(limitedTargetExtent) === 0) {\r\n      // Tile is completely outside range -> EMPTY\r\n      // TODO: is it actually correct that the source even creates the tile ?\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    if (sourceProjExtent) {\r\n      if (!maxSourceExtent) {\r\n        maxSourceExtent = sourceProjExtent;\r\n      } else {\r\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\r\n      }\r\n    }\r\n\r\n    const targetResolution = this.targetTileGrid_.getResolution(\r\n      this.wrappedTileCoord_[0],\r\n    );\r\n\r\n    const targetProj = options.targetProj;\r\n    const sourceResolution = calculateSourceExtentResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      targetResolution,\r\n    );\r\n\r\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n      // invalid sourceResolution -> EMPTY\r\n      // probably edges of the projections when no extent is defined\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const errorThresholdInPixels =\r\n      options.errorThreshold !== undefined\r\n        ? options.errorThreshold\r\n        : ERROR_THRESHOLD;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution,\r\n    );\r\n\r\n    if (this.triangulation_.getTriangles().length === 0) {\r\n      // no valid triangles -> EMPTY\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\r\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\r\n\r\n    if (maxSourceExtent) {\r\n      if (sourceProj.canWrapX()) {\r\n        sourceExtent[1] = clamp(\r\n          sourceExtent[1],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n        sourceExtent[3] = clamp(\r\n          sourceExtent[3],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n      } else {\r\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\r\n      }\r\n    }\r\n\r\n    if (!getArea(sourceExtent)) {\r\n      this.state = TileState.EMPTY;\r\n    } else {\r\n      let worldWidth = 0;\r\n      let worldsAway = 0;\r\n      if (sourceProj.canWrapX()) {\r\n        worldWidth = getWidth(sourceProjExtent);\r\n        worldsAway = Math.floor(\r\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\r\n        );\r\n      }\r\n\r\n      const sourceExtents = wrapAndSliceX(\r\n        sourceExtent.slice(),\r\n        sourceProj,\r\n        true,\r\n      );\r\n      sourceExtents.forEach((extent) => {\r\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\r\n          extent,\r\n          this.sourceZ_,\r\n        );\r\n        const getTile = options.getTileFunction;\r\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\r\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\r\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\r\n            if (tile) {\r\n              const offset = worldsAway * worldWidth;\r\n              this.sourceTiles_.push({tile, offset});\r\n            }\r\n          }\r\n        }\r\n        ++worldsAway;\r\n      });\r\n\r\n      if (this.sourceTiles_.length === 0) {\r\n        this.state = TileState.EMPTY;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the tile size.\r\n   * @return {import('../size.js').Size} Tile size.\r\n   * @override\r\n   */\r\n  getSize() {\r\n    return this.reprojSize_;\r\n  }\r\n\r\n  /**\r\n   * Get the data for the tile.\r\n   * @return {import(\"../DataTile.js\").Data} Tile data.\r\n   * @override\r\n   */\r\n  getData() {\r\n    return this.reprojData_;\r\n  }\r\n\r\n  /**\r\n   * Get any loading error.\r\n   * @return {Error} Loading error.\r\n   * @override\r\n   */\r\n  getError() {\r\n    return this.reprojError_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const dataSources = [];\r\n    let imageLike = false;\r\n    this.sourceTiles_.forEach((source) => {\r\n      const tile = source.tile;\r\n      if (!tile || tile.getState() !== TileState.LOADED) {\r\n        return;\r\n      }\r\n      const size = tile.getSize();\r\n      const gutter = this.gutter_;\r\n      /**\r\n       * @type {import(\"../DataTile.js\").ArrayLike}\r\n       */\r\n      let tileData;\r\n      const arrayData = asArrayLike(tile.getData());\r\n      if (arrayData) {\r\n        tileData = arrayData;\r\n      } else {\r\n        imageLike = true;\r\n        tileData = toArray(asImageLike(tile.getData()));\r\n      }\r\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\r\n      const isFloat = tileData instanceof Float32Array;\r\n      const pixelCount = pixelSize[0] * pixelSize[1];\r\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\r\n      const tileDataR = new DataType(tileData.buffer);\r\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\r\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\r\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\r\n      const bandCount = Math.floor(\r\n        bytesPerRow / bytesPerElement / pixelSize[0],\r\n      );\r\n      const packedLength = pixelCount * bandCount;\r\n      let packedData = tileDataR;\r\n      if (tileDataR.length !== packedLength) {\r\n        packedData = new DataType(packedLength);\r\n        let dataIndex = 0;\r\n        let rowOffset = 0;\r\n        const colCount = pixelSize[0] * bandCount;\r\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\r\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\r\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\r\n          }\r\n          rowOffset += bytesPerRow / bytesPerElement;\r\n        }\r\n      }\r\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\r\n      extent[0] += source.offset;\r\n      extent[2] += source.offset;\r\n      const clipExtent = this.clipExtent_?.slice();\r\n      if (clipExtent) {\r\n        clipExtent[0] += source.offset;\r\n        clipExtent[2] += source.offset;\r\n      }\r\n      dataSources.push({\r\n        extent: extent,\r\n        clipExtent: clipExtent,\r\n        data: new Uint8ClampedArray(packedData.buffer),\r\n        dataType: DataType,\r\n        bytesPerPixel: bytesPerPixel,\r\n        pixelSize: pixelSize,\r\n      });\r\n    });\r\n    this.sourceTiles_.length = 0;\r\n\r\n    if (dataSources.length === 0) {\r\n      this.state = TileState.ERROR;\r\n      this.changed();\r\n      return;\r\n    }\r\n\r\n    const z = this.wrappedTileCoord_[0];\r\n    const size = this.targetTileGrid_.getTileSize(z);\r\n    const targetWidth = typeof size === 'number' ? size : size[0];\r\n    const targetHeight = typeof size === 'number' ? size : size[1];\r\n    const targetResolution = this.targetTileGrid_.getResolution(z);\r\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\r\n\r\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n      this.wrappedTileCoord_,\r\n    );\r\n\r\n    let dataR, dataU;\r\n\r\n    const bytesPerPixel = dataSources[0].bytesPerPixel;\r\n\r\n    const reprojs = Math.ceil(bytesPerPixel / 3);\r\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\r\n      const sources = [];\r\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\r\n        const dataSource = dataSources[i];\r\n        const buffer = dataSource.data;\r\n        const pixelSize = dataSource.pixelSize;\r\n        const width = pixelSize[0];\r\n        const height = pixelSize[1];\r\n        const context = createCanvasContext2D(width, height, canvasPool);\r\n        const imageData = context.createImageData(width, height);\r\n        const data = imageData.data;\r\n        let offset = reproj * 3;\r\n        for (let j = 0, len = data.length; j < len; j += 4) {\r\n          data[j] = buffer[offset];\r\n          data[j + 1] = buffer[offset + 1];\r\n          data[j + 2] = buffer[offset + 2];\r\n          data[j + 3] = 255;\r\n          offset += bytesPerPixel;\r\n        }\r\n        context.putImageData(imageData, 0, 0);\r\n        sources.push({\r\n          extent: dataSource.extent,\r\n          clipExtent: dataSource.clipExtent,\r\n          image: context.canvas,\r\n        });\r\n      }\r\n\r\n      const canvas = renderReprojected(\r\n        targetWidth,\r\n        targetHeight,\r\n        this.pixelRatio_,\r\n        sourceResolution,\r\n        this.sourceTileGrid_.getExtent(),\r\n        targetResolution,\r\n        targetExtent,\r\n        this.triangulation_,\r\n        sources,\r\n        this.gutter_,\r\n        false,\r\n        false,\r\n        false,\r\n      );\r\n\r\n      for (let i = 0, len = sources.length; i < len; ++i) {\r\n        const canvas = sources[i].image;\r\n        const context = canvas.getContext('2d');\r\n        releaseCanvas(context);\r\n        canvasPool.push(context.canvas);\r\n      }\r\n\r\n      const context = canvas.getContext('2d');\r\n      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n      releaseCanvas(context);\r\n      canvasPool.push(canvas);\r\n\r\n      if (!dataR) {\r\n        dataU = new Uint8ClampedArray(\r\n          bytesPerPixel * imageData.width * imageData.height,\r\n        );\r\n        dataR = new dataSources[0].dataType(dataU.buffer);\r\n      }\r\n\r\n      const data = imageData.data;\r\n      let offset = reproj * 3;\r\n      for (let i = 0, len = data.length; i < len; i += 4) {\r\n        if (data[i + 3] === 255) {\r\n          dataU[offset] = data[i];\r\n          dataU[offset + 1] = data[i + 1];\r\n          dataU[offset + 2] = data[i + 2];\r\n        } else {\r\n          dataU[offset] = 0;\r\n          dataU[offset + 1] = 0;\r\n          dataU[offset + 2] = 0;\r\n        }\r\n        offset += bytesPerPixel;\r\n      }\r\n    }\r\n\r\n    if (imageLike) {\r\n      const context = createCanvasContext2D(targetWidth, targetHeight);\r\n      const imageData = new ImageData(dataR, targetWidth);\r\n      context.putImageData(imageData, 0, 0);\r\n      this.reprojData_ = context.canvas;\r\n    } else {\r\n      this.reprojData_ = dataR;\r\n    }\r\n    this.reprojSize_ = [\r\n      Math.round(targetWidth * this.pixelRatio_),\r\n      Math.round(targetHeight * this.pixelRatio_),\r\n    ];\r\n    this.state = TileState.LOADED;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\r\n      return;\r\n    }\r\n    this.state = TileState.LOADING;\r\n    this.changed();\r\n\r\n    let leftToLoad = 0;\r\n\r\n    this.sourcesListenerKeys_ = [];\r\n    this.sourceTiles_.forEach(({tile}) => {\r\n      const state = tile.getState();\r\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\r\n        return;\r\n      }\r\n      leftToLoad++;\r\n\r\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\r\n        const state = tile.getState();\r\n        if (\r\n          state == TileState.LOADED ||\r\n          state == TileState.ERROR ||\r\n          state == TileState.EMPTY\r\n        ) {\r\n          unlistenByKey(sourceListenKey);\r\n          leftToLoad--;\r\n          if (leftToLoad === 0) {\r\n            this.unlistenSources_();\r\n            this.reproject_();\r\n          }\r\n        }\r\n      });\r\n      this.sourcesListenerKeys_.push(sourceListenKey);\r\n    });\r\n\r\n    if (leftToLoad === 0) {\r\n      setTimeout(this.reproject_.bind(this), 0);\r\n    } else {\r\n      this.sourceTiles_.forEach(function ({tile}) {\r\n        const state = tile.getState();\r\n        if (state == TileState.IDLE) {\r\n          tile.load();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSources_() {\r\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\r\n    this.sourcesListenerKeys_ = null;\r\n  }\r\n}\r\n\r\nexport default ReprojDataTile;\r\n","/**\r\n * @module CME2D/asserts\r\n */\r\n\r\n/**\r\n * @param {*} assertion Assertion we expected to be truthy.\r\n * @param {string} errorMessage Error message.\r\n */\r\nexport function assert(assertion, errorMessage) {\r\n  if (!assertion) {\r\n    throw new Error(errorMessage);\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/structs/LRUCache\r\n */\r\n\r\nimport {assert} from '../asserts.js';\r\n\r\n/**\r\n * @typedef {Object} Entry\r\n * @property {string} key_ Key.\r\n * @property {Entry|null} newer Newer.\r\n * @property {Entry|null} older Older.\r\n * @property {*} value_ Value.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Implements a Least-Recently-Used cache where the keys do not conflict with\r\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\r\n * items from the cache is the responsibility of the user.\r\n *\r\n * @fires import(\"../events/Event.js\").default\r\n * @template T\r\n */\r\nclass LRUCache {\r\n  /**\r\n   * @param {number} [highWaterMark] High water mark.\r\n   */\r\n  constructor(highWaterMark) {\r\n    /**\r\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\r\n     * will be pruned at all.\r\n     * @type {number}\r\n     */\r\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.count_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, Entry>}\r\n     */\r\n    this.entries_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\r\n    this.oldest_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\r\n    this.newest_ = null;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\r\n  }\r\n\r\n  /**\r\n   * Expire the cache.\r\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\r\n   */\r\n  expireCache(keep) {\r\n    while (this.canExpireCache()) {\r\n      this.pop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * FIXME empty description for jsdoc\r\n   */\r\n  clear() {\r\n    this.count_ = 0;\r\n    this.entries_ = {};\r\n    this.oldest_ = null;\r\n    this.newest_ = null;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @return {boolean} Contains key.\r\n   */\r\n  containsKey(key) {\r\n    return this.entries_.hasOwnProperty(key);\r\n  }\r\n\r\n  /**\r\n   * @param {function(T, string, LRUCache<T>): ?} f The function\r\n   *     to call for every entry from the oldest to the newer. This function takes\r\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\r\n   *     The return value is ignored.\r\n   */\r\n  forEach(f) {\r\n    let entry = this.oldest_;\r\n    while (entry) {\r\n      f(entry.value_, entry.key_, this);\r\n      entry = entry.newer;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {*} [options] Options (reserved for subclasses).\r\n   * @return {T} Value.\r\n   */\r\n  get(key, options) {\r\n    const entry = this.entries_[key];\r\n    assert(\r\n      entry !== undefined,\r\n      'Tried to get a value for a key that does not exist in the cache',\r\n    );\r\n    if (entry === this.newest_) {\r\n      return entry.value_;\r\n    }\r\n    if (entry === this.oldest_) {\r\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\r\n      this.oldest_.older = null;\r\n    } else {\r\n      entry.newer.older = entry.older;\r\n      entry.older.newer = entry.newer;\r\n    }\r\n    entry.newer = null;\r\n    entry.older = this.newest_;\r\n    this.newest_.newer = entry;\r\n    this.newest_ = entry;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * Remove an entry from the cache.\r\n   * @param {string} key The entry key.\r\n   * @return {T} The removed entry.\r\n   */\r\n  remove(key) {\r\n    const entry = this.entries_[key];\r\n    assert(\r\n      entry !== undefined,\r\n      'Tried to get a value for a key that does not exist in the cache',\r\n    );\r\n    if (entry === this.newest_) {\r\n      this.newest_ = /** @type {Entry} */ (entry.older);\r\n      if (this.newest_) {\r\n        this.newest_.newer = null;\r\n      }\r\n    } else if (entry === this.oldest_) {\r\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\r\n      if (this.oldest_) {\r\n        this.oldest_.older = null;\r\n      }\r\n    } else {\r\n      entry.newer.older = entry.older;\r\n      entry.older.newer = entry.newer;\r\n    }\r\n    delete this.entries_[key];\r\n    --this.count_;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Count.\r\n   */\r\n  getCount() {\r\n    return this.count_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<string>} Keys.\r\n   */\r\n  getKeys() {\r\n    const keys = new Array(this.count_);\r\n    let i = 0;\r\n    let entry;\r\n    for (entry = this.newest_; entry; entry = entry.older) {\r\n      keys[i++] = entry.key_;\r\n    }\r\n    return keys;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<T>} Values.\r\n   */\r\n  getValues() {\r\n    const values = new Array(this.count_);\r\n    let i = 0;\r\n    let entry;\r\n    for (entry = this.newest_; entry; entry = entry.older) {\r\n      values[i++] = entry.value_;\r\n    }\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * @return {T} Last value.\r\n   */\r\n  peekLast() {\r\n    return this.oldest_.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {string} Last key.\r\n   */\r\n  peekLastKey() {\r\n    return this.oldest_.key_;\r\n  }\r\n\r\n  /**\r\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\r\n   * @return {string} The newest key.\r\n   */\r\n  peekFirstKey() {\r\n    return this.newest_.key_;\r\n  }\r\n\r\n  /**\r\n   * Return an entry without updating least recently used time.\r\n   * @param {string} key Key.\r\n   * @return {T|undefined} Value.\r\n   */\r\n  peek(key) {\r\n    return this.entries_[key]?.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {T} value Value.\r\n   */\r\n  pop() {\r\n    const entry = this.oldest_;\r\n    delete this.entries_[entry.key_];\r\n    if (entry.newer) {\r\n      entry.newer.older = null;\r\n    }\r\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\r\n    if (!this.oldest_) {\r\n      this.newest_ = null;\r\n    }\r\n    --this.count_;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\r\n  replace(key, value) {\r\n    this.get(key); // update `newest_`\r\n    this.entries_[key].value_ = value;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\r\n  set(key, value) {\r\n    assert(\r\n      !(key in this.entries_),\r\n      'Tried to set a value for a key that is used already',\r\n    );\r\n    const entry = {\r\n      key_: key,\r\n      newer: null,\r\n      older: this.newest_,\r\n      value_: value,\r\n    };\r\n    if (!this.newest_) {\r\n      this.oldest_ = entry;\r\n    } else {\r\n      this.newest_.newer = entry;\r\n    }\r\n    this.newest_ = entry;\r\n    this.entries_[key] = entry;\r\n    ++this.count_;\r\n  }\r\n\r\n  /**\r\n   * Set a maximum number of entries for the cache.\r\n   * @param {number} size Cache size.\r\n   * @api\r\n   */\r\n  setSize(size) {\r\n    this.highWaterMark = size;\r\n  }\r\n}\r\n\r\nexport default LRUCache;\r\n","/**\r\n * @module CME2D/tilecoord\r\n */\r\n\r\n/**\r\n * An array of three numbers representing the location of a tile in a tile\r\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\r\n * @typedef {Array<number>} TileCoord\r\n * @api\r\n */\r\n\r\n/**\r\n * @param {number} z Z.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {TileCoord} [tileCoord] Tile coordinate.\r\n * @return {TileCoord} Tile coordinate.\r\n */\r\nexport function createOrUpdate(z, x, y, tileCoord) {\r\n  if (tileCoord !== undefined) {\r\n    tileCoord[0] = z;\r\n    tileCoord[1] = x;\r\n    tileCoord[2] = y;\r\n    return tileCoord;\r\n  }\r\n  return [z, x, y];\r\n}\r\n\r\n/**\r\n * @param {number} z Z.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {string} Key.\r\n */\r\nexport function getKeyZXY(z, x, y) {\r\n  return z + '/' + x + '/' + y;\r\n}\r\n\r\n/**\r\n * Get the key for a tile coord.\r\n * @param {TileCoord} tileCoord The tile coord.\r\n * @return {string} Key.\r\n */\r\nexport function getKey(tileCoord) {\r\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\r\n}\r\n\r\n/**\r\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\r\n * @param {string} tileKey The tile key.\r\n * @return {string} The cache key.\r\n */\r\nexport function getCacheKeyForTileKey(tileKey) {\r\n  const [z, x, y] = tileKey\r\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\r\n    .split(',')\r\n    .map(Number);\r\n  return getKeyZXY(z, x, y);\r\n}\r\n\r\n/**\r\n * Get a tile coord given a key.\r\n * @param {string} key The tile coord key.\r\n * @return {TileCoord} The tile coord.\r\n */\r\nexport function fromKey(key) {\r\n  return key.split('/').map(Number);\r\n}\r\n\r\n/**\r\n * @param {TileCoord} tileCoord Tile coord.\r\n * @return {number} Hash.\r\n */\r\nexport function hash(tileCoord) {\r\n  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\r\n}\r\n\r\n/**\r\n * @param {number} z The tile z coordinate.\r\n * @param {number} x The tile x coordinate.\r\n * @param {number} y The tile y coordinate.\r\n * @return {number} Hash.\r\n */\r\nexport function hashZXY(z, x, y) {\r\n  return (x << z) + y;\r\n}\r\n\r\n/**\r\n * @param {TileCoord} tileCoord Tile coordinate.\r\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\r\n * @return {boolean} Tile coordinate is within extent and zoom level range.\r\n */\r\nexport function withinExtentAndZ(tileCoord, tileGrid) {\r\n  const z = tileCoord[0];\r\n  const x = tileCoord[1];\r\n  const y = tileCoord[2];\r\n\r\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\r\n    return false;\r\n  }\r\n  const tileRange = tileGrid.getFullTileRange(z);\r\n  if (!tileRange) {\r\n    return true;\r\n  }\r\n  return tileRange.containsXY(x, y);\r\n}\r\n","/**\r\n * @module CME2D/TileCache\r\n */\r\nimport LRUCache from './structs/LRUCache.js';\r\nimport {fromKey, getKey} from './tilecoord.js';\r\n\r\nclass TileCache extends LRUCache {\r\n  /**\r\n   * @override\r\n   */\r\n  clear() {\r\n    while (this.getCount() > 0) {\r\n      this.pop().release();\r\n    }\r\n    super.clear();\r\n  }\r\n\r\n  /**\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   * @override\r\n   */\r\n  expireCache(usedTiles) {\r\n    while (this.canExpireCache()) {\r\n      const tile = this.peekLast();\r\n      if (tile.getKey() in usedTiles) {\r\n        break;\r\n      } else {\r\n        this.pop().release();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\r\n   */\r\n  pruneExceptNewestZ() {\r\n    if (this.getCount() === 0) {\r\n      return;\r\n    }\r\n    const key = this.peekFirstKey();\r\n    const tileCoord = fromKey(key);\r\n    const z = tileCoord[0];\r\n    this.forEach((tile) => {\r\n      if (tile.tileCoord[0] !== z) {\r\n        this.remove(getKey(tile.tileCoord));\r\n        tile.release();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default TileCache;\r\n","/**\r\n * @module CME2D/source/TileEventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * Triggered when a tile starts loading.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\r\n   * @api\r\n   */\r\n  TILELOADSTART: 'tileloadstart',\r\n\r\n  /**\r\n   * Triggered when a tile finishes loading, either when its data is loaded,\r\n   * or when loading was aborted because the tile is no longer needed.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\r\n   * @api\r\n   */\r\n  TILELOADEND: 'tileloadend',\r\n\r\n  /**\r\n   * Triggered if tile loading results in an error. Note that this is not the\r\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\r\n   * for details.\r\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\r\n   * @api\r\n   */\r\n  TILELOADERROR: 'tileloaderror',\r\n};\r\n\r\n/**\r\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\r\n */\r\n","/**\r\n * @module CME2D/ObjectEventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * Triggered when a property is changed.\r\n   * @event module:ol/Object.ObjectEvent#propertychange\r\n   * @api\r\n   */\r\n  PROPERTYCHANGE: 'propertychange',\r\n};\r\n\r\n/**\r\n * @typedef {'propertychange'} Types\r\n */\r\n","/**\r\n * @module CME2D/Observable\r\n */\r\nimport EventTarget from './events/Target.js';\r\nimport EventType from './events/EventType.js';\r\nimport {listen, listenOnce, unlistenByKey} from './events.js';\r\n\r\n/***\r\n * @template {string} Type\r\n * @template {Event|import(\"./events/Event.js\").default} EventClass\r\n * @template Return\r\n * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature\r\n */\r\n\r\n/***\r\n * @template {string} Type\r\n * @template Return\r\n * @typedef {(type: Type[], listener: (event: Event|import(\"./events/Event\").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {'change'|'error'} EventTypes\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {OnSignature<EventTypes, import(\"./events/Event.js\").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * An event target providing convenient methods for listener registration\r\n * and unregistration. A generic `change` event is always available through\r\n * {@link module:ol/Observable~Observable#changed}.\r\n *\r\n * @fires import(\"./events/Event.js\").default\r\n * @api\r\n */\r\nclass Observable extends EventTarget {\r\n  constructor() {\r\n    super();\r\n\r\n    this.on =\r\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\r\n        this.onInternal\r\n      );\r\n\r\n    this.once =\r\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\r\n        this.onceInternal\r\n      );\r\n\r\n    this.un = /** @type {ObservableOnSignature<void>} */ (this.unInternal);\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.revision_ = 0;\r\n  }\r\n\r\n  /**\r\n   * Increases the revision counter and dispatches a 'change' event.\r\n   * @api\r\n   */\r\n  changed() {\r\n    ++this.revision_;\r\n    this.dispatchEvent(EventType.CHANGE);\r\n  }\r\n\r\n  /**\r\n   * Get the version number for this object.  Each time the object is modified,\r\n   * its version number will be incremented.\r\n   * @return {number} Revision.\r\n   * @api\r\n   */\r\n  getRevision() {\r\n    return this.revision_;\r\n  }\r\n\r\n  /**\r\n   * @param {string|Array<string>} type Type.\r\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\r\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\r\n   * @protected\r\n   */\r\n  onInternal(type, listener) {\r\n    if (Array.isArray(type)) {\r\n      const len = type.length;\r\n      const keys = new Array(len);\r\n      for (let i = 0; i < len; ++i) {\r\n        keys[i] = listen(this, type[i], listener);\r\n      }\r\n      return keys;\r\n    }\r\n    return listen(this, /** @type {string} */ (type), listener);\r\n  }\r\n\r\n  /**\r\n   * @param {string|Array<string>} type Type.\r\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\r\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\r\n   * @protected\r\n   */\r\n  onceInternal(type, listener) {\r\n    let key;\r\n    if (Array.isArray(type)) {\r\n      const len = type.length;\r\n      key = new Array(len);\r\n      for (let i = 0; i < len; ++i) {\r\n        key[i] = listenOnce(this, type[i], listener);\r\n      }\r\n    } else {\r\n      key = listenOnce(this, /** @type {string} */ (type), listener);\r\n    }\r\n    /** @type {Object} */ (listener).ol_key = key;\r\n    return key;\r\n  }\r\n\r\n  /**\r\n   * Unlisten for a certain type of event.\r\n   * @param {string|Array<string>} type Type.\r\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\r\n   * @protected\r\n   */\r\n  unInternal(type, listener) {\r\n    const key = /** @type {Object} */ (listener).ol_key;\r\n    if (key) {\r\n      unByKey(key);\r\n    } else if (Array.isArray(type)) {\r\n      for (let i = 0, ii = type.length; i < ii; ++i) {\r\n        this.removeEventListener(type[i], listener);\r\n      }\r\n    } else {\r\n      this.removeEventListener(type, listener);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Listen for a certain type of event.\r\n * @function\r\n * @param {string|Array<string>} type The event type or array of event types.\r\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\r\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\r\n *     called with an array of event types as the first argument, the return\r\n *     will be an array of keys.\r\n * @api\r\n */\r\nObservable.prototype.on;\r\n\r\n/**\r\n * Listen once for a certain type of event.\r\n * @function\r\n * @param {string|Array<string>} type The event type or array of event types.\r\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\r\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\r\n *     called with an array of event types as the first argument, the return\r\n *     will be an array of keys.\r\n * @api\r\n */\r\nObservable.prototype.once;\r\n\r\n/**\r\n * Unlisten for a certain type of event.\r\n * @function\r\n * @param {string|Array<string>} type The event type or array of event types.\r\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\r\n * @api\r\n */\r\nObservable.prototype.un;\r\n\r\n/**\r\n * Removes an event listener using the key returned by `on()` or `once()`.\r\n * @param {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} key The key returned by `on()`\r\n *     or `once()` (or an array of keys).\r\n * @api\r\n */\r\nexport function unByKey(key) {\r\n  if (Array.isArray(key)) {\r\n    for (let i = 0, ii = key.length; i < ii; ++i) {\r\n      unlistenByKey(key[i]);\r\n    }\r\n  } else {\r\n    unlistenByKey(/** @type {import(\"./events.js\").EventsKey} */ (key));\r\n  }\r\n}\r\n\r\nexport default Observable;\r\n","/**\r\n * @module CME2D/Object\r\n */\r\nimport Event from './events/Event.js';\r\nimport ObjectEventType from './ObjectEventType.js';\r\nimport Observable from './Observable.js';\r\nimport {getUid} from './util.js';\r\nimport {isEmpty} from './obj.js';\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.\r\n */\r\nexport class ObjectEvent extends Event {\r\n  /**\r\n   * @param {string} type The event type.\r\n   * @param {string} key The property name.\r\n   * @param {*} oldValue The old value for `key`.\r\n   */\r\n  constructor(type, key, oldValue) {\r\n    super(type);\r\n\r\n    /**\r\n     * The name of the property whose value is changing.\r\n     * @type {string}\r\n     * @api\r\n     */\r\n    this.key = key;\r\n\r\n    /**\r\n     * The old value. To get the new value use `e.target.get(e.key)` where\r\n     * `e` is the event object.\r\n     * @type {*}\r\n     * @api\r\n     */\r\n    this.oldValue = oldValue;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\r\n *    import(\"./Observable\").OnSignature<import(\"./ObjectEventType\").Types, ObjectEvent, Return> &\r\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|import(\"./ObjectEventType\").Types, Return>} ObjectOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Most non-trivial classes inherit from this.\r\n *\r\n * This extends {@link module:ol/Observable~Observable} with observable\r\n * properties, where each property is observable as well as the object as a\r\n * whole.\r\n *\r\n * Classes that inherit from this have pre-defined properties, to which you can\r\n * add your owns. The pre-defined properties are listed in this documentation as\r\n * 'Observable Properties', and have their own accessors; for example,\r\n * {@link module:ol/Map~Map} has a `target` property, accessed with\r\n * `getTarget()` and changed with `setTarget()`. Not all properties are however\r\n * settable. There are also general-purpose accessors `get()` and `set()`. For\r\n * example, `get('target')` is equivalent to `getTarget()`.\r\n *\r\n * The `set` accessors trigger a change event, and you can monitor this by\r\n * registering a listener. For example, {@link module:ol/View~View} has a\r\n * `center` property, so `view.on('change:center', function(evt) {...});` would\r\n * call the function whenever the value of the center property changes. Within\r\n * the function, `evt.target` would be the view, so `evt.target.getCenter()`\r\n * would return the new center.\r\n *\r\n * You can add your own observable properties with\r\n * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\r\n * You can listen for changes on that property value with\r\n * `object.on('change:prop', listener)`. You can get a list of all\r\n * properties with {@link module:ol/Object~BaseObject#getProperties}.\r\n *\r\n * Note that the observable properties are separate from standard JS properties.\r\n * You can, for example, give your map object a title with\r\n * `map.title='New title'` and with `map.set('title', 'Another title')`. The\r\n * first will be a `hasOwnProperty`; the second will appear in\r\n * `getProperties()`. Only the second is observable.\r\n *\r\n * Properties can be deleted by using the unset method. E.g.\r\n * object.unset('foo').\r\n *\r\n * @fires ObjectEvent\r\n * @api\r\n */\r\nclass BaseObject extends Observable {\r\n  /**\r\n   * @param {Object<string, *>} [values] An object with key-value pairs.\r\n   */\r\n  constructor(values) {\r\n    super();\r\n\r\n    /***\r\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {ObjectOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is\r\n    // the same as the order in which they were created.  This also helps to\r\n    // ensure that object properties are always added in the same order, which\r\n    // helps many JavaScript engines generate faster code.\r\n    getUid(this);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, *>|null}\r\n     */\r\n    this.values_ = null;\r\n\r\n    if (values !== undefined) {\r\n      this.setProperties(values);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets a value.\r\n   * @param {string} key Key name.\r\n   * @return {*} Value.\r\n   * @api\r\n   */\r\n  get(key) {\r\n    let value;\r\n    if (this.values_ && this.values_.hasOwnProperty(key)) {\r\n      value = this.values_[key];\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Get a list of object property names.\r\n   * @return {Array<string>} List of property names.\r\n   * @api\r\n   */\r\n  getKeys() {\r\n    return (this.values_ && Object.keys(this.values_)) || [];\r\n  }\r\n\r\n  /**\r\n   * Get an object of all property names and values.\r\n   * @return {Object<string, *>} Object.\r\n   * @api\r\n   */\r\n  getProperties() {\r\n    return (this.values_ && Object.assign({}, this.values_)) || {};\r\n  }\r\n\r\n  /**\r\n   * Get an object of all property names and values.\r\n   * @return {Object<string, *>?} Object.\r\n   */\r\n  getPropertiesInternal() {\r\n    return this.values_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} The object has properties.\r\n   */\r\n  hasProperties() {\r\n    return !!this.values_;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key name.\r\n   * @param {*} oldValue Old value.\r\n   */\r\n  notify(key, oldValue) {\r\n    let eventType;\r\n    eventType = `change:${key}`;\r\n    if (this.hasListener(eventType)) {\r\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\r\n    }\r\n    eventType = ObjectEventType.PROPERTYCHANGE;\r\n    if (this.hasListener(eventType)) {\r\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key name.\r\n   * @param {import(\"./events.js\").Listener} listener Listener.\r\n   */\r\n  addChangeListener(key, listener) {\r\n    this.addEventListener(`change:${key}`, listener);\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key name.\r\n   * @param {import(\"./events.js\").Listener} listener Listener.\r\n   */\r\n  removeChangeListener(key, listener) {\r\n    this.removeEventListener(`change:${key}`, listener);\r\n  }\r\n\r\n  /**\r\n   * Sets a value.\r\n   * @param {string} key Key name.\r\n   * @param {*} value Value.\r\n   * @param {boolean} [silent] Update without triggering an event.\r\n   * @api\r\n   */\r\n  set(key, value, silent) {\r\n    const values = this.values_ || (this.values_ = {});\r\n    if (silent) {\r\n      values[key] = value;\r\n    } else {\r\n      const oldValue = values[key];\r\n      values[key] = value;\r\n      if (oldValue !== value) {\r\n        this.notify(key, oldValue);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets a collection of key-value pairs.  Note that this changes any existing\r\n   * properties and adds new ones (it does not remove any existing properties).\r\n   * @param {Object<string, *>} values Values.\r\n   * @param {boolean} [silent] Update without triggering an event.\r\n   * @api\r\n   */\r\n  setProperties(values, silent) {\r\n    for (const key in values) {\r\n      this.set(key, values[key], silent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply any properties from another object without triggering events.\r\n   * @param {BaseObject} source The source object.\r\n   * @protected\r\n   */\r\n  applyProperties(source) {\r\n    if (!source.values_) {\r\n      return;\r\n    }\r\n    Object.assign(this.values_ || (this.values_ = {}), source.values_);\r\n  }\r\n\r\n  /**\r\n   * Unsets a property.\r\n   * @param {string} key Key name.\r\n   * @param {boolean} [silent] Unset without triggering an event.\r\n   * @api\r\n   */\r\n  unset(key, silent) {\r\n    if (this.values_ && key in this.values_) {\r\n      const oldValue = this.values_[key];\r\n      delete this.values_[key];\r\n      if (isEmpty(this.values_)) {\r\n        this.values_ = null;\r\n      }\r\n      if (!silent) {\r\n        this.notify(key, oldValue);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default BaseObject;\r\n","/**\r\n * @module CME2D/source/Source\r\n */\r\nimport BaseObject from '../Object.js';\r\nimport {get as getProjection} from '../proj.js';\r\n\r\n/**\r\n * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State\r\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\r\n */\r\n\r\n/**\r\n * A function that takes a {@link import(\"../View.js\").ViewStateLayerStateExtent} and returns a string or\r\n * an array of strings representing source attributions.\r\n *\r\n * @typedef {function(import(\"../View.js\").ViewStateLayerStateExtent): (string|Array<string>)} Attribution\r\n */\r\n\r\n/**\r\n * A type that can be used to provide attribution information for data sources.\r\n *\r\n * It represents either\r\n * * a simple string (e.g. `'© Acme Inc.'`)\r\n * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)\r\n * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})\r\n *\r\n * @typedef {string|Array<string>|Attribution} AttributionLike\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\r\n * @property {import(\"./Source.js\").State} [state='ready'] State.\r\n * @property {boolean} [wrapX=false] WrapX.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\r\n *\r\n * A generic `change` event is triggered when the state of the source changes.\r\n * @abstract\r\n * @api\r\n */\r\nclass Source extends BaseObject {\r\n  /**\r\n   * @param {Options} options Source options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../proj/Projection.js\").default|null}\r\n     */\r\n    this.projection = getProjection(options.projection);\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Attribution}\r\n     */\r\n    this.attributions_ = adaptAttributions(options.attributions);\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;\r\n\r\n    /**\r\n     * This source is currently loading data. Sources that defer loading to the\r\n     * map's tile queue never set this to `true`.\r\n     * @type {boolean}\r\n     */\r\n    this.loading = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./Source.js\").State}\r\n     */\r\n    this.state_ = options.state !== undefined ? options.state : 'ready';\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.interpolate_ = !!options.interpolate;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {function(import(\"../View.js\").ViewOptions):void}\r\n     */\r\n    this.viewResolver = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {function(Error):void}\r\n     */\r\n    this.viewRejector = null;\r\n\r\n    const self = this;\r\n    /**\r\n     * @private\r\n     * @type {Promise<import(\"../View.js\").ViewOptions>}\r\n     */\r\n    this.viewPromise_ = new Promise(function (resolve, reject) {\r\n      self.viewResolver = resolve;\r\n      self.viewRejector = reject;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the attribution function for the source.\r\n   * @return {?Attribution} Attribution function.\r\n   * @api\r\n   */\r\n  getAttributions() {\r\n    return this.attributions_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Attributions are collapsible.\r\n   * @api\r\n   */\r\n  getAttributionsCollapsible() {\r\n    return this.attributionsCollapsible_;\r\n  }\r\n\r\n  /**\r\n   * Get the projection of the source.\r\n   * @return {import(\"../proj/Projection.js\").default|null} Projection.\r\n   * @api\r\n   */\r\n  getProjection() {\r\n    return this.projection;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\r\n   * @return {Array<number>|null} Resolutions.\r\n   */\r\n  getResolutions(projection) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\r\n   */\r\n  getView() {\r\n    return this.viewPromise_;\r\n  }\r\n\r\n  /**\r\n   * Get the state of the source, see {@link import(\"./Source.js\").State} for possible states.\r\n   * @return {import(\"./Source.js\").State} State.\r\n   * @api\r\n   */\r\n  getState() {\r\n    return this.state_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean|undefined} Wrap X.\r\n   */\r\n  getWrapX() {\r\n    return this.wrapX_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Use linear interpolation when resampling.\r\n   */\r\n  getInterpolate() {\r\n    return this.interpolate_;\r\n  }\r\n\r\n  /**\r\n   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.\r\n   * @api\r\n   */\r\n  refresh() {\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the attributions of the source.\r\n   * @param {AttributionLike|undefined} attributions Attributions.\r\n   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},\r\n   *     or `undefined`.\r\n   * @api\r\n   */\r\n  setAttributions(attributions) {\r\n    this.attributions_ = adaptAttributions(attributions);\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the state of the source.\r\n   * @param {import(\"./Source.js\").State} state State.\r\n   */\r\n  setState(state) {\r\n    this.state_ = state;\r\n    this.changed();\r\n  }\r\n}\r\n\r\n/**\r\n * Turns the attributions option into an attributions function.\r\n * @param {AttributionLike|undefined} attributionLike The attribution option.\r\n * @return {Attribution|null} An attribution function (or null).\r\n */\r\nfunction adaptAttributions(attributionLike) {\r\n  if (!attributionLike) {\r\n    return null;\r\n  }\r\n  if (typeof attributionLike === 'function') {\r\n    return attributionLike;\r\n  }\r\n  if (!Array.isArray(attributionLike)) {\r\n    attributionLike = [attributionLike];\r\n  }\r\n  return (frameState) => attributionLike;\r\n}\r\n\r\nexport default Source;\r\n","/**\r\n * @module CME2D/TileRange\r\n */\r\n\r\n/**\r\n * A representation of a contiguous block of tiles.  A tile range is specified\r\n * by its min/max tile coordinates and is inclusive of coordinates.\r\n */\r\nclass TileRange {\r\n  /**\r\n   * @param {number} minX Minimum X.\r\n   * @param {number} maxX Maximum X.\r\n   * @param {number} minY Minimum Y.\r\n   * @param {number} maxY Maximum Y.\r\n   */\r\n  constructor(minX, maxX, minY, maxY) {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.minX = minX;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.maxX = maxX;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.minY = minY;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.maxY = maxY;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {boolean} Contains tile coordinate.\r\n   */\r\n  contains(tileCoord) {\r\n    return this.containsXY(tileCoord[1], tileCoord[2]);\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   * @return {boolean} Contains.\r\n   */\r\n  containsTileRange(tileRange) {\r\n    return (\r\n      this.minX <= tileRange.minX &&\r\n      tileRange.maxX <= this.maxX &&\r\n      this.minY <= tileRange.minY &&\r\n      tileRange.maxY <= this.maxY\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @return {boolean} Contains coordinate.\r\n   */\r\n  containsXY(x, y) {\r\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   * @return {boolean} Equals.\r\n   */\r\n  equals(tileRange) {\r\n    return (\r\n      this.minX == tileRange.minX &&\r\n      this.minY == tileRange.minY &&\r\n      this.maxX == tileRange.maxX &&\r\n      this.maxY == tileRange.maxY\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   */\r\n  extend(tileRange) {\r\n    if (tileRange.minX < this.minX) {\r\n      this.minX = tileRange.minX;\r\n    }\r\n    if (tileRange.maxX > this.maxX) {\r\n      this.maxX = tileRange.maxX;\r\n    }\r\n    if (tileRange.minY < this.minY) {\r\n      this.minY = tileRange.minY;\r\n    }\r\n    if (tileRange.maxY > this.maxY) {\r\n      this.maxY = tileRange.maxY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {number} Height.\r\n   */\r\n  getHeight() {\r\n    return this.maxY - this.minY + 1;\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./size.js\").Size} Size.\r\n   */\r\n  getSize() {\r\n    return [this.getWidth(), this.getHeight()];\r\n  }\r\n\r\n  /**\r\n   * @return {number} Width.\r\n   */\r\n  getWidth() {\r\n    return this.maxX - this.minX + 1;\r\n  }\r\n\r\n  /**\r\n   * @param {TileRange} tileRange Tile range.\r\n   * @return {boolean} Intersects.\r\n   */\r\n  intersects(tileRange) {\r\n    return (\r\n      this.minX <= tileRange.maxX &&\r\n      this.maxX >= tileRange.minX &&\r\n      this.minY <= tileRange.maxY &&\r\n      this.maxY >= tileRange.minY\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} minX Minimum X.\r\n * @param {number} maxX Maximum X.\r\n * @param {number} minY Minimum Y.\r\n * @param {number} maxY Maximum Y.\r\n * @param {TileRange} [tileRange] TileRange.\r\n * @return {TileRange} Tile range.\r\n */\r\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\r\n  if (tileRange !== undefined) {\r\n    tileRange.minX = minX;\r\n    tileRange.maxX = maxX;\r\n    tileRange.minY = minY;\r\n    tileRange.maxY = maxY;\r\n    return tileRange;\r\n  }\r\n  return new TileRange(minX, maxX, minY, maxY);\r\n}\r\n\r\nexport default TileRange;\r\n","/**\r\n * @module CME2D/tilegrid/common\r\n */\r\n\r\n/**\r\n * Default maximum zoom for default tile grids.\r\n * @type {number}\r\n */\r\nexport const DEFAULT_MAX_ZOOM = 42;\r\n\r\n/**\r\n * Default tile size.\r\n * @type {number}\r\n */\r\nexport const DEFAULT_TILE_SIZE = 256;\r\n","/**\r\n * @module CME2D/geom/flat/segments\r\n */\r\n\r\n/**\r\n * This function calls `callback` for each segment of the flat coordinates\r\n * array. If the callback returns a truthy value the function returns that\r\n * value immediately. Otherwise the function returns `false`.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\r\n *     called for each segment.\r\n * @return {T|boolean} Value.\r\n * @template T\r\n */\r\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\r\n  let ret;\r\n  offset += stride;\r\n  for (; offset < end; offset += stride) {\r\n    ret = callback(\r\n      flatCoordinates.slice(offset - stride, offset),\r\n      flatCoordinates.slice(offset, offset + stride),\r\n    );\r\n    if (ret) {\r\n      return ret;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/contains\r\n */\r\nimport {forEachCorner} from '../../extent.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} Contains extent.\r\n */\r\nexport function linearRingContainsExtent(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  extent,\r\n) {\r\n  const outside = forEachCorner(\r\n    extent,\r\n    /**\r\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\r\n     * @return {boolean} Contains (x, y).\r\n     */\r\n    function (coordinate) {\r\n      return !linearRingContainsXY(\r\n        flatCoordinates,\r\n        offset,\r\n        end,\r\n        stride,\r\n        coordinate[0],\r\n        coordinate[1],\r\n      );\r\n    },\r\n  );\r\n  return !outside;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {boolean} Contains (x, y).\r\n */\r\nexport function linearRingContainsXY(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  x,\r\n  y,\r\n) {\r\n  // https://geomalgorithms.com/a03-_inclusion.html\r\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\r\n  // This code may be freely used and modified for any purpose\r\n  // providing that this copyright notice is included with it.\r\n  // SoftSurfer makes no warranty for this code, and cannot be held\r\n  // liable for any real or imagined damage resulting from its use.\r\n  // Users of this code must verify correctness for their application.\r\n  let wn = 0;\r\n  let x1 = flatCoordinates[end - stride];\r\n  let y1 = flatCoordinates[end - stride + 1];\r\n  for (; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    if (y1 <= y) {\r\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\r\n        wn++;\r\n      }\r\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\r\n      wn--;\r\n    }\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return wn !== 0;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {boolean} Contains (x, y).\r\n */\r\nexport function linearRingsContainsXY(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  x,\r\n  y,\r\n) {\r\n  if (ends.length === 0) {\r\n    return false;\r\n  }\r\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\r\n    return false;\r\n  }\r\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\r\n    if (\r\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\r\n    ) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {boolean} Contains (x, y).\r\n */\r\nexport function linearRingssContainsXY(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  x,\r\n  y,\r\n) {\r\n  if (endss.length === 0) {\r\n    return false;\r\n  }\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\r\n      return true;\r\n    }\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return false;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/intersectsextent\r\n */\r\nimport {\r\n  containsExtent,\r\n  createEmpty,\r\n  extendFlatCoordinates,\r\n  intersects,\r\n  intersectsSegment,\r\n} from '../../extent.js';\r\nimport {forEach as forEachSegment} from './segments.js';\r\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLineString(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  extent,\r\n) {\r\n  const coordinatesExtent = extendFlatCoordinates(\r\n    createEmpty(),\r\n    flatCoordinates,\r\n    offset,\r\n    end,\r\n    stride,\r\n  );\r\n  if (!intersects(extent, coordinatesExtent)) {\r\n    return false;\r\n  }\r\n  if (containsExtent(extent, coordinatesExtent)) {\r\n    return true;\r\n  }\r\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\r\n    return true;\r\n  }\r\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\r\n    return true;\r\n  }\r\n  return forEachSegment(\r\n    flatCoordinates,\r\n    offset,\r\n    end,\r\n    stride,\r\n    /**\r\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\r\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\r\n     * @return {boolean} `true` if the segment and the extent intersect,\r\n     *     `false` otherwise.\r\n     */\r\n    function (point1, point2) {\r\n      return intersectsSegment(extent, point1, point2);\r\n    },\r\n  );\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLineStringArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  extent,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    if (\r\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\r\n    ) {\r\n      return true;\r\n    }\r\n    offset = ends[i];\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLinearRing(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  extent,\r\n) {\r\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\r\n    return true;\r\n  }\r\n  if (\r\n    linearRingContainsXY(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      extent[0],\r\n      extent[1],\r\n    )\r\n  ) {\r\n    return true;\r\n  }\r\n  if (\r\n    linearRingContainsXY(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      extent[0],\r\n      extent[3],\r\n    )\r\n  ) {\r\n    return true;\r\n  }\r\n  if (\r\n    linearRingContainsXY(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      extent[2],\r\n      extent[1],\r\n    )\r\n  ) {\r\n    return true;\r\n  }\r\n  if (\r\n    linearRingContainsXY(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      extent[2],\r\n      extent[3],\r\n    )\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLinearRingArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  extent,\r\n) {\r\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\r\n    return false;\r\n  }\r\n  if (ends.length === 1) {\r\n    return true;\r\n  }\r\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\r\n    if (\r\n      linearRingContainsExtent(\r\n        flatCoordinates,\r\n        ends[i - 1],\r\n        ends[i],\r\n        stride,\r\n        extent,\r\n      )\r\n    ) {\r\n      if (\r\n        !intersectsLineString(\r\n          flatCoordinates,\r\n          ends[i - 1],\r\n          ends[i],\r\n          stride,\r\n          extent,\r\n        )\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../extent.js\").Extent} extent Extent.\r\n * @return {boolean} True if the geometry and the extent intersect.\r\n */\r\nexport function intersectsLinearRingMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  extent,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    if (\r\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\r\n    ) {\r\n      return true;\r\n    }\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return false;\r\n}\r\n","/**\r\n * @module CME2D/size\r\n */\r\n\r\n/**\r\n * An array of numbers representing a size: `[width, height]`.\r\n * @typedef {Array<number>} Size\r\n * @api\r\n */\r\n\r\n/**\r\n * Returns a buffered size.\r\n * @param {Size} size Size.\r\n * @param {number} num The amount by which to buffer.\r\n * @param {Size} [dest] Optional reusable size array.\r\n * @return {Size} The buffered size.\r\n */\r\nexport function buffer(size, num, dest) {\r\n  if (dest === undefined) {\r\n    dest = [0, 0];\r\n  }\r\n  dest[0] = size[0] + 2 * num;\r\n  dest[1] = size[1] + 2 * num;\r\n  return dest;\r\n}\r\n\r\n/**\r\n * Determines if a size has a positive area.\r\n * @param {Size} size The size to test.\r\n * @return {boolean} The size has a positive area.\r\n */\r\nexport function hasArea(size) {\r\n  return size[0] > 0 && size[1] > 0;\r\n}\r\n\r\n/**\r\n * Returns a size scaled by a ratio. The result will be an array of integers.\r\n * @param {Size} size Size.\r\n * @param {number} ratio Ratio.\r\n * @param {Size} [dest] Optional reusable size array.\r\n * @return {Size} The scaled size.\r\n */\r\nexport function scale(size, ratio, dest) {\r\n  if (dest === undefined) {\r\n    dest = [0, 0];\r\n  }\r\n  dest[0] = (size[0] * ratio + 0.5) | 0;\r\n  dest[1] = (size[1] * ratio + 0.5) | 0;\r\n  return dest;\r\n}\r\n\r\n/**\r\n * Returns an `Size` array for the passed in number (meaning: square) or\r\n * `Size` array.\r\n * (meaning: non-square),\r\n * @param {number|Size} size Width and height.\r\n * @param {Size} [dest] Optional reusable size array.\r\n * @return {Size} Size.\r\n * @api\r\n */\r\nexport function toSize(size, dest) {\r\n  if (Array.isArray(size)) {\r\n    return size;\r\n  }\r\n  if (dest === undefined) {\r\n    dest = [size, size];\r\n  } else {\r\n    dest[0] = size;\r\n    dest[1] = size;\r\n  }\r\n  return dest;\r\n}\r\n","/**\r\n * @module CME2D/tilegrid/TileGrid\r\n */\r\nimport TileRange, {\r\n  createOrUpdate as createOrUpdateTileRange,\r\n} from '../TileRange.js';\r\nimport {DEFAULT_TILE_SIZE} from './common.js';\r\nimport {assert} from '../asserts.js';\r\nimport {ceil, clamp, floor} from '../math.js';\r\nimport {createOrUpdate, getTopLeft} from '../extent.js';\r\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\r\nimport {intersectsLinearRing} from '../geom/flat/intersectsextent.js';\r\nimport {isSorted, linearFindNearest} from '../array.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @private\r\n * @type {import(\"../tilecoord.js\").TileCoord}\r\n */\r\nconst tmpTileCoord = [0, 0, 0];\r\n\r\n/**\r\n * Number of decimal digits to consider in integer values when rounding.\r\n * @type {number}\r\n */\r\nconst DECIMALS = 5;\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\r\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\r\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\r\n * @property {number} [minZoom=0] Minimum zoom.\r\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\r\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\r\n * specified, `extent` or `origins` must be provided.\r\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\r\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\r\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\r\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\r\n * `origin` must be provided.\r\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\r\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\r\n * array will have a length of `maxZoom + 1`.\r\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\r\n * of the grid for each zoom level. If specified the values\r\n * define each zoom level's extent together with the `origin` or `origins`.\r\n * A grid `extent` can be configured in addition, and will further limit the extent\r\n * for which tile requests are made by sources. If the bottom-left corner of\r\n * an extent is used as `origin` or `origins`, then the `y` value must be\r\n * negative because OpenLayers tile coordinates use the top left as the origin.\r\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\r\n * Default is `[256, 256]`.\r\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\r\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\r\n * tile size.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for setting the grid pattern for sources accessing tiled-image\r\n * servers.\r\n * @api\r\n */\r\nclass TileGrid {\r\n  /**\r\n   * @param {Options} options Tile grid options.\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<number>}\r\n     */\r\n    this.resolutions_ = options.resolutions;\r\n    assert(\r\n      isSorted(\r\n        this.resolutions_,\r\n        /**\r\n         * @param {number} a First resolution\r\n         * @param {number} b Second resolution\r\n         * @return {number} Comparison result\r\n         */\r\n        (a, b) => b - a,\r\n        true,\r\n      ),\r\n      '`resolutions` must be sorted in descending order',\r\n    );\r\n\r\n    // check if we've got a consistent zoom factor and origin\r\n    let zoomFactor;\r\n    if (!options.origins) {\r\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\r\n        if (!zoomFactor) {\r\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\r\n        } else {\r\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\r\n            zoomFactor = undefined;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.zoomFactor_ = zoomFactor;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.maxZoom = this.resolutions_.length - 1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate|null}\r\n     */\r\n    this.origin_ = options.origin !== undefined ? options.origin : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\r\n     */\r\n    this.origins_ = null;\r\n    if (options.origins !== undefined) {\r\n      this.origins_ = options.origins;\r\n      assert(\r\n        this.origins_.length == this.resolutions_.length,\r\n        'Number of `origins` and `resolutions` must be equal',\r\n      );\r\n    }\r\n\r\n    const extent = options.extent;\r\n\r\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\r\n      this.origin_ = getTopLeft(extent);\r\n    }\r\n\r\n    assert(\r\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\r\n      'Either `origin` or `origins` must be configured, never both',\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number|import(\"../size.js\").Size>}\r\n     */\r\n    this.tileSizes_ = null;\r\n    if (options.tileSizes !== undefined) {\r\n      this.tileSizes_ = options.tileSizes;\r\n      assert(\r\n        this.tileSizes_.length == this.resolutions_.length,\r\n        'Number of `tileSizes` and `resolutions` must be equal',\r\n      );\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|import(\"../size.js\").Size}\r\n     */\r\n    this.tileSize_ =\r\n      options.tileSize !== undefined\r\n        ? options.tileSize\r\n        : !this.tileSizes_\r\n          ? DEFAULT_TILE_SIZE\r\n          : null;\r\n    assert(\r\n      (!this.tileSize_ && this.tileSizes_) ||\r\n        (this.tileSize_ && !this.tileSizes_),\r\n      'Either `tileSize` or `tileSizes` must be configured, never both',\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = extent !== undefined ? extent : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import(\"../TileRange.js\").default>}\r\n     */\r\n    this.fullTileRanges_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../size.js\").Size}\r\n     */\r\n    this.tmpSize_ = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.tmpExtent_ = [0, 0, 0, 0];\r\n\r\n    if (options.sizes !== undefined) {\r\n      this.fullTileRanges_ = options.sizes.map((size, z) => {\r\n        const tileRange = new TileRange(\r\n          Math.min(0, size[0]),\r\n          Math.max(size[0] - 1, -1),\r\n          Math.min(0, size[1]),\r\n          Math.max(size[1] - 1, -1),\r\n        );\r\n        if (extent) {\r\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\r\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\r\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\r\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\r\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\r\n        }\r\n        return tileRange;\r\n      });\r\n    } else if (extent) {\r\n      this.calculateTileRanges_(extent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call a function with each tile coordinate for a given extent and zoom level.\r\n   *\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} zoom Integer zoom level.\r\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\r\n   * @api\r\n   */\r\n  forEachTileCoord(extent, zoom, callback) {\r\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\r\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\r\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\r\n        callback([zoom, i, j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {boolean} Callback succeeded.\r\n   */\r\n  forEachTileCoordParentTileRange(\r\n    tileCoord,\r\n    callback,\r\n    tempTileRange,\r\n    tempExtent,\r\n  ) {\r\n    let tileRange, x, y;\r\n    let tileCoordExtent = null;\r\n    let z = tileCoord[0] - 1;\r\n    if (this.zoomFactor_ === 2) {\r\n      x = tileCoord[1];\r\n      y = tileCoord[2];\r\n    } else {\r\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\r\n    }\r\n    while (z >= this.minZoom) {\r\n      if (x !== undefined && y !== undefined) {\r\n        x = Math.floor(x / 2);\r\n        y = Math.floor(y / 2);\r\n        tileRange = createOrUpdateTileRange(x, x, y, y, tempTileRange);\r\n      } else {\r\n        tileRange = this.getTileRangeForExtentAndZ(\r\n          tileCoordExtent,\r\n          z,\r\n          tempTileRange,\r\n        );\r\n      }\r\n      if (callback(z, tileRange)) {\r\n        return true;\r\n      }\r\n      --z;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get the extent for this tile grid, if it was configured.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return this.extent_;\r\n  }\r\n\r\n  /**\r\n   * Get the maximum zoom level for the grid.\r\n   * @return {number} Max zoom.\r\n   * @api\r\n   */\r\n  getMaxZoom() {\r\n    return this.maxZoom;\r\n  }\r\n\r\n  /**\r\n   * Get the minimum zoom level for the grid.\r\n   * @return {number} Min zoom.\r\n   * @api\r\n   */\r\n  getMinZoom() {\r\n    return this.minZoom;\r\n  }\r\n\r\n  /**\r\n   * Get the origin for the grid at the given zoom level.\r\n   * @param {number} z Integer zoom level.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\r\n   * @api\r\n   */\r\n  getOrigin(z) {\r\n    if (this.origin_) {\r\n      return this.origin_;\r\n    }\r\n    return this.origins_[z];\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for the given zoom level.\r\n   * @param {number} z Integer zoom level.\r\n   * @return {number} Resolution.\r\n   * @api\r\n   */\r\n  getResolution(z) {\r\n    return this.resolutions_[z];\r\n  }\r\n\r\n  /**\r\n   * Get the list of resolutions for the tile grid.\r\n   * @return {Array<number>} Resolutions.\r\n   * @api\r\n   */\r\n  getResolutions() {\r\n    return this.resolutions_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\r\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\r\n   */\r\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\r\n    if (tileCoord[0] < this.maxZoom) {\r\n      if (this.zoomFactor_ === 2) {\r\n        const minX = tileCoord[1] * 2;\r\n        const minY = tileCoord[2] * 2;\r\n        return createOrUpdateTileRange(\r\n          minX,\r\n          minX + 1,\r\n          minY,\r\n          minY + 1,\r\n          tempTileRange,\r\n        );\r\n      }\r\n      const tileCoordExtent = this.getTileCoordExtent(\r\n        tileCoord,\r\n        tempExtent || this.tmpExtent_,\r\n      );\r\n      return this.getTileRangeForExtentAndZ(\r\n        tileCoordExtent,\r\n        tileCoord[0] + 1,\r\n        tempTileRange,\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\r\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\r\n   */\r\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\r\n    if (z > this.maxZoom || z < this.minZoom) {\r\n      return null;\r\n    }\r\n\r\n    const tileCoordZ = tileCoord[0];\r\n    const tileCoordX = tileCoord[1];\r\n    const tileCoordY = tileCoord[2];\r\n\r\n    if (z === tileCoordZ) {\r\n      return createOrUpdateTileRange(\r\n        tileCoordX,\r\n        tileCoordY,\r\n        tileCoordX,\r\n        tileCoordY,\r\n        tempTileRange,\r\n      );\r\n    }\r\n\r\n    if (this.zoomFactor_) {\r\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\r\n      const minX = Math.floor(tileCoordX * factor);\r\n      const minY = Math.floor(tileCoordY * factor);\r\n      if (z < tileCoordZ) {\r\n        return createOrUpdateTileRange(minX, minX, minY, minY, tempTileRange);\r\n      }\r\n\r\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\r\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\r\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\r\n    }\r\n\r\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\r\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\r\n  }\r\n\r\n  /**\r\n   * Get a tile range for the given extent and integer zoom level.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary tile range object.\r\n   * @return {import(\"../TileRange.js\").default} Tile range.\r\n   */\r\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\r\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);\r\n    const minX = tmpTileCoord[1];\r\n    const minY = tmpTileCoord[2];\r\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);\r\n    const maxX = tmpTileCoord[1];\r\n    const maxY = tmpTileCoord[2];\r\n    return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\r\n   */\r\n  getTileCoordCenter(tileCoord) {\r\n    const origin = this.getOrigin(tileCoord[0]);\r\n    const resolution = this.getResolution(tileCoord[0]);\r\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\r\n    return [\r\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\r\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Get the extent of a tile coordinate.\r\n   *\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary extent object.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getTileCoordExtent(tileCoord, tempExtent) {\r\n    const origin = this.getOrigin(tileCoord[0]);\r\n    const resolution = this.getResolution(tileCoord[0]);\r\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\r\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\r\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\r\n    const maxX = minX + tileSize[0] * resolution;\r\n    const maxY = minY + tileSize[1] * resolution;\r\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\r\n  }\r\n\r\n  /**\r\n   * Get the tile coordinate for the given map coordinate and resolution.  This\r\n   * method considers that coordinates that intersect tile boundaries should be\r\n   * assigned the higher tile coordinate.\r\n   *\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} resolution Resolution.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\r\n    return this.getTileCoordForXYAndResolution_(\r\n      coordinate[0],\r\n      coordinate[1],\r\n      resolution,\r\n      false,\r\n      opt_tileCoord,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Note that this method should not be called for resolutions that correspond\r\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {number} resolution Resolution (for a non-integer zoom level).\r\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\r\n   *     intersections go to the higher tile coordinate, let edge intersections\r\n   *     go to the lower tile coordinate.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @private\r\n   */\r\n  getTileCoordForXYAndResolution_(\r\n    x,\r\n    y,\r\n    resolution,\r\n    reverseIntersectionPolicy,\r\n    opt_tileCoord,\r\n  ) {\r\n    const z = this.getZForResolution(resolution);\r\n    const scale = resolution / this.getResolution(z);\r\n    const origin = this.getOrigin(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n\r\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\r\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\r\n\r\n    if (reverseIntersectionPolicy) {\r\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\r\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\r\n    } else {\r\n      tileCoordX = floor(tileCoordX, DECIMALS);\r\n      tileCoordY = floor(tileCoordY, DECIMALS);\r\n    }\r\n\r\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\r\n  }\r\n\r\n  /**\r\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\r\n   * they should have separate implementations.  This method is for integer zoom\r\n   * levels.  The other method should only be called for resolutions corresponding\r\n   * to non-integer zoom levels.\r\n   * @param {number} x Map x coordinate.\r\n   * @param {number} y Map y coordinate.\r\n   * @param {number} z Integer zoom level.\r\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\r\n   *     intersections go to the higher tile coordinate, let edge intersections\r\n   *     go to the lower tile coordinate.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @private\r\n   */\r\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\r\n    const origin = this.getOrigin(z);\r\n    const resolution = this.getResolution(z);\r\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\r\n\r\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\r\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\r\n\r\n    if (reverseIntersectionPolicy) {\r\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\r\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\r\n    } else {\r\n      tileCoordX = floor(tileCoordX, DECIMALS);\r\n      tileCoordY = floor(tileCoordY, DECIMALS);\r\n    }\r\n\r\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\r\n  }\r\n\r\n  /**\r\n   * Get a tile coordinate given a map coordinate and zoom level.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call\r\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\r\n   * @api\r\n   */\r\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\r\n    return this.getTileCoordForXYAndZ_(\r\n      coordinate[0],\r\n      coordinate[1],\r\n      z,\r\n      false,\r\n      opt_tileCoord,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @return {number} Tile resolution.\r\n   */\r\n  getTileCoordResolution(tileCoord) {\r\n    return this.resolutions_[tileCoord[0]];\r\n  }\r\n\r\n  /**\r\n   * Get the tile size for a zoom level. The type of the return value matches the\r\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\r\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\r\n   * @param {number} z Z.\r\n   * @return {number|import(\"../size.js\").Size} Tile size.\r\n   * @api\r\n   */\r\n  getTileSize(z) {\r\n    if (this.tileSize_) {\r\n      return this.tileSize_;\r\n    }\r\n    return this.tileSizes_[z];\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Zoom level.\r\n   * @return {import(\"../TileRange.js\").default|null} Extent tile range for the specified zoom level.\r\n   */\r\n  getFullTileRange(z) {\r\n    if (!this.fullTileRanges_) {\r\n      return this.extent_\r\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\r\n        : null;\r\n    }\r\n    return this.fullTileRanges_[z];\r\n  }\r\n\r\n  /**\r\n   * @param {number} resolution Resolution.\r\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\r\n   *     If 0, the nearest resolution will be used.\r\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\r\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\r\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\r\n   *\r\n   * For example to change tile Z at the midpoint of zoom levels\r\n   * ```js\r\n   * function(value, high, low) {\r\n   *   return value - low * Math.sqrt(high / low);\r\n   * }\r\n   * ```\r\n   * @return {number} Z.\r\n   * @api\r\n   */\r\n  getZForResolution(resolution, opt_direction) {\r\n    const z = linearFindNearest(\r\n      this.resolutions_,\r\n      resolution,\r\n      opt_direction || 0,\r\n    );\r\n    return clamp(z, this.minZoom, this.maxZoom);\r\n  }\r\n\r\n  /**\r\n   * The tile with the provided tile coordinate intersects the given viewport.\r\n   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\r\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\r\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\r\n   */\r\n  tileCoordIntersectsViewport(tileCoord, viewport) {\r\n    return intersectsLinearRing(\r\n      viewport,\r\n      0,\r\n      viewport.length,\r\n      2,\r\n      this.getTileCoordExtent(tileCoord),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\r\n   * @private\r\n   */\r\n  calculateTileRanges_(extent) {\r\n    const length = this.resolutions_.length;\r\n    const fullTileRanges = new Array(length);\r\n    for (let z = this.minZoom; z < length; ++z) {\r\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\r\n    }\r\n    this.fullTileRanges_ = fullTileRanges;\r\n  }\r\n}\r\n\r\nexport default TileGrid;\r\n","/**\r\n * @module CME2D/tilegrid\r\n */\r\nimport TileGrid from './tilegrid/TileGrid.js';\r\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\r\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\r\nimport {\r\n  containsCoordinate,\r\n  createOrUpdate,\r\n  getCorner,\r\n  getHeight,\r\n  getWidth,\r\n} from './extent.js';\r\nimport {toSize} from './size.js';\r\n\r\nexport {TileGrid};\r\nexport {default as WMTS} from './tilegrid/WMTS.js';\r\n\r\n/**\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {!TileGrid} Default tile grid for the\r\n * passed projection.\r\n */\r\nexport function getForProjection(projection) {\r\n  let tileGrid = projection.getDefaultTileGrid();\r\n  if (!tileGrid) {\r\n    tileGrid = createForProjection(projection);\r\n    projection.setDefaultTileGrid(tileGrid);\r\n  }\r\n  return tileGrid;\r\n}\r\n\r\n/**\r\n * @param {TileGrid} tileGrid Tile grid.\r\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\r\n */\r\nexport function wrapX(tileGrid, tileCoord, projection) {\r\n  const z = tileCoord[0];\r\n  const center = tileGrid.getTileCoordCenter(tileCoord);\r\n  const projectionExtent = extentFromProjection(projection);\r\n  if (!containsCoordinate(projectionExtent, center)) {\r\n    const worldWidth = getWidth(projectionExtent);\r\n    const worldsAway = Math.ceil(\r\n      (projectionExtent[0] - center[0]) / worldWidth,\r\n    );\r\n    center[0] += worldWidth * worldsAway;\r\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\r\n  }\r\n  return tileCoord;\r\n}\r\n\r\n/**\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {number} [maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\r\n * @return {!TileGrid} TileGrid instance.\r\n */\r\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\r\n  corner = corner !== undefined ? corner : 'top-left';\r\n\r\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\r\n\r\n  return new TileGrid({\r\n    extent: extent,\r\n    origin: getCorner(extent, corner),\r\n    resolutions: resolutions,\r\n    tileSize: tileSize,\r\n  });\r\n}\r\n\r\n/**\r\n * @typedef {Object} XYZOptions\r\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\r\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\r\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\r\n * @property {number} [maxResolution] Resolution at level zero.\r\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\r\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\r\n * @property {number} [minZoom=0] Minimum zoom.\r\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\r\n */\r\n\r\n/**\r\n * Creates a tile grid with a standard XYZ tiling scheme.\r\n * @param {XYZOptions} [options] Tile grid options.\r\n * @return {!TileGrid} Tile grid instance.\r\n * @api\r\n */\r\nexport function createXYZ(options) {\r\n  const xyzOptions = options || {};\r\n\r\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\r\n\r\n  const gridOptions = {\r\n    extent: extent,\r\n    minZoom: xyzOptions.minZoom,\r\n    tileSize: xyzOptions.tileSize,\r\n    resolutions: resolutionsFromExtent(\r\n      extent,\r\n      xyzOptions.maxZoom,\r\n      xyzOptions.tileSize,\r\n      xyzOptions.maxResolution,\r\n    ),\r\n  };\r\n  return new TileGrid(gridOptions);\r\n}\r\n\r\n/**\r\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {number} [maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {number} [maxResolution] Resolution at level zero.\r\n * @return {!Array<number>} Resolutions array.\r\n */\r\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\r\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\r\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\r\n\r\n  const height = getHeight(extent);\r\n  const width = getWidth(extent);\r\n\r\n  maxResolution =\r\n    maxResolution > 0\r\n      ? maxResolution\r\n      : Math.max(width / tileSize[0], height / tileSize[1]);\r\n\r\n  const length = maxZoom + 1;\r\n  const resolutions = new Array(length);\r\n  for (let z = 0; z < length; ++z) {\r\n    resolutions[z] = maxResolution / Math.pow(2, z);\r\n  }\r\n  return resolutions;\r\n}\r\n\r\n/**\r\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\r\n * @param {number} [maxZoom] Maximum zoom level (default is\r\n *     DEFAULT_MAX_ZOOM).\r\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\r\n *     DEFAULT_TILE_SIZE).\r\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\r\n * @return {!TileGrid} TileGrid instance.\r\n */\r\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\r\n  const extent = extentFromProjection(projection);\r\n  return createForExtent(extent, maxZoom, tileSize, corner);\r\n}\r\n\r\n/**\r\n * Generate a tile grid extent from a projection.  If the projection has an\r\n * extent, it is used.  If not, a global extent is assumed.\r\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\r\n * @return {import(\"./extent.js\").Extent} Extent.\r\n */\r\nexport function extentFromProjection(projection) {\r\n  projection = getProjection(projection);\r\n  let extent = projection.getExtent();\r\n  if (!extent) {\r\n    const half =\r\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\r\n    extent = createOrUpdate(-half, -half, half, half);\r\n  }\r\n  return extent;\r\n}\r\n","/**\r\n * @module CME2D/source/Tile\r\n */\r\nimport Event from '../events/Event.js';\r\nimport Source from './Source.js';\r\nimport TileCache from '../TileCache.js';\r\nimport {abstract} from '../util.js';\r\nimport {assert} from '../asserts.js';\r\nimport {equivalent} from '../proj.js';\r\nimport {\r\n  getForProjection as getTileGridForProjection,\r\n  wrapX,\r\n} from '../tilegrid.js';\r\nimport {scale as scaleSize, toSize} from '../size.js';\r\nimport {withinExtentAndZ} from '../tilecoord.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\r\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\r\n * @property {number} [tilePixelRatio] TilePixelRatio.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\r\n * @property {import(\"./Source.js\").State} [state] State.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\r\n * @property {boolean} [wrapX=false] WrapX.\r\n * @property {number} [transition] Transition.\r\n * @property {string} [key] Key.\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for sources providing images divided into a tile grid.\r\n *\r\n * @template {import(\"../Tile.js\").default} [TileType=import(\"../Tile.js\").default]\r\n * @abstract\r\n * @api\r\n */\r\nclass TileSource extends Source {\r\n  /**\r\n   * @param {Options} options SourceTile source options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      wrapX: options.wrapX,\r\n      interpolate: options.interpolate,\r\n    });\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {TileSourceOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.tilePixelRatio_ =\r\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\r\n\r\n    /**\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\r\n     */\r\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\r\n\r\n    const tileSize = [256, 256];\r\n    if (this.tileGrid) {\r\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\r\n    }\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../TileCache.js\").default}\r\n     */\r\n    this.tileCache = new TileCache(options.cacheSize || 0);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../size.js\").Size}\r\n     */\r\n    this.tmpSize = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.key_ = options.key || '';\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Tile.js\").Options}\r\n     */\r\n    this.tileOptions = {\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n    };\r\n\r\n    /**\r\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\r\n     * by a renderer if the views resolution does not match any resolution of the tile source.\r\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\r\n     * will be used. If -1, the nearest higher resolution will be used.\r\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\r\n     */\r\n    this.zDirection = options.zDirection ? options.zDirection : 0;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    return this.tileCache.canExpireCache();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   */\r\n  expireCache(projection, usedTiles) {\r\n    const tileCache = this.getTileCacheForProjection(projection);\r\n    if (tileCache) {\r\n      tileCache.expireCache(usedTiles);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {number} Gutter.\r\n   */\r\n  getGutterForProjection(projection) {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Return the key to be used for all tiles in the source.\r\n   * @return {string} The key for all tiles.\r\n   */\r\n  getKey() {\r\n    return this.key_;\r\n  }\r\n\r\n  /**\r\n   * Set the value to be used as the key for all tiles in the source.\r\n   * @param {string} key The key for tiles.\r\n   * @protected\r\n   */\r\n  setKey(key) {\r\n    if (this.key_ !== key) {\r\n      this.key_ = key;\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\r\n   * @return {Array<number>|null} Resolutions.\r\n   * @override\r\n   */\r\n  getResolutions(projection) {\r\n    const tileGrid = projection\r\n      ? this.getTileGridForProjection(projection)\r\n      : this.tileGrid;\r\n    if (!tileGrid) {\r\n      return null;\r\n    }\r\n    return tileGrid.getResolutions();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {TileType|null} Tile.\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the tile grid of the tile source.\r\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\r\n   * @api\r\n   */\r\n  getTileGrid() {\r\n    return this.tileGrid;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\r\n   */\r\n  getTileGridForProjection(projection) {\r\n    if (!this.tileGrid) {\r\n      return getTileGridForProjection(projection);\r\n    }\r\n    return this.tileGrid;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../TileCache.js\").default} Tile cache.\r\n   * @protected\r\n   */\r\n  getTileCacheForProjection(projection) {\r\n    const sourceProjection = this.getProjection();\r\n    assert(\r\n      sourceProjection === null || equivalent(sourceProjection, projection),\r\n      'A VectorTile source can only be rendered if it has a projection compatible with the view projection.',\r\n    );\r\n    return this.tileCache;\r\n  }\r\n\r\n  /**\r\n   * Get the tile pixel ratio for this source. Subclasses may override this\r\n   * method, which is meant to return a supported pixel ratio that matches the\r\n   * provided `pixelRatio` as close as possible.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @return {number} Tile pixel ratio.\r\n   */\r\n  getTilePixelRatio(pixelRatio) {\r\n    return this.tilePixelRatio_;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Z.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../size.js\").Size} Tile size.\r\n   */\r\n  getTilePixelSize(z, pixelRatio, projection) {\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\r\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\r\n    if (tilePixelRatio == 1) {\r\n      return tileSize;\r\n    }\r\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\r\n  }\r\n\r\n  /**\r\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\r\n   * is outside the resolution and extent range of the tile grid, `null` will be\r\n   * returned.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\r\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\r\n   *     null if no tile URL should be created for the passed `tileCoord`.\r\n   */\r\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\r\n    projection = projection !== undefined ? projection : this.getProjection();\r\n    const tileGrid = this.getTileGridForProjection(projection);\r\n    if (this.getWrapX() && projection.isGlobal()) {\r\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\r\n    }\r\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\r\n  }\r\n\r\n  /**\r\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\r\n   * @api\r\n   */\r\n  clear() {\r\n    this.tileCache.clear();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  refresh() {\r\n    this.clear();\r\n    super.refresh();\r\n  }\r\n\r\n  /**\r\n   * Marks a tile coord as being used, without triggering a load.\r\n   * @abstract\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   */\r\n  useTile(z, x, y, projection) {}\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\r\n * type.\r\n */\r\nexport class TileSourceEvent extends Event {\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../Tile.js\").default} tile The tile.\r\n   */\r\n  constructor(type, tile) {\r\n    super(type);\r\n\r\n    /**\r\n     * The tile related to the event.\r\n     * @type {import(\"../Tile.js\").default}\r\n     * @api\r\n     */\r\n    this.tile = tile;\r\n  }\r\n}\r\n\r\nexport default TileSource;\r\n","/**\r\n * @module CME2D/source/DataTile\r\n */\r\nimport DataTile from '../DataTile.js';\r\nimport EventType from '../events/EventType.js';\r\nimport ReprojDataTile from '../reproj/DataTile.js';\r\nimport TileCache from '../TileCache.js';\r\nimport TileEventType from './TileEventType.js';\r\nimport TileSource, {TileSourceEvent} from './Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport {\r\n  createXYZ,\r\n  extentFromProjection,\r\n  getForProjection as getTileGridForProjection,\r\n} from '../tilegrid.js';\r\nimport {equivalent, get as getProjection} from '../proj.js';\r\nimport {getKeyZXY} from '../tilecoord.js';\r\nimport {getUid} from '../util.js';\r\nimport {toPromise} from '../functions.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute\r\n */\r\n\r\n/**\r\n * @typedef {Object} LoaderOptions\r\n * @property {AbortSignal} signal An abort controller signal.\r\n * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.\r\n * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the\r\n * underlying tile grid does not have a known extent.\r\n */\r\n\r\n/**\r\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\r\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\r\n * @typedef {function(number, number, number, LoaderOptions) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\r\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\r\n * For loaders that generate images, the promise should not resolve until the image is loaded.\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\r\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\r\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\r\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\r\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\r\n * This allows artifacts of rendering at tile edges to be ignored.\r\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\r\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\r\n * @property {import(\"./Source.js\").State} [state] The source state.\r\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\r\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\r\n * @property {number} [bandCount=4] Number of bands represented in the data.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\r\n * @property {string} [key] Key for use in caching tiles.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A source for typed array data tiles.\r\n *\r\n * @fires import(\"./Tile.js\").TileSourceEvent\r\n * @template {import(\"../Tile.js\").default} [TileType=DataTile]\r\n * @extends TileSource<TileType>\r\n * @api\r\n */\r\nclass DataTileSource extends TileSource {\r\n  /**\r\n   * @param {Options} options DataTile source options.\r\n   */\r\n  constructor(options) {\r\n    const projection =\r\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\r\n\r\n    let tileGrid = options.tileGrid;\r\n    if (tileGrid === undefined && projection) {\r\n      tileGrid = createXYZ({\r\n        extent: extentFromProjection(projection),\r\n        maxResolution: options.maxResolution,\r\n        maxZoom: options.maxZoom,\r\n        minZoom: options.minZoom,\r\n        tileSize: options.tileSize,\r\n      });\r\n    }\r\n\r\n    super({\r\n      cacheSize: 0.1, // don't cache on the source\r\n      attributions: options.attributions,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      projection: projection,\r\n      tileGrid: tileGrid,\r\n      state: options.state,\r\n      wrapX: options.wrapX,\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n      key: options.key,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import('../size.js').Size|null}\r\n     */\r\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<import('../size.js').Size>|null}\r\n     */\r\n    this.tileSizes_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, boolean>}\r\n     */\r\n    this.tileLoadingKeys_ = {};\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.loader_ = options.loader;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\r\n     */\r\n    this.tileGridForProjection_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, import(\"../TileCache.js\").default>}\r\n     */\r\n    this.tileCacheForProjection_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {CrossOriginAttribute}\r\n     */\r\n    this.crossOrigin_ = options.crossOrigin || 'anonymous';\r\n  }\r\n\r\n  /**\r\n   * Set the source tile sizes.  The length of the array is expected to match the number of\r\n   * levels in the tile grid.\r\n   * @protected\r\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\r\n   */\r\n  setTileSizes(tileSizes) {\r\n    this.tileSizes_ = tileSizes;\r\n  }\r\n\r\n  /**\r\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\r\n   * size.\r\n   * @protected\r\n   * @param {number} z Tile zoom level.\r\n   * @return {import('../size.js').Size} The source tile size.\r\n   */\r\n  getTileSize(z) {\r\n    if (this.tileSizes_) {\r\n      return this.tileSizes_[z];\r\n    }\r\n    if (this.tileSize_) {\r\n      return this.tileSize_;\r\n    }\r\n    const tileGrid = this.getTileGrid();\r\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {number} Gutter.\r\n   * @override\r\n   */\r\n  getGutterForProjection(projection) {\r\n    const thisProj = this.getProjection();\r\n    if (!thisProj || equivalent(thisProj, projection)) {\r\n      return this.gutter_;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @param {Loader} loader The data loader.\r\n   * @protected\r\n   */\r\n  setLoader(loader) {\r\n    this.loader_ = loader;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\r\n   * @return {!TileType} Tile.\r\n   */\r\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\r\n    const cache = this.getTileCacheForProjection(targetProj);\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    if (cache.containsKey(tileCoordKey)) {\r\n      const tile = cache.get(tileCoordKey);\r\n      if (tile && tile.key == this.getKey()) {\r\n        return tile;\r\n      }\r\n    }\r\n\r\n    const tileGrid = this.getTileGrid();\r\n    const reprojTilePixelRatio = Math.max.apply(\r\n      null,\r\n      tileGrid.getResolutions().map((r, z) => {\r\n        const tileSize = toSize(tileGrid.getTileSize(z));\r\n        const textureSize = this.getTileSize(z);\r\n        return Math.max(\r\n          textureSize[0] / tileSize[0],\r\n          textureSize[1] / tileSize[1],\r\n        );\r\n      }),\r\n    );\r\n\r\n    const sourceTileGrid = this.getTileGridForProjection(sourceProj);\r\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\r\n    const tileCoord = [z, x, y];\r\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\r\n      tileCoord,\r\n      targetProj,\r\n    );\r\n\r\n    const options = Object.assign(\r\n      {\r\n        sourceProj,\r\n        sourceTileGrid,\r\n        targetProj,\r\n        targetTileGrid,\r\n        tileCoord,\r\n        wrappedTileCoord,\r\n        pixelRatio: reprojTilePixelRatio,\r\n        gutter: this.getGutterForProjection(sourceProj),\r\n        getTileFunction: (z, x, y, pixelRatio) =>\r\n          this.getTile(z, x, y, pixelRatio, sourceProj),\r\n      },\r\n      /** @type {import(\"../reproj/DataTile.js\").Options} */ (this.tileOptions),\r\n    );\r\n    const newTile = /** @type {TileType} */ (\r\n      /** @type {*} */ (new ReprojDataTile(options))\r\n    );\r\n    newTile.key = this.getKey();\r\n    return newTile;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {TileType|null} Tile (or null if outside source extent).\r\n   * @override\r\n   */\r\n  getTile(z, x, y, pixelRatio, projection) {\r\n    const sourceProjection = this.getProjection();\r\n    if (\r\n      sourceProjection &&\r\n      projection &&\r\n      !equivalent(sourceProjection, projection)\r\n    ) {\r\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\r\n    }\r\n\r\n    const size = this.getTileSize(z);\r\n    const tileCoordKey = getKeyZXY(z, x, y);\r\n    if (this.tileCache.containsKey(tileCoordKey)) {\r\n      return this.tileCache.get(tileCoordKey);\r\n    }\r\n\r\n    const sourceLoader = this.loader_;\r\n    const controller = new AbortController();\r\n    /**\r\n     * @type {LoaderOptions}\r\n     */\r\n    const loaderOptions = {\r\n      signal: controller.signal,\r\n      crossOrigin: this.crossOrigin_,\r\n    };\r\n\r\n    const tileCoord = this.getTileCoordForTileUrlFunction([z, x, y]);\r\n    if (!tileCoord) {\r\n      return null;\r\n    }\r\n\r\n    const requestZ = tileCoord[0];\r\n    const requestX = tileCoord[1];\r\n    const requestY = tileCoord[2];\r\n    function loader() {\r\n      return toPromise(function () {\r\n        return sourceLoader(requestZ, requestX, requestY, loaderOptions);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * @type {import(\"../DataTile.js\").Options}\r\n     */\r\n    const options = Object.assign(\r\n      {\r\n        tileCoord: [z, x, y],\r\n        loader: loader,\r\n        size: size,\r\n        controller: controller,\r\n      },\r\n      this.tileOptions,\r\n    );\r\n\r\n    const tile = /** @type {TileType} */ (\r\n      /** @type {*} */ (new DataTile(options))\r\n    );\r\n    tile.key = this.getKey();\r\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\r\n\r\n    this.tileCache.set(tileCoordKey, tile);\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * Handle tile change events.\r\n   * @param {import(\"../events/Event.js\").default} event Event.\r\n   */\r\n  handleTileChange_(event) {\r\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\r\n    const uid = getUid(tile);\r\n    const tileState = tile.getState();\r\n    let type;\r\n    if (tileState == TileState.LOADING) {\r\n      this.tileLoadingKeys_[uid] = true;\r\n      type = TileEventType.TILELOADSTART;\r\n    } else if (uid in this.tileLoadingKeys_) {\r\n      delete this.tileLoadingKeys_[uid];\r\n      type =\r\n        tileState == TileState.ERROR\r\n          ? TileEventType.TILELOADERROR\r\n          : tileState == TileState.LOADED\r\n            ? TileEventType.TILELOADEND\r\n            : undefined;\r\n    }\r\n    if (type) {\r\n      this.dispatchEvent(new TileSourceEvent(type, tile));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\r\n   * @override\r\n   */\r\n  getTileGridForProjection(projection) {\r\n    const thisProj = this.getProjection();\r\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\r\n      return this.tileGrid;\r\n    }\r\n    const projKey = getUid(projection);\r\n    if (!(projKey in this.tileGridForProjection_)) {\r\n      this.tileGridForProjection_[projKey] =\r\n        getTileGridForProjection(projection);\r\n    }\r\n    return this.tileGridForProjection_[projKey];\r\n  }\r\n\r\n  /**\r\n   * Sets the tile grid to use when reprojecting the tiles to the given\r\n   * projection instead of the default tile grid for the projection.\r\n   *\r\n   * This can be useful when the default tile grid cannot be created\r\n   * (e.g. projection has no extent defined) or\r\n   * for optimization reasons (custom tile size, resolutions, ...).\r\n   *\r\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\r\n   * @api\r\n   */\r\n  setTileGridForProjection(projection, tilegrid) {\r\n    const proj = getProjection(projection);\r\n    if (proj) {\r\n      const projKey = getUid(proj);\r\n      if (!(projKey in this.tileGridForProjection_)) {\r\n        this.tileGridForProjection_[projKey] = tilegrid;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../TileCache.js\").default} Tile cache.\r\n   * @override\r\n   */\r\n  getTileCacheForProjection(projection) {\r\n    const thisProj = this.getProjection();\r\n    if (!thisProj || equivalent(thisProj, projection)) {\r\n      return this.tileCache;\r\n    }\r\n\r\n    const projKey = getUid(projection);\r\n    if (!(projKey in this.tileCacheForProjection_)) {\r\n      this.tileCacheForProjection_[projKey] = new TileCache(0.1); // don't cache\r\n    }\r\n    return this.tileCacheForProjection_[projKey];\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\r\n   * @override\r\n   */\r\n  expireCache(projection, usedTiles) {\r\n    const usedTileCache = this.getTileCacheForProjection(projection);\r\n\r\n    this.tileCache.expireCache(\r\n      this.tileCache == usedTileCache ? usedTiles : {},\r\n    );\r\n    for (const id in this.tileCacheForProjection_) {\r\n      const tileCache = this.tileCacheForProjection_[id];\r\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  clear() {\r\n    super.clear();\r\n    for (const id in this.tileCacheForProjection_) {\r\n      this.tileCacheForProjection_[id].clear();\r\n    }\r\n  }\r\n}\r\n\r\nexport default DataTileSource;\r\n","/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\nimport { CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT } from \"./messages.mjs\";\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nexport const {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nexport const NativeProxy = Proxy;\n\n// Number\nexport const {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nexport const {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nexport const NativeObject = Object;\nexport const {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nexport const ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nexport const ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nexport const ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nexport const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nexport const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nexport const ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nexport const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nexport const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nexport const {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nexport const NativeArrayBuffer = ArrayBuffer;\nexport const ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nexport const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nexport const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nexport const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nexport const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nexport const TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nexport const TypedArrayPrototype = TypedArray.prototype;\nexport const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nexport const TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nexport const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nexport const TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nexport const TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nexport const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nexport const TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nexport const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nexport const NativeUint8Array = Uint8Array;\n\n// Uint16Array\nexport const NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nexport const Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nexport const NativeUint32Array = Uint32Array;\n\n// Float32Array\nexport const NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nexport const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nexport const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nexport const GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nexport const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nexport const DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nexport const DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nexport const NativeTypeError = TypeError;\nexport const NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nexport const NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nexport const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nexport const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nexport const NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nexport const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nexport const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nexport const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n","import {\n  ArrayIteratorPrototype,\n  ArrayIteratorPrototypeNext,\n  ArrayPrototypeSymbolIterator,\n  GeneratorPrototypeNext,\n  IteratorPrototype,\n  NativeArrayPrototypeSymbolIterator,\n  NativeWeakMap,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  SymbolIterator,\n  WeakMapPrototypeGet,\n  WeakMapPrototypeSet,\n} from \"./primordials.mjs\";\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new NativeWeakMap();\n\nconst SafeIteratorPrototype = ObjectCreate(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n      return ArrayIteratorPrototypeNext(arrayIterator);\n    },\n  },\n\n  [SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nexport function safeIfNeeded(array) {\n  if (\n    array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n    ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = ObjectCreate(SafeIteratorPrototype);\n  WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = WeakMapPrototypeGet(generators, this);\n      return GeneratorPrototypeNext(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nexport function wrap(generator) {\n  const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n  WeakMapPrototypeSet(generators, dummy, generator);\n  return dummy;\n}\n","import {\n  EPSILON,\n  MathAbs,\n  NativeArrayBuffer,\n  NativeFloat32Array,\n  NativeUint16Array,\n  NativeUint32Array,\n  NativeUint8Array,\n  NumberIsFinite,\n  NumberIsNaN,\n} from \"./primordials.mjs\";\n\nconst INVERSE_OF_EPSILON = 1 / EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number\n */\nexport function roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!NumberIsFinite(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = MathAbs(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new NativeArrayBuffer(4);\nconst floatView = new NativeFloat32Array(buffer);\nconst uint32View = new NativeUint32Array(buffer);\n\nconst baseTable = new NativeUint16Array(512);\nconst shiftTable = new NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -24) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n","import { safeIfNeeded } from \"./_util/arrayIterator.mjs\";\nimport { convertToNumber, roundToFloat16Bits } from \"./_util/converter.mjs\";\nimport {\n  DataViewPrototypeGetUint16,\n  DataViewPrototypeSetUint16,\n} from \"./_util/primordials.mjs\";\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nexport function getFloat16(dataView, byteOffset, ...opts) {\n  return convertToNumber(\n    DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nexport function setFloat16(dataView, byteOffset, value, ...opts) {\n  return DataViewPrototypeSetUint16(\n    dataView,\n    byteOffset,\n    roundToFloat16Bits(value),\n    ...safeIfNeeded(opts)\n  );\n}\n","function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports.default = getAttribute;\n","function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports.default = indexOfMatch;\n","function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports.default = indexOfMatchEnd;\n","function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports.default = countSubstring;\n","const indexOfMatch = require(\"./index-of-match.js\");\nconst indexOfMatchEnd = require(\"./index-of-match-end.js\");\nconst countSubstring = require(\"./count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;\n","const findTagByName = require(\"./find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports.default = findTagsByName;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export default class QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n\n\n    debugger\n    console.log(\"headers-signal---------------------------\")\n    console.log(headers)\n    let _cmeUrl = this.url;\n    if (headers.Range) {\n      debugger\n      _cmeUrl = this.url + '?Range=' + headers.Range.match(/=([^=]*)$/)[1]\n    }\n\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","export default {}","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n","/**\r\n * @module CME2D/source/GeoTIFF\r\n */\r\nimport DataTile from './DataTile.js';\r\nimport TileGrid from '../tilegrid/TileGrid.js';\r\nimport {\r\n  Pool,\r\n  globals as geotiffGlobals,\r\n  fromBlob as tiffFromBlob,\r\n  fromUrl as tiffFromUrl,\r\n  fromUrls as tiffFromUrls,\r\n} from 'geotiff';\r\nimport {\r\n  Projection,\r\n  get as getCachedProjection,\r\n  toUserCoordinate,\r\n  toUserExtent,\r\n} from '../proj.js';\r\nimport {clamp} from '../math.js';\r\nimport {getCenter, getIntersection} from '../extent.js';\r\nimport {error as logError} from '../console.js';\r\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\r\n\r\n/**\r\n * Determine if an image type is a mask.\r\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\r\n * @param {GeoTIFFImage} image The image.\r\n * @return {boolean} The image is a mask.\r\n */\r\nfunction isMask(image) {\r\n  const fileDirectory = image.fileDirectory;\r\n  const type = fileDirectory.NewSubfileType || 0;\r\n  return (type & 4) === 4;\r\n}\r\n\r\n/**\r\n * @param {true|false|'auto'} preference The convertToRGB option.\r\n * @param {GeoTIFFImage} image The image.\r\n * @return {boolean} Use the `image.readRGB()` method.\r\n */\r\nfunction readRGB(preference, image) {\r\n  if (!preference) {\r\n    return false;\r\n  }\r\n  if (preference === true) {\r\n    return true;\r\n  }\r\n  if (image.getSamplesPerPixel() !== 3) {\r\n    return false;\r\n  }\r\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\r\n  const interpretations = geotiffGlobals.photometricInterpretations;\r\n  return (\r\n    interpretation === interpretations.CMYK ||\r\n    interpretation === interpretations.YCbCr ||\r\n    interpretation === interpretations.CIELab ||\r\n    interpretation === interpretations.ICCLab\r\n  );\r\n}\r\n\r\n/**\r\n * @typedef {Object} SourceInfo\r\n * @property {string} [url] URL for the source GeoTIFF.\r\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\r\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\r\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\r\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\r\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\r\n * the `normalize` option to `false` in the constructor.\r\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\r\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\r\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\r\n * the `normalize` option to `false` in the constructor.\r\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\r\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\r\n * will include information about nodata values, so you should only need to set this property if\r\n * you find that it is not already extracted from the metadata.\r\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\r\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\r\n * near-infrared band, configure `bands: [4]`.\r\n */\r\n\r\n/**\r\n * @typedef {Object} GeoKeys\r\n * @property {number} GTModelTypeGeoKey Model type.\r\n * @property {number} GTRasterTypeGeoKey Raster type.\r\n * @property {number} GeogAngularUnitsGeoKey Angular units.\r\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\r\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\r\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\r\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\r\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\r\n */\r\n\r\n/**\r\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\r\n */\r\n\r\n/**\r\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\r\n */\r\n\r\n/**\r\n * @typedef {Object} GDALMetadata\r\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\r\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\r\n */\r\n\r\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\r\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\r\n\r\nconst defaultTileSize = 256;\r\n\r\n/**\r\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\r\n */\r\n\r\nlet workerPool;\r\nfunction getWorkerPool() {\r\n  if (!workerPool) {\r\n    workerPool = new Pool();\r\n  }\r\n  return workerPool;\r\n}\r\n\r\n/**\r\n * Get the bounding box of an image.  If the image does not have an affine transform,\r\n * the pixel bounds are returned.\r\n * @param {GeoTIFFImage} image The image.\r\n * @return {Array<number>} The image bounding box.\r\n */\r\nfunction getBoundingBox(image) {\r\n  try {\r\n    return image.getBoundingBox();\r\n  } catch (_) {\r\n    return [0, 0, image.getWidth(), image.getHeight()];\r\n  }\r\n}\r\n\r\n/**\r\n * Get the origin of an image.  If the image does not have an affine transform,\r\n * the top-left corner of the pixel bounds is returned.\r\n * @param {GeoTIFFImage} image The image.\r\n * @return {Array<number>} The image origin.\r\n */\r\nfunction getOrigin(image) {\r\n  try {\r\n    return image.getOrigin().slice(0, 2);\r\n  } catch (_) {\r\n    return [0, image.getHeight()];\r\n  }\r\n}\r\n\r\n/**\r\n * Get the resolution of an image.  If the image does not have an affine transform,\r\n * the width of the image is compared with the reference image.\r\n * @param {GeoTIFFImage} image The image.\r\n * @param {GeoTIFFImage} referenceImage The reference image.\r\n * @return {Array<number>} The map x and y units per pixel.\r\n */\r\nfunction getResolutions(image, referenceImage) {\r\n  try {\r\n    return image.getResolution(referenceImage);\r\n  } catch (_) {\r\n    return [\r\n      referenceImage.getWidth() / image.getWidth(),\r\n      referenceImage.getHeight() / image.getHeight(),\r\n    ];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {GeoTIFFImage} image A GeoTIFF.\r\n * @return {import(\"../proj/Projection.js\").default} The image projection.\r\n */\r\nfunction getProjection(image) {\r\n  const geoKeys = image.geoKeys;\r\n  if (!geoKeys) {\r\n    return null;\r\n  }\r\n\r\n  if (\r\n    geoKeys.ProjectedCSTypeGeoKey &&\r\n    geoKeys.ProjectedCSTypeGeoKey !== 32767\r\n  ) {\r\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\r\n    let projection = getCachedProjection(code);\r\n    if (!projection) {\r\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\r\n      if (units) {\r\n        projection = new Projection({\r\n          code: code,\r\n          units: units,\r\n        });\r\n      }\r\n    }\r\n    return projection;\r\n  }\r\n\r\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\r\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\r\n    let projection = getCachedProjection(code);\r\n    if (!projection) {\r\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\r\n      if (units) {\r\n        projection = new Projection({\r\n          code: code,\r\n          units: units,\r\n        });\r\n      }\r\n    }\r\n    return projection;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\r\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\r\n */\r\nfunction getImagesForTIFF(tiff) {\r\n  return tiff.getImageCount().then(function (count) {\r\n    const requests = new Array(count);\r\n    for (let i = 0; i < count; ++i) {\r\n      requests[i] = tiff.getImage(i);\r\n    }\r\n    return Promise.all(requests);\r\n  });\r\n}\r\n\r\n/**\r\n * @param {SourceInfo} source The GeoTIFF source.\r\n * @param {Object} options Options for the GeoTIFF source.\r\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\r\n */\r\nfunction getImagesForSource(source, options) {\r\n  let request;\r\n  if (source.blob) {\r\n    request = tiffFromBlob(source.blob);\r\n  } else if (source.overviews) {\r\n    request = tiffFromUrls(source.url, source.overviews, options);\r\n  } else {\r\n    request = tiffFromUrl(source.url, options);\r\n  }\r\n  return request.then(getImagesForTIFF);\r\n}\r\n\r\n/**\r\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\r\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\r\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\r\n * @param {string} message The error message.\r\n * @param {function(Error):void} rejector A function to be called with any error.\r\n */\r\nfunction assertEqual(expected, got, tolerance, message, rejector) {\r\n  if (Array.isArray(expected)) {\r\n    const length = expected.length;\r\n    if (!Array.isArray(got) || length != got.length) {\r\n      const error = new Error(message);\r\n      rejector(error);\r\n      throw error;\r\n    }\r\n    for (let i = 0; i < length; ++i) {\r\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\r\n    }\r\n    return;\r\n  }\r\n\r\n  got = /** @type {number} */ (got);\r\n  if (Math.abs(expected - got) > tolerance * expected) {\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array} array The data array.\r\n * @return {number} The minimum value.\r\n */\r\nfunction getMinForDataType(array) {\r\n  if (array instanceof Int8Array) {\r\n    return -128;\r\n  }\r\n  if (array instanceof Int16Array) {\r\n    return -32768;\r\n  }\r\n  if (array instanceof Int32Array) {\r\n    return -2147483648;\r\n  }\r\n  if (array instanceof Float32Array) {\r\n    return 1.2e-38;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/**\r\n * @param {Array} array The data array.\r\n * @return {number} The maximum value.\r\n */\r\nfunction getMaxForDataType(array) {\r\n  if (array instanceof Int8Array) {\r\n    return 127;\r\n  }\r\n  if (array instanceof Uint8Array) {\r\n    return 255;\r\n  }\r\n  if (array instanceof Uint8ClampedArray) {\r\n    return 255;\r\n  }\r\n  if (array instanceof Int16Array) {\r\n    return 32767;\r\n  }\r\n  if (array instanceof Uint16Array) {\r\n    return 65535;\r\n  }\r\n  if (array instanceof Int32Array) {\r\n    return 2147483647;\r\n  }\r\n  if (array instanceof Uint32Array) {\r\n    return 4294967295;\r\n  }\r\n  if (array instanceof Float32Array) {\r\n    return 3.4e38;\r\n  }\r\n  return 255;\r\n}\r\n\r\n/**\r\n * @typedef {Object} GeoTIFFSourceOptions\r\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\r\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\r\n * @property {string} [credentials] How credentials shall be handled. See\r\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\r\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\r\n * By default only a single range is used.\r\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\r\n * requested. Only use this when you know the source image to be small enough to fit in memory.\r\n * @property {number} [blockSize=65536] The block size to use.\r\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\r\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\r\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\r\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\r\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\r\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\r\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\r\n * band from the first source, and 1 band from the second source.\r\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\r\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\r\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\r\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\r\n * CIELab, and ICCLab images will automatically be converted to RGB.\r\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\r\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\r\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\r\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\r\n * will be read for projection information.\r\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\r\n * To disable the opacity transition, pass `transition: 0`.\r\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A source for working with GeoTIFF data.\r\n * **Note for users of the full build**: The `GeoTIFF` source requires the\r\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\r\n *\r\n * @api\r\n */\r\nclass GeoTIFFSource extends DataTile {\r\n  /**\r\n   * @param {Options} options Data tile options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      state: 'loading',\r\n      tileGrid: null,\r\n      projection: options.projection || null,\r\n      transition: options.transition,\r\n      interpolate: options.interpolate !== false,\r\n      wrapX: options.wrapX,\r\n    });\r\n\r\n    /**\r\n     * @type {Array<SourceInfo>}\r\n     * @private\r\n     */\r\n    this.sourceInfo_ = options.sources;\r\n\r\n    const numSources = this.sourceInfo_.length;\r\n\r\n    /**\r\n     * @type {Object}\r\n     * @private\r\n     */\r\n    this.sourceOptions_ = options.sourceOptions;\r\n\r\n    /**\r\n     * @type {Array<Array<GeoTIFFImage>>}\r\n     * @private\r\n     */\r\n    this.sourceImagery_ = new Array(numSources);\r\n\r\n    /**\r\n     * @type {Array<Array<GeoTIFFImage>>}\r\n     * @private\r\n     */\r\n    this.sourceMasks_ = new Array(numSources);\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.resolutionFactors_ = new Array(numSources);\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.samplesPerPixel_;\r\n\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     * @private\r\n     */\r\n    this.nodataValues_;\r\n\r\n    /**\r\n     * @type {Array<Array<GDALMetadata>>}\r\n     * @private\r\n     */\r\n    this.metadata_;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.normalize_ = options.normalize !== false;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.addAlpha_ = false;\r\n\r\n    /**\r\n     * @type {Error}\r\n     * @private\r\n     */\r\n    this.error_ = null;\r\n\r\n    /**\r\n     * @type {true|false|'auto'}\r\n     * @private\r\n     */\r\n    this.convertToRGB_ = options.convertToRGB || false;\r\n\r\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\r\n\r\n    const self = this;\r\n    const requests = new Array(numSources);\r\n    for (let i = 0; i < numSources; ++i) {\r\n      requests[i] = getImagesForSource(\r\n        this.sourceInfo_[i],\r\n        this.sourceOptions_,\r\n      );\r\n    }\r\n    Promise.all(requests)\r\n      .then(function (sources) {\r\n        self.configure_(sources);\r\n      })\r\n      .catch(function (error) {\r\n        logError(error);\r\n        self.error_ = error;\r\n        self.setState('error');\r\n      });\r\n  }\r\n\r\n  /**\r\n   * @return {Error} A source loading error. When the source state is `error`, use this function\r\n   * to get more information about the error. To debug a faulty configuration, you may want to use\r\n   * a listener like\r\n   * ```js\r\n   * geotiffSource.on('change', () => {\r\n   *   if (geotiffSource.getState() === 'error') {\r\n   *     console.error(geotiffSource.getError());\r\n   *   }\r\n   * });\r\n   * ```\r\n   */\r\n  getError() {\r\n    return this.error_;\r\n  }\r\n\r\n  /**\r\n   * Determine the projection of the images in this GeoTIFF.\r\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\r\n   * of each image in turn.\r\n   * You can override this method in a subclass to support more projections.\r\n   *\r\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\r\n   * from a single GeoTIFF.\r\n   */\r\n  determineProjection(sources) {\r\n    const firstSource = sources[0];\r\n    for (let i = firstSource.length - 1; i >= 0; --i) {\r\n      const image = firstSource[i];\r\n      const projection = getProjection(image);\r\n      if (projection) {\r\n        this.projection = projection;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\r\n   * must have the same internal tiled structure.\r\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\r\n   * from a single GeoTIFF.\r\n   * @private\r\n   */\r\n  configure_(sources) {\r\n    let extent;\r\n    let origin;\r\n    let commonRenderTileSizes;\r\n    let commonSourceTileSizes;\r\n    let resolutions;\r\n    const samplesPerPixel = new Array(sources.length);\r\n    const nodataValues = new Array(sources.length);\r\n    const metadata = new Array(sources.length);\r\n    let minZoom = 0;\r\n\r\n    const sourceCount = sources.length;\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      const images = [];\r\n      const masks = [];\r\n      sources[sourceIndex].forEach((item) => {\r\n        if (isMask(item)) {\r\n          masks.push(item);\r\n        } else {\r\n          images.push(item);\r\n        }\r\n      });\r\n\r\n      const imageCount = images.length;\r\n      if (masks.length > 0 && masks.length !== imageCount) {\r\n        throw new Error(\r\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`,\r\n        );\r\n      }\r\n\r\n      let sourceExtent;\r\n      let sourceOrigin;\r\n      const sourceTileSizes = new Array(imageCount);\r\n      const renderTileSizes = new Array(imageCount);\r\n      const sourceResolutions = new Array(imageCount);\r\n\r\n      nodataValues[sourceIndex] = new Array(imageCount);\r\n      metadata[sourceIndex] = new Array(imageCount);\r\n\r\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\r\n        const image = images[imageIndex];\r\n        const nodataValue = image.getGDALNoData();\r\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\r\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\r\n\r\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\r\n        samplesPerPixel[sourceIndex] = wantedSamples\r\n          ? wantedSamples.length\r\n          : image.getSamplesPerPixel();\r\n        const level = imageCount - (imageIndex + 1);\r\n\r\n        if (!sourceExtent) {\r\n          sourceExtent = getBoundingBox(image);\r\n        }\r\n\r\n        if (!sourceOrigin) {\r\n          sourceOrigin = getOrigin(image);\r\n        }\r\n\r\n        const imageResolutions = getResolutions(image, images[0]);\r\n        sourceResolutions[level] = imageResolutions[0];\r\n\r\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\r\n\r\n        // request larger blocks for untiled layouts\r\n        if (\r\n          sourceTileSize[0] !== sourceTileSize[1] &&\r\n          sourceTileSize[1] < defaultTileSize\r\n        ) {\r\n          sourceTileSize[0] = defaultTileSize;\r\n          sourceTileSize[1] = defaultTileSize;\r\n        }\r\n\r\n        sourceTileSizes[level] = sourceTileSize;\r\n\r\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\r\n        renderTileSizes[level] = [\r\n          sourceTileSize[0],\r\n          sourceTileSize[1] / aspectRatio,\r\n        ];\r\n      }\r\n\r\n      if (!extent) {\r\n        extent = sourceExtent;\r\n      } else {\r\n        getIntersection(extent, sourceExtent, extent);\r\n      }\r\n\r\n      if (!origin) {\r\n        origin = sourceOrigin;\r\n      } else {\r\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\r\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\r\n      }\r\n\r\n      if (!resolutions) {\r\n        resolutions = sourceResolutions;\r\n        this.resolutionFactors_[sourceIndex] = 1;\r\n      } else {\r\n        if (resolutions.length - minZoom > sourceResolutions.length) {\r\n          minZoom = resolutions.length - sourceResolutions.length;\r\n        }\r\n        const resolutionFactor =\r\n          resolutions[resolutions.length - 1] /\r\n          sourceResolutions[sourceResolutions.length - 1];\r\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\r\n        const scaledSourceResolutions = sourceResolutions.map(\r\n          (resolution) => (resolution *= resolutionFactor),\r\n        );\r\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\r\n        assertEqual(\r\n          resolutions.slice(minZoom, resolutions.length),\r\n          scaledSourceResolutions,\r\n          0.02,\r\n          message,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      if (!commonRenderTileSizes) {\r\n        commonRenderTileSizes = renderTileSizes;\r\n      } else {\r\n        assertEqual(\r\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\r\n          renderTileSizes,\r\n          0.01,\r\n          `Tile size mismatch for source ${sourceIndex}`,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      if (!commonSourceTileSizes) {\r\n        commonSourceTileSizes = sourceTileSizes;\r\n      } else {\r\n        assertEqual(\r\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\r\n          sourceTileSizes,\r\n          0,\r\n          `Tile size mismatch for source ${sourceIndex}`,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      this.sourceImagery_[sourceIndex] = images.reverse();\r\n      this.sourceMasks_[sourceIndex] = masks.reverse();\r\n    }\r\n\r\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\r\n      const sourceImagery = this.sourceImagery_[i];\r\n      while (sourceImagery.length < resolutions.length) {\r\n        sourceImagery.unshift(undefined);\r\n      }\r\n    }\r\n\r\n    if (!this.getProjection()) {\r\n      this.determineProjection(sources);\r\n    }\r\n\r\n    this.samplesPerPixel_ = samplesPerPixel;\r\n    this.nodataValues_ = nodataValues;\r\n    this.metadata_ = metadata;\r\n\r\n    // decide if we need to add an alpha band to handle nodata\r\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      // option 1: source is configured with a nodata value\r\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\r\n        this.addAlpha_ = true;\r\n        break;\r\n      }\r\n      if (this.sourceMasks_[sourceIndex].length) {\r\n        this.addAlpha_ = true;\r\n        break;\r\n      }\r\n\r\n      const values = nodataValues[sourceIndex];\r\n\r\n      // option 2: check image metadata for limited bands\r\n      const bands = this.sourceInfo_[sourceIndex].bands;\r\n      if (bands) {\r\n        for (let i = 0; i < bands.length; ++i) {\r\n          if (values[bands[i] - 1] !== null) {\r\n            this.addAlpha_ = true;\r\n            break outer;\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // option 3: check image metadata for all bands\r\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\r\n        if (values[imageIndex] !== null) {\r\n          this.addAlpha_ = true;\r\n          break outer;\r\n        }\r\n      }\r\n    }\r\n\r\n    let bandCount = this.addAlpha_ ? 1 : 0;\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      bandCount += samplesPerPixel[sourceIndex];\r\n    }\r\n    this.bandCount = bandCount;\r\n\r\n    const tileGrid = new TileGrid({\r\n      extent: extent,\r\n      minZoom: minZoom,\r\n      origin: origin,\r\n      resolutions: resolutions,\r\n      tileSizes: commonRenderTileSizes,\r\n    });\r\n\r\n    this.tileGrid = tileGrid;\r\n    this.setTileSizes(commonSourceTileSizes);\r\n\r\n    this.setLoader(this.loadTile_.bind(this));\r\n    this.setState('ready');\r\n\r\n    const zoom = 1;\r\n    if (resolutions.length === 2) {\r\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\r\n    } else if (resolutions.length === 1) {\r\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\r\n    }\r\n\r\n    this.viewResolver({\r\n      showFullExtent: true,\r\n      projection: this.projection,\r\n      resolutions: resolutions,\r\n      center: toUserCoordinate(getCenter(extent), this.projection),\r\n      extent: toUserExtent(extent, this.projection),\r\n      zoom: zoom,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {number} z The z tile index.\r\n   * @param {number} x The x tile index.\r\n   * @param {number} y The y tile index.\r\n   * @param {import('./DataTile.js').LoaderOptions} options The loader options.\r\n   * @return {Promise} The composed tile data.\r\n   * @private\r\n   */\r\n  loadTile_(z, x, y, options) {\r\n    const sourceTileSize = this.getTileSize(z);\r\n    const sourceCount = this.sourceImagery_.length;\r\n    const requests = new Array(sourceCount * 2);\r\n    const nodataValues = this.nodataValues_;\r\n    const sourceInfo = this.sourceInfo_;\r\n    const pool = getWorkerPool();\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      const source = sourceInfo[sourceIndex];\r\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\r\n      const pixelBounds = [\r\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\r\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\r\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\r\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\r\n      ];\r\n      const image = this.sourceImagery_[sourceIndex][z];\r\n      let samples;\r\n      if (source.bands) {\r\n        samples = source.bands.map(function (bandNumber) {\r\n          return bandNumber - 1;\r\n        });\r\n      }\r\n\r\n      /** @type {number|Array<number>} */\r\n      let fillValue;\r\n      if ('nodata' in source && source.nodata !== null) {\r\n        fillValue = source.nodata;\r\n      } else {\r\n        if (!samples) {\r\n          fillValue = nodataValues[sourceIndex];\r\n        } else {\r\n          fillValue = samples.map(function (sampleIndex) {\r\n            return nodataValues[sourceIndex][sampleIndex];\r\n          });\r\n        }\r\n      }\r\n\r\n      const readOptions = {\r\n        window: pixelBounds,\r\n        width: sourceTileSize[0],\r\n        height: sourceTileSize[1],\r\n        samples: samples,\r\n        fillValue: fillValue,\r\n        pool: pool,\r\n        interleave: false,\r\n        signal: options.signal,\r\n      };\r\n      if (readRGB(this.convertToRGB_, image)) {\r\n        requests[sourceIndex] = image.readRGB(readOptions);\r\n      } else {\r\n        requests[sourceIndex] = image.readRasters(readOptions);\r\n      }\r\n\r\n      // requests after `sourceCount` are for mask data (if any)\r\n      const maskIndex = sourceCount + sourceIndex;\r\n      const mask = this.sourceMasks_[sourceIndex][z];\r\n      if (!mask) {\r\n        requests[maskIndex] = Promise.resolve(null);\r\n        continue;\r\n      }\r\n\r\n      requests[maskIndex] = mask.readRasters({\r\n        window: pixelBounds,\r\n        width: sourceTileSize[0],\r\n        height: sourceTileSize[1],\r\n        samples: [0],\r\n        pool: pool,\r\n        interleave: false,\r\n      });\r\n    }\r\n\r\n    return Promise.all(requests)\r\n      .then(this.composeTile_.bind(this, sourceTileSize))\r\n      .catch(function (error) {\r\n        logError(error);\r\n        throw error;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\r\n   * @param {Array} sourceSamples The source samples.\r\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\r\n   * @private\r\n   */\r\n  composeTile_(sourceTileSize, sourceSamples) {\r\n    const metadata = this.metadata_;\r\n    const sourceInfo = this.sourceInfo_;\r\n    const sourceCount = this.sourceImagery_.length;\r\n    const bandCount = this.bandCount;\r\n    const samplesPerPixel = this.samplesPerPixel_;\r\n    const nodataValues = this.nodataValues_;\r\n    const normalize = this.normalize_;\r\n    const addAlpha = this.addAlpha_;\r\n\r\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\r\n    const dataLength = pixelCount * bandCount;\r\n\r\n    /** @type {Uint8Array|Float32Array} */\r\n    let data;\r\n    if (normalize) {\r\n      data = new Uint8Array(dataLength);\r\n    } else {\r\n      data = new Float32Array(dataLength);\r\n    }\r\n\r\n    let dataIndex = 0;\r\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\r\n      let transparent = addAlpha;\r\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n        const source = sourceInfo[sourceIndex];\r\n\r\n        let min = source.min;\r\n        let max = source.max;\r\n        let gain, bias;\r\n        if (normalize) {\r\n          const stats = metadata[sourceIndex][0];\r\n          if (min === undefined) {\r\n            if (stats && STATISTICS_MINIMUM in stats) {\r\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\r\n            } else {\r\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\r\n            }\r\n          }\r\n          if (max === undefined) {\r\n            if (stats && STATISTICS_MAXIMUM in stats) {\r\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\r\n            } else {\r\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\r\n            }\r\n          }\r\n\r\n          gain = 255 / (max - min);\r\n          bias = -min * gain;\r\n        }\r\n\r\n        for (\r\n          let sampleIndex = 0;\r\n          sampleIndex < samplesPerPixel[sourceIndex];\r\n          ++sampleIndex\r\n        ) {\r\n          const sourceValue =\r\n            sourceSamples[sourceIndex][sampleIndex][pixelIndex];\r\n\r\n          let value;\r\n          if (normalize) {\r\n            value = clamp(gain * sourceValue + bias, 0, 255);\r\n          } else {\r\n            value = sourceValue;\r\n          }\r\n\r\n          if (!addAlpha) {\r\n            data[dataIndex] = value;\r\n          } else {\r\n            let nodata = source.nodata;\r\n            if (nodata === undefined) {\r\n              let bandIndex;\r\n              if (source.bands) {\r\n                bandIndex = source.bands[sampleIndex] - 1;\r\n              } else {\r\n                bandIndex = sampleIndex;\r\n              }\r\n              nodata = nodataValues[sourceIndex][bandIndex];\r\n            }\r\n\r\n            const nodataIsNaN = isNaN(nodata);\r\n            if (\r\n              (!nodataIsNaN && sourceValue !== nodata) ||\r\n              (nodataIsNaN && !isNaN(sourceValue))\r\n            ) {\r\n              transparent = false;\r\n              data[dataIndex] = value;\r\n            }\r\n          }\r\n          dataIndex++;\r\n        }\r\n        if (!transparent) {\r\n          const maskIndex = sourceCount + sourceIndex;\r\n          const mask = sourceSamples[maskIndex];\r\n          if (mask && !mask[0][pixelIndex]) {\r\n            transparent = true;\r\n          }\r\n        }\r\n      }\r\n      if (addAlpha) {\r\n        if (!transparent) {\r\n          data[dataIndex] = 255;\r\n        }\r\n        dataIndex++;\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n}\r\n\r\n/**\r\n * Get a promise for view properties based on the source.  Use the result of this function\r\n * as the `view` option in a map constructor.\r\n *\r\n *     const source = new GeoTIFF(options);\r\n *\r\n *     const map = new Map({\r\n *       target: 'map',\r\n *       layers: [\r\n *         new TileLayer({\r\n *           source: source,\r\n *         }),\r\n *       ],\r\n *       view: source.getView(),\r\n *     });\r\n *\r\n * @function\r\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\r\n * @api\r\n *\r\n */\r\nGeoTIFFSource.prototype.getView;\r\n\r\nexport default GeoTIFFSource;\r\n","/**\r\n * @module CME2D/layer/Property\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  OPACITY: 'opacity',\r\n  VISIBLE: 'visible',\r\n  EXTENT: 'extent',\r\n  Z_INDEX: 'zIndex',\r\n  MAX_RESOLUTION: 'maxResolution',\r\n  MIN_RESOLUTION: 'minResolution',\r\n  MAX_ZOOM: 'maxZoom',\r\n  MIN_ZOOM: 'minZoom',\r\n  SOURCE: 'source',\r\n  MAP: 'map',\r\n};\r\n","/**\r\n * @module CME2D/layer/Base\r\n */\r\nimport BaseObject from '../Object.js';\r\nimport LayerProperty from './Property.js';\r\nimport {abstract} from '../util.js';\r\nimport {assert} from '../asserts.js';\r\nimport {clamp} from '../math.js';\r\n\r\n/**\r\n * A css color, or a function called with a view resolution returning a css color.\r\n *\r\n * @typedef {string|function(number):string} BackgroundColor\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../ObjectEventType\").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|\r\n *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<BaseLayerObjectEventTypes, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background\r\n * will be rendered.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in\r\n * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so\r\n * is observable, and has get/set accessors.\r\n *\r\n * @api\r\n */\r\nclass BaseLayer extends BaseObject {\r\n  /**\r\n   * @param {Options} options Layer options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /***\r\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {BaseLayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @type {BackgroundColor|false}\r\n     * @private\r\n     */\r\n    this.background_ = options.background;\r\n\r\n    /**\r\n     * @type {Object<string, *>}\r\n     */\r\n    const properties = Object.assign({}, options);\r\n    if (typeof options.properties === 'object') {\r\n      delete properties.properties;\r\n      Object.assign(properties, options.properties);\r\n    }\r\n\r\n    properties[LayerProperty.OPACITY] =\r\n      options.opacity !== undefined ? options.opacity : 1;\r\n    assert(\r\n      typeof properties[LayerProperty.OPACITY] === 'number',\r\n      'Layer opacity must be a number',\r\n    );\r\n\r\n    properties[LayerProperty.VISIBLE] =\r\n      options.visible !== undefined ? options.visible : true;\r\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\r\n    properties[LayerProperty.MAX_RESOLUTION] =\r\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\r\n    properties[LayerProperty.MIN_RESOLUTION] =\r\n      options.minResolution !== undefined ? options.minResolution : 0;\r\n    properties[LayerProperty.MIN_ZOOM] =\r\n      options.minZoom !== undefined ? options.minZoom : -Infinity;\r\n    properties[LayerProperty.MAX_ZOOM] =\r\n      options.maxZoom !== undefined ? options.maxZoom : Infinity;\r\n\r\n    /**\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this.className_ =\r\n      properties.className !== undefined ? properties.className : 'ol-layer';\r\n    delete properties.className;\r\n\r\n    this.setProperties(properties);\r\n\r\n    /**\r\n     * @type {import(\"./Layer.js\").State}\r\n     * @private\r\n     */\r\n    this.state_ = null;\r\n  }\r\n\r\n  /**\r\n   * Get the background for this layer.\r\n   * @return {BackgroundColor|false} Layer background.\r\n   */\r\n  getBackground() {\r\n    return this.background_;\r\n  }\r\n\r\n  /**\r\n   * @return {string} CSS class name.\r\n   */\r\n  getClassName() {\r\n    return this.className_;\r\n  }\r\n\r\n  /**\r\n   * This method is not meant to be called by layers or layer renderers because the state\r\n   * is incorrect if the layer is included in a layer group.\r\n   *\r\n   * @param {boolean} [managed] Layer is managed.\r\n   * @return {import(\"./Layer.js\").State} Layer state.\r\n   */\r\n  getLayerState(managed) {\r\n    /** @type {import(\"./Layer.js\").State} */\r\n    const state =\r\n      this.state_ ||\r\n      /** @type {?} */ ({\r\n        layer: this,\r\n        managed: managed === undefined ? true : managed,\r\n      });\r\n    const zIndex = this.getZIndex();\r\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\r\n    state.visible = this.getVisible();\r\n    state.extent = this.getExtent();\r\n    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;\r\n    state.maxResolution = this.getMaxResolution();\r\n    state.minResolution = Math.max(this.getMinResolution(), 0);\r\n    state.minZoom = this.getMinZoom();\r\n    state.maxZoom = this.getMaxZoom();\r\n    this.state_ = state;\r\n\r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be\r\n   *     modified in place).\r\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\r\n   */\r\n  getLayersArray(array) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer\r\n   *     states (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\r\n   */\r\n  getLayerStatesArray(states) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\r\n   * will be visible regardless of extent.\r\n   * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return /** @type {import(\"../extent.js\").Extent|undefined} */ (\r\n      this.get(LayerProperty.EXTENT)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the maximum resolution of the layer. Returns Infinity if\r\n   * the layer has no maximum resolution set.\r\n   * @return {number} The maximum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMaxResolution() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\r\n  }\r\n\r\n  /**\r\n   * Return the minimum resolution of the layer. Returns 0 if\r\n   * the layer has no minimum resolution set.\r\n   * @return {number} The minimum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMinResolution() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\r\n  }\r\n\r\n  /**\r\n   * Return the minimum zoom level of the layer. Returns -Infinity if\r\n   * the layer has no minimum zoom set.\r\n   * @return {number} The minimum zoom level of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMinZoom() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));\r\n  }\r\n\r\n  /**\r\n   * Return the maximum zoom level of the layer. Returns Infinity if\r\n   * the layer has no maximum zoom set.\r\n   * @return {number} The maximum zoom level of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getMaxZoom() {\r\n    return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));\r\n  }\r\n\r\n  /**\r\n   * Return the opacity of the layer (between 0 and 1).\r\n   * @return {number} The opacity of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getOpacity() {\r\n    return /** @type {number} */ (this.get(LayerProperty.OPACITY));\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @return {import(\"../source/Source.js\").State} Source state.\r\n   */\r\n  getSourceState() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the value of this layer's `visible` property. To find out whether the layer\r\n   * is visible on a map, use `isVisible()` instead.\r\n   * @return {boolean} The value of the `visible` property of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getVisible() {\r\n    return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\r\n  }\r\n\r\n  /**\r\n   * Return the Z-index of the layer, which is used to order layers before\r\n   * rendering. Returns undefined if the layer is unmanaged.\r\n   * @return {number|undefined} The Z-index of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getZIndex() {\r\n    return /** @type {number|undefined} */ (this.get(LayerProperty.Z_INDEX));\r\n  }\r\n\r\n  /**\r\n   * Sets the background color.\r\n   * @param {BackgroundColor} [background] Background color.\r\n   */\r\n  setBackground(background) {\r\n    this.background_ = background;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\r\n   * will be visible at all extents.\r\n   * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setExtent(extent) {\r\n    this.set(LayerProperty.EXTENT, extent);\r\n  }\r\n\r\n  /**\r\n   * Set the maximum resolution at which the layer is visible.\r\n   * @param {number} maxResolution The maximum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMaxResolution(maxResolution) {\r\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\r\n  }\r\n\r\n  /**\r\n   * Set the minimum resolution at which the layer is visible.\r\n   * @param {number} minResolution The minimum resolution of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMinResolution(minResolution) {\r\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\r\n  }\r\n\r\n  /**\r\n   * Set the maximum zoom (exclusive) at which the layer is visible.\r\n   * Note that the zoom levels for layer visibility are based on the\r\n   * view zoom level, which may be different from a tile source zoom level.\r\n   * @param {number} maxZoom The maximum zoom of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMaxZoom(maxZoom) {\r\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\r\n  }\r\n\r\n  /**\r\n   * Set the minimum zoom (inclusive) at which the layer is visible.\r\n   * Note that the zoom levels for layer visibility are based on the\r\n   * view zoom level, which may be different from a tile source zoom level.\r\n   * @param {number} minZoom The minimum zoom of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setMinZoom(minZoom) {\r\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\r\n  }\r\n\r\n  /**\r\n   * Set the opacity of the layer, allowed values range from 0 to 1.\r\n   * @param {number} opacity The opacity of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setOpacity(opacity) {\r\n    assert(typeof opacity === 'number', 'Layer opacity must be a number');\r\n    this.set(LayerProperty.OPACITY, opacity);\r\n  }\r\n\r\n  /**\r\n   * Set the visibility of the layer (`true` or `false`).\r\n   * @param {boolean} visible The visibility of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setVisible(visible) {\r\n    this.set(LayerProperty.VISIBLE, visible);\r\n  }\r\n\r\n  /**\r\n   * Set Z-index of the layer, which is used to order layers before rendering.\r\n   * The default Z-index is 0.\r\n   * @param {number} zindex The z-index of the layer.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setZIndex(zindex) {\r\n    this.set(LayerProperty.Z_INDEX, zindex);\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    if (this.state_) {\r\n      this.state_.layer = null;\r\n      this.state_ = null;\r\n    }\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default BaseLayer;\r\n","/**\r\n * @module CME2D/render/EventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  /**\r\n   * Triggered before a layer is rendered.\r\n   * @event module:ol/render/Event~RenderEvent#prerender\r\n   * @api\r\n   */\r\n  PRERENDER: 'prerender',\r\n\r\n  /**\r\n   * Triggered after a layer is rendered.\r\n   * @event module:ol/render/Event~RenderEvent#postrender\r\n   * @api\r\n   */\r\n  POSTRENDER: 'postrender',\r\n\r\n  /**\r\n   * Triggered before layers are composed.  When dispatched by the map, the event object will not have\r\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\r\n   * WebGL layers currently dispatch this event.\r\n   * @event module:ol/render/Event~RenderEvent#precompose\r\n   * @api\r\n   */\r\n  PRECOMPOSE: 'precompose',\r\n\r\n  /**\r\n   * Triggered after layers are composed.  When dispatched by the map, the event object will not have\r\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\r\n   * WebGL layers currently dispatch this event.\r\n   * @event module:ol/render/Event~RenderEvent#postcompose\r\n   * @api\r\n   */\r\n  POSTCOMPOSE: 'postcompose',\r\n\r\n  /**\r\n   * Triggered when rendering is complete, i.e. all sources and tiles have\r\n   * finished loading for the current viewport, and all tiles are faded in.\r\n   * The event object will not have a `context` set.\r\n   * @event module:ol/render/Event~RenderEvent#rendercomplete\r\n   * @api\r\n   */\r\n  RENDERCOMPLETE: 'rendercomplete',\r\n};\r\n\r\n/**\r\n * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes\r\n */\r\n\r\n/**\r\n * @typedef {'postrender'|'prerender'} LayerRenderEventTypes\r\n */\r\n","/**\r\n * @module CME2D/ViewHint\r\n */\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nexport default {\r\n  ANIMATING: 0,\r\n  INTERACTING: 1,\r\n};\r\n","/**\r\n * @module CME2D/ViewProperty\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  CENTER: 'center',\r\n  RESOLUTION: 'resolution',\r\n  ROTATION: 'rotation',\r\n};\r\n","/**\r\n * @module CME2D/centerconstraint\r\n */\r\nimport {clamp} from './math.js';\r\n\r\n/**\r\n * @typedef {function((import(\"./coordinate.js\").Coordinate|undefined), number, import(\"./size.js\").Size, boolean=, Array<number>=): (import(\"./coordinate.js\").Coordinate|undefined)} Type\r\n */\r\n\r\n/**\r\n * @param {import(\"./extent.js\").Extent} extent Extent.\r\n * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.\r\n * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent\r\n * (only during interaction and animation).\r\n * @return {Type} The constraint.\r\n */\r\nexport function createExtent(extent, onlyCenter, smooth) {\r\n  return (\r\n    /**\r\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center Center.\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {import(\"./size.js\").Size} size Viewport size; unused if `onlyCenter` was specified.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @param {Array<number>} [centerShift] Shift between map center and viewport center.\r\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\r\n     */\r\n    function (center, resolution, size, isMoving, centerShift) {\r\n      if (!center) {\r\n        return undefined;\r\n      }\r\n      if (!resolution && !onlyCenter) {\r\n        return center;\r\n      }\r\n      const viewWidth = onlyCenter ? 0 : size[0] * resolution;\r\n      const viewHeight = onlyCenter ? 0 : size[1] * resolution;\r\n      const shiftX = centerShift ? centerShift[0] : 0;\r\n      const shiftY = centerShift ? centerShift[1] : 0;\r\n      let minX = extent[0] + viewWidth / 2 + shiftX;\r\n      let maxX = extent[2] - viewWidth / 2 + shiftX;\r\n      let minY = extent[1] + viewHeight / 2 + shiftY;\r\n      let maxY = extent[3] - viewHeight / 2 + shiftY;\r\n\r\n      // note: when zooming out of bounds, min and max values for x and y may\r\n      // end up inverted (min > max); this has to be accounted for\r\n      if (minX > maxX) {\r\n        minX = (maxX + minX) / 2;\r\n        maxX = minX;\r\n      }\r\n      if (minY > maxY) {\r\n        minY = (maxY + minY) / 2;\r\n        maxY = minY;\r\n      }\r\n\r\n      let x = clamp(center[0], minX, maxX);\r\n      let y = clamp(center[1], minY, maxY);\r\n\r\n      // during an interaction, allow some overscroll\r\n      if (isMoving && smooth && resolution) {\r\n        const ratio = 30 * resolution;\r\n        x +=\r\n          -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +\r\n          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);\r\n        y +=\r\n          -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +\r\n          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);\r\n      }\r\n\r\n      return [x, y];\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} [center] Center.\r\n * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\r\n */\r\nexport function none(center) {\r\n  return center;\r\n}\r\n","/**\r\n * @module CME2D/resolutionconstraint\r\n */\r\nimport {clamp} from './math.js';\r\nimport {getHeight, getWidth} from './extent.js';\r\nimport {linearFindNearest} from './array.js';\r\n\r\n/**\r\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\r\n */\r\n\r\n/**\r\n * Returns a modified resolution taking into account the viewport size and maximum\r\n * allowed extent.\r\n * @param {number} resolution Resolution\r\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\r\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\r\n * @param {boolean} showFullExtent Whether to show the full extent.\r\n * @return {number} Capped resolution.\r\n */\r\nfunction getViewportClampedResolution(\r\n  resolution,\r\n  maxExtent,\r\n  viewportSize,\r\n  showFullExtent,\r\n) {\r\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\r\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\r\n\r\n  if (showFullExtent) {\r\n    return Math.min(resolution, Math.max(xResolution, yResolution));\r\n  }\r\n  return Math.min(resolution, Math.min(xResolution, yResolution));\r\n}\r\n\r\n/**\r\n * Returns a modified resolution to be between maxResolution and minResolution while\r\n * still allowing the value to be slightly out of bounds.\r\n * Note: the computation is based on the logarithm function (ln):\r\n *  - at 1, ln(x) is 0\r\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\r\n * The final result is clamped to prevent getting too far away from bounds.\r\n * @param {number} resolution Resolution.\r\n * @param {number} maxResolution Max resolution.\r\n * @param {number} minResolution Min resolution.\r\n * @return {number} Smoothed resolution.\r\n */\r\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\r\n  let result = Math.min(resolution, maxResolution);\r\n  const ratio = 50;\r\n\r\n  result *=\r\n    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\r\n    1;\r\n  if (minResolution) {\r\n    result = Math.max(result, minResolution);\r\n    result /=\r\n      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\r\n        ratio +\r\n      1;\r\n  }\r\n  return clamp(result, minResolution / 2, maxResolution * 2);\r\n}\r\n\r\n/**\r\n * @param {Array<number>} resolutions Resolutions.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\r\nexport function createSnapToResolutions(\r\n  resolutions,\r\n  smooth,\r\n  maxExtent,\r\n  showFullExtent,\r\n) {\r\n  smooth = smooth !== undefined ? smooth : true;\r\n  return (\r\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\r\n    function (resolution, direction, size, isMoving) {\r\n      if (resolution !== undefined) {\r\n        const maxResolution = resolutions[0];\r\n        const minResolution = resolutions[resolutions.length - 1];\r\n        const cappedMaxRes = maxExtent\r\n          ? getViewportClampedResolution(\r\n              maxResolution,\r\n              maxExtent,\r\n              size,\r\n              showFullExtent,\r\n            )\r\n          : maxResolution;\r\n\r\n        // during interacting or animating, allow intermediary values\r\n        if (isMoving) {\r\n          if (!smooth) {\r\n            return clamp(resolution, minResolution, cappedMaxRes);\r\n          }\r\n          return getSmoothClampedResolution(\r\n            resolution,\r\n            cappedMaxRes,\r\n            minResolution,\r\n          );\r\n        }\r\n\r\n        const capped = Math.min(cappedMaxRes, resolution);\r\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\r\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\r\n          return resolutions[z + 1];\r\n        }\r\n        return resolutions[z];\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {number} power Power.\r\n * @param {number} maxResolution Maximum resolution.\r\n * @param {number} [minResolution] Minimum resolution.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\r\nexport function createSnapToPower(\r\n  power,\r\n  maxResolution,\r\n  minResolution,\r\n  smooth,\r\n  maxExtent,\r\n  showFullExtent,\r\n) {\r\n  smooth = smooth !== undefined ? smooth : true;\r\n  minResolution = minResolution !== undefined ? minResolution : 0;\r\n\r\n  return (\r\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\r\n    function (resolution, direction, size, isMoving) {\r\n      if (resolution !== undefined) {\r\n        const cappedMaxRes = maxExtent\r\n          ? getViewportClampedResolution(\r\n              maxResolution,\r\n              maxExtent,\r\n              size,\r\n              showFullExtent,\r\n            )\r\n          : maxResolution;\r\n\r\n        // during interacting or animating, allow intermediary values\r\n        if (isMoving) {\r\n          if (!smooth) {\r\n            return clamp(resolution, minResolution, cappedMaxRes);\r\n          }\r\n          return getSmoothClampedResolution(\r\n            resolution,\r\n            cappedMaxRes,\r\n            minResolution,\r\n          );\r\n        }\r\n\r\n        const tolerance = 1e-9;\r\n        const minZoomLevel = Math.ceil(\r\n          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance,\r\n        );\r\n        const offset = -direction * (0.5 - tolerance) + 0.5;\r\n        const capped = Math.min(cappedMaxRes, resolution);\r\n        const cappedZoomLevel = Math.floor(\r\n          Math.log(maxResolution / capped) / Math.log(power) + offset,\r\n        );\r\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\r\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\r\n        return clamp(newResolution, minResolution, cappedMaxRes);\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {number} maxResolution Max resolution.\r\n * @param {number} minResolution Min resolution.\r\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\r\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\r\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\r\n * @return {Type} Zoom function.\r\n */\r\nexport function createMinMaxResolution(\r\n  maxResolution,\r\n  minResolution,\r\n  smooth,\r\n  maxExtent,\r\n  showFullExtent,\r\n) {\r\n  smooth = smooth !== undefined ? smooth : true;\r\n\r\n  return (\r\n    /**\r\n     * @param {number|undefined} resolution Resolution.\r\n     * @param {number} direction Direction.\r\n     * @param {import(\"./size.js\").Size} size Viewport size.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Resolution.\r\n     */\r\n    function (resolution, direction, size, isMoving) {\r\n      if (resolution !== undefined) {\r\n        const cappedMaxRes = maxExtent\r\n          ? getViewportClampedResolution(\r\n              maxResolution,\r\n              maxExtent,\r\n              size,\r\n              showFullExtent,\r\n            )\r\n          : maxResolution;\r\n\r\n        if (!smooth || !isMoving) {\r\n          return clamp(resolution, minResolution, cappedMaxRes);\r\n        }\r\n        return getSmoothClampedResolution(\r\n          resolution,\r\n          cappedMaxRes,\r\n          minResolution,\r\n        );\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n","/**\r\n * @module CME2D/rotationconstraint\r\n */\r\nimport {toRadians} from './math.js';\r\n\r\n/**\r\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\r\n */\r\n\r\n/**\r\n * @param {number|undefined} rotation Rotation.\r\n * @return {number|undefined} Rotation.\r\n */\r\nexport function disable(rotation) {\r\n  if (rotation !== undefined) {\r\n    return 0;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * @param {number|undefined} rotation Rotation.\r\n * @return {number|undefined} Rotation.\r\n */\r\nexport function none(rotation) {\r\n  if (rotation !== undefined) {\r\n    return rotation;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * @param {number} n N.\r\n * @return {Type} Rotation constraint.\r\n */\r\nexport function createSnapToN(n) {\r\n  const theta = (2 * Math.PI) / n;\r\n  return (\r\n    /**\r\n     * @param {number|undefined} rotation Rotation.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Rotation.\r\n     */\r\n    function (rotation, isMoving) {\r\n      if (isMoving) {\r\n        return rotation;\r\n      }\r\n\r\n      if (rotation !== undefined) {\r\n        rotation = Math.floor(rotation / theta + 0.5) * theta;\r\n        return rotation;\r\n      }\r\n      return undefined;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {number} [tolerance] Tolerance.\r\n * @return {Type} Rotation constraint.\r\n */\r\nexport function createSnapToZero(tolerance) {\r\n  const t = tolerance === undefined ? toRadians(5) : tolerance;\r\n  return (\r\n    /**\r\n     * @param {number|undefined} rotation Rotation.\r\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\r\n     * @return {number|undefined} Rotation.\r\n     */\r\n    function (rotation, isMoving) {\r\n      if (isMoving || rotation === undefined) {\r\n        return rotation;\r\n      }\r\n\r\n      if (Math.abs(rotation) <= t) {\r\n        return 0;\r\n      }\r\n      return rotation;\r\n    }\r\n  );\r\n}\r\n","/**\r\n * @module CME2D/transform\r\n */\r\nimport {assert} from './asserts.js';\r\n\r\n/**\r\n * An array representing an affine 2d transformation for use with\r\n * {@link module:ol/transform} functions. The array has 6 elements.\r\n * @typedef {!Array<number>} Transform\r\n * @api\r\n */\r\n\r\n/**\r\n * Collection of affine 2d transformation functions. The functions work on an\r\n * array of 6 elements. The element order is compatible with the [SVGMatrix\r\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\r\n * a subset (elements a to f) of a 3×3 matrix:\r\n * ```\r\n * [ a c e ]\r\n * [ b d f ]\r\n * [ 0 0 1 ]\r\n * ```\r\n */\r\n\r\n/**\r\n * @private\r\n * @type {Transform}\r\n */\r\nconst tmp_ = new Array(6);\r\n\r\n/**\r\n * Create an identity transform.\r\n * @return {!Transform} Identity transform.\r\n */\r\nexport function create() {\r\n  return [1, 0, 0, 1, 0, 0];\r\n}\r\n\r\n/**\r\n * Resets the given transform to an identity transform.\r\n * @param {!Transform} transform Transform.\r\n * @return {!Transform} Transform.\r\n */\r\nexport function reset(transform) {\r\n  return set(transform, 1, 0, 0, 1, 0, 0);\r\n}\r\n\r\n/**\r\n * Multiply the underlying matrices of two transforms and return the result in\r\n * the first transform.\r\n * @param {!Transform} transform1 Transform parameters of matrix 1.\r\n * @param {!Transform} transform2 Transform parameters of matrix 2.\r\n * @return {!Transform} transform1 multiplied with transform2.\r\n */\r\nexport function multiply(transform1, transform2) {\r\n  const a1 = transform1[0];\r\n  const b1 = transform1[1];\r\n  const c1 = transform1[2];\r\n  const d1 = transform1[3];\r\n  const e1 = transform1[4];\r\n  const f1 = transform1[5];\r\n  const a2 = transform2[0];\r\n  const b2 = transform2[1];\r\n  const c2 = transform2[2];\r\n  const d2 = transform2[3];\r\n  const e2 = transform2[4];\r\n  const f2 = transform2[5];\r\n\r\n  transform1[0] = a1 * a2 + c1 * b2;\r\n  transform1[1] = b1 * a2 + d1 * b2;\r\n  transform1[2] = a1 * c2 + c1 * d2;\r\n  transform1[3] = b1 * c2 + d1 * d2;\r\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\r\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\r\n\r\n  return transform1;\r\n}\r\n\r\n/**\r\n * Set the transform components a-f on a given transform.\r\n * @param {!Transform} transform Transform.\r\n * @param {number} a The a component of the transform.\r\n * @param {number} b The b component of the transform.\r\n * @param {number} c The c component of the transform.\r\n * @param {number} d The d component of the transform.\r\n * @param {number} e The e component of the transform.\r\n * @param {number} f The f component of the transform.\r\n * @return {!Transform} Matrix with transform applied.\r\n */\r\nexport function set(transform, a, b, c, d, e, f) {\r\n  transform[0] = a;\r\n  transform[1] = b;\r\n  transform[2] = c;\r\n  transform[3] = d;\r\n  transform[4] = e;\r\n  transform[5] = f;\r\n  return transform;\r\n}\r\n\r\n/**\r\n * Set transform on one matrix from another matrix.\r\n * @param {!Transform} transform1 Matrix to set transform to.\r\n * @param {!Transform} transform2 Matrix to set transform from.\r\n * @return {!Transform} transform1 with transform from transform2 applied.\r\n */\r\nexport function setFromArray(transform1, transform2) {\r\n  transform1[0] = transform2[0];\r\n  transform1[1] = transform2[1];\r\n  transform1[2] = transform2[2];\r\n  transform1[3] = transform2[3];\r\n  transform1[4] = transform2[4];\r\n  transform1[5] = transform2[5];\r\n  return transform1;\r\n}\r\n\r\n/**\r\n * Transforms the given coordinate with the given transform returning the\r\n * resulting, transformed coordinate. The coordinate will be modified in-place.\r\n *\r\n * @param {Transform} transform The transformation.\r\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\r\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\r\n *     chained together.\r\n */\r\nexport function apply(transform, coordinate) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\r\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Applies rotation to the given transform.\r\n * @param {!Transform} transform Transform.\r\n * @param {number} angle Angle in radians.\r\n * @return {!Transform} The rotated transform.\r\n */\r\nexport function rotate(transform, angle) {\r\n  const cos = Math.cos(angle);\r\n  const sin = Math.sin(angle);\r\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\r\n}\r\n\r\n/**\r\n * Applies scale to a given transform.\r\n * @param {!Transform} transform Transform.\r\n * @param {number} x Scale factor x.\r\n * @param {number} y Scale factor y.\r\n * @return {!Transform} The scaled transform.\r\n */\r\nexport function scale(transform, x, y) {\r\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\r\n}\r\n\r\n/**\r\n * Creates a scale transform.\r\n * @param {!Transform} target Transform to overwrite.\r\n * @param {number} x Scale factor x.\r\n * @param {number} y Scale factor y.\r\n * @return {!Transform} The scale transform.\r\n */\r\nexport function makeScale(target, x, y) {\r\n  return set(target, x, 0, 0, y, 0, 0);\r\n}\r\n\r\n/**\r\n * Applies translation to the given transform.\r\n * @param {!Transform} transform Transform.\r\n * @param {number} dx Translation x.\r\n * @param {number} dy Translation y.\r\n * @return {!Transform} The translated transform.\r\n */\r\nexport function translate(transform, dx, dy) {\r\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\r\n}\r\n\r\n/**\r\n * Creates a composite transform given an initial translation, scale, rotation, and\r\n * final translation (in that order only, not commutative).\r\n * @param {!Transform} transform The transform (will be modified in place).\r\n * @param {number} dx1 Initial translation x.\r\n * @param {number} dy1 Initial translation y.\r\n * @param {number} sx Scale factor x.\r\n * @param {number} sy Scale factor y.\r\n * @param {number} angle Rotation (in counter-clockwise radians).\r\n * @param {number} dx2 Final translation x.\r\n * @param {number} dy2 Final translation y.\r\n * @return {!Transform} The composite transform.\r\n */\r\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\r\n  const sin = Math.sin(angle);\r\n  const cos = Math.cos(angle);\r\n  transform[0] = sx * cos;\r\n  transform[1] = sy * sin;\r\n  transform[2] = -sx * sin;\r\n  transform[3] = sy * cos;\r\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\r\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\r\n  return transform;\r\n}\r\n\r\n/**\r\n * Creates a composite transform given an initial translation, scale, rotation, and\r\n * final translation (in that order only, not commutative). The resulting transform\r\n * string can be applied as `transform` property of an HTMLElement's style.\r\n * @param {number} dx1 Initial translation x.\r\n * @param {number} dy1 Initial translation y.\r\n * @param {number} sx Scale factor x.\r\n * @param {number} sy Scale factor y.\r\n * @param {number} angle Rotation (in counter-clockwise radians).\r\n * @param {number} dx2 Final translation x.\r\n * @param {number} dy2 Final translation y.\r\n * @return {string} The composite css transform.\r\n * @api\r\n */\r\nexport function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\r\n  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\r\n}\r\n\r\n/**\r\n * Invert the given transform.\r\n * @param {!Transform} source The source transform to invert.\r\n * @return {!Transform} The inverted (source) transform.\r\n */\r\nexport function invert(source) {\r\n  return makeInverse(source, source);\r\n}\r\n\r\n/**\r\n * Invert the given transform.\r\n * @param {!Transform} target Transform to be set as the inverse of\r\n *     the source transform.\r\n * @param {!Transform} source The source transform to invert.\r\n * @return {!Transform} The inverted (target) transform.\r\n */\r\nexport function makeInverse(target, source) {\r\n  const det = determinant(source);\r\n  assert(det !== 0, 'Transformation matrix cannot be inverted');\r\n\r\n  const a = source[0];\r\n  const b = source[1];\r\n  const c = source[2];\r\n  const d = source[3];\r\n  const e = source[4];\r\n  const f = source[5];\r\n\r\n  target[0] = d / det;\r\n  target[1] = -b / det;\r\n  target[2] = -c / det;\r\n  target[3] = a / det;\r\n  target[4] = (c * f - d * e) / det;\r\n  target[5] = -(a * f - b * e) / det;\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Returns the determinant of the given matrix.\r\n * @param {!Transform} mat Matrix.\r\n * @return {number} Determinant.\r\n */\r\nexport function determinant(mat) {\r\n  return mat[0] * mat[3] - mat[1] * mat[2];\r\n}\r\n\r\n/**\r\n * @type {Array}\r\n */\r\nconst matrixPrecision = [1e6, 1e6, 1e6, 1e6, 2, 2];\r\n\r\n/**\r\n * A rounded string version of the transform.  This can be used\r\n * for CSS transforms.\r\n * @param {!Transform} mat Matrix.\r\n * @return {string} The transform as a string.\r\n */\r\nexport function toString(mat) {\r\n  const transformString =\r\n    'matrix(' +\r\n    mat\r\n      .map(\r\n        (value, i) =>\r\n          Math.round(value * matrixPrecision[i]) / matrixPrecision[i],\r\n      )\r\n      .join(', ') +\r\n    ')';\r\n  return transformString;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/transform\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {import(\"../../transform.js\").Transform} transform Transform.\r\n * @param {Array<number>} [dest] Destination.\r\n * @param {number} [destinationStride] Stride of destination coordinates; if unspecified, assumed to be 2.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function transform2D(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  transform,\r\n  dest,\r\n  destinationStride,\r\n) {\r\n  dest = dest ? dest : [];\r\n  destinationStride = destinationStride ? destinationStride : 2;\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    const x = flatCoordinates[j];\r\n    const y = flatCoordinates[j + 1];\r\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\r\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\r\n\r\n    for (let k = 2; k < destinationStride; k++) {\r\n      dest[i++] = flatCoordinates[j + k];\r\n    }\r\n  }\r\n\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} angle Angle.\r\n * @param {Array<number>} anchor Rotation anchor point.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function rotate(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  angle,\r\n  anchor,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  const cos = Math.cos(angle);\r\n  const sin = Math.sin(angle);\r\n  const anchorX = anchor[0];\r\n  const anchorY = anchor[1];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    const deltaX = flatCoordinates[j] - anchorX;\r\n    const deltaY = flatCoordinates[j + 1] - anchorY;\r\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\r\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\r\n    for (let k = j + 2; k < j + stride; ++k) {\r\n      dest[i++] = flatCoordinates[k];\r\n    }\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * Scale the coordinates.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} sx Scale factor in the x-direction.\r\n * @param {number} sy Scale factor in the y-direction.\r\n * @param {Array<number>} anchor Scale anchor point.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function scale(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  sx,\r\n  sy,\r\n  anchor,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  const anchorX = anchor[0];\r\n  const anchorY = anchor[1];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    const deltaX = flatCoordinates[j] - anchorX;\r\n    const deltaY = flatCoordinates[j + 1] - anchorY;\r\n    dest[i++] = anchorX + sx * deltaX;\r\n    dest[i++] = anchorY + sy * deltaY;\r\n    for (let k = j + 2; k < j + stride; ++k) {\r\n      dest[i++] = flatCoordinates[k];\r\n    }\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} deltaX Delta X.\r\n * @param {number} deltaY Delta Y.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed coordinates.\r\n */\r\nexport function translate(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  deltaX,\r\n  deltaY,\r\n  dest,\r\n) {\r\n  dest = dest ? dest : [];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    dest[i++] = flatCoordinates[j] + deltaX;\r\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\r\n    for (let k = j + 2; k < j + stride; ++k) {\r\n      dest[i++] = flatCoordinates[k];\r\n    }\r\n  }\r\n  if (dest && dest.length != i) {\r\n    dest.length = i;\r\n  }\r\n  return dest;\r\n}\r\n","/**\r\n * @module CME2D/geom/Geometry\r\n */\r\nimport BaseObject from '../Object.js';\r\nimport {abstract} from '../util.js';\r\nimport {\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n} from '../transform.js';\r\nimport {\r\n  createEmpty,\r\n  createOrUpdateEmpty,\r\n  getHeight,\r\n  returnOrUpdate,\r\n} from '../extent.js';\r\nimport {get as getProjection, getTransform} from '../proj.js';\r\nimport {memoizeOne} from '../functions.js';\r\nimport {transform2D} from './flat/transform.js';\r\n\r\n/**\r\n * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout\r\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\r\n * or measure ('M') coordinate is available.\r\n */\r\n\r\n/**\r\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type\r\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\r\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\r\n * `'GeometryCollection'`, or `'Circle'`.\r\n */\r\n\r\n/**\r\n * @type {import(\"../transform.js\").Transform}\r\n */\r\nconst tmpTransform = createTransform();\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; normally only used for creating subclasses and not\r\n * instantiated in apps.\r\n * Base class for vector geometries.\r\n *\r\n * To get notified of changes to the geometry, register a listener for the\r\n * generic `change` event on your geometry instance.\r\n *\r\n * @abstract\r\n * @api\r\n */\r\nclass Geometry extends BaseObject {\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = createEmpty();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.extentRevision_ = -1;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.simplifiedGeometryRevision = 0;\r\n\r\n    /**\r\n     * Get a transformed and simplified version of the geometry.\r\n     * @abstract\r\n     * @param {number} revision The geometry revision.\r\n     * @param {number} squaredTolerance Squared tolerance.\r\n     * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\r\n     * @return {Geometry} Simplified geometry.\r\n     */\r\n    this.simplifyTransformedInternal = memoizeOne(\r\n      (revision, squaredTolerance, transform) => {\r\n        if (!transform) {\r\n          return this.getSimplifiedGeometry(squaredTolerance);\r\n        }\r\n        const clone = this.clone();\r\n        clone.applyTransform(transform);\r\n        return clone.getSimplifiedGeometry(squaredTolerance);\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get a transformed and simplified version of the geometry.\r\n   * @abstract\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\r\n   * @return {Geometry} Simplified geometry.\r\n   */\r\n  simplifyTransformed(squaredTolerance, transform) {\r\n    return this.simplifyTransformedInternal(\r\n      this.getRevision(),\r\n      squaredTolerance,\r\n      transform,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @abstract\r\n   * @return {!Geometry} Clone.\r\n   */\r\n  clone() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   */\r\n  containsXY(x, y) {\r\n    const coord = this.getClosestPoint([x, y]);\r\n    return coord[0] === x && coord[1] === y;\r\n  }\r\n\r\n  /**\r\n   * Return the closest point of the geometry to the passed point as\r\n   * {@link module:ol/coordinate~Coordinate coordinate}.\r\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\r\n   * @param {import(\"../coordinate.js\").Coordinate} [closestPoint] Closest point.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\r\n   * @api\r\n   */\r\n  getClosestPoint(point, closestPoint) {\r\n    closestPoint = closestPoint ? closestPoint : [NaN, NaN];\r\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\r\n    return closestPoint;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this geometry includes the specified coordinate. If the\r\n   * coordinate is on the boundary of the geometry, returns false.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @return {boolean} Contains coordinate.\r\n   * @api\r\n   */\r\n  intersectsCoordinate(coordinate) {\r\n    return this.containsXY(coordinate[0], coordinate[1]);\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @protected\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   */\r\n  computeExtent(extent) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Get the extent of the geometry.\r\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   * @api\r\n   */\r\n  getExtent(extent) {\r\n    if (this.extentRevision_ != this.getRevision()) {\r\n      const extent = this.computeExtent(this.extent_);\r\n      if (isNaN(extent[0]) || isNaN(extent[1])) {\r\n        createOrUpdateEmpty(extent);\r\n      }\r\n      this.extentRevision_ = this.getRevision();\r\n    }\r\n    return returnOrUpdate(this.extent_, extent);\r\n  }\r\n\r\n  /**\r\n   * Rotate the geometry around a given coordinate. This modifies the geometry\r\n   * coordinates in place.\r\n   * @abstract\r\n   * @param {number} angle Rotation angle in radians.\r\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\r\n   * @api\r\n   */\r\n  rotate(angle, anchor) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Scale the geometry (with an optional origin).  This modifies the geometry\r\n   * coordinates in place.\r\n   * @abstract\r\n   * @param {number} sx The scaling factor in the x-direction.\r\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\r\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\r\n   *     of the geometry extent).\r\n   * @api\r\n   */\r\n  scale(sx, sy, anchor) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Create a simplified version of this geometry.  For linestrings, this uses\r\n   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\r\n   * algorithm.  For polygons, a quantization-based\r\n   * simplification is used to preserve topology.\r\n   * @param {number} tolerance The tolerance distance for simplification.\r\n   * @return {Geometry} A new, simplified version of the original geometry.\r\n   * @api\r\n   */\r\n  simplify(tolerance) {\r\n    return this.getSimplifiedGeometry(tolerance * tolerance);\r\n  }\r\n\r\n  /**\r\n   * Create a simplified version of this geometry using the Douglas Peucker\r\n   * algorithm.\r\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\r\n   * @abstract\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {Geometry} Simplified geometry.\r\n   */\r\n  getSimplifiedGeometry(squaredTolerance) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @abstract\r\n   * @return {Type} Geometry type.\r\n   */\r\n  getType() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Apply a transform function to the coordinates of the geometry.\r\n   * The geometry is modified in place.\r\n   * If you do not want the geometry modified in place, first `clone()` it and\r\n   * then use this function on the clone.\r\n   * @abstract\r\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\r\n   * Called with a flat array of geometry coordinates.\r\n   */\r\n  applyTransform(transformFn) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @abstract\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   */\r\n  intersectsExtent(extent) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\r\n   * instead you want a new geometry, first `clone()` this geometry.\r\n   * @abstract\r\n   * @param {number} deltaX Delta X.\r\n   * @param {number} deltaY Delta Y.\r\n   * @api\r\n   */\r\n  translate(deltaX, deltaY) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * Transform each coordinate of the geometry from one coordinate reference\r\n   * system to another. The geometry is modified in place.\r\n   * For example, a line will be transformed to a line and a circle to a circle.\r\n   * If you do not want the geometry modified in place, first `clone()` it and\r\n   * then use this function on the clone.\r\n   *\r\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\r\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\r\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\r\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\r\n   * @return {this} This geometry.  Note that original geometry is\r\n   *     modified in place.\r\n   * @api\r\n   */\r\n  transform(source, destination) {\r\n    /** @type {import(\"../proj/Projection.js\").default} */\r\n    const sourceProj = getProjection(source);\r\n    const transformFn =\r\n      sourceProj.getUnits() == 'tile-pixels'\r\n        ? function (inCoordinates, outCoordinates, stride) {\r\n            const pixelExtent = sourceProj.getExtent();\r\n            const projectedExtent = sourceProj.getWorldExtent();\r\n            const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\r\n            composeTransform(\r\n              tmpTransform,\r\n              projectedExtent[0],\r\n              projectedExtent[3],\r\n              scale,\r\n              -scale,\r\n              0,\r\n              0,\r\n              0,\r\n            );\r\n            transform2D(\r\n              inCoordinates,\r\n              0,\r\n              inCoordinates.length,\r\n              stride,\r\n              tmpTransform,\r\n              outCoordinates,\r\n            );\r\n            return getTransform(sourceProj, destination)(\r\n              inCoordinates,\r\n              outCoordinates,\r\n              stride,\r\n            );\r\n          }\r\n        : getTransform(sourceProj, destination);\r\n    this.applyTransform(transformFn);\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Geometry;\r\n","/**\r\n * @module CME2D/geom/SimpleGeometry\r\n */\r\nimport Geometry from './Geometry.js';\r\nimport {abstract} from '../util.js';\r\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\r\nimport {rotate, scale, transform2D, translate} from './flat/transform.js';\r\n\r\n/**\r\n * @classdesc\r\n * Abstract base class; only used for creating subclasses; do not instantiate\r\n * in apps, as cannot be rendered.\r\n *\r\n * @abstract\r\n * @api\r\n */\r\nclass SimpleGeometry extends Geometry {\r\n  constructor() {\r\n    super();\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./Geometry.js\").GeometryLayout}\r\n     */\r\n    this.layout = 'XY';\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.stride = 2;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {Array<number>}\r\n     */\r\n    this.flatCoordinates;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @protected\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   * @override\r\n   */\r\n  computeExtent(extent) {\r\n    return createOrUpdateFromFlatCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      extent,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @return {Array<*> | null} Coordinates.\r\n   */\r\n  getCoordinates() {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Return the first coordinate of the geometry.\r\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\r\n   * @api\r\n   */\r\n  getFirstCoordinate() {\r\n    return this.flatCoordinates.slice(0, this.stride);\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Flat coordinates.\r\n   */\r\n  getFlatCoordinates() {\r\n    return this.flatCoordinates;\r\n  }\r\n\r\n  /**\r\n   * Return the last coordinate of the geometry.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\r\n   * @api\r\n   */\r\n  getLastCoordinate() {\r\n    return this.flatCoordinates.slice(\r\n      this.flatCoordinates.length - this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\r\n   * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\r\n   * @api\r\n   */\r\n  getLayout() {\r\n    return this.layout;\r\n  }\r\n\r\n  /**\r\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {SimpleGeometry} Simplified geometry.\r\n   * @override\r\n   */\r\n  getSimplifiedGeometry(squaredTolerance) {\r\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\r\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\r\n      this.simplifiedGeometryRevision = this.getRevision();\r\n    }\r\n    // If squaredTolerance is negative or if we know that simplification will not\r\n    // have any effect then just return this.\r\n    if (\r\n      squaredTolerance < 0 ||\r\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\r\n        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)\r\n    ) {\r\n      return this;\r\n    }\r\n\r\n    const simplifiedGeometry =\r\n      this.getSimplifiedGeometryInternal(squaredTolerance);\r\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\r\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\r\n      return simplifiedGeometry;\r\n    }\r\n    // Simplification did not actually remove any coordinates.  We now know\r\n    // that any calls to getSimplifiedGeometry with a squaredTolerance less\r\n    // than or equal to the current squaredTolerance will also not have any\r\n    // effect.  This allows us to short circuit simplification (saving CPU\r\n    // cycles) and prevents the cache of simplified geometries from filling\r\n    // up with useless identical copies of this geometry (saving memory).\r\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {SimpleGeometry} Simplified geometry.\r\n   * @protected\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Stride.\r\n   */\r\n  getStride() {\r\n    return this.stride;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\r\n   * @param {Array<number>} flatCoordinates Flat coordinates.\r\n   */\r\n  setFlatCoordinates(layout, flatCoordinates) {\r\n    this.stride = getStrideForLayout(layout);\r\n    this.layout = layout;\r\n    this.flatCoordinates = flatCoordinates;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {!Array<*>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\r\n   * @param {Array<*>} coordinates Coordinates.\r\n   * @param {number} nesting Nesting.\r\n   * @protected\r\n   */\r\n  setLayout(layout, coordinates, nesting) {\r\n    let stride;\r\n    if (layout) {\r\n      stride = getStrideForLayout(layout);\r\n    } else {\r\n      for (let i = 0; i < nesting; ++i) {\r\n        if (coordinates.length === 0) {\r\n          this.layout = 'XY';\r\n          this.stride = 2;\r\n          return;\r\n        }\r\n        coordinates = /** @type {Array<unknown>} */ (coordinates[0]);\r\n      }\r\n      stride = coordinates.length;\r\n      layout = getLayoutForStride(stride);\r\n    }\r\n    this.layout = layout;\r\n    this.stride = stride;\r\n  }\r\n\r\n  /**\r\n   * Apply a transform function to the coordinates of the geometry.\r\n   * The geometry is modified in place.\r\n   * If you do not want the geometry modified in place, first `clone()` it and\r\n   * then use this function on the clone.\r\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\r\n   * Called with a flat array of geometry coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  applyTransform(transformFn) {\r\n    if (this.flatCoordinates) {\r\n      transformFn(\r\n        this.flatCoordinates,\r\n        this.flatCoordinates,\r\n        this.layout.startsWith('XYZ') ? 3 : 2,\r\n        this.stride,\r\n      );\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rotate the geometry around a given coordinate. This modifies the geometry\r\n   * coordinates in place.\r\n   * @param {number} angle Rotation angle in counter-clockwise radians.\r\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\r\n   * @api\r\n   * @override\r\n   */\r\n  rotate(angle, anchor) {\r\n    const flatCoordinates = this.getFlatCoordinates();\r\n    if (flatCoordinates) {\r\n      const stride = this.getStride();\r\n      rotate(\r\n        flatCoordinates,\r\n        0,\r\n        flatCoordinates.length,\r\n        stride,\r\n        angle,\r\n        anchor,\r\n        flatCoordinates,\r\n      );\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scale the geometry (with an optional origin).  This modifies the geometry\r\n   * coordinates in place.\r\n   * @param {number} sx The scaling factor in the x-direction.\r\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\r\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\r\n   *     of the geometry extent).\r\n   * @api\r\n   * @override\r\n   */\r\n  scale(sx, sy, anchor) {\r\n    if (sy === undefined) {\r\n      sy = sx;\r\n    }\r\n    if (!anchor) {\r\n      anchor = getCenter(this.getExtent());\r\n    }\r\n    const flatCoordinates = this.getFlatCoordinates();\r\n    if (flatCoordinates) {\r\n      const stride = this.getStride();\r\n      scale(\r\n        flatCoordinates,\r\n        0,\r\n        flatCoordinates.length,\r\n        stride,\r\n        sx,\r\n        sy,\r\n        anchor,\r\n        flatCoordinates,\r\n      );\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\r\n   * instead you want a new geometry, first `clone()` this geometry.\r\n   * @param {number} deltaX Delta X.\r\n   * @param {number} deltaY Delta Y.\r\n   * @api\r\n   * @override\r\n   */\r\n  translate(deltaX, deltaY) {\r\n    const flatCoordinates = this.getFlatCoordinates();\r\n    if (flatCoordinates) {\r\n      const stride = this.getStride();\r\n      translate(\r\n        flatCoordinates,\r\n        0,\r\n        flatCoordinates.length,\r\n        stride,\r\n        deltaX,\r\n        deltaY,\r\n        flatCoordinates,\r\n      );\r\n      this.changed();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} stride Stride.\r\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\r\n */\r\nexport function getLayoutForStride(stride) {\r\n  let layout;\r\n  if (stride == 2) {\r\n    layout = 'XY';\r\n  } else if (stride == 3) {\r\n    layout = 'XYZ';\r\n  } else if (stride == 4) {\r\n    layout = 'XYZM';\r\n  }\r\n  return /** @type {import(\"./Geometry.js\").GeometryLayout} */ (layout);\r\n}\r\n\r\n/**\r\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\r\n * @return {number} Stride.\r\n */\r\nexport function getStrideForLayout(layout) {\r\n  let stride;\r\n  if (layout == 'XY') {\r\n    stride = 2;\r\n  } else if (layout == 'XYZ' || layout == 'XYM') {\r\n    stride = 3;\r\n  } else if (layout == 'XYZM') {\r\n    stride = 4;\r\n  }\r\n  return /** @type {number} */ (stride);\r\n}\r\n\r\n/**\r\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\r\n * @param {import(\"../transform.js\").Transform} transform Transform.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Transformed flat coordinates.\r\n */\r\nexport function transformGeom2D(simpleGeometry, transform, dest) {\r\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\r\n  if (!flatCoordinates) {\r\n    return null;\r\n  }\r\n  const stride = simpleGeometry.getStride();\r\n  return transform2D(\r\n    flatCoordinates,\r\n    0,\r\n    flatCoordinates.length,\r\n    stride,\r\n    transform,\r\n    dest,\r\n  );\r\n}\r\n\r\nexport default SimpleGeometry;\r\n","/**\r\n * @module CME2D/geom/flat/closest\r\n */\r\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\r\n\r\n/**\r\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\r\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\r\n * dimensions are linearly interpolated.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset1 Offset 1.\r\n * @param {number} offset2 Offset 2.\r\n * @param {number} stride Stride.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n */\r\nfunction assignClosest(\r\n  flatCoordinates,\r\n  offset1,\r\n  offset2,\r\n  stride,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n) {\r\n  const x1 = flatCoordinates[offset1];\r\n  const y1 = flatCoordinates[offset1 + 1];\r\n  const dx = flatCoordinates[offset2] - x1;\r\n  const dy = flatCoordinates[offset2 + 1] - y1;\r\n  let offset;\r\n  if (dx === 0 && dy === 0) {\r\n    offset = offset1;\r\n  } else {\r\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\r\n    if (t > 1) {\r\n      offset = offset2;\r\n    } else if (t > 0) {\r\n      for (let i = 0; i < stride; ++i) {\r\n        closestPoint[i] = lerp(\r\n          flatCoordinates[offset1 + i],\r\n          flatCoordinates[offset2 + i],\r\n          t,\r\n        );\r\n      }\r\n      closestPoint.length = stride;\r\n      return;\r\n    } else {\r\n      offset = offset1;\r\n    }\r\n  }\r\n  for (let i = 0; i < stride; ++i) {\r\n    closestPoint[i] = flatCoordinates[offset + i];\r\n  }\r\n  closestPoint.length = stride;\r\n}\r\n\r\n/**\r\n * Return the squared of the largest distance between any pair of consecutive\r\n * coordinates.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\r\n    if (squaredDelta > max) {\r\n      max = squaredDelta;\r\n    }\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function arrayMaxSquaredDelta(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  max,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\r\n    offset = end;\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} max Max squared delta.\r\n * @return {number} Max squared delta.\r\n */\r\nexport function multiArrayMaxSquaredDelta(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  max,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return max;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint,\r\n) {\r\n  if (offset == end) {\r\n    return minSquaredDistance;\r\n  }\r\n  let i, squaredDistance;\r\n  if (maxDelta === 0) {\r\n    // All points are identical, so just test the first point.\r\n    squaredDistance = squaredDx(\r\n      x,\r\n      y,\r\n      flatCoordinates[offset],\r\n      flatCoordinates[offset + 1],\r\n    );\r\n    if (squaredDistance < minSquaredDistance) {\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = flatCoordinates[offset + i];\r\n      }\r\n      closestPoint.length = stride;\r\n      return squaredDistance;\r\n    }\r\n    return minSquaredDistance;\r\n  }\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  let index = offset + stride;\r\n  while (index < end) {\r\n    assignClosest(\r\n      flatCoordinates,\r\n      index - stride,\r\n      index,\r\n      stride,\r\n      x,\r\n      y,\r\n      tmpPoint,\r\n    );\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n      index += stride;\r\n    } else {\r\n      // Skip ahead multiple points, because we know that all the skipped\r\n      // points cannot be any closer than the closest point we have found so\r\n      // far.  We know this because we know how close the current point is, how\r\n      // close the closest point we have found so far is, and the maximum\r\n      // distance between consecutive points.  For example, if we're currently\r\n      // at distance 10, the best we've found so far is 3, and that the maximum\r\n      // distance between consecutive points is 2, then we'll need to skip at\r\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\r\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\r\n      // always advance at least one point, to avoid an infinite loop.\r\n      index +=\r\n        stride *\r\n        Math.max(\r\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\r\n            maxDelta) |\r\n            0,\r\n          1,\r\n        );\r\n    }\r\n  }\r\n  if (isRing) {\r\n    // Check the closing segment.\r\n    assignClosest(\r\n      flatCoordinates,\r\n      end - stride,\r\n      offset,\r\n      stride,\r\n      x,\r\n      y,\r\n      tmpPoint,\r\n    );\r\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\r\n    if (squaredDistance < minSquaredDistance) {\r\n      minSquaredDistance = squaredDistance;\r\n      for (i = 0; i < stride; ++i) {\r\n        closestPoint[i] = tmpPoint[i];\r\n      }\r\n      closestPoint.length = stride;\r\n    }\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestArrayPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint,\r\n) {\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    minSquaredDistance = assignClosestPoint(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      maxDelta,\r\n      isRing,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n      tmpPoint,\r\n    );\r\n    offset = end;\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} maxDelta Max delta.\r\n * @param {boolean} isRing Is ring.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @param {Array<number>} closestPoint Closest point.\r\n * @param {number} minSquaredDistance Minimum squared distance.\r\n * @param {Array<number>} [tmpPoint] Temporary point object.\r\n * @return {number} Minimum squared distance.\r\n */\r\nexport function assignClosestMultiArrayPoint(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  maxDelta,\r\n  isRing,\r\n  x,\r\n  y,\r\n  closestPoint,\r\n  minSquaredDistance,\r\n  tmpPoint,\r\n) {\r\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    minSquaredDistance = assignClosestArrayPoint(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      maxDelta,\r\n      isRing,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n      tmpPoint,\r\n    );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return minSquaredDistance;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/deflate\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {number} stride Stride.\r\n * @return {number} offset Offset.\r\n */\r\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\r\n  for (let i = 0, ii = coordinate.length; i < ii; ++i) {\r\n    flatCoordinates[offset++] = coordinate[i];\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @param {number} stride Stride.\r\n * @return {number} offset Offset.\r\n */\r\nexport function deflateCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  coordinates,\r\n  stride,\r\n) {\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    const coordinate = coordinates[i];\r\n    for (let j = 0; j < stride; ++j) {\r\n      flatCoordinates[offset++] = coordinate[j];\r\n    }\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\r\n * @param {number} stride Stride.\r\n * @param {Array<number>} [ends] Ends.\r\n * @return {Array<number>} Ends.\r\n */\r\nexport function deflateCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  coordinatess,\r\n  stride,\r\n  ends,\r\n) {\r\n  ends = ends ? ends : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {\r\n    const end = deflateCoordinates(\r\n      flatCoordinates,\r\n      offset,\r\n      coordinatess[j],\r\n      stride,\r\n    );\r\n    ends[i++] = end;\r\n    offset = end;\r\n  }\r\n  ends.length = i;\r\n  return ends;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<number>>} [endss] Endss.\r\n * @return {Array<Array<number>>} Endss.\r\n */\r\nexport function deflateMultiCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  coordinatesss,\r\n  stride,\r\n  endss,\r\n) {\r\n  endss = endss ? endss : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {\r\n    const ends = deflateCoordinatesArray(\r\n      flatCoordinates,\r\n      offset,\r\n      coordinatesss[j],\r\n      stride,\r\n      endss[i],\r\n    );\r\n    if (ends.length === 0) {\r\n      ends[0] = offset;\r\n    }\r\n    endss[i++] = ends;\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  endss.length = i;\r\n  return endss;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/simplify\r\n */\r\n// Based on simplify-js https://github.com/mourner/simplify-js\r\n// Copyright (c) 2012, Vladimir Agafonkin\r\n// All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//\r\n//    1. Redistributions of source code must retain the above copyright notice,\r\n//       this list of conditions and the following disclaimer.\r\n//\r\n//    2. Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n// POSSIBILITY OF SUCH DAMAGE.\r\n\r\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {boolean} highQuality Highest quality.\r\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\r\n *     coordinates.\r\n * @return {Array<number>} Simplified line string.\r\n */\r\nexport function simplifyLineString(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  highQuality,\r\n  simplifiedFlatCoordinates,\r\n) {\r\n  simplifiedFlatCoordinates =\r\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\r\n  if (!highQuality) {\r\n    end = radialDistance(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n    );\r\n    flatCoordinates = simplifiedFlatCoordinates;\r\n    offset = 0;\r\n    stride = 2;\r\n  }\r\n  simplifiedFlatCoordinates.length = douglasPeucker(\r\n    flatCoordinates,\r\n    offset,\r\n    end,\r\n    stride,\r\n    squaredTolerance,\r\n    simplifiedFlatCoordinates,\r\n    0,\r\n  );\r\n  return simplifiedFlatCoordinates;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeucker(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n) {\r\n  const n = (end - offset) / stride;\r\n  if (n < 3) {\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  /** @type {Array<number>} */\r\n  const markers = new Array(n);\r\n  markers[0] = 1;\r\n  markers[n - 1] = 1;\r\n  /** @type {Array<number>} */\r\n  const stack = [offset, end - stride];\r\n  let index = 0;\r\n  while (stack.length > 0) {\r\n    const last = stack.pop();\r\n    const first = stack.pop();\r\n    let maxSquaredDistance = 0;\r\n    const x1 = flatCoordinates[first];\r\n    const y1 = flatCoordinates[first + 1];\r\n    const x2 = flatCoordinates[last];\r\n    const y2 = flatCoordinates[last + 1];\r\n    for (let i = first + stride; i < last; i += stride) {\r\n      const x = flatCoordinates[i];\r\n      const y = flatCoordinates[i + 1];\r\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\r\n      if (squaredDistance > maxSquaredDistance) {\r\n        index = i;\r\n        maxSquaredDistance = squaredDistance;\r\n      }\r\n    }\r\n    if (maxSquaredDistance > squaredTolerance) {\r\n      markers[(index - offset) / stride] = 1;\r\n      if (first + stride < index) {\r\n        stack.push(first, index);\r\n      }\r\n      if (index + stride < last) {\r\n        stack.push(index, last);\r\n      }\r\n    }\r\n  }\r\n  for (let i = 0; i < n; ++i) {\r\n    if (markers[i]) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + i * stride];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + i * stride + 1];\r\n    }\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEnds,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = douglasPeucker(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n    );\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function douglasPeuckerMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEndss,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    /** @type {Array<number>} */\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = douglasPeuckerArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n      simplifiedEnds,\r\n    );\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} squaredTolerance Squared tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function radialDistance(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  squaredTolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n) {\r\n  if (end <= offset + stride) {\r\n    // zero or one point, no simplification possible, so copy and return\r\n    for (; offset < end; offset += stride) {\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\r\n      simplifiedFlatCoordinates[simplifiedOffset++] =\r\n        flatCoordinates[offset + 1];\r\n    }\r\n    return simplifiedOffset;\r\n  }\r\n  let x1 = flatCoordinates[offset];\r\n  let y1 = flatCoordinates[offset + 1];\r\n  // copy first point\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  let x2 = x1;\r\n  let y2 = y1;\r\n  for (offset += stride; offset < end; offset += stride) {\r\n    x2 = flatCoordinates[offset];\r\n    y2 = flatCoordinates[offset + 1];\r\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\r\n      // copy point at offset\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n  }\r\n  if (x2 != x1 || y2 != y1) {\r\n    // copy last point\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {number} value Value.\r\n * @param {number} tolerance Tolerance.\r\n * @return {number} Rounded value.\r\n */\r\nexport function snap(value, tolerance) {\r\n  return tolerance * Math.round(value / tolerance);\r\n}\r\n\r\n/**\r\n * Simplifies a line string using an algorithm designed by Tim Schaub.\r\n * Coordinates are snapped to the nearest value in a virtual grid and\r\n * consecutive duplicate coordinates are discarded.  This effectively preserves\r\n * topology as the simplification of any subsection of a line string is\r\n * independent of the rest of the line string.  This means that, for examples,\r\n * the common edge between two polygons will be simplified to the same line\r\n * string independently in both polygons.  This implementation uses a single\r\n * pass over the coordinates and eliminates intermediate collinear points.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantize(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n) {\r\n  // do nothing if the line is empty\r\n  if (offset == end) {\r\n    return simplifiedOffset;\r\n  }\r\n  // snap the first coordinate (P1)\r\n  let x1 = snap(flatCoordinates[offset], tolerance);\r\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\r\n  offset += stride;\r\n  // add the first coordinate to the output\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\r\n  // find the next coordinate that does not snap to the same value as the first\r\n  // coordinate (P2)\r\n  let x2, y2;\r\n  do {\r\n    x2 = snap(flatCoordinates[offset], tolerance);\r\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    if (offset == end) {\r\n      // all coordinates snap to the same value, the line collapses to a point\r\n      // push the last snapped value anyway to ensure that the output contains\r\n      // at least two points\r\n      // FIXME should we really return at least two points anyway?\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n      return simplifiedOffset;\r\n    }\r\n  } while (x2 == x1 && y2 == y1);\r\n  while (offset < end) {\r\n    // snap the next coordinate (P3)\r\n    const x3 = snap(flatCoordinates[offset], tolerance);\r\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\r\n    offset += stride;\r\n    // skip P3 if it is equal to P2\r\n    if (x3 == x2 && y3 == y2) {\r\n      continue;\r\n    }\r\n    // calculate the delta between P1 and P2\r\n    const dx1 = x2 - x1;\r\n    const dy1 = y2 - y1;\r\n    // calculate the delta between P3 and P1\r\n    const dx2 = x3 - x1;\r\n    const dy2 = y3 - y1;\r\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\r\n    // P1 in the same direction then P2 is on the straight line between P1 and\r\n    // P3\r\n    if (\r\n      dx1 * dy2 == dy1 * dx2 &&\r\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\r\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\r\n    ) {\r\n      // discard P2 and set P2 = P3\r\n      x2 = x3;\r\n      y2 = y3;\r\n      continue;\r\n    }\r\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\r\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\r\n    // and continue with P1 = P2 and P2 = P3\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n    x1 = x2;\r\n    y1 = y2;\r\n    x2 = x3;\r\n    y2 = y3;\r\n  }\r\n  // add the last point (P2)\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\r\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<number>} simplifiedEnds Simplified ends.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEnds,\r\n) {\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    simplifiedOffset = quantize(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n    );\r\n    simplifiedEnds.push(simplifiedOffset);\r\n    offset = end;\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {number} tolerance Tolerance.\r\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\r\n *     coordinates.\r\n * @param {number} simplifiedOffset Simplified offset.\r\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\r\n * @return {number} Simplified offset.\r\n */\r\nexport function quantizeMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  tolerance,\r\n  simplifiedFlatCoordinates,\r\n  simplifiedOffset,\r\n  simplifiedEndss,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    /** @type {Array<number>} */\r\n    const simplifiedEnds = [];\r\n    simplifiedOffset = quantizeArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      tolerance,\r\n      simplifiedFlatCoordinates,\r\n      simplifiedOffset,\r\n      simplifiedEnds,\r\n    );\r\n    simplifiedEndss.push(simplifiedEnds);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return simplifiedOffset;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/inflate\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\r\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\r\n */\r\nexport function inflateCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  coordinates,\r\n) {\r\n  coordinates = coordinates !== undefined ? coordinates : [];\r\n  let i = 0;\r\n  for (let j = offset; j < end; j += stride) {\r\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\r\n  }\r\n  coordinates.length = i;\r\n  return coordinates;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\r\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\r\n */\r\nexport function inflateCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  coordinatess,\r\n) {\r\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\r\n    const end = ends[j];\r\n    coordinatess[i++] = inflateCoordinates(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n      coordinatess[i],\r\n    );\r\n    offset = end;\r\n  }\r\n  coordinatess.length = i;\r\n  return coordinatess;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\r\n *     Coordinatesss.\r\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\r\n */\r\nexport function inflateMultiCoordinatesArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  coordinatesss,\r\n) {\r\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\r\n  let i = 0;\r\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\r\n    const ends = endss[j];\r\n    coordinatesss[i++] =\r\n      ends.length === 1 && ends[0] === offset\r\n        ? []\r\n        : inflateCoordinatesArray(\r\n            flatCoordinates,\r\n            offset,\r\n            ends,\r\n            stride,\r\n            coordinatesss[i],\r\n          );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  coordinatesss.length = i;\r\n  return coordinatesss;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/area\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {number} Area.\r\n */\r\nexport function linearRing(flatCoordinates, offset, end, stride) {\r\n  let twiceArea = 0;\r\n  const x0 = flatCoordinates[end - stride];\r\n  const y0 = flatCoordinates[end - stride + 1];\r\n  let dx1 = 0;\r\n  let dy1 = 0;\r\n  for (; offset < end; offset += stride) {\r\n    const dx2 = flatCoordinates[offset] - x0;\r\n    const dy2 = flatCoordinates[offset + 1] - y0;\r\n    twiceArea += dy1 * dx2 - dx1 * dy2;\r\n    dx1 = dx2;\r\n    dy1 = dy2;\r\n  }\r\n  return twiceArea / 2;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @return {number} Area.\r\n */\r\nexport function linearRings(flatCoordinates, offset, ends, stride) {\r\n  let area = 0;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    area += linearRing(flatCoordinates, offset, end, stride);\r\n    offset = end;\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @return {number} Area.\r\n */\r\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\r\n  let area = 0;\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    area += linearRings(flatCoordinates, offset, ends, stride);\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return area;\r\n}\r\n","/**\r\n * @module CME2D/geom/LinearRing\r\n */\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY} from '../extent.js';\r\nimport {deflateCoordinates} from './flat/deflate.js';\r\nimport {douglasPeucker} from './flat/simplify.js';\r\nimport {inflateCoordinates} from './flat/inflate.js';\r\nimport {linearRing as linearRingArea} from './flat/area.js';\r\n\r\n/**\r\n * @classdesc\r\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\r\n * on its own.\r\n *\r\n * @api\r\n */\r\nclass LinearRing extends SimpleGeometry {\r\n  /**\r\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\r\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  constructor(coordinates, layout) {\r\n    super();\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates),\r\n      );\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\r\n          coordinates\r\n        ),\r\n        layout,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!LinearRing} Clone.\r\n   * @api\r\n   * @override\r\n   */\r\n  clone() {\r\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   * @override\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        maxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.flatCoordinates.length,\r\n          this.stride,\r\n          0,\r\n        ),\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestPoint(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      true,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the area of the linear ring on projected plane.\r\n   * @return {number} Area (on projected plane).\r\n   * @api\r\n   */\r\n  getArea() {\r\n    return linearRingArea(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the coordinates of the linear ring.\r\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  getCoordinates() {\r\n    return inflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {LinearRing} Simplified LinearRing.\r\n   * @protected\r\n   * @override\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    /** @type {Array<number>} */\r\n    const simplifiedFlatCoordinates = [];\r\n    simplifiedFlatCoordinates.length = douglasPeucker(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.flatCoordinates.length,\r\n      this.stride,\r\n      squaredTolerance,\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n    );\r\n    return new LinearRing(simplifiedFlatCoordinates, 'XY');\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   * @override\r\n   */\r\n  getType() {\r\n    return 'LinearRing';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   * @override\r\n   */\r\n  intersectsExtent(extent) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the linear ring.\r\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   * @override\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 1);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    this.flatCoordinates.length = deflateCoordinates(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n    );\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default LinearRing;\r\n","/**\r\n * @module CME2D/geom/Point\r\n */\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {containsXY, createOrUpdateFromCoordinate} from '../extent.js';\r\nimport {deflateCoordinate} from './flat/deflate.js';\r\nimport {squaredDistance as squaredDx} from '../math.js';\r\n\r\n/**\r\n * @classdesc\r\n * Point geometry.\r\n *\r\n * @api\r\n */\r\nclass Point extends SimpleGeometry {\r\n  /**\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   */\r\n  constructor(coordinates, layout) {\r\n    super();\r\n    this.setCoordinates(coordinates, layout);\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!Point} Clone.\r\n   * @api\r\n   * @override\r\n   */\r\n  clone() {\r\n    const point = new Point(this.flatCoordinates.slice(), this.layout);\r\n    point.applyProperties(this);\r\n    return point;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   * @override\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const squaredDistance = squaredDx(\r\n      x,\r\n      y,\r\n      flatCoordinates[0],\r\n      flatCoordinates[1],\r\n    );\r\n    if (squaredDistance < minSquaredDistance) {\r\n      const stride = this.stride;\r\n      for (let i = 0; i < stride; ++i) {\r\n        closestPoint[i] = flatCoordinates[i];\r\n      }\r\n      closestPoint.length = stride;\r\n      return squaredDistance;\r\n    }\r\n    return minSquaredDistance;\r\n  }\r\n\r\n  /**\r\n   * Return the coordinate of the point.\r\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  getCoordinates() {\r\n    return this.flatCoordinates.slice();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @protected\r\n   * @return {import(\"../extent.js\").Extent} extent Extent.\r\n   * @override\r\n   */\r\n  computeExtent(extent) {\r\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   * @override\r\n   */\r\n  getType() {\r\n    return 'Point';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   * @override\r\n   */\r\n  intersectsExtent(extent) {\r\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\r\n  }\r\n\r\n  /**\r\n   * @param {!Array<*>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   * @override\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 0);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    this.flatCoordinates.length = deflateCoordinate(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n    );\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default Point;\r\n","/**\r\n * @module CME2D/geom/flat/interiorpoint\r\n */\r\nimport {ascending} from '../../array.js';\r\nimport {linearRingsContainsXY} from './contains.js';\r\n\r\n/**\r\n * Calculates a point that is likely to lie in the interior of the linear rings.\r\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {Array<number>} flatCenters Flat centers.\r\n * @param {number} flatCentersOffset Flat center offset.\r\n * @param {Array<number>} [dest] Destination.\r\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\r\n * length of the horizontal intersection that the point belongs to.\r\n */\r\nexport function getInteriorPointOfArray(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  flatCenters,\r\n  flatCentersOffset,\r\n  dest,\r\n) {\r\n  let i, ii, x, x1, x2, y1, y2;\r\n  const y = flatCenters[flatCentersOffset + 1];\r\n  /** @type {Array<number>} */\r\n  const intersections = [];\r\n  // Calculate intersections with the horizontal line\r\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\r\n    const end = ends[r];\r\n    x1 = flatCoordinates[end - stride];\r\n    y1 = flatCoordinates[end - stride + 1];\r\n    for (i = offset; i < end; i += stride) {\r\n      x2 = flatCoordinates[i];\r\n      y2 = flatCoordinates[i + 1];\r\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\r\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\r\n        intersections.push(x);\r\n      }\r\n      x1 = x2;\r\n      y1 = y2;\r\n    }\r\n  }\r\n  // Find the longest segment of the horizontal line that has its center point\r\n  // inside the linear ring.\r\n  let pointX = NaN;\r\n  let maxSegmentLength = -Infinity;\r\n  intersections.sort(ascending);\r\n  x1 = intersections[0];\r\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\r\n    x2 = intersections[i];\r\n    const segmentLength = Math.abs(x2 - x1);\r\n    if (segmentLength > maxSegmentLength) {\r\n      x = (x1 + x2) / 2;\r\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\r\n        pointX = x;\r\n        maxSegmentLength = segmentLength;\r\n      }\r\n    }\r\n    x1 = x2;\r\n  }\r\n  if (isNaN(pointX)) {\r\n    // There is no horizontal line that has its center point inside the linear\r\n    // ring.  Use the center of the the linear ring's extent.\r\n    pointX = flatCenters[flatCentersOffset];\r\n  }\r\n  if (dest) {\r\n    dest.push(pointX, y, maxSegmentLength);\r\n    return dest;\r\n  }\r\n  return [pointX, y, maxSegmentLength];\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Endss.\r\n * @param {number} stride Stride.\r\n * @param {Array<number>} flatCenters Flat centers.\r\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\r\n * length of the horizontal intersection that the point belongs to.\r\n */\r\nexport function getInteriorPointsOfMultiArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  flatCenters,\r\n) {\r\n  /** @type {Array<number>} */\r\n  let interiorPoints = [];\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    interiorPoints = getInteriorPointOfArray(\r\n      flatCoordinates,\r\n      offset,\r\n      ends,\r\n      stride,\r\n      flatCenters,\r\n      2 * i,\r\n      interiorPoints,\r\n    );\r\n    offset = ends[ends.length - 1];\r\n  }\r\n  return interiorPoints;\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/reverse\r\n */\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n */\r\nexport function coordinates(flatCoordinates, offset, end, stride) {\r\n  while (offset < end - stride) {\r\n    for (let i = 0; i < stride; ++i) {\r\n      const tmp = flatCoordinates[offset + i];\r\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\r\n      flatCoordinates[end - stride + i] = tmp;\r\n    }\r\n    offset += stride;\r\n    end -= stride;\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/geom/flat/orient\r\n */\r\nimport {coordinates as reverseCoordinates} from './reverse.js';\r\n\r\n/**\r\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\r\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\r\n * the ring's orientation is clockwise when this function returns false.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {boolean|undefined} Is clockwise.\r\n */\r\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\r\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\r\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\r\n  let edge = 0;\r\n  let x1 = flatCoordinates[end - stride];\r\n  let y1 = flatCoordinates[end - stride + 1];\r\n  for (; offset < end; offset += stride) {\r\n    const x2 = flatCoordinates[offset];\r\n    const y2 = flatCoordinates[offset + 1];\r\n    edge += (x2 - x1) * (y2 + y1);\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return edge === 0 ? undefined : edge > 0;\r\n}\r\n\r\n/**\r\n * Determines if linear rings are oriented.  By default, left-hand orientation\r\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\r\n * To test for right-hand orientation, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Array of end indexes.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Test for right-hand orientation\r\n *     (counter-clockwise exterior ring and clockwise interior rings).\r\n * @return {boolean} Rings are correctly oriented.\r\n */\r\nexport function linearRingsAreOriented(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  right,\r\n) {\r\n  right = right !== undefined ? right : false;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    const isClockwise = linearRingIsClockwise(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n    );\r\n    if (i === 0) {\r\n      if ((right && isClockwise) || (!right && !isClockwise)) {\r\n        return false;\r\n      }\r\n    } else {\r\n      if ((right && !isClockwise) || (!right && isClockwise)) {\r\n        return false;\r\n      }\r\n    }\r\n    offset = end;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Determines if linear rings are oriented.  By default, left-hand orientation\r\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\r\n * To test for right-hand orientation, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Array of array of end indexes.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Test for right-hand orientation\r\n *     (counter-clockwise exterior ring and clockwise interior rings).\r\n * @return {boolean} Rings are correctly oriented.\r\n */\r\nexport function linearRingssAreOriented(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  right,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    const ends = endss[i];\r\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\r\n      return false;\r\n    }\r\n    if (ends.length) {\r\n      offset = ends[ends.length - 1];\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Orient coordinates in a flat array of linear rings.  By default, rings\r\n * are oriented following the left-hand rule (clockwise for exterior and\r\n * counter-clockwise for interior rings).  To orient according to the\r\n * right-hand rule, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<number>} ends Ends.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Follow the right-hand rule for orientation.\r\n * @return {number} End.\r\n */\r\nexport function orientLinearRings(\r\n  flatCoordinates,\r\n  offset,\r\n  ends,\r\n  stride,\r\n  right,\r\n) {\r\n  right = right !== undefined ? right : false;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    const isClockwise = linearRingIsClockwise(\r\n      flatCoordinates,\r\n      offset,\r\n      end,\r\n      stride,\r\n    );\r\n    const reverse =\r\n      i === 0\r\n        ? (right && isClockwise) || (!right && !isClockwise)\r\n        : (right && !isClockwise) || (!right && isClockwise);\r\n    if (reverse) {\r\n      reverseCoordinates(flatCoordinates, offset, end, stride);\r\n    }\r\n    offset = end;\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * Orient coordinates in a flat array of linear rings.  By default, rings\r\n * are oriented following the left-hand rule (clockwise for exterior and\r\n * counter-clockwise for interior rings).  To orient according to the\r\n * right-hand rule, use the `right` argument.\r\n *\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {Array<Array<number>>} endss Array of array of end indexes.\r\n * @param {number} stride Stride.\r\n * @param {boolean} [right] Follow the right-hand rule for orientation.\r\n * @return {number} End.\r\n */\r\nexport function orientLinearRingsArray(\r\n  flatCoordinates,\r\n  offset,\r\n  endss,\r\n  stride,\r\n  right,\r\n) {\r\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\r\n    offset = orientLinearRings(\r\n      flatCoordinates,\r\n      offset,\r\n      endss[i],\r\n      stride,\r\n      right,\r\n    );\r\n  }\r\n  return offset;\r\n}\r\n\r\n/**\r\n * Return a two-dimensional endss\r\n * @param {Array<number>} flatCoordinates Flat coordinates\r\n * @param {Array<number>} ends Linear ring end indexes\r\n * @return {Array<Array<number>>} Two dimensional endss array that can\r\n * be used to construct a MultiPolygon\r\n */\r\nexport function inflateEnds(flatCoordinates, ends) {\r\n  const endss = [];\r\n  let offset = 0;\r\n  let prevEndIndex = 0;\r\n  let startOrientation;\r\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n    const end = ends[i];\r\n    // classifies an array of rings into polygons with outer rings and holes\r\n    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);\r\n    if (startOrientation === undefined) {\r\n      startOrientation = orientation;\r\n    }\r\n    if (orientation === startOrientation) {\r\n      endss.push(ends.slice(prevEndIndex, i + 1));\r\n    } else {\r\n      if (endss.length === 0) {\r\n        continue;\r\n      }\r\n      endss[endss.length - 1].push(ends[prevEndIndex]);\r\n    }\r\n    prevEndIndex = i + 1;\r\n    offset = end;\r\n  }\r\n  return endss;\r\n}\r\n","/**\r\n * @module CME2D/geom/Polygon\r\n */\r\nimport LinearRing from './LinearRing.js';\r\nimport Point from './Point.js';\r\nimport SimpleGeometry from './SimpleGeometry.js';\r\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\r\nimport {closestSquaredDistanceXY, getCenter, isEmpty} from '../extent.js';\r\nimport {deflateCoordinatesArray} from './flat/deflate.js';\r\nimport {extend} from '../array.js';\r\nimport {getInteriorPointOfArray} from './flat/interiorpoint.js';\r\nimport {inflateCoordinatesArray} from './flat/inflate.js';\r\nimport {intersectsLinearRingArray} from './flat/intersectsextent.js';\r\nimport {linearRingsAreOriented, orientLinearRings} from './flat/orient.js';\r\nimport {linearRings as linearRingsArea} from './flat/area.js';\r\nimport {linearRingsContainsXY} from './flat/contains.js';\r\nimport {modulo} from '../math.js';\r\nimport {quantizeArray} from './flat/simplify.js';\r\nimport {offset as sphereOffset} from '../sphere.js';\r\n\r\n/**\r\n * @classdesc\r\n * Polygon geometry.\r\n *\r\n * @api\r\n */\r\nclass Polygon extends SimpleGeometry {\r\n  /**\r\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\r\n   *     Array of linear rings that define the polygon. The first linear ring of the\r\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\r\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\r\n   *     an array of vertices' coordinates where the first coordinate and the last are\r\n   *     equivalent. (For internal use, flat coordinates in combination with\r\n   *     `layout` and `ends` are also accepted.)\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).\r\n   */\r\n  constructor(coordinates, layout, ends) {\r\n    super();\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @private\r\n     */\r\n    this.ends_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.flatInteriorPointRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../coordinate.js\").Coordinate|null}\r\n     */\r\n    this.flatInteriorPoint_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDelta_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxDeltaRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.orientedRevision_ = -1;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>|null}\r\n     */\r\n    this.orientedFlatCoordinates_ = null;\r\n\r\n    if (layout !== undefined && ends) {\r\n      this.setFlatCoordinates(\r\n        layout,\r\n        /** @type {Array<number>} */ (coordinates),\r\n      );\r\n      this.ends_ = ends;\r\n    } else {\r\n      this.setCoordinates(\r\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\r\n          coordinates\r\n        ),\r\n        layout,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Append the passed linear ring to this polygon.\r\n   * @param {LinearRing} linearRing Linear ring.\r\n   * @api\r\n   */\r\n  appendLinearRing(linearRing) {\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\r\n    } else {\r\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\r\n    }\r\n    this.ends_.push(this.flatCoordinates.length);\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Make a complete copy of the geometry.\r\n   * @return {!Polygon} Clone.\r\n   * @api\r\n   * @override\r\n   */\r\n  clone() {\r\n    const polygon = new Polygon(\r\n      this.flatCoordinates.slice(),\r\n      this.layout,\r\n      this.ends_.slice(),\r\n    );\r\n    polygon.applyProperties(this);\r\n    return polygon;\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\r\n   * @param {number} minSquaredDistance Minimum squared distance.\r\n   * @return {number} Minimum squared distance.\r\n   * @override\r\n   */\r\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\r\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\r\n      return minSquaredDistance;\r\n    }\r\n    if (this.maxDeltaRevision_ != this.getRevision()) {\r\n      this.maxDelta_ = Math.sqrt(\r\n        arrayMaxSquaredDelta(\r\n          this.flatCoordinates,\r\n          0,\r\n          this.ends_,\r\n          this.stride,\r\n          0,\r\n        ),\r\n      );\r\n      this.maxDeltaRevision_ = this.getRevision();\r\n    }\r\n    return assignClosestArrayPoint(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      this.maxDelta_,\r\n      true,\r\n      x,\r\n      y,\r\n      closestPoint,\r\n      minSquaredDistance,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {number} x X.\r\n   * @param {number} y Y.\r\n   * @return {boolean} Contains (x, y).\r\n   * @override\r\n   */\r\n  containsXY(x, y) {\r\n    return linearRingsContainsXY(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      x,\r\n      y,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the area of the polygon on projected plane.\r\n   * @return {number} Area (on projected plane).\r\n   * @api\r\n   */\r\n  getArea() {\r\n    return linearRingsArea(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the coordinate array for this geometry.  This array has the structure\r\n   * of a GeoJSON coordinate array for polygons.\r\n   *\r\n   * @param {boolean} [right] Orient coordinates according to the right-hand\r\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\r\n   *     If `false`, coordinates will be oriented according to the left-hand rule\r\n   *     (clockwise for exterior and counter-clockwise for interior rings).\r\n   *     By default, coordinate orientation will depend on how the geometry was\r\n   *     constructed.\r\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\r\n   * @api\r\n   * @override\r\n   */\r\n  getCoordinates(right) {\r\n    let flatCoordinates;\r\n    if (right !== undefined) {\r\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\r\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);\r\n    } else {\r\n      flatCoordinates = this.flatCoordinates;\r\n    }\r\n\r\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Ends.\r\n   */\r\n  getEnds() {\r\n    return this.ends_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Interior point.\r\n   */\r\n  getFlatInteriorPoint() {\r\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\r\n      const flatCenter = getCenter(this.getExtent());\r\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\r\n        this.getOrientedFlatCoordinates(),\r\n        0,\r\n        this.ends_,\r\n        this.stride,\r\n        flatCenter,\r\n        0,\r\n      );\r\n      this.flatInteriorPointRevision_ = this.getRevision();\r\n    }\r\n    return /** @type {import(\"../coordinate.js\").Coordinate} */ (\r\n      this.flatInteriorPoint_\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return an interior point of the polygon.\r\n   * @return {Point} Interior point as XYM coordinate, where M is the\r\n   * length of the horizontal intersection that the point belongs to.\r\n   * @api\r\n   */\r\n  getInteriorPoint() {\r\n    return new Point(this.getFlatInteriorPoint(), 'XYM');\r\n  }\r\n\r\n  /**\r\n   * Return the number of rings of the polygon,  this includes the exterior\r\n   * ring and any interior rings.\r\n   *\r\n   * @return {number} Number of rings.\r\n   * @api\r\n   */\r\n  getLinearRingCount() {\r\n    return this.ends_.length;\r\n  }\r\n\r\n  /**\r\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\r\n   * given index is out of range.\r\n   * The exterior linear ring is available at index `0` and the interior rings\r\n   * at index `1` and beyond.\r\n   *\r\n   * @param {number} index Index.\r\n   * @return {LinearRing|null} Linear ring.\r\n   * @api\r\n   */\r\n  getLinearRing(index) {\r\n    if (index < 0 || this.ends_.length <= index) {\r\n      return null;\r\n    }\r\n    return new LinearRing(\r\n      this.flatCoordinates.slice(\r\n        index === 0 ? 0 : this.ends_[index - 1],\r\n        this.ends_[index],\r\n      ),\r\n      this.layout,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the linear rings of the polygon.\r\n   * @return {Array<LinearRing>} Linear rings.\r\n   * @api\r\n   */\r\n  getLinearRings() {\r\n    const layout = this.layout;\r\n    const flatCoordinates = this.flatCoordinates;\r\n    const ends = this.ends_;\r\n    const linearRings = [];\r\n    let offset = 0;\r\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\r\n      const end = ends[i];\r\n      const linearRing = new LinearRing(\r\n        flatCoordinates.slice(offset, end),\r\n        layout,\r\n      );\r\n      linearRings.push(linearRing);\r\n      offset = end;\r\n    }\r\n    return linearRings;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>} Oriented flat coordinates.\r\n   */\r\n  getOrientedFlatCoordinates() {\r\n    if (this.orientedRevision_ != this.getRevision()) {\r\n      const flatCoordinates = this.flatCoordinates;\r\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\r\n        this.orientedFlatCoordinates_ = flatCoordinates;\r\n      } else {\r\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\r\n        this.orientedFlatCoordinates_.length = orientLinearRings(\r\n          this.orientedFlatCoordinates_,\r\n          0,\r\n          this.ends_,\r\n          this.stride,\r\n        );\r\n      }\r\n      this.orientedRevision_ = this.getRevision();\r\n    }\r\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\r\n  }\r\n\r\n  /**\r\n   * @param {number} squaredTolerance Squared tolerance.\r\n   * @return {Polygon} Simplified Polygon.\r\n   * @protected\r\n   * @override\r\n   */\r\n  getSimplifiedGeometryInternal(squaredTolerance) {\r\n    /** @type {Array<number>} */\r\n    const simplifiedFlatCoordinates = [];\r\n    /** @type {Array<number>} */\r\n    const simplifiedEnds = [];\r\n    simplifiedFlatCoordinates.length = quantizeArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      Math.sqrt(squaredTolerance),\r\n      simplifiedFlatCoordinates,\r\n      0,\r\n      simplifiedEnds,\r\n    );\r\n    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\r\n  }\r\n\r\n  /**\r\n   * Get the type of this geometry.\r\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\r\n   * @api\r\n   * @override\r\n   */\r\n  getType() {\r\n    return 'Polygon';\r\n  }\r\n\r\n  /**\r\n   * Test if the geometry and the passed extent intersect.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @return {boolean} `true` if the geometry and the extent intersect.\r\n   * @api\r\n   * @override\r\n   */\r\n  intersectsExtent(extent) {\r\n    return intersectsLinearRingArray(\r\n      this.getOrientedFlatCoordinates(),\r\n      0,\r\n      this.ends_,\r\n      this.stride,\r\n      extent,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the coordinates of the polygon.\r\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\r\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\r\n   * @api\r\n   * @override\r\n   */\r\n  setCoordinates(coordinates, layout) {\r\n    this.setLayout(layout, coordinates, 2);\r\n    if (!this.flatCoordinates) {\r\n      this.flatCoordinates = [];\r\n    }\r\n    const ends = deflateCoordinatesArray(\r\n      this.flatCoordinates,\r\n      0,\r\n      coordinates,\r\n      this.stride,\r\n      this.ends_,\r\n    );\r\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\r\n    this.changed();\r\n  }\r\n}\r\n\r\nexport default Polygon;\r\n\r\n/**\r\n * Create an approximation of a circle on the surface of a sphere.\r\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\r\n * @param {number} radius The great-circle distance from the center to\r\n *     the polygon vertices in meters.\r\n * @param {number} [n] Optional number of vertices for the resulting\r\n *     polygon. Default is `32`.\r\n * @param {number} [sphereRadius] Optional radius for the sphere (defaults to\r\n *     the Earth's mean radius using the WGS84 ellipsoid).\r\n * @return {Polygon} The \"circular\" polygon.\r\n * @api\r\n */\r\nexport function circular(center, radius, n, sphereRadius) {\r\n  n = n ? n : 32;\r\n  /** @type {Array<number>} */\r\n  const flatCoordinates = [];\r\n  for (let i = 0; i < n; ++i) {\r\n    extend(\r\n      flatCoordinates,\r\n      sphereOffset(center, radius, (2 * Math.PI * i) / n, sphereRadius),\r\n    );\r\n  }\r\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\r\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\r\n}\r\n\r\n/**\r\n * Create a polygon from an extent. The layout used is `XY`.\r\n * @param {import(\"../extent.js\").Extent} extent The extent.\r\n * @return {Polygon} The polygon.\r\n * @api\r\n */\r\nexport function fromExtent(extent) {\r\n  if (isEmpty(extent)) {\r\n    throw new Error('Cannot create polygon from empty extent');\r\n  }\r\n  const minX = extent[0];\r\n  const minY = extent[1];\r\n  const maxX = extent[2];\r\n  const maxY = extent[3];\r\n  const flatCoordinates = [\r\n    minX,\r\n    minY,\r\n    minX,\r\n    maxY,\r\n    maxX,\r\n    maxY,\r\n    maxX,\r\n    minY,\r\n    minX,\r\n    minY,\r\n  ];\r\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\r\n}\r\n\r\n/**\r\n * Create a regular polygon from a circle.\r\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\r\n * @param {number} [sides] Number of sides of the polygon. Default is 32.\r\n * @param {number} [angle] Start angle for the first vertex of the polygon in\r\n *     counter-clockwise radians. 0 means East. Default is 0.\r\n * @return {Polygon} Polygon geometry.\r\n * @api\r\n */\r\nexport function fromCircle(circle, sides, angle) {\r\n  sides = sides ? sides : 32;\r\n  const stride = circle.getStride();\r\n  const layout = circle.getLayout();\r\n  const center = circle.getCenter();\r\n  const arrayLength = stride * (sides + 1);\r\n  const flatCoordinates = new Array(arrayLength);\r\n  for (let i = 0; i < arrayLength; i += stride) {\r\n    flatCoordinates[i] = 0;\r\n    flatCoordinates[i + 1] = 0;\r\n    for (let j = 2; j < stride; j++) {\r\n      flatCoordinates[i + j] = center[j];\r\n    }\r\n  }\r\n  const ends = [flatCoordinates.length];\r\n  const polygon = new Polygon(flatCoordinates, layout, ends);\r\n  makeRegular(polygon, center, circle.getRadius(), angle);\r\n  return polygon;\r\n}\r\n\r\n/**\r\n * Modify the coordinates of a polygon to make it a regular polygon.\r\n * @param {Polygon} polygon Polygon geometry.\r\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\r\n * @param {number} radius Radius of the regular polygon.\r\n * @param {number} [angle] Start angle for the first vertex of the polygon in\r\n *     counter-clockwise radians. 0 means East. Default is 0.\r\n */\r\nexport function makeRegular(polygon, center, radius, angle) {\r\n  const flatCoordinates = polygon.getFlatCoordinates();\r\n  const stride = polygon.getStride();\r\n  const sides = flatCoordinates.length / stride - 1;\r\n  const startAngle = angle ? angle : 0;\r\n  for (let i = 0; i <= sides; ++i) {\r\n    const offset = i * stride;\r\n    const angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\r\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\r\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\r\n  }\r\n  polygon.changed();\r\n}\r\n","/**\r\n * @module CME2D/View\r\n */\r\nimport BaseObject from './Object.js';\r\nimport ViewHint from './ViewHint.js';\r\nimport ViewProperty from './ViewProperty.js';\r\nimport {DEFAULT_TILE_SIZE} from './tilegrid/common.js';\r\nimport {\r\n  METERS_PER_UNIT,\r\n  createProjection,\r\n  disableCoordinateWarning,\r\n  fromUserCoordinate,\r\n  fromUserExtent,\r\n  getUserProjection,\r\n  toUserCoordinate,\r\n  toUserExtent,\r\n} from './proj.js';\r\nimport {VOID} from './functions.js';\r\nimport {\r\n  add as addCoordinate,\r\n  equals as coordinatesEqual,\r\n  equals,\r\n  rotate as rotateCoordinate,\r\n} from './coordinate.js';\r\nimport {assert} from './asserts.js';\r\nimport {none as centerNone, createExtent} from './centerconstraint.js';\r\nimport {clamp, modulo} from './math.js';\r\nimport {\r\n  createMinMaxResolution,\r\n  createSnapToPower,\r\n  createSnapToResolutions,\r\n} from './resolutionconstraint.js';\r\nimport {\r\n  createSnapToN,\r\n  createSnapToZero,\r\n  disable,\r\n  none as rotationNone,\r\n} from './rotationconstraint.js';\r\nimport {easeOut, inAndOut} from './easing.js';\r\nimport {\r\n  getCenter,\r\n  getForViewAndSize,\r\n  getHeight,\r\n  getWidth,\r\n  isEmpty,\r\n} from './extent.js';\r\nimport {linearFindNearest} from './array.js';\r\nimport {fromExtent as polygonFromExtent} from './geom/Polygon.js';\r\n\r\n/**\r\n * An animation configuration\r\n *\r\n * @typedef {Object} Animation\r\n * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter] Source center.\r\n * @property {import(\"./coordinate.js\").Coordinate} [targetCenter] Target center.\r\n * @property {number} [sourceResolution] Source resolution.\r\n * @property {number} [targetResolution] Target resolution.\r\n * @property {number} [sourceRotation] Source rotation.\r\n * @property {number} [targetRotation] Target rotation.\r\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Anchor.\r\n * @property {number} start Start.\r\n * @property {number} duration Duration.\r\n * @property {boolean} complete Complete.\r\n * @property {function(number):number} easing Easing.\r\n * @property {function(boolean):void} callback Callback.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Constraints\r\n * @property {import(\"./centerconstraint.js\").Type} center Center.\r\n * @property {import(\"./resolutionconstraint.js\").Type} resolution Resolution.\r\n * @property {import(\"./rotationconstraint.js\").Type} rotation Rotation.\r\n */\r\n\r\n/**\r\n * @typedef {Object} FitOptions\r\n * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to\r\n * fit the extent into. Defaults to the size of the map the view is associated with.\r\n * If no map or multiple maps are connected to the view, provide the desired box size\r\n * (e.g. `map.getSize()`).\r\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\r\n * cleared inside the view. Values in the array are top, right, bottom and left\r\n * padding.\r\n * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,\r\n * get the nearest extent instead of the closest that actually fits the view.\r\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\r\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\r\n * `minResolution` is given, this property is ignored.\r\n * @property {number} [duration] The duration of the animation in milliseconds.\r\n * By default, there is no animation to the target extent.\r\n * @property {function(number):number} [easing] The easing function used during\r\n * the animation (defaults to {@link module:ol/easing.inAndOut}).\r\n * The function will be called for each frame with a number representing a\r\n * fraction of the animation's duration.  The function should return a number\r\n * between 0 and 1 representing the progress toward the destination state.\r\n * @property {function(boolean):void} [callback] Function called when the view is in\r\n * its final position. The callback will be called with `true` if the animation\r\n * series completed on its own or `false` if it was cancelled.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ViewOptions\r\n * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\r\n * the view. If a user projection is not set, the coordinate system for the center is\r\n * specified with the `projection` option. Layer sources will not be fetched if this\r\n * is not set, but the center can be set later with {@link #setCenter}.\r\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\r\n * `false` means no constraint. `true` means no constraint, but snap to zero\r\n * near zero. A number constrains the rotation to that number of values. For\r\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\r\n * @property {boolean} [enableRotation=true] Enable rotation.\r\n * If `false`, a rotation constraint that always sets the rotation to zero is\r\n * used. The `constrainRotation` option has no effect if `enableRotation` is\r\n * `false`.\r\n * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\r\n * view, in other words, nothing outside of this extent can be visible on the map.\r\n * @property {boolean} [constrainOnlyCenter=false] If true, the extent\r\n * constraint will only apply to the view center and not the whole extent.\r\n * @property {boolean} [smoothExtentConstraint=true] If true, the extent\r\n * constraint will be applied smoothly, i.e. allow the view to go slightly outside\r\n * of the given `extent`.\r\n * @property {number} [maxResolution] The maximum resolution used to determine\r\n * the resolution constraint. It is used together with `minResolution` (or\r\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\r\n * that the projection's validity extent fits in a 256x256 px tile. If the\r\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\r\n * to `40075016.68557849 / 256 = 156543.03392804097`.\r\n * @property {number} [minResolution] The minimum resolution used to determine\r\n * the resolution constraint.  It is used together with `maxResolution` (or\r\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\r\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\r\n * (the default) then `minResolution` defaults to\r\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\r\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\r\n * resolution constraint. It is used together with `minZoom` (or\r\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\r\n * provided, it is given precedence over `maxZoom`.\r\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\r\n * resolution constraint. It is used together with `maxZoom` (or\r\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\r\n * provided, it is given precedence over `minZoom`.\r\n * @property {boolean} [multiWorld=false] If `false` the view is constrained so\r\n * only one world is visible, and you cannot pan off the edge.  If `true` the map\r\n * may show multiple worlds at low zoom levels.  Only used if the `projection` is\r\n * global.  Note that if `extent` is also provided it is given precedence.\r\n * @property {boolean} [constrainResolution=false] If true, the view will always\r\n * animate to the closest zoom level after an interaction; false means\r\n * intermediary zoom levels are allowed.\r\n * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution\r\n * min/max values will be applied smoothly, i. e. allow the view to exceed slightly\r\n * the given resolution or zoom bounds.\r\n * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to\r\n * show the full configured extent. By default, when a view is configured with an\r\n * extent, users will not be able to zoom out so the viewport exceeds the extent in\r\n * either dimension. This means the full extent may not be visible if the viewport\r\n * is taller or wider than the aspect ratio of the configured extent. If\r\n * showFullExtent is true, the user will be able to zoom out so that the viewport\r\n * exceeds the height or width of the configured extent, but not both, allowing the\r\n * full extent to be shown.\r\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\r\n * projection. The default is Spherical Mercator.\r\n * @property {number} [resolution] The initial resolution for the view. The\r\n * units are `projection` units per pixel (e.g. meters per pixel). An\r\n * alternative to setting this is to set `zoom`. Layer sources will not be\r\n * fetched if neither this nor `zoom` are defined, but they can be set later\r\n * with {@link #setZoom} or {@link #setResolution}.\r\n * @property {Array<number>} [resolutions] Resolutions that determine the\r\n * zoom levels if specified. The index in the array corresponds to the zoom level,\r\n * therefore the resolution values have to be in descending order. It also constrains\r\n * the resolution by the minimum and maximum value. If set the `maxResolution`,\r\n * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\r\n * @property {number} [rotation=0] The initial rotation for the view in radians\r\n * (positive rotation clockwise, 0 means North).\r\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\r\n * level used to calculate the initial resolution for the view.\r\n * @property {number} [zoomFactor=2] The zoom factor used to compute the\r\n * corresponding resolution.\r\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).\r\n * If the map viewport is partially covered with other content (overlays) along\r\n * its edges, this setting allows to shift the center of the viewport away from\r\n * that content. The order of the values is top, right, bottom, left.\r\n */\r\n\r\n/**\r\n * @typedef {Object} AnimationOptions\r\n * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\r\n * the animation.\r\n * @property {number} [zoom] The zoom level of the view at the end of the\r\n * animation. This takes precedence over `resolution`.\r\n * @property {number} [resolution] The resolution of the view at the end\r\n * of the animation.  If `zoom` is also provided, this option will be ignored.\r\n * @property {number} [rotation] The rotation of the view at the end of\r\n * the animation.\r\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remain fixed\r\n * during a rotation or resolution animation.\r\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\r\n * @property {function(number):number} [easing] The easing function used\r\n * during the animation (defaults to {@link module:ol/easing.inAndOut}).\r\n * The function will be called for each frame with a number representing a\r\n * fraction of the animation's duration.  The function should return a number\r\n * between 0 and 1 representing the progress toward the destination state.\r\n */\r\n\r\n/**\r\n * @typedef {Object} State\r\n * @property {import(\"./coordinate.js\").Coordinate} center Center (in view projection coordinates).\r\n * @property {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @property {number} resolution Resolution.\r\n * @property {import(\"./coordinate.js\").Coordinate} [nextCenter] The next center during an animation series.\r\n * @property {number} [nextResolution] The next resolution during an animation series.\r\n * @property {number} [nextRotation] The next rotation during an animation series.\r\n * @property {number} rotation Rotation.\r\n * @property {number} zoom Zoom.\r\n */\r\n\r\n/**\r\n * Like {@link import(\"./Map.js\").FrameState}, but just `viewState` and `extent`.\r\n * @typedef {Object} ViewStateLayerStateExtent\r\n * @property {State} viewState View state.\r\n * @property {import(\"./extent.js\").Extent} extent Extent (in user projection coordinates).\r\n * @property {Array<import(\"./layer/Layer.js\").State>} [layerStatesArray] Layer states.\r\n */\r\n\r\n/**\r\n * Default min zoom level for the map view.\r\n * @type {number}\r\n */\r\nconst DEFAULT_MIN_ZOOM = 0;\r\n\r\n/**\r\n * @typedef {import(\"./ObjectEventType\").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\r\n *   import(\"./Observable\").OnSignature<ViewObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\r\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A View object represents a simple 2D view of the map.\r\n *\r\n * This is the object to act upon to change the center, resolution,\r\n * and rotation of the map.\r\n *\r\n * A View has a `projection`. The projection determines the\r\n * coordinate system of the center, and its units determine the units of the\r\n * resolution (projection units per pixel). The default projection is\r\n * Web Mercator (EPSG:3857).\r\n *\r\n * ### The view states\r\n *\r\n * A View is determined by three states: `center`, `resolution`,\r\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\r\n * `getCenter` and `setCenter` for the `center` state.\r\n *\r\n * The `zoom` state is actually not saved on the view: all computations\r\n * internally use the `resolution` state. Still, the `setZoom` and `getZoom`\r\n * methods are available, as well as `getResolutionForZoom` and\r\n * `getZoomForResolution` to switch from one system to the other.\r\n *\r\n * ### The constraints\r\n *\r\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\r\n * states of the view, but any constraint defined in the constructor will\r\n * be applied along the way.\r\n *\r\n * A View object can have a *resolution constraint*, a *rotation constraint*\r\n * and a *center constraint*.\r\n *\r\n * The *resolution constraint* typically restricts min/max values and\r\n * snaps to specific resolutions. It is determined by the following\r\n * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.\r\n * If `resolutions` is set, the other three options are ignored. See\r\n * documentation for each option for more information. By default, the view\r\n * only has a min/max restriction and allow intermediary zoom levels when\r\n * pinch-zooming for example.\r\n *\r\n * The *rotation constraint* snaps to specific angles. It is determined\r\n * by the following options: `enableRotation` and `constrainRotation`.\r\n * By default rotation is allowed and its value is snapped to zero when approaching the\r\n * horizontal.\r\n *\r\n * The *center constraint* is determined by the `extent` option. By\r\n * default the view center is not constrained at all.\r\n *\r\n * ### Changing the view state\r\n *\r\n * It is important to note that `setZoom`, `setResolution`, `setCenter` and\r\n * `setRotation` are subject to the above mentioned constraints. As such, it\r\n * may sometimes not be possible to know in advance the resulting state of the\r\n * View. For example, calling `setResolution(10)` does not guarantee that\r\n * `getResolution()` will return `10`.\r\n *\r\n * A consequence of this is that, when applying a delta on the view state, one\r\n * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`\r\n * rather than the corresponding setters. This will let view do its internal\r\n * computations. Besides, the `adjust*` methods also take an `anchor`\r\n * argument which allows specifying an origin for the transformation.\r\n *\r\n * ### Interacting with the view\r\n *\r\n * View constraints are usually only applied when the view is *at rest*, meaning that\r\n * no interaction or animation is ongoing. As such, if the user puts the view in a\r\n * state that is not equivalent to a constrained one (e.g. rotating the view when\r\n * the snap angle is 0), an animation will be triggered at the interaction end to\r\n * put back the view to a stable state;\r\n *\r\n * @api\r\n */\r\nclass View extends BaseObject {\r\n  /**\r\n   * @param {ViewOptions} [options] View options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /***\r\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {ViewOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    options = Object.assign({}, options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.hints_ = [0, 0];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<Array<Animation>>}\r\n     */\r\n    this.animations_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.updateAnimationKey_;\r\n\r\n    /**\r\n     * @private\r\n     * @const\r\n     * @type {import(\"./proj/Projection.js\").default}\r\n     */\r\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./size.js\").Size}\r\n     */\r\n    this.viewportSize_ = [100, 100];\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\r\n     */\r\n    this.targetCenter_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.targetResolution_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.targetRotation_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./coordinate.js\").Coordinate}\r\n     */\r\n    this.nextCenter_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.nextResolution_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.nextRotation_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\r\n     */\r\n    this.cancelAnchor_ = undefined;\r\n\r\n    if (options.projection) {\r\n      disableCoordinateWarning();\r\n    }\r\n    if (options.center) {\r\n      options.center = fromUserCoordinate(options.center, this.projection_);\r\n    }\r\n    if (options.extent) {\r\n      options.extent = fromUserExtent(options.extent, this.projection_);\r\n    }\r\n\r\n    this.applyOptions_(options);\r\n  }\r\n\r\n  /**\r\n   * Set up the view with the given options.\r\n   * @param {ViewOptions} options View options.\r\n   */\r\n  applyOptions_(options) {\r\n    const properties = Object.assign({}, options);\r\n    for (const key in ViewProperty) {\r\n      delete properties[key];\r\n    }\r\n    this.setProperties(properties, true);\r\n\r\n    const resolutionConstraintInfo = createResolutionConstraint(options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>|undefined}\r\n     */\r\n    this.resolutions_ = options.resolutions;\r\n\r\n    /**\r\n     * @type {Array<number>|undefined}\r\n     * @private\r\n     */\r\n    this.padding_ = options.padding;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\r\n\r\n    const centerConstraint = createCenterConstraint(options);\r\n    const resolutionConstraint = resolutionConstraintInfo.constraint;\r\n    const rotationConstraint = createRotationConstraint(options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {Constraints}\r\n     */\r\n    this.constraints_ = {\r\n      center: centerConstraint,\r\n      resolution: resolutionConstraint,\r\n      rotation: rotationConstraint,\r\n    };\r\n\r\n    this.setRotation(options.rotation !== undefined ? options.rotation : 0);\r\n    this.setCenterInternal(\r\n      options.center !== undefined ? options.center : null,\r\n    );\r\n    if (options.resolution !== undefined) {\r\n      this.setResolution(options.resolution);\r\n    } else if (options.zoom !== undefined) {\r\n      this.setZoom(options.zoom);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Padding (in css pixels).\r\n   * If the map viewport is partially covered with other content (overlays) along\r\n   * its edges, this setting allows to shift the center of the viewport away from that\r\n   * content. The order of the values in the array is top, right, bottom, left.\r\n   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.\r\n   * @type {Array<number>|undefined}\r\n   * @api\r\n   */\r\n  get padding() {\r\n    return this.padding_;\r\n  }\r\n  set padding(padding) {\r\n    let oldPadding = this.padding_;\r\n    this.padding_ = padding;\r\n    const center = this.getCenterInternal();\r\n    if (center) {\r\n      const newPadding = padding || [0, 0, 0, 0];\r\n      oldPadding = oldPadding || [0, 0, 0, 0];\r\n      const resolution = this.getResolution();\r\n      const offsetX =\r\n        (resolution / 2) *\r\n        (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\r\n      const offsetY =\r\n        (resolution / 2) *\r\n        (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\r\n      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get an updated version of the view options used to construct the view.  The\r\n   * current resolution (or zoom), center, and rotation are applied to any stored\r\n   * options.  The provided options can be used to apply new min/max zoom or\r\n   * resolution limits.\r\n   * @param {ViewOptions} newOptions New options to be applied.\r\n   * @return {ViewOptions} New options updated with the current view state.\r\n   */\r\n  getUpdatedOptions_(newOptions) {\r\n    const options = this.getProperties();\r\n\r\n    // preserve resolution (or zoom)\r\n    if (options.resolution !== undefined) {\r\n      options.resolution = this.getResolution();\r\n    } else {\r\n      options.zoom = this.getZoom();\r\n    }\r\n\r\n    // preserve center\r\n    options.center = this.getCenterInternal();\r\n\r\n    // preserve rotation\r\n    options.rotation = this.getRotation();\r\n\r\n    return Object.assign({}, options, newOptions);\r\n  }\r\n\r\n  /**\r\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\r\n   * can be animated for smooth transitions between view states.  For example,\r\n   * to animate the view to a new zoom level:\r\n   *\r\n   *     view.animate({zoom: view.getZoom() + 1});\r\n   *\r\n   * By default, the animation lasts one second and uses in-and-out easing.  You\r\n   * can customize this behavior by including `duration` (in milliseconds) and\r\n   * `easing` options (see {@link module:ol/easing}).\r\n   *\r\n   * To chain together multiple animations, call the method with multiple\r\n   * animation objects.  For example, to first zoom and then pan:\r\n   *\r\n   *     view.animate({zoom: 10}, {center: [0, 0]});\r\n   *\r\n   * If you provide a function as the last argument to the animate method, it\r\n   * will get called at the end of an animation series.  The callback will be\r\n   * called with `true` if the animation series completed on its own or `false`\r\n   * if it was cancelled.\r\n   *\r\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\r\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\r\n   * (or another method that calls one of these).\r\n   *\r\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation\r\n   *     options.  Multiple animations can be run in series by passing multiple\r\n   *     options objects.  To run multiple animations in parallel, call the method\r\n   *     multiple times.  An optional callback can be provided as a final\r\n   *     argument.  The callback will be called with a boolean indicating whether\r\n   *     the animation completed without being cancelled.\r\n   * @api\r\n   */\r\n  animate(var_args) {\r\n    if (this.isDef() && !this.getAnimating()) {\r\n      this.resolveConstraints(0);\r\n    }\r\n    const args = new Array(arguments.length);\r\n    for (let i = 0; i < args.length; ++i) {\r\n      let options = arguments[i];\r\n      if (options.center) {\r\n        options = Object.assign({}, options);\r\n        options.center = fromUserCoordinate(\r\n          options.center,\r\n          this.getProjection(),\r\n        );\r\n      }\r\n      if (options.anchor) {\r\n        options = Object.assign({}, options);\r\n        options.anchor = fromUserCoordinate(\r\n          options.anchor,\r\n          this.getProjection(),\r\n        );\r\n      }\r\n      args[i] = options;\r\n    }\r\n    this.animateInternal.apply(this, args);\r\n  }\r\n\r\n  /**\r\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.\r\n   */\r\n  animateInternal(var_args) {\r\n    let animationCount = arguments.length;\r\n    let callback;\r\n    if (\r\n      animationCount > 1 &&\r\n      typeof arguments[animationCount - 1] === 'function'\r\n    ) {\r\n      callback = arguments[animationCount - 1];\r\n      --animationCount;\r\n    }\r\n\r\n    let i = 0;\r\n    for (; i < animationCount && !this.isDef(); ++i) {\r\n      // if view properties are not yet set, shortcut to the final state\r\n      const state = arguments[i];\r\n      if (state.center) {\r\n        this.setCenterInternal(state.center);\r\n      }\r\n      if (state.zoom !== undefined) {\r\n        this.setZoom(state.zoom);\r\n      } else if (state.resolution) {\r\n        this.setResolution(state.resolution);\r\n      }\r\n      if (state.rotation !== undefined) {\r\n        this.setRotation(state.rotation);\r\n      }\r\n    }\r\n    if (i === animationCount) {\r\n      if (callback) {\r\n        animationCallback(callback, true);\r\n      }\r\n      return;\r\n    }\r\n\r\n    let start = Date.now();\r\n    let center = this.targetCenter_.slice();\r\n    let resolution = this.targetResolution_;\r\n    let rotation = this.targetRotation_;\r\n    const series = [];\r\n    for (; i < animationCount; ++i) {\r\n      const options = /** @type {AnimationOptions} */ (arguments[i]);\r\n\r\n      const animation = {\r\n        start: start,\r\n        complete: false,\r\n        anchor: options.anchor,\r\n        duration: options.duration !== undefined ? options.duration : 1000,\r\n        easing: options.easing || inAndOut,\r\n        callback: callback,\r\n      };\r\n\r\n      if (options.center) {\r\n        animation.sourceCenter = center;\r\n        animation.targetCenter = options.center.slice();\r\n        center = animation.targetCenter;\r\n      }\r\n\r\n      if (options.zoom !== undefined) {\r\n        animation.sourceResolution = resolution;\r\n        animation.targetResolution = this.getResolutionForZoom(options.zoom);\r\n        resolution = animation.targetResolution;\r\n      } else if (options.resolution) {\r\n        animation.sourceResolution = resolution;\r\n        animation.targetResolution = options.resolution;\r\n        resolution = animation.targetResolution;\r\n      }\r\n\r\n      if (options.rotation !== undefined) {\r\n        animation.sourceRotation = rotation;\r\n        const delta =\r\n          modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\r\n        animation.targetRotation = rotation + delta;\r\n        rotation = animation.targetRotation;\r\n      }\r\n\r\n      // check if animation is a no-op\r\n      if (isNoopAnimation(animation)) {\r\n        animation.complete = true;\r\n        // we still push it onto the series for callback handling\r\n      } else {\r\n        start += animation.duration;\r\n      }\r\n      series.push(animation);\r\n    }\r\n    this.animations_.push(series);\r\n    this.setHint(ViewHint.ANIMATING, 1);\r\n    this.updateAnimations_();\r\n  }\r\n\r\n  /**\r\n   * Determine if the view is being animated.\r\n   * @return {boolean} The view is being animated.\r\n   * @api\r\n   */\r\n  getAnimating() {\r\n    return this.hints_[ViewHint.ANIMATING] > 0;\r\n  }\r\n\r\n  /**\r\n   * Determine if the user is interacting with the view, such as panning or zooming.\r\n   * @return {boolean} The view is being interacted with.\r\n   * @api\r\n   */\r\n  getInteracting() {\r\n    return this.hints_[ViewHint.INTERACTING] > 0;\r\n  }\r\n\r\n  /**\r\n   * Cancel any ongoing animations.\r\n   * @api\r\n   */\r\n  cancelAnimations() {\r\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\r\n    let anchor;\r\n    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {\r\n      const series = this.animations_[i];\r\n      if (series[0].callback) {\r\n        animationCallback(series[0].callback, false);\r\n      }\r\n      if (!anchor) {\r\n        for (let j = 0, jj = series.length; j < jj; ++j) {\r\n          const animation = series[j];\r\n          if (!animation.complete) {\r\n            anchor = animation.anchor;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.animations_.length = 0;\r\n    this.cancelAnchor_ = anchor;\r\n    this.nextCenter_ = null;\r\n    this.nextResolution_ = NaN;\r\n    this.nextRotation_ = NaN;\r\n  }\r\n\r\n  /**\r\n   * Update all animations.\r\n   */\r\n  updateAnimations_() {\r\n    if (this.updateAnimationKey_ !== undefined) {\r\n      cancelAnimationFrame(this.updateAnimationKey_);\r\n      this.updateAnimationKey_ = undefined;\r\n    }\r\n    if (!this.getAnimating()) {\r\n      return;\r\n    }\r\n    const now = Date.now();\r\n    let more = false;\r\n    for (let i = this.animations_.length - 1; i >= 0; --i) {\r\n      const series = this.animations_[i];\r\n      let seriesComplete = true;\r\n      for (let j = 0, jj = series.length; j < jj; ++j) {\r\n        const animation = series[j];\r\n        if (animation.complete) {\r\n          continue;\r\n        }\r\n        const elapsed = now - animation.start;\r\n        let fraction =\r\n          animation.duration > 0 ? elapsed / animation.duration : 1;\r\n        if (fraction >= 1) {\r\n          animation.complete = true;\r\n          fraction = 1;\r\n        } else {\r\n          seriesComplete = false;\r\n        }\r\n        const progress = animation.easing(fraction);\r\n        if (animation.sourceCenter) {\r\n          const x0 = animation.sourceCenter[0];\r\n          const y0 = animation.sourceCenter[1];\r\n          const x1 = animation.targetCenter[0];\r\n          const y1 = animation.targetCenter[1];\r\n          this.nextCenter_ = animation.targetCenter;\r\n          const x = x0 + progress * (x1 - x0);\r\n          const y = y0 + progress * (y1 - y0);\r\n          this.targetCenter_ = [x, y];\r\n        }\r\n        if (animation.sourceResolution && animation.targetResolution) {\r\n          const resolution =\r\n            progress === 1\r\n              ? animation.targetResolution\r\n              : animation.sourceResolution +\r\n                progress *\r\n                  (animation.targetResolution - animation.sourceResolution);\r\n          if (animation.anchor) {\r\n            const size = this.getViewportSize_(this.getRotation());\r\n            const constrainedResolution = this.constraints_.resolution(\r\n              resolution,\r\n              0,\r\n              size,\r\n              true,\r\n            );\r\n            this.targetCenter_ = this.calculateCenterZoom(\r\n              constrainedResolution,\r\n              animation.anchor,\r\n            );\r\n          }\r\n          this.nextResolution_ = animation.targetResolution;\r\n          this.targetResolution_ = resolution;\r\n          this.applyTargetState_(true);\r\n        }\r\n        if (\r\n          animation.sourceRotation !== undefined &&\r\n          animation.targetRotation !== undefined\r\n        ) {\r\n          const rotation =\r\n            progress === 1\r\n              ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -\r\n                Math.PI\r\n              : animation.sourceRotation +\r\n                progress *\r\n                  (animation.targetRotation - animation.sourceRotation);\r\n          if (animation.anchor) {\r\n            const constrainedRotation = this.constraints_.rotation(\r\n              rotation,\r\n              true,\r\n            );\r\n            this.targetCenter_ = this.calculateCenterRotate(\r\n              constrainedRotation,\r\n              animation.anchor,\r\n            );\r\n          }\r\n          this.nextRotation_ = animation.targetRotation;\r\n          this.targetRotation_ = rotation;\r\n        }\r\n        this.applyTargetState_(true);\r\n        more = true;\r\n        if (!animation.complete) {\r\n          break;\r\n        }\r\n      }\r\n      if (seriesComplete) {\r\n        this.animations_[i] = null;\r\n        this.setHint(ViewHint.ANIMATING, -1);\r\n        this.nextCenter_ = null;\r\n        this.nextResolution_ = NaN;\r\n        this.nextRotation_ = NaN;\r\n        const callback = series[0].callback;\r\n        if (callback) {\r\n          animationCallback(callback, true);\r\n        }\r\n      }\r\n    }\r\n    // prune completed series\r\n    this.animations_ = this.animations_.filter(Boolean);\r\n    if (more && this.updateAnimationKey_ === undefined) {\r\n      this.updateAnimationKey_ = requestAnimationFrame(\r\n        this.updateAnimations_.bind(this),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} rotation Target rotation.\r\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\r\n   */\r\n  calculateCenterRotate(rotation, anchor) {\r\n    let center;\r\n    const currentCenter = this.getCenterInternal();\r\n    if (currentCenter !== undefined) {\r\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\r\n      rotateCoordinate(center, rotation - this.getRotation());\r\n      addCoordinate(center, anchor);\r\n    }\r\n    return center;\r\n  }\r\n\r\n  /**\r\n   * @param {number} resolution Target resolution.\r\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\r\n   */\r\n  calculateCenterZoom(resolution, anchor) {\r\n    let center;\r\n    const currentCenter = this.getCenterInternal();\r\n    const currentResolution = this.getResolution();\r\n    if (currentCenter !== undefined && currentResolution !== undefined) {\r\n      const x =\r\n        anchor[0] -\r\n        (resolution * (anchor[0] - currentCenter[0])) / currentResolution;\r\n      const y =\r\n        anchor[1] -\r\n        (resolution * (anchor[1] - currentCenter[1])) / currentResolution;\r\n      center = [x, y];\r\n    }\r\n    return center;\r\n  }\r\n\r\n  /**\r\n   * Returns the current viewport size.\r\n   * @private\r\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\r\n   * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\r\n   */\r\n  getViewportSize_(rotation) {\r\n    const size = this.viewportSize_;\r\n    if (rotation) {\r\n      const w = size[0];\r\n      const h = size[1];\r\n      return [\r\n        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),\r\n        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation)),\r\n      ];\r\n    }\r\n    return size;\r\n  }\r\n\r\n  /**\r\n   * Stores the viewport size on the view. The viewport size is not read every time from the DOM\r\n   * to avoid performance hit and layout reflow.\r\n   * This should be done on map size change.\r\n   * Note: the constraints are not resolved during an animation to avoid stopping it\r\n   * @param {import(\"./size.js\").Size} [size] Viewport size; if undefined, [100, 100] is assumed\r\n   */\r\n  setViewportSize(size) {\r\n    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];\r\n    if (!this.getAnimating()) {\r\n      this.resolveConstraints(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the view center.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getCenter() {\r\n    const center = this.getCenterInternal();\r\n    if (!center) {\r\n      return center;\r\n    }\r\n    return toUserCoordinate(center, this.getProjection());\r\n  }\r\n\r\n  /**\r\n   * Get the view center without transforming to user projection.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\r\n   */\r\n  getCenterInternal() {\r\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\r\n      this.get(ViewProperty.CENTER)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {Constraints} Constraints.\r\n   */\r\n  getConstraints() {\r\n    return this.constraints_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Resolution constraint is set\r\n   */\r\n  getConstrainResolution() {\r\n    return this.get('constrainResolution');\r\n  }\r\n\r\n  /**\r\n   * @param {Array<number>} [hints] Destination array.\r\n   * @return {Array<number>} Hint.\r\n   */\r\n  getHints(hints) {\r\n    if (hints !== undefined) {\r\n      hints[0] = this.hints_[0];\r\n      hints[1] = this.hints_[1];\r\n      return hints;\r\n    }\r\n    return this.hints_.slice();\r\n  }\r\n\r\n  /**\r\n   * Calculate the extent for the current view state and the passed box size.\r\n   * @param {import(\"./size.js\").Size} [size] The pixel dimensions of the box\r\n   * into which the calculated extent should fit. Defaults to the size of the\r\n   * map the view is associated with.\r\n   * If no map or multiple maps are connected to the view, provide the desired\r\n   * box size (e.g. `map.getSize()`).\r\n   * @return {import(\"./extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  calculateExtent(size) {\r\n    const extent = this.calculateExtentInternal(size);\r\n    return toUserExtent(extent, this.getProjection());\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided,\r\n   * the map's last known viewport size will be used.\r\n   * @return {import(\"./extent.js\").Extent} Extent.\r\n   */\r\n  calculateExtentInternal(size) {\r\n    size = size || this.getViewportSizeMinusPadding_();\r\n    const center = /** @type {!import(\"./coordinate.js\").Coordinate} */ (\r\n      this.getCenterInternal()\r\n    );\r\n    assert(center, 'The view center is not defined');\r\n    const resolution = /** @type {!number} */ (this.getResolution());\r\n    assert(resolution !== undefined, 'The view resolution is not defined');\r\n    const rotation = /** @type {!number} */ (this.getRotation());\r\n    assert(rotation !== undefined, 'The view rotation is not defined');\r\n\r\n    return getForViewAndSize(center, resolution, rotation, size);\r\n  }\r\n\r\n  /**\r\n   * Get the maximum resolution of the view.\r\n   * @return {number} The maximum resolution of the view.\r\n   * @api\r\n   */\r\n  getMaxResolution() {\r\n    return this.maxResolution_;\r\n  }\r\n\r\n  /**\r\n   * Get the minimum resolution of the view.\r\n   * @return {number} The minimum resolution of the view.\r\n   * @api\r\n   */\r\n  getMinResolution() {\r\n    return this.minResolution_;\r\n  }\r\n\r\n  /**\r\n   * Get the maximum zoom level for the view.\r\n   * @return {number} The maximum zoom level.\r\n   * @api\r\n   */\r\n  getMaxZoom() {\r\n    return /** @type {number} */ (\r\n      this.getZoomForResolution(this.minResolution_)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set a new maximum zoom level for the view.\r\n   * @param {number} zoom The maximum zoom level.\r\n   * @api\r\n   */\r\n  setMaxZoom(zoom) {\r\n    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\r\n  }\r\n\r\n  /**\r\n   * Get the minimum zoom level for the view.\r\n   * @return {number} The minimum zoom level.\r\n   * @api\r\n   */\r\n  getMinZoom() {\r\n    return /** @type {number} */ (\r\n      this.getZoomForResolution(this.maxResolution_)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set a new minimum zoom level for the view.\r\n   * @param {number} zoom The minimum zoom level.\r\n   * @api\r\n   */\r\n  setMinZoom(zoom) {\r\n    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\r\n  }\r\n\r\n  /**\r\n   * Set whether the view should allow intermediary zoom levels.\r\n   * @param {boolean} enabled Whether the resolution is constrained.\r\n   * @api\r\n   */\r\n  setConstrainResolution(enabled) {\r\n    this.applyOptions_(this.getUpdatedOptions_({constrainResolution: enabled}));\r\n  }\r\n\r\n  /**\r\n   * Get the view projection.\r\n   * @return {import(\"./proj/Projection.js\").default} The projection of the view.\r\n   * @api\r\n   */\r\n  getProjection() {\r\n    return this.projection_;\r\n  }\r\n\r\n  /**\r\n   * Get the view resolution.\r\n   * @return {number|undefined} The resolution of the view.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getResolution() {\r\n    return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\r\n  }\r\n\r\n  /**\r\n   * Get the resolutions for the view. This returns the array of resolutions\r\n   * passed to the constructor of the View, or undefined if none were given.\r\n   * @return {Array<number>|undefined} The resolutions of the view.\r\n   * @api\r\n   */\r\n  getResolutions() {\r\n    return this.resolutions_;\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\r\n   * @return {number} The resolution at which the provided extent will render at\r\n   *     the given size.\r\n   * @api\r\n   */\r\n  getResolutionForExtent(extent, size) {\r\n    return this.getResolutionForExtentInternal(\r\n      fromUserExtent(extent, this.getProjection()),\r\n      size,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\r\n   * @return {number} The resolution at which the provided extent will render at\r\n   *     the given size.\r\n   */\r\n  getResolutionForExtentInternal(extent, size) {\r\n    size = size || this.getViewportSizeMinusPadding_();\r\n    const xResolution = getWidth(extent) / size[0];\r\n    const yResolution = getHeight(extent) / size[1];\r\n    return Math.max(xResolution, yResolution);\r\n  }\r\n\r\n  /**\r\n   * Return a function that returns a value between 0 and 1 for a\r\n   * resolution. Exponential scaling is assumed.\r\n   * @param {number} [power] Power.\r\n   * @return {function(number): number} Resolution for value function.\r\n   */\r\n  getResolutionForValueFunction(power) {\r\n    power = power || 2;\r\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\r\n    const minResolution = this.minResolution_;\r\n    const max = Math.log(maxResolution / minResolution) / Math.log(power);\r\n    return (\r\n      /**\r\n       * @param {number} value Value.\r\n       * @return {number} Resolution.\r\n       */\r\n      function (value) {\r\n        const resolution = maxResolution / Math.pow(power, value * max);\r\n        return resolution;\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the view rotation.\r\n   * @return {number} The rotation of the view in radians.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getRotation() {\r\n    return /** @type {number} */ (this.get(ViewProperty.ROTATION));\r\n  }\r\n\r\n  /**\r\n   * Return a function that returns a resolution for a value between\r\n   * 0 and 1. Exponential scaling is assumed.\r\n   * @param {number} [power] Power.\r\n   * @return {function(number): number} Value for resolution function.\r\n   */\r\n  getValueForResolutionFunction(power) {\r\n    const logPower = Math.log(power || 2);\r\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\r\n    const minResolution = this.minResolution_;\r\n    const max = Math.log(maxResolution / minResolution) / logPower;\r\n    return (\r\n      /**\r\n       * @param {number} resolution Resolution.\r\n       * @return {number} Value.\r\n       */\r\n      function (resolution) {\r\n        const value = Math.log(maxResolution / resolution) / logPower / max;\r\n        return value;\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the size of the viewport minus padding.\r\n   * @private\r\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\r\n   * @return {import(\"./size.js\").Size} Viewport size reduced by the padding.\r\n   */\r\n  getViewportSizeMinusPadding_(rotation) {\r\n    let size = this.getViewportSize_(rotation);\r\n    const padding = this.padding_;\r\n    if (padding) {\r\n      size = [\r\n        size[0] - padding[1] - padding[3],\r\n        size[1] - padding[0] - padding[2],\r\n      ];\r\n    }\r\n    return size;\r\n  }\r\n\r\n  /**\r\n   * @return {State} View state.\r\n   */\r\n  getState() {\r\n    const projection = this.getProjection();\r\n    const resolution = this.getResolution();\r\n    const rotation = this.getRotation();\r\n    let center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\r\n      this.getCenterInternal()\r\n    );\r\n    const padding = this.padding_;\r\n    if (padding) {\r\n      const reducedSize = this.getViewportSizeMinusPadding_();\r\n      center = calculateCenterOn(\r\n        center,\r\n        this.getViewportSize_(),\r\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\r\n        resolution,\r\n        rotation,\r\n      );\r\n    }\r\n    return {\r\n      center: center.slice(0),\r\n      projection: projection !== undefined ? projection : null,\r\n      resolution: resolution,\r\n      nextCenter: this.nextCenter_,\r\n      nextResolution: this.nextResolution_,\r\n      nextRotation: this.nextRotation_,\r\n      rotation: rotation,\r\n      zoom: this.getZoom(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.\r\n   */\r\n  getViewStateAndExtent() {\r\n    return {\r\n      viewState: this.getState(),\r\n      extent: this.calculateExtent(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get the current zoom level. This method may return non-integer zoom levels\r\n   * if the view does not constrain the resolution, or if an interaction or\r\n   * animation is underway.\r\n   * @return {number|undefined} Zoom.\r\n   * @api\r\n   */\r\n  getZoom() {\r\n    let zoom;\r\n    const resolution = this.getResolution();\r\n    if (resolution !== undefined) {\r\n      zoom = this.getZoomForResolution(resolution);\r\n    }\r\n    return zoom;\r\n  }\r\n\r\n  /**\r\n   * Get the zoom level for a resolution.\r\n   * @param {number} resolution The resolution.\r\n   * @return {number|undefined} The zoom level for the provided resolution.\r\n   * @api\r\n   */\r\n  getZoomForResolution(resolution) {\r\n    let offset = this.minZoom_ || 0;\r\n    let max, zoomFactor;\r\n    if (this.resolutions_) {\r\n      const nearest = linearFindNearest(this.resolutions_, resolution, 1);\r\n      offset = nearest;\r\n      max = this.resolutions_[nearest];\r\n      if (nearest == this.resolutions_.length - 1) {\r\n        zoomFactor = 2;\r\n      } else {\r\n        zoomFactor = max / this.resolutions_[nearest + 1];\r\n      }\r\n    } else {\r\n      max = this.maxResolution_;\r\n      zoomFactor = this.zoomFactor_;\r\n    }\r\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\r\n  }\r\n\r\n  /**\r\n   * Get the resolution for a zoom level.\r\n   * @param {number} zoom Zoom level.\r\n   * @return {number} The view resolution for the provided zoom level.\r\n   * @api\r\n   */\r\n  getResolutionForZoom(zoom) {\r\n    if (this.resolutions_) {\r\n      if (this.resolutions_.length <= 1) {\r\n        return 0;\r\n      }\r\n      const baseLevel = clamp(\r\n        Math.floor(zoom),\r\n        0,\r\n        this.resolutions_.length - 2,\r\n      );\r\n      const zoomFactor =\r\n        this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\r\n      return (\r\n        this.resolutions_[baseLevel] /\r\n        Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1))\r\n      );\r\n    }\r\n    return (\r\n      this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Fit the given geometry or extent based on the given map size and border.\r\n   * The size is pixel dimensions of the box to fit the extent into.\r\n   * In most cases you will want to use the map size, that is `map.getSize()`.\r\n   * Takes care of the map angle.\r\n   * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\r\n   *     extent to fit the view to.\r\n   * @param {FitOptions} [options] Options.\r\n   * @api\r\n   */\r\n  fit(geometryOrExtent, options) {\r\n    /** @type {import(\"./geom/SimpleGeometry.js\").default} */\r\n    let geometry;\r\n    assert(\r\n      Array.isArray(geometryOrExtent) ||\r\n        typeof (/** @type {?} */ (geometryOrExtent).getSimplifiedGeometry) ===\r\n          'function',\r\n      'Invalid extent or geometry provided as `geometry`',\r\n    );\r\n    if (Array.isArray(geometryOrExtent)) {\r\n      assert(\r\n        !isEmpty(geometryOrExtent),\r\n        'Cannot fit empty extent provided as `geometry`',\r\n      );\r\n      const extent = fromUserExtent(geometryOrExtent, this.getProjection());\r\n      geometry = polygonFromExtent(extent);\r\n    } else if (geometryOrExtent.getType() === 'Circle') {\r\n      const extent = fromUserExtent(\r\n        geometryOrExtent.getExtent(),\r\n        this.getProjection(),\r\n      );\r\n      geometry = polygonFromExtent(extent);\r\n      geometry.rotate(this.getRotation(), getCenter(extent));\r\n    } else {\r\n      const userProjection = getUserProjection();\r\n      if (userProjection) {\r\n        geometry = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n          geometryOrExtent\r\n            .clone()\r\n            .transform(userProjection, this.getProjection())\r\n        );\r\n      } else {\r\n        geometry = geometryOrExtent;\r\n      }\r\n    }\r\n\r\n    this.fitInternal(geometry, options);\r\n  }\r\n\r\n  /**\r\n   * Calculate rotated extent\r\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\r\n   * @return {import(\"./extent\").Extent} The rotated extent for the geometry.\r\n   */\r\n  rotatedExtentForGeometry(geometry) {\r\n    const rotation = this.getRotation();\r\n    const cosAngle = Math.cos(rotation);\r\n    const sinAngle = Math.sin(-rotation);\r\n    const coords = geometry.getFlatCoordinates();\r\n    const stride = geometry.getStride();\r\n    let minRotX = +Infinity;\r\n    let minRotY = +Infinity;\r\n    let maxRotX = -Infinity;\r\n    let maxRotY = -Infinity;\r\n    for (let i = 0, ii = coords.length; i < ii; i += stride) {\r\n      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\r\n      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\r\n      minRotX = Math.min(minRotX, rotX);\r\n      minRotY = Math.min(minRotY, rotY);\r\n      maxRotX = Math.max(maxRotX, rotX);\r\n      maxRotY = Math.max(maxRotY, rotY);\r\n    }\r\n    return [minRotX, minRotY, maxRotX, maxRotY];\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\r\n   * @param {FitOptions} [options] Options.\r\n   */\r\n  fitInternal(geometry, options) {\r\n    options = options || {};\r\n    let size = options.size;\r\n    if (!size) {\r\n      size = this.getViewportSizeMinusPadding_();\r\n    }\r\n    const padding =\r\n      options.padding !== undefined ? options.padding : [0, 0, 0, 0];\r\n    const nearest = options.nearest !== undefined ? options.nearest : false;\r\n    let minResolution;\r\n    if (options.minResolution !== undefined) {\r\n      minResolution = options.minResolution;\r\n    } else if (options.maxZoom !== undefined) {\r\n      minResolution = this.getResolutionForZoom(options.maxZoom);\r\n    } else {\r\n      minResolution = 0;\r\n    }\r\n\r\n    const rotatedExtent = this.rotatedExtentForGeometry(geometry);\r\n\r\n    // calculate resolution\r\n    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [\r\n      size[0] - padding[1] - padding[3],\r\n      size[1] - padding[0] - padding[2],\r\n    ]);\r\n    resolution = isNaN(resolution)\r\n      ? minResolution\r\n      : Math.max(resolution, minResolution);\r\n    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);\r\n\r\n    // calculate center\r\n    const rotation = this.getRotation();\r\n    const sinAngle = Math.sin(rotation);\r\n    const cosAngle = Math.cos(rotation);\r\n    const centerRot = getCenter(rotatedExtent);\r\n    centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;\r\n    centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;\r\n    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\r\n    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\r\n    const center = this.getConstrainedCenter([centerX, centerY], resolution);\r\n    const callback = options.callback ? options.callback : VOID;\r\n\r\n    if (options.duration !== undefined) {\r\n      this.animateInternal(\r\n        {\r\n          resolution: resolution,\r\n          center: center,\r\n          duration: options.duration,\r\n          easing: options.easing,\r\n        },\r\n        callback,\r\n      );\r\n    } else {\r\n      this.targetResolution_ = resolution;\r\n      this.targetCenter_ = center;\r\n      this.applyTargetState_(false, true);\r\n      animationCallback(callback, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Center on coordinate and view position.\r\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"./size.js\").Size} size Box pixel size.\r\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\r\n   * @api\r\n   */\r\n  centerOn(coordinate, size, position) {\r\n    this.centerOnInternal(\r\n      fromUserCoordinate(coordinate, this.getProjection()),\r\n      size,\r\n      position,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"./size.js\").Size} size Box pixel size.\r\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\r\n   */\r\n  centerOnInternal(coordinate, size, position) {\r\n    this.setCenterInternal(\r\n      calculateCenterOn(\r\n        coordinate,\r\n        size,\r\n        position,\r\n        this.getResolution(),\r\n        this.getRotation(),\r\n      ),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Calculates the shift between map and viewport center.\r\n   * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} rotation Rotation.\r\n   * @param {import(\"./size.js\").Size} size Size.\r\n   * @return {Array<number>|undefined} Center shift.\r\n   */\r\n  calculateCenterShift(center, resolution, rotation, size) {\r\n    let centerShift;\r\n    const padding = this.padding_;\r\n    if (padding && center) {\r\n      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);\r\n      const shiftedCenter = calculateCenterOn(\r\n        center,\r\n        size,\r\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\r\n        resolution,\r\n        rotation,\r\n      );\r\n      centerShift = [\r\n        center[0] - shiftedCenter[0],\r\n        center[1] - shiftedCenter[1],\r\n      ];\r\n    }\r\n    return centerShift;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Is defined.\r\n   */\r\n  isDef() {\r\n    return !!this.getCenterInternal() && this.getResolution() !== undefined;\r\n  }\r\n\r\n  /**\r\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\r\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\r\n   * @api\r\n   */\r\n  adjustCenter(deltaCoordinates) {\r\n    const center = toUserCoordinate(this.targetCenter_, this.getProjection());\r\n    this.setCenter([\r\n      center[0] + deltaCoordinates[0],\r\n      center[1] + deltaCoordinates[1],\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\r\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\r\n   */\r\n  adjustCenterInternal(deltaCoordinates) {\r\n    const center = this.targetCenter_;\r\n    this.setCenterInternal([\r\n      center[0] + deltaCoordinates[0],\r\n      center[1] + deltaCoordinates[1],\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\r\n   * constraint will apply.\r\n   * @param {number} ratio The ratio to apply on the view resolution.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   * @api\r\n   */\r\n  adjustResolution(ratio, anchor) {\r\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\r\n    this.adjustResolutionInternal(ratio, anchor);\r\n  }\r\n\r\n  /**\r\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\r\n   * constraint will apply.\r\n   * @param {number} ratio The ratio to apply on the view resolution.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   */\r\n  adjustResolutionInternal(ratio, anchor) {\r\n    const isMoving = this.getAnimating() || this.getInteracting();\r\n    const size = this.getViewportSize_(this.getRotation());\r\n    const newResolution = this.constraints_.resolution(\r\n      this.targetResolution_ * ratio,\r\n      0,\r\n      size,\r\n      isMoving,\r\n    );\r\n\r\n    if (anchor) {\r\n      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);\r\n    }\r\n\r\n    this.targetResolution_ *= ratio;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * Adds a value to the view zoom level, optionally using an anchor. Any resolution\r\n   * constraint will apply.\r\n   * @param {number} delta Relative value to add to the zoom level.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   * @api\r\n   */\r\n  adjustZoom(delta, anchor) {\r\n    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);\r\n  }\r\n\r\n  /**\r\n   * Adds a value to the view rotation, optionally using an anchor. Any rotation\r\n   * constraint will apply.\r\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\r\n   * @api\r\n   */\r\n  adjustRotation(delta, anchor) {\r\n    if (anchor) {\r\n      anchor = fromUserCoordinate(anchor, this.getProjection());\r\n    }\r\n    this.adjustRotationInternal(delta, anchor);\r\n  }\r\n\r\n  /**\r\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\r\n   */\r\n  adjustRotationInternal(delta, anchor) {\r\n    const isMoving = this.getAnimating() || this.getInteracting();\r\n    const newRotation = this.constraints_.rotation(\r\n      this.targetRotation_ + delta,\r\n      isMoving,\r\n    );\r\n    if (anchor) {\r\n      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);\r\n    }\r\n    this.targetRotation_ += delta;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * Set the center of the current view. Any extent constraint will apply.\r\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setCenter(center) {\r\n    this.setCenterInternal(\r\n      center ? fromUserCoordinate(center, this.getProjection()) : center,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Set the center using the view projection (not the user projection).\r\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\r\n   */\r\n  setCenterInternal(center) {\r\n    this.targetCenter_ = center;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./ViewHint.js\").default} hint Hint.\r\n   * @param {number} delta Delta.\r\n   * @return {number} New value.\r\n   */\r\n  setHint(hint, delta) {\r\n    this.hints_[hint] += delta;\r\n    this.changed();\r\n    return this.hints_[hint];\r\n  }\r\n\r\n  /**\r\n   * Set the resolution for this view. Any resolution constraint will apply.\r\n   * @param {number|undefined} resolution The resolution of the view.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setResolution(resolution) {\r\n    this.targetResolution_ = resolution;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * Set the rotation for this view. Any rotation constraint will apply.\r\n   * @param {number} rotation The rotation of the view in radians.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setRotation(rotation) {\r\n    this.targetRotation_ = rotation;\r\n    this.applyTargetState_();\r\n  }\r\n\r\n  /**\r\n   * Zoom to a specific zoom level. Any resolution constrain will apply.\r\n   * @param {number} zoom Zoom level.\r\n   * @api\r\n   */\r\n  setZoom(zoom) {\r\n    this.setResolution(this.getResolutionForZoom(zoom));\r\n  }\r\n\r\n  /**\r\n   * Recompute rotation/resolution/center based on target values.\r\n   * Note: we have to compute rotation first, then resolution and center considering that\r\n   * parameters can influence one another in case a view extent constraint is present.\r\n   * @param {boolean} [doNotCancelAnims] Do not cancel animations.\r\n   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.\r\n   * @private\r\n   */\r\n  applyTargetState_(doNotCancelAnims, forceMoving) {\r\n    const isMoving =\r\n      this.getAnimating() || this.getInteracting() || forceMoving;\r\n\r\n    // compute rotation\r\n    const newRotation = this.constraints_.rotation(\r\n      this.targetRotation_,\r\n      isMoving,\r\n    );\r\n    const size = this.getViewportSize_(newRotation);\r\n    const newResolution = this.constraints_.resolution(\r\n      this.targetResolution_,\r\n      0,\r\n      size,\r\n      isMoving,\r\n    );\r\n    const newCenter = this.constraints_.center(\r\n      this.targetCenter_,\r\n      newResolution,\r\n      size,\r\n      isMoving,\r\n      this.calculateCenterShift(\r\n        this.targetCenter_,\r\n        newResolution,\r\n        newRotation,\r\n        size,\r\n      ),\r\n    );\r\n\r\n    if (this.get(ViewProperty.ROTATION) !== newRotation) {\r\n      this.set(ViewProperty.ROTATION, newRotation);\r\n    }\r\n    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\r\n      this.set(ViewProperty.RESOLUTION, newResolution);\r\n      this.set('zoom', this.getZoom(), true);\r\n    }\r\n    if (\r\n      !newCenter ||\r\n      !this.get(ViewProperty.CENTER) ||\r\n      !equals(this.get(ViewProperty.CENTER), newCenter)\r\n    ) {\r\n      this.set(ViewProperty.CENTER, newCenter);\r\n    }\r\n\r\n    if (this.getAnimating() && !doNotCancelAnims) {\r\n      this.cancelAnimations();\r\n    }\r\n    this.cancelAnchor_ = undefined;\r\n  }\r\n\r\n  /**\r\n   * If any constraints need to be applied, an animation will be triggered.\r\n   * This is typically done on interaction end.\r\n   * Note: calling this with a duration of 0 will apply the constrained values straight away,\r\n   * without animation.\r\n   * @param {number} [duration] The animation duration in ms.\r\n   * @param {number} [resolutionDirection] Which direction to zoom.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   */\r\n  resolveConstraints(duration, resolutionDirection, anchor) {\r\n    duration = duration !== undefined ? duration : 200;\r\n    const direction = resolutionDirection || 0;\r\n\r\n    const newRotation = this.constraints_.rotation(this.targetRotation_);\r\n    const size = this.getViewportSize_(newRotation);\r\n    const newResolution = this.constraints_.resolution(\r\n      this.targetResolution_,\r\n      direction,\r\n      size,\r\n    );\r\n    const newCenter = this.constraints_.center(\r\n      this.targetCenter_,\r\n      newResolution,\r\n      size,\r\n      false,\r\n      this.calculateCenterShift(\r\n        this.targetCenter_,\r\n        newResolution,\r\n        newRotation,\r\n        size,\r\n      ),\r\n    );\r\n\r\n    if (duration === 0 && !this.cancelAnchor_) {\r\n      this.targetResolution_ = newResolution;\r\n      this.targetRotation_ = newRotation;\r\n      this.targetCenter_ = newCenter;\r\n      this.applyTargetState_();\r\n      return;\r\n    }\r\n\r\n    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);\r\n    this.cancelAnchor_ = undefined;\r\n\r\n    if (\r\n      this.getResolution() !== newResolution ||\r\n      this.getRotation() !== newRotation ||\r\n      !this.getCenterInternal() ||\r\n      !equals(this.getCenterInternal(), newCenter)\r\n    ) {\r\n      if (this.getAnimating()) {\r\n        this.cancelAnimations();\r\n      }\r\n\r\n      this.animateInternal({\r\n        rotation: newRotation,\r\n        center: newCenter,\r\n        resolution: newResolution,\r\n        duration: duration,\r\n        easing: easeOut,\r\n        anchor: anchor,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notify the View that an interaction has started.\r\n   * The view state will be resolved to a stable one if needed\r\n   * (depending on its constraints).\r\n   * @api\r\n   */\r\n  beginInteraction() {\r\n    this.resolveConstraints(0);\r\n\r\n    this.setHint(ViewHint.INTERACTING, 1);\r\n  }\r\n\r\n  /**\r\n   * Notify the View that an interaction has ended. The view state will be resolved\r\n   * to a stable one if needed (depending on its constraints).\r\n   * @param {number} [duration] Animation duration in ms.\r\n   * @param {number} [resolutionDirection] Which direction to zoom.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   * @api\r\n   */\r\n  endInteraction(duration, resolutionDirection, anchor) {\r\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\r\n    this.endInteractionInternal(duration, resolutionDirection, anchor);\r\n  }\r\n\r\n  /**\r\n   * Notify the View that an interaction has ended. The view state will be resolved\r\n   * to a stable one if needed (depending on its constraints).\r\n   * @param {number} [duration] Animation duration in ms.\r\n   * @param {number} [resolutionDirection] Which direction to zoom.\r\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\r\n   */\r\n  endInteractionInternal(duration, resolutionDirection, anchor) {\r\n    if (!this.getInteracting()) {\r\n      return;\r\n    }\r\n    this.setHint(ViewHint.INTERACTING, -1);\r\n    this.resolveConstraints(duration, resolutionDirection, anchor);\r\n  }\r\n\r\n  /**\r\n   * Get a valid position for the view center according to the current constraints.\r\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} targetCenter Target center position.\r\n   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.\r\n   * This is useful to guess a valid center position at a different zoom level.\r\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Valid center position.\r\n   */\r\n  getConstrainedCenter(targetCenter, targetResolution) {\r\n    const size = this.getViewportSize_(this.getRotation());\r\n    return this.constraints_.center(\r\n      targetCenter,\r\n      targetResolution || this.getResolution(),\r\n      size,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get a valid zoom level according to the current view constraints.\r\n   * @param {number|undefined} targetZoom Target zoom.\r\n   * @param {number} [direction=0] Indicate which resolution should be used\r\n   * by a renderer if the view resolution does not match any resolution of the tile source.\r\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\r\n   * will be used. If -1, the nearest higher resolution will be used.\r\n   * @return {number|undefined} Valid zoom level.\r\n   */\r\n  getConstrainedZoom(targetZoom, direction) {\r\n    const targetRes = this.getResolutionForZoom(targetZoom);\r\n    return this.getZoomForResolution(\r\n      this.getConstrainedResolution(targetRes, direction),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get a valid resolution according to the current view constraints.\r\n   * @param {number|undefined} targetResolution Target resolution.\r\n   * @param {number} [direction=0] Indicate which resolution should be used\r\n   * by a renderer if the view resolution does not match any resolution of the tile source.\r\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\r\n   * will be used. If -1, the nearest higher resolution will be used.\r\n   * @return {number|undefined} Valid resolution.\r\n   */\r\n  getConstrainedResolution(targetResolution, direction) {\r\n    direction = direction || 0;\r\n    const size = this.getViewportSize_(this.getRotation());\r\n\r\n    return this.constraints_.resolution(targetResolution, direction, size);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Function} callback Callback.\r\n * @param {*} returnValue Return value.\r\n */\r\nfunction animationCallback(callback, returnValue) {\r\n  setTimeout(function () {\r\n    callback(returnValue);\r\n  }, 0);\r\n}\r\n\r\n/**\r\n * @param {ViewOptions} options View options.\r\n * @return {import(\"./centerconstraint.js\").Type} The constraint.\r\n */\r\nexport function createCenterConstraint(options) {\r\n  if (options.extent !== undefined) {\r\n    const smooth =\r\n      options.smoothExtentConstraint !== undefined\r\n        ? options.smoothExtentConstraint\r\n        : true;\r\n    return createExtent(options.extent, options.constrainOnlyCenter, smooth);\r\n  }\r\n\r\n  const projection = createProjection(options.projection, 'EPSG:3857');\r\n  if (options.multiWorld !== true && projection.isGlobal()) {\r\n    const extent = projection.getExtent().slice();\r\n    extent[0] = -Infinity;\r\n    extent[2] = Infinity;\r\n    return createExtent(extent, false, false);\r\n  }\r\n\r\n  return centerNone;\r\n}\r\n\r\n/**\r\n * @param {ViewOptions} options View options.\r\n * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\r\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\r\n */\r\nexport function createResolutionConstraint(options) {\r\n  let resolutionConstraint;\r\n  let maxResolution;\r\n  let minResolution;\r\n\r\n  // TODO: move these to be ol constants\r\n  // see https://github.com/openlayers/openlayers/issues/2076\r\n  const defaultMaxZoom = 28;\r\n  const defaultZoomFactor = 2;\r\n\r\n  let minZoom =\r\n    options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\r\n\r\n  let maxZoom =\r\n    options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\r\n\r\n  const zoomFactor =\r\n    options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\r\n\r\n  const multiWorld =\r\n    options.multiWorld !== undefined ? options.multiWorld : false;\r\n\r\n  const smooth =\r\n    options.smoothResolutionConstraint !== undefined\r\n      ? options.smoothResolutionConstraint\r\n      : true;\r\n\r\n  const showFullExtent =\r\n    options.showFullExtent !== undefined ? options.showFullExtent : false;\r\n\r\n  const projection = createProjection(options.projection, 'EPSG:3857');\r\n  const projExtent = projection.getExtent();\r\n  let constrainOnlyCenter = options.constrainOnlyCenter;\r\n  let extent = options.extent;\r\n  if (!multiWorld && !extent && projection.isGlobal()) {\r\n    constrainOnlyCenter = false;\r\n    extent = projExtent;\r\n  }\r\n\r\n  if (options.resolutions !== undefined) {\r\n    const resolutions = options.resolutions;\r\n    maxResolution = resolutions[minZoom];\r\n    minResolution =\r\n      resolutions[maxZoom] !== undefined\r\n        ? resolutions[maxZoom]\r\n        : resolutions[resolutions.length - 1];\r\n\r\n    if (options.constrainResolution) {\r\n      resolutionConstraint = createSnapToResolutions(\r\n        resolutions,\r\n        smooth,\r\n        !constrainOnlyCenter && extent,\r\n        showFullExtent,\r\n      );\r\n    } else {\r\n      resolutionConstraint = createMinMaxResolution(\r\n        maxResolution,\r\n        minResolution,\r\n        smooth,\r\n        !constrainOnlyCenter && extent,\r\n        showFullExtent,\r\n      );\r\n    }\r\n  } else {\r\n    // calculate the default min and max resolution\r\n    const size = !projExtent\r\n      ? // use an extent that can fit the whole world if need be\r\n        (360 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit()\r\n      : Math.max(getWidth(projExtent), getHeight(projExtent));\r\n\r\n    const defaultMaxResolution =\r\n      size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\r\n\r\n    const defaultMinResolution =\r\n      defaultMaxResolution /\r\n      Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\r\n\r\n    // user provided maxResolution takes precedence\r\n    maxResolution = options.maxResolution;\r\n    if (maxResolution !== undefined) {\r\n      minZoom = 0;\r\n    } else {\r\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\r\n    }\r\n\r\n    // user provided minResolution takes precedence\r\n    minResolution = options.minResolution;\r\n    if (minResolution === undefined) {\r\n      if (options.maxZoom !== undefined) {\r\n        if (options.maxResolution !== undefined) {\r\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\r\n        } else {\r\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\r\n        }\r\n      } else {\r\n        minResolution = defaultMinResolution;\r\n      }\r\n    }\r\n\r\n    // given discrete zoom levels, minResolution may be different than provided\r\n    maxZoom =\r\n      minZoom +\r\n      Math.floor(\r\n        Math.log(maxResolution / minResolution) / Math.log(zoomFactor),\r\n      );\r\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\r\n\r\n    if (options.constrainResolution) {\r\n      resolutionConstraint = createSnapToPower(\r\n        zoomFactor,\r\n        maxResolution,\r\n        minResolution,\r\n        smooth,\r\n        !constrainOnlyCenter && extent,\r\n        showFullExtent,\r\n      );\r\n    } else {\r\n      resolutionConstraint = createMinMaxResolution(\r\n        maxResolution,\r\n        minResolution,\r\n        smooth,\r\n        !constrainOnlyCenter && extent,\r\n        showFullExtent,\r\n      );\r\n    }\r\n  }\r\n  return {\r\n    constraint: resolutionConstraint,\r\n    maxResolution: maxResolution,\r\n    minResolution: minResolution,\r\n    minZoom: minZoom,\r\n    zoomFactor: zoomFactor,\r\n  };\r\n}\r\n\r\n/**\r\n * @param {ViewOptions} options View options.\r\n * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\r\n */\r\nexport function createRotationConstraint(options) {\r\n  const enableRotation =\r\n    options.enableRotation !== undefined ? options.enableRotation : true;\r\n  if (enableRotation) {\r\n    const constrainRotation = options.constrainRotation;\r\n    if (constrainRotation === undefined || constrainRotation === true) {\r\n      return createSnapToZero();\r\n    }\r\n    if (constrainRotation === false) {\r\n      return rotationNone;\r\n    }\r\n    if (typeof constrainRotation === 'number') {\r\n      return createSnapToN(constrainRotation);\r\n    }\r\n    return rotationNone;\r\n  }\r\n  return disable;\r\n}\r\n\r\n/**\r\n * Determine if an animation involves no view change.\r\n * @param {Animation} animation The animation.\r\n * @return {boolean} The animation involves no view change.\r\n */\r\nexport function isNoopAnimation(animation) {\r\n  if (animation.sourceCenter && animation.targetCenter) {\r\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\r\n      return false;\r\n    }\r\n  }\r\n  if (animation.sourceResolution !== animation.targetResolution) {\r\n    return false;\r\n  }\r\n  if (animation.sourceRotation !== animation.targetRotation) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {import(\"./size.js\").Size} size Box pixel size.\r\n * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @return {import(\"./coordinate.js\").Coordinate} Shifted center.\r\n */\r\nfunction calculateCenterOn(coordinate, size, position, resolution, rotation) {\r\n  // calculate rotated position\r\n  const cosAngle = Math.cos(-rotation);\r\n  let sinAngle = Math.sin(-rotation);\r\n  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\r\n  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\r\n  rotX += (size[0] / 2 - position[0]) * resolution;\r\n  rotY += (position[1] - size[1] / 2) * resolution;\r\n\r\n  // go back to original angle\r\n  sinAngle = -sinAngle; // go back to original rotation\r\n  const centerX = rotX * cosAngle - rotY * sinAngle;\r\n  const centerY = rotY * cosAngle + rotX * sinAngle;\r\n\r\n  return [centerX, centerY];\r\n}\r\n\r\nexport default View;\r\n","/**\r\n * @module CME2D/layer/Layer\r\n */\r\nimport BaseLayer from './Base.js';\r\nimport EventType from '../events/EventType.js';\r\nimport LayerProperty from './Property.js';\r\nimport RenderEventType from '../render/EventType.js';\r\nimport View from '../View.js';\r\nimport {assert} from '../asserts.js';\r\nimport {intersects} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {function(import(\"../Map.js\").FrameState):HTMLElement} RenderFunction\r\n */\r\n\r\n/**\r\n * @typedef {'sourceready'|'change:source'} LayerEventType\r\n */\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\r\n *     LayerEventType, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|LayerEventType|\r\n *     import(\"../render/EventType\").LayerRenderEventTypes, Return>} LayerOnSignature\r\n */\r\n\r\n/**\r\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,\r\n * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after\r\n * construction.\r\n * @property {import(\"../Map.js\").default|null} [map] Map.\r\n * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an\r\n * HTML element. Will overwrite the default rendering for the layer.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @typedef {Object} State\r\n * @property {import(\"./Layer.js\").default} layer Layer.\r\n * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.\r\n * @property {boolean} visible Visible.\r\n * @property {boolean} managed Managed.\r\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\r\n * @property {number} zIndex ZIndex.\r\n * @property {number} maxResolution Maximum resolution.\r\n * @property {number} minResolution Minimum resolution.\r\n * @property {number} minZoom Minimum zoom.\r\n * @property {number} maxZoom Maximum zoom.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class from which all layer types are derived. This should only be instantiated\r\n * in the case where a custom layer is added to the map with a custom `render` function.\r\n * Such a function can be specified in the `options` object, and is expected to return an HTML element.\r\n *\r\n * A visual representation of raster or vector map data.\r\n * Layers group together those properties that pertain to how the data is to be\r\n * displayed, irrespective of the source of that data.\r\n *\r\n * Layers are usually added to a map with [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\r\n * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers\r\n * internally. These unmanaged layers are associated with the map using\r\n * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.\r\n *\r\n * A generic `change` event is fired when the state of the source changes.\r\n * A `sourceready` event is fired when the layer's source is ready.\r\n *\r\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\r\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\r\n * @fires import(\"../events/Event.js\").BaseEvent#sourceready\r\n *\r\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\r\n * @template {import(\"../renderer/Layer.js\").default} [RendererType=import(\"../renderer/Layer.js\").default]\r\n * @api\r\n */\r\nclass Layer extends BaseLayer {\r\n  /**\r\n   * @param {Options<SourceType>} options Layer options.\r\n   */\r\n  constructor(options) {\r\n    const baseOptions = Object.assign({}, options);\r\n    delete baseOptions.source;\r\n\r\n    super(baseOptions);\r\n\r\n    /***\r\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {LayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.mapPrecomposeKey_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.mapRenderKey_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.sourceChangeKey_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {RendererType}\r\n     */\r\n    this.renderer_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.sourceReady_ = false;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {boolean}\r\n     */\r\n    this.rendered = false;\r\n\r\n    // Overwrite default render method with a custom one\r\n    if (options.render) {\r\n      this.render = options.render;\r\n    }\r\n\r\n    if (options.map) {\r\n      this.setMap(options.map);\r\n    }\r\n\r\n    this.addChangeListener(\r\n      LayerProperty.SOURCE,\r\n      this.handleSourcePropertyChange_,\r\n    );\r\n\r\n    const source = options.source\r\n      ? /** @type {SourceType} */ (options.source)\r\n      : null;\r\n    this.setSource(source);\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\r\n   * @override\r\n   */\r\n  getLayersArray(array) {\r\n    array = array ? array : [];\r\n    array.push(this);\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer states (to be modified in place).\r\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\r\n   * @override\r\n   */\r\n  getLayerStatesArray(states) {\r\n    states = states ? states : [];\r\n    states.push(this.getLayerState());\r\n    return states;\r\n  }\r\n\r\n  /**\r\n   * Get the layer source.\r\n   * @return {SourceType|null} The layer source (or `null` if not yet set).\r\n   * @observable\r\n   * @api\r\n   */\r\n  getSource() {\r\n    return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;\r\n  }\r\n\r\n  /**\r\n   * @return {SourceType|null} The source being rendered.\r\n   */\r\n  getRenderSource() {\r\n    return this.getSource();\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../source/Source.js\").State} Source state.\r\n   * @override\r\n   */\r\n  getSourceState() {\r\n    const source = this.getSource();\r\n    return !source ? 'undefined' : source.getState();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleSourceChange_() {\r\n    this.changed();\r\n    if (this.sourceReady_ || this.getSource().getState() !== 'ready') {\r\n      return;\r\n    }\r\n    this.sourceReady_ = true;\r\n    this.dispatchEvent('sourceready');\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleSourcePropertyChange_() {\r\n    if (this.sourceChangeKey_) {\r\n      unlistenByKey(this.sourceChangeKey_);\r\n      this.sourceChangeKey_ = null;\r\n    }\r\n    this.sourceReady_ = false;\r\n    const source = this.getSource();\r\n    if (source) {\r\n      this.sourceChangeKey_ = listen(\r\n        source,\r\n        EventType.CHANGE,\r\n        this.handleSourceChange_,\r\n        this,\r\n      );\r\n      if (source.getState() === 'ready') {\r\n        this.sourceReady_ = true;\r\n        setTimeout(() => {\r\n          this.dispatchEvent('sourceready');\r\n        }, 0);\r\n      }\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\r\n   * an array of features.\r\n   */\r\n  getFeatures(pixel) {\r\n    if (!this.renderer_) {\r\n      return Promise.resolve([]);\r\n    }\r\n    return this.renderer_.getFeatures(pixel);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   */\r\n  getData(pixel) {\r\n    if (!this.renderer_ || !this.rendered) {\r\n      return null;\r\n    }\r\n    return this.renderer_.getData(pixel);\r\n  }\r\n\r\n  /**\r\n   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and\r\n   * extent, not set to `visible: false`, and not inside a layer group that is set\r\n   * to `visible: false`.\r\n   * @param {View|import(\"../View.js\").ViewStateLayerStateExtent} [view] View or {@link import(\"../Map.js\").FrameState}.\r\n   * Only required when the layer is not added to a map.\r\n   * @return {boolean} The layer is visible in the map view.\r\n   * @api\r\n   */\r\n  isVisible(view) {\r\n    let frameState;\r\n    const map = this.getMapInternal();\r\n    if (!view && map) {\r\n      view = map.getView();\r\n    }\r\n    if (view instanceof View) {\r\n      frameState = {\r\n        viewState: view.getState(),\r\n        extent: view.calculateExtent(),\r\n      };\r\n    } else {\r\n      frameState = view;\r\n    }\r\n    if (!frameState.layerStatesArray && map) {\r\n      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();\r\n    }\r\n    let layerState;\r\n    if (frameState.layerStatesArray) {\r\n      layerState = frameState.layerStatesArray.find(\r\n        (layerState) => layerState.layer === this,\r\n      );\r\n    } else {\r\n      layerState = this.getLayerState();\r\n    }\r\n\r\n    const layerExtent = this.getExtent();\r\n\r\n    return (\r\n      inView(layerState, frameState.viewState) &&\r\n      (!layerExtent || intersects(layerExtent, frameState.extent))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the attributions of the source of this layer for the given view.\r\n   * @param {View|import(\"../View.js\").ViewStateLayerStateExtent} [view] View or {@link import(\"../Map.js\").FrameState}.\r\n   * Only required when the layer is not added to a map.\r\n   * @return {Array<string>} Attributions for this layer at the given view.\r\n   * @api\r\n   */\r\n  getAttributions(view) {\r\n    if (!this.isVisible(view)) {\r\n      return [];\r\n    }\r\n    const getAttributions = this.getSource()?.getAttributions();\r\n    if (!getAttributions) {\r\n      return [];\r\n    }\r\n    const frameState =\r\n      view instanceof View ? view.getViewStateAndExtent() : view;\r\n    let attributions = getAttributions(frameState);\r\n    if (!Array.isArray(attributions)) {\r\n      attributions = [attributions];\r\n    }\r\n    return attributions;\r\n  }\r\n\r\n  /**\r\n   * In charge to manage the rendering of the layer. One layer type is\r\n   * bounded with one layer renderer.\r\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\r\n   * for rendering its content.\r\n   * @return {HTMLElement|null} The rendered element.\r\n   */\r\n  render(frameState, target) {\r\n    const layerRenderer = this.getRenderer();\r\n\r\n    if (layerRenderer.prepareFrame(frameState)) {\r\n      this.rendered = true;\r\n      return layerRenderer.renderFrame(frameState, target);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Called when a layer is not visible during a map render.\r\n   */\r\n  unrender() {\r\n    this.rendered = false;\r\n  }\r\n\r\n  /** @return {string} Declutter */\r\n  getDeclutter() {\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../layer/Layer.js\").State} layerState Layer state.\r\n   */\r\n  renderDeclutter(frameState, layerState) {}\r\n\r\n  /**\r\n   * When the renderer follows a layout -> render approach, do the final rendering here.\r\n   * @param {import('../Map.js').FrameState} frameState Frame state\r\n   */\r\n  renderDeferred(frameState) {\r\n    const layerRenderer = this.getRenderer();\r\n    if (!layerRenderer) {\r\n      return;\r\n    }\r\n    layerRenderer.renderDeferred(frameState);\r\n  }\r\n\r\n  /**\r\n   * For use inside the library only.\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   */\r\n  setMapInternal(map) {\r\n    if (!map) {\r\n      this.unrender();\r\n    }\r\n    this.set(LayerProperty.MAP, map);\r\n  }\r\n\r\n  /**\r\n   * For use inside the library only.\r\n   * @return {import(\"../Map.js\").default|null} Map.\r\n   */\r\n  getMapInternal() {\r\n    return this.get(LayerProperty.MAP);\r\n  }\r\n\r\n  /**\r\n   * Sets the layer to be rendered on top of other layers on a map. The map will\r\n   * not manage this layer in its layers collection. This\r\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\r\n   * use `#setMap(null)`.\r\n   *\r\n   * To add the layer to a map and have it managed by the map, use\r\n   * {@link module:ol/Map~Map#addLayer} instead.\r\n   * @param {import(\"../Map.js\").default|null} map Map.\r\n   * @api\r\n   */\r\n  setMap(map) {\r\n    if (this.mapPrecomposeKey_) {\r\n      unlistenByKey(this.mapPrecomposeKey_);\r\n      this.mapPrecomposeKey_ = null;\r\n    }\r\n    if (!map) {\r\n      this.changed();\r\n    }\r\n    if (this.mapRenderKey_) {\r\n      unlistenByKey(this.mapRenderKey_);\r\n      this.mapRenderKey_ = null;\r\n    }\r\n    if (map) {\r\n      this.mapPrecomposeKey_ = listen(\r\n        map,\r\n        RenderEventType.PRECOMPOSE,\r\n        (evt) => {\r\n          const renderEvent =\r\n            /** @type {import(\"../render/Event.js\").default} */ (evt);\r\n          const layerStatesArray = renderEvent.frameState.layerStatesArray;\r\n          const layerState = this.getLayerState(false);\r\n          assert(\r\n            !layerStatesArray.some(function (arrayLayerState) {\r\n              return arrayLayerState.layer === layerState.layer;\r\n            }),\r\n            'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.',\r\n          );\r\n          layerStatesArray.push(layerState);\r\n        },\r\n      );\r\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the layer source.\r\n   * @param {SourceType|null} source The layer source.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setSource(source) {\r\n    this.set(LayerProperty.SOURCE, source);\r\n  }\r\n\r\n  /**\r\n   * Get the renderer for this layer.\r\n   * @return {RendererType|null} The layer renderer.\r\n   */\r\n  getRenderer() {\r\n    if (!this.renderer_) {\r\n      this.renderer_ = this.createRenderer();\r\n    }\r\n    return this.renderer_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} The layer has a renderer.\r\n   */\r\n  hasRenderer() {\r\n    return !!this.renderer_;\r\n  }\r\n\r\n  /**\r\n   * Create a renderer for this layer.\r\n   * @return {RendererType} A layer renderer.\r\n   * @protected\r\n   */\r\n  createRenderer() {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    if (this.renderer_) {\r\n      this.renderer_.dispose();\r\n      delete this.renderer_;\r\n    }\r\n\r\n    this.setSource(null);\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\n/**\r\n * Return `true` if the layer is visible and if the provided view state\r\n * has resolution and zoom levels that are in range of the layer's min/max.\r\n * @param {State} layerState Layer state.\r\n * @param {import(\"../View.js\").State} viewState View state.\r\n * @return {boolean} The layer is visible at the given view state.\r\n */\r\nexport function inView(layerState, viewState) {\r\n  if (!layerState.visible) {\r\n    return false;\r\n  }\r\n  const resolution = viewState.resolution;\r\n  if (\r\n    resolution < layerState.minResolution ||\r\n    resolution >= layerState.maxResolution\r\n  ) {\r\n    return false;\r\n  }\r\n  const zoom = viewState.zoom;\r\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\r\n}\r\n\r\nexport default Layer;\r\n","/**\r\n * @module CME2D/layer/TileProperty\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  PRELOAD: 'preload',\r\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\r\n};\r\n","/**\r\n * @module CME2D/layer/BaseTile\r\n */\r\nimport Layer from './Layer.js';\r\nimport TileProperty from './TileProperty.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\r\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\r\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\r\n */\r\n\r\n/**\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\r\n * means no preloading.\r\n * @property {TileSourceType} [source] Source for this layer.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\r\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\r\n * two zoom levels worth of tiles.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @template {import(\"../renderer/Layer.js\").default} RendererType\r\n * @extends {Layer<TileSourceType, RendererType>}\r\n * @api\r\n */\r\nclass BaseTileLayer extends Layer {\r\n  /**\r\n   * @param {Options<TileSourceType>} [options] Tile layer options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    const baseOptions = Object.assign({}, options);\r\n\r\n    const cacheSize = options.cacheSize;\r\n    delete options.cacheSize;\r\n\r\n    delete baseOptions.preload;\r\n    delete baseOptions.useInterimTilesOnError;\r\n    super(baseOptions);\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @type {number|undefined}\r\n     * @private\r\n     */\r\n    this.cacheSize_ = cacheSize;\r\n\r\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\r\n    this.setUseInterimTilesOnError(\r\n      options.useInterimTilesOnError !== undefined\r\n        ? options.useInterimTilesOnError\r\n        : true,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {number|undefined} The suggested cache size\r\n   * @protected\r\n   */\r\n  getCacheSize() {\r\n    return this.cacheSize_;\r\n  }\r\n\r\n  /**\r\n   * Return the level as number to which we will preload tiles up to.\r\n   * @return {number} The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getPreload() {\r\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\r\n  }\r\n\r\n  /**\r\n   * Set the level as number to which we will preload tiles up to.\r\n   * @param {number} preload The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setPreload(preload) {\r\n    this.set(TileProperty.PRELOAD, preload);\r\n  }\r\n\r\n  /**\r\n   * Deprecated.  Whether we use interim tiles on error.\r\n   * @return {boolean} Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getUseInterimTilesOnError() {\r\n    return /** @type {boolean} */ (\r\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Deprecated.  Set whether we use interim tiles on error.\r\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setUseInterimTilesOnError(useInterimTilesOnError) {\r\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\r\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\r\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\r\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\r\n   *\r\n   * ```js\r\n   * // display layer data on every pointer move\r\n   * map.on('pointermove', (event) => {\r\n   *   console.log(layer.getData(event.pixel));\r\n   * });\r\n   * ```\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   * @api\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    return super.getData(pixel);\r\n  }\r\n}\r\n\r\nexport default BaseTileLayer;\r\n","/**\r\n * @module CME2D/reproj/Tile\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport EventType from '../events/EventType.js';\r\nimport Tile from '../Tile.js';\r\nimport TileState from '../TileState.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {\r\n  calculateSourceExtentResolution,\r\n  canvasPool,\r\n  render as renderReprojected,\r\n} from '../reproj.js';\r\nimport {clamp} from '../math.js';\r\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\nimport {releaseCanvas} from '../dom.js';\r\n\r\n/**\r\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\r\n */\r\n\r\n/**\r\n * @typedef {Object} TileOffset\r\n * @property {import(\"../ImageTile.js\").default} tile Tile.\r\n * @property {number} offset Offset.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected tile.\r\n * See {@link module:ol/source/TileImage~TileImage}.\r\n *\r\n */\r\nclass ReprojTile extends Tile {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\r\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {number} gutter Gutter of the source tiles.\r\n   * @param {FunctionType} getTileFunction\r\n   *     Function returning source tiles (z, x, y, pixelRatio).\r\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\r\n   * @param {boolean} [renderEdges] Render reprojection edges.\r\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    sourceTileGrid,\r\n    targetProj,\r\n    targetTileGrid,\r\n    tileCoord,\r\n    wrappedTileCoord,\r\n    pixelRatio,\r\n    gutter,\r\n    getTileFunction,\r\n    errorThreshold,\r\n    renderEdges,\r\n    options,\r\n  ) {\r\n    super(tileCoord, TileState.IDLE, options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = pixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = gutter;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.sourceTileGrid_ = sourceTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.targetTileGrid_ = targetTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilecoord.js\").TileCoord}\r\n     */\r\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<TileOffset>}\r\n     */\r\n    this.sourceTiles_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.sourcesListenerKeys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourceZ_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.clipExtent_ = sourceProj.canWrapX()\r\n      ? sourceProj.getExtent()\r\n      : undefined;\r\n\r\n    const targetExtent = targetTileGrid.getTileCoordExtent(\r\n      this.wrappedTileCoord_,\r\n    );\r\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\r\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    if (getArea(limitedTargetExtent) === 0) {\r\n      // Tile is completely outside range -> EMPTY\r\n      // TODO: is it actually correct that the source even creates the tile ?\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const sourceProjExtent = sourceProj.getExtent();\r\n    if (sourceProjExtent) {\r\n      if (!maxSourceExtent) {\r\n        maxSourceExtent = sourceProjExtent;\r\n      } else {\r\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\r\n      }\r\n    }\r\n\r\n    const targetResolution = targetTileGrid.getResolution(\r\n      this.wrappedTileCoord_[0],\r\n    );\r\n\r\n    const sourceResolution = calculateSourceExtentResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      targetResolution,\r\n    );\r\n\r\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n      // invalid sourceResolution -> EMPTY\r\n      // probably edges of the projections when no extent is defined\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const errorThresholdInPixels =\r\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution,\r\n    );\r\n\r\n    if (this.triangulation_.getTriangles().length === 0) {\r\n      // no valid triangles -> EMPTY\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\r\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\r\n\r\n    if (maxSourceExtent) {\r\n      if (sourceProj.canWrapX()) {\r\n        sourceExtent[1] = clamp(\r\n          sourceExtent[1],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n        sourceExtent[3] = clamp(\r\n          sourceExtent[3],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n      } else {\r\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\r\n      }\r\n    }\r\n\r\n    if (!getArea(sourceExtent)) {\r\n      this.state = TileState.EMPTY;\r\n    } else {\r\n      let worldWidth = 0;\r\n      let worldsAway = 0;\r\n      if (sourceProj.canWrapX()) {\r\n        worldWidth = getWidth(sourceProjExtent);\r\n        worldsAway = Math.floor(\r\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\r\n        );\r\n      }\r\n\r\n      const sourceExtents = wrapAndSliceX(\r\n        sourceExtent.slice(),\r\n        sourceProj,\r\n        true,\r\n      );\r\n      sourceExtents.forEach((extent) => {\r\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\r\n          extent,\r\n          this.sourceZ_,\r\n        );\r\n\r\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\r\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\r\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\r\n            if (tile) {\r\n              const offset = worldsAway * worldWidth;\r\n              this.sourceTiles_.push({tile, offset});\r\n            }\r\n          }\r\n        }\r\n        ++worldsAway;\r\n      });\r\n\r\n      if (this.sourceTiles_.length === 0) {\r\n        this.state = TileState.EMPTY;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the HTML Canvas element for this tile.\r\n   * @return {HTMLCanvasElement} Canvas.\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const sources = [];\r\n    this.sourceTiles_.forEach((source) => {\r\n      const tile = source.tile;\r\n      if (tile && tile.getState() == TileState.LOADED) {\r\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\r\n        extent[0] += source.offset;\r\n        extent[2] += source.offset;\r\n        const clipExtent = this.clipExtent_?.slice();\r\n        if (clipExtent) {\r\n          clipExtent[0] += source.offset;\r\n          clipExtent[2] += source.offset;\r\n        }\r\n        sources.push({\r\n          extent: extent,\r\n          clipExtent: clipExtent,\r\n          image: tile.getImage(),\r\n        });\r\n      }\r\n    });\r\n    this.sourceTiles_.length = 0;\r\n\r\n    if (sources.length === 0) {\r\n      this.state = TileState.ERROR;\r\n    } else {\r\n      const z = this.wrappedTileCoord_[0];\r\n      const size = this.targetTileGrid_.getTileSize(z);\r\n      const width = typeof size === 'number' ? size : size[0];\r\n      const height = typeof size === 'number' ? size : size[1];\r\n      const targetResolution = this.targetTileGrid_.getResolution(z);\r\n      const sourceResolution = this.sourceTileGrid_.getResolution(\r\n        this.sourceZ_,\r\n      );\r\n\r\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n        this.wrappedTileCoord_,\r\n      );\r\n\r\n      this.canvas_ = renderReprojected(\r\n        width,\r\n        height,\r\n        this.pixelRatio_,\r\n        sourceResolution,\r\n        this.sourceTileGrid_.getExtent(),\r\n        targetResolution,\r\n        targetExtent,\r\n        this.triangulation_,\r\n        sources,\r\n        this.gutter_,\r\n        this.renderEdges_,\r\n        this.interpolate,\r\n      );\r\n\r\n      this.state = TileState.LOADED;\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      this.changed();\r\n\r\n      let leftToLoad = 0;\r\n\r\n      this.sourcesListenerKeys_ = [];\r\n      this.sourceTiles_.forEach(({tile}) => {\r\n        const state = tile.getState();\r\n        if (state == TileState.IDLE || state == TileState.LOADING) {\r\n          leftToLoad++;\r\n\r\n          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {\r\n            const state = tile.getState();\r\n            if (\r\n              state == TileState.LOADED ||\r\n              state == TileState.ERROR ||\r\n              state == TileState.EMPTY\r\n            ) {\r\n              unlistenByKey(sourceListenKey);\r\n              leftToLoad--;\r\n              if (leftToLoad === 0) {\r\n                this.unlistenSources_();\r\n                this.reproject_();\r\n              }\r\n            }\r\n          });\r\n          this.sourcesListenerKeys_.push(sourceListenKey);\r\n        }\r\n      });\r\n\r\n      if (leftToLoad === 0) {\r\n        setTimeout(this.reproject_.bind(this), 0);\r\n      } else {\r\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\r\n          const state = tile.getState();\r\n          if (state == TileState.IDLE) {\r\n            tile.load();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSources_() {\r\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\r\n    this.sourcesListenerKeys_ = null;\r\n  }\r\n\r\n  /**\r\n   * Remove from the cache due to expiry\r\n   * @override\r\n   */\r\n  release() {\r\n    if (this.canvas_) {\r\n      releaseCanvas(this.canvas_.getContext('2d'));\r\n      canvasPool.push(this.canvas_);\r\n      this.canvas_ = null;\r\n    }\r\n    super.release();\r\n  }\r\n}\r\n\r\nexport default ReprojTile;\r\n","/**\r\n * @module CME2D/ImageState\r\n */\r\n\r\n/**\r\n * @enum {number}\r\n */\r\nexport default {\r\n  IDLE: 0,\r\n  LOADING: 1,\r\n  LOADED: 2,\r\n  ERROR: 3,\r\n  EMPTY: 4,\r\n};\r\n","/**\r\n * @module CME2D/Image\r\n */\r\nimport EventTarget from './events/Target.js';\r\nimport EventType from './events/EventType.js';\r\nimport ImageState from './ImageState.js';\r\nimport {CREATE_IMAGE_BITMAP, IMAGE_DECODE} from './has.js';\r\nimport {listenOnce, unlistenByKey} from './events.js';\r\nimport {toPromise} from './functions.js';\r\n\r\n/**\r\n * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a\r\n * `{string}` for the src as arguments. It is supposed to make it so the\r\n * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the\r\n * content specified by the src. If not specified, the default is\r\n *\r\n *     function(image, src) {\r\n *       image.getImage().src = src;\r\n *     }\r\n *\r\n * Providing a custom `imageLoadFunction` can be useful to load images with\r\n * post requests or - in general - through XHR requests, where the src of the\r\n * image element would be set to a data URI when the content is loaded.\r\n *\r\n * @typedef {function(import(\"./Image.js\").default, string): void} LoadFunction\r\n * @api\r\n */\r\n\r\n/**\r\n * @typedef {Object} ImageObject\r\n * @property {import(\"./extent.js\").Extent} [extent] Extent, if different from the requested one.\r\n * @property {import(\"./resolution.js\").ResolutionLike} [resolution] Resolution, if different from the requested one.\r\n * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).\r\n * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.\r\n * @property {import('./DataTile.js').ImageLike} image Image.\r\n */\r\n\r\n/**\r\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\r\n * For images that cover any extent and resolution (static images), the loader function should not accept\r\n * any arguments. The function returns an {@link import(\"./DataTile.js\").ImageLike image}, an\r\n * {@link import(\"./Image.js\").ImageObject image object}, or a promise for the same.\r\n * For loaders that generate images, the promise should not resolve until the image is loaded.\r\n * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,\r\n * it has to return an {@link import(\"./Image.js\").ImageObject image object} with the `image` and the\r\n * correct `extent`, `resolution` and `pixelRatio`.\r\n *\r\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} Loader\r\n * @api\r\n */\r\n\r\n/**\r\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\r\n * The function returns a promise for an  {@link import(\"./Image.js\").ImageObject image object}.\r\n *\r\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} ImageObjectPromiseLoader\r\n */\r\n\r\nclass ImageWrapper extends EventTarget {\r\n  /**\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y\r\n   * resolution will be assumed.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"./ImageState.js\").default|import(\"./Image.js\").Loader} stateOrLoader State.\r\n   */\r\n  constructor(extent, resolution, pixelRatio, stateOrLoader) {\r\n    super();\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./extent.js\").Extent}\r\n     */\r\n    this.extent = extent;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = pixelRatio;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number|Array<number>|undefined}\r\n     */\r\n    this.resolution = resolution;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./ImageState.js\").default}\r\n     */\r\n    this.state =\r\n      typeof stateOrLoader === 'function' ? ImageState.IDLE : stateOrLoader;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import('./DataTile.js').ImageLike|null}\r\n     */\r\n    this.image_ = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"./Image.js\").Loader}\r\n     */\r\n    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  changed() {\r\n    this.dispatchEvent(EventType.CHANGE);\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./extent.js\").Extent} Extent.\r\n   */\r\n  getExtent() {\r\n    return this.extent;\r\n  }\r\n\r\n  /**\r\n   * @return {import('./DataTile.js').ImageLike} Image.\r\n   */\r\n  getImage() {\r\n    return this.image_;\r\n  }\r\n\r\n  /**\r\n   * @return {number} PixelRatio.\r\n   */\r\n  getPixelRatio() {\r\n    return this.pixelRatio_;\r\n  }\r\n\r\n  /**\r\n   * @return {number|Array<number>} Resolution.\r\n   */\r\n  getResolution() {\r\n    return /** @type {number} */ (this.resolution);\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"./ImageState.js\").default} State.\r\n   */\r\n  getState() {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   */\r\n  load() {\r\n    if (this.state == ImageState.IDLE) {\r\n      if (this.loader) {\r\n        this.state = ImageState.LOADING;\r\n        this.changed();\r\n        const resolution = this.getResolution();\r\n        const requestResolution = Array.isArray(resolution)\r\n          ? resolution[0]\r\n          : resolution;\r\n        toPromise(() =>\r\n          this.loader(\r\n            this.getExtent(),\r\n            requestResolution,\r\n            this.getPixelRatio(),\r\n          ),\r\n        )\r\n          .then((image) => {\r\n            if ('image' in image) {\r\n              this.image_ = image.image;\r\n            }\r\n            if ('extent' in image) {\r\n              this.extent = image.extent;\r\n            }\r\n            if ('resolution' in image) {\r\n              this.resolution = image.resolution;\r\n            }\r\n            if ('pixelRatio' in image) {\r\n              this.pixelRatio_ = image.pixelRatio;\r\n            }\r\n            if (\r\n              image instanceof HTMLImageElement ||\r\n              image instanceof ImageBitmap ||\r\n              image instanceof HTMLCanvasElement ||\r\n              image instanceof HTMLVideoElement\r\n            ) {\r\n              this.image_ = image;\r\n            }\r\n            this.state = ImageState.LOADED;\r\n          })\r\n          .catch((error) => {\r\n            this.state = ImageState.ERROR;\r\n            console.error(error); // eslint-disable-line no-console\r\n          })\r\n          .finally(() => this.changed());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import('./DataTile.js').ImageLike} image The image.\r\n   */\r\n  setImage(image) {\r\n    this.image_ = image;\r\n  }\r\n\r\n  /**\r\n   * @param {number|Array<number>} resolution Resolution.\r\n   */\r\n  setResolution(resolution) {\r\n    this.resolution = resolution;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./DataTile.js').ImageLike} image Image element.\r\n * @param {function():any} loadHandler Load callback function.\r\n * @param {function():any} errorHandler Error callback function.\r\n * @return {function():void} Callback to stop listening.\r\n */\r\nexport function listenImage(image, loadHandler, errorHandler) {\r\n  const img = /** @type {HTMLImageElement} */ (image);\r\n  let listening = true;\r\n  let decoding = false;\r\n  let loaded = false;\r\n\r\n  const listenerKeys = [\r\n    listenOnce(img, EventType.LOAD, function () {\r\n      loaded = true;\r\n      if (!decoding) {\r\n        loadHandler();\r\n      }\r\n    }),\r\n  ];\r\n\r\n  if (img.src && IMAGE_DECODE) {\r\n    decoding = true;\r\n    img\r\n      .decode()\r\n      .then(function () {\r\n        if (listening) {\r\n          loadHandler();\r\n        }\r\n      })\r\n      .catch(function (error) {\r\n        if (listening) {\r\n          if (loaded) {\r\n            loadHandler();\r\n          } else {\r\n            errorHandler();\r\n          }\r\n        }\r\n      });\r\n  } else {\r\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\r\n  }\r\n\r\n  return function unlisten() {\r\n    listening = false;\r\n    listenerKeys.forEach(unlistenByKey);\r\n  };\r\n}\r\n\r\n/**\r\n * Loads an image.\r\n * @param {HTMLImageElement} image Image, not yet loaded.\r\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\r\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\r\n * @api\r\n */\r\nexport function load(image, src) {\r\n  return new Promise((resolve, reject) => {\r\n    function handleLoad() {\r\n      unlisten();\r\n      resolve(image);\r\n    }\r\n    function handleError() {\r\n      unlisten();\r\n      reject(new Error('Image load error'));\r\n    }\r\n    function unlisten() {\r\n      image.removeEventListener('load', handleLoad);\r\n      image.removeEventListener('error', handleError);\r\n    }\r\n    image.addEventListener('load', handleLoad);\r\n    image.addEventListener('error', handleError);\r\n    if (src) {\r\n      image.src = src;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * @param {HTMLImageElement} image Image, not yet loaded.\r\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\r\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\r\n */\r\nexport function decodeFallback(image, src) {\r\n  if (src) {\r\n    image.src = src;\r\n  }\r\n  return image.src && IMAGE_DECODE\r\n    ? new Promise((resolve, reject) =>\r\n        image\r\n          .decode()\r\n          .then(() => resolve(image))\r\n          .catch((e) =>\r\n            image.complete && image.width ? resolve(image) : reject(e),\r\n          ),\r\n      )\r\n    : load(image);\r\n}\r\n\r\n/**\r\n * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns\r\n * the loaded image otherwise.\r\n * @param {HTMLImageElement} image Image, not yet loaded.\r\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\r\n * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an\r\n * `HTMLImageElement` if `createImageBitmap()` is not supported.\r\n * @api\r\n */\r\nexport function decode(image, src) {\r\n  if (src) {\r\n    image.src = src;\r\n  }\r\n  return image.src && IMAGE_DECODE && CREATE_IMAGE_BITMAP\r\n    ? image\r\n        .decode()\r\n        .then(() => createImageBitmap(image))\r\n        .catch((e) => {\r\n          if (image.complete && image.width) {\r\n            return image;\r\n          }\r\n          throw e;\r\n        })\r\n    : decodeFallback(image);\r\n}\r\n\r\nexport default ImageWrapper;\r\n","/**\r\n * @module CME2D/ImageTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport TileState from './TileState.js';\r\nimport {createCanvasContext2D} from './dom.js';\r\nimport {listenImage} from './Image.js';\r\n\r\nclass ImageTile extends Tile {\r\n  /**\r\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"./TileState.js\").default} state State.\r\n   * @param {string} src Image source URI.\r\n   * @param {?string} crossOrigin Cross origin.\r\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\r\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\r\n   */\r\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\r\n    super(tileCoord, state, options);\r\n\r\n    /**\r\n     * @private\r\n     * @type {?string}\r\n     */\r\n    this.crossOrigin_ = crossOrigin;\r\n\r\n    /**\r\n     * Image URI\r\n     *\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.src_ = src;\r\n\r\n    this.key = src;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLImageElement|HTMLCanvasElement}\r\n     */\r\n    this.image_ = new Image();\r\n    if (crossOrigin !== null) {\r\n      this.image_.crossOrigin = crossOrigin;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @type {?function():void}\r\n     */\r\n    this.unlisten_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./Tile.js\").LoadFunction}\r\n     */\r\n    this.tileLoadFunction_ = tileLoadFunction;\r\n  }\r\n\r\n  /**\r\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\r\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\r\n   * @api\r\n   */\r\n  getImage() {\r\n    return this.image_;\r\n  }\r\n\r\n  /**\r\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\r\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\r\n   */\r\n  setImage(element) {\r\n    this.image_ = element;\r\n    this.state = TileState.LOADED;\r\n    this.unlistenImage_();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Tracks loading or read errors.\r\n   *\r\n   * @private\r\n   */\r\n  handleImageError_() {\r\n    this.state = TileState.ERROR;\r\n    this.unlistenImage_();\r\n    this.image_ = getBlankImage();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Tracks successful image load.\r\n   *\r\n   * @private\r\n   */\r\n  handleImageLoad_() {\r\n    const image = /** @type {HTMLImageElement} */ (this.image_);\r\n    if (image.naturalWidth && image.naturalHeight) {\r\n      this.state = TileState.LOADED;\r\n    } else {\r\n      this.state = TileState.EMPTY;\r\n    }\r\n    this.unlistenImage_();\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load the image or retry if loading previously failed.\r\n   * Loading is taken care of by the tile queue, and calling this method is\r\n   * only needed for preloading or for reloading in case of an error.\r\n   *\r\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\r\n   * that checks for error status codes and reloads only when the status code is\r\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\r\n   * made already:\r\n   *\r\n   * ```js\r\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\r\n   * const retries = {};\r\n   * source.setTileLoadFunction((tile, src) => {\r\n   *   const image = tile.getImage();\r\n   *   fetch(src)\r\n   *     .then((response) => {\r\n   *       if (retryCodes.includes(response.status)) {\r\n   *         retries[src] = (retries[src] || 0) + 1;\r\n   *         if (retries[src] <= 3) {\r\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\r\n   *         }\r\n   *         return Promise.reject();\r\n   *       }\r\n   *       return response.blob();\r\n   *     })\r\n   *     .then((blob) => {\r\n   *       const imageUrl = URL.createObjectURL(blob);\r\n   *       image.src = imageUrl;\r\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\r\n   *     })\r\n   *     .catch(() => tile.setState(3)); // error\r\n   * });\r\n   * ```\r\n   * @api\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state == TileState.ERROR) {\r\n      this.state = TileState.IDLE;\r\n      this.image_ = new Image();\r\n      if (this.crossOrigin_ !== null) {\r\n        this.image_.crossOrigin = this.crossOrigin_;\r\n      }\r\n    }\r\n    if (this.state == TileState.IDLE) {\r\n      this.state = TileState.LOADING;\r\n      this.changed();\r\n      this.tileLoadFunction_(this, this.src_);\r\n      this.unlisten_ = listenImage(\r\n        this.image_,\r\n        this.handleImageLoad_.bind(this),\r\n        this.handleImageError_.bind(this),\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Discards event handlers which listen for load completion or errors.\r\n   *\r\n   * @private\r\n   */\r\n  unlistenImage_() {\r\n    if (this.unlisten_) {\r\n      this.unlisten_();\r\n      this.unlisten_ = null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get a 1-pixel blank image.\r\n * @return {HTMLCanvasElement} Blank image.\r\n */\r\nfunction getBlankImage() {\r\n  const ctx = createCanvasContext2D(1, 1);\r\n  ctx.fillStyle = 'rgba(0,0,0,0)';\r\n  ctx.fillRect(0, 0, 1, 1);\r\n  return ctx.canvas;\r\n}\r\n\r\nexport default ImageTile;\r\n","/**\r\n * @module CME2D/webgl/BaseTileRepresentation\r\n */\r\n\r\nimport EventTarget from '../events/Target.js';\r\nimport EventType from '../events/EventType.js';\r\nimport ImageTile from '../ImageTile.js';\r\nimport TileState from '../TileState.js';\r\nimport {abstract} from '../util.js';\r\n\r\n/**\r\n * @typedef {import(\"../Tile.js\").default} BaseTileType\r\n */\r\n\r\n/**\r\n * @template {BaseTileType} TileType\r\n * @typedef {Object} TileRepresentationOptions\r\n * @property {TileType} tile The tile.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid Tile grid.\r\n * @property {import(\"../webgl/Helper.js\").default} helper WebGL helper.\r\n * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for representing a tile in a webgl context\r\n * @template {import(\"../Tile.js\").default} TileType\r\n * @abstract\r\n */\r\nclass BaseTileRepresentation extends EventTarget {\r\n  /**\r\n   * @param {TileRepresentationOptions<TileType>} options The tile representation options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * @type {TileType}\r\n     */\r\n    this.tile;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\r\n\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.gutter = options.gutter || 0;\r\n\r\n    /**\r\n     * @type {import(\"../webgl/Helper.js\").default}\r\n     * @protected\r\n     */\r\n    this.helper = options.helper;\r\n\r\n    this.loaded = false;\r\n    this.ready = false;\r\n  }\r\n\r\n  /**\r\n   * @param {TileType} tile Tile.\r\n   */\r\n  setTile(tile) {\r\n    if (tile !== this.tile) {\r\n      if (this.tile) {\r\n        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\r\n      }\r\n      this.tile = tile;\r\n      this.loaded = tile.getState() === TileState.LOADED;\r\n      if (this.loaded) {\r\n        this.uploadTile();\r\n      } else {\r\n        if (tile instanceof ImageTile) {\r\n          const image = tile.getImage();\r\n          if (image instanceof Image && !image.crossOrigin) {\r\n            image.crossOrigin = 'anonymous';\r\n          }\r\n        }\r\n        tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @protected\r\n   */\r\n  uploadTile() {\r\n    abstract();\r\n  }\r\n\r\n  setReady() {\r\n    this.ready = true;\r\n    this.dispatchEvent(EventType.CHANGE);\r\n  }\r\n\r\n  handleTileChange_() {\r\n    if (this.tile.getState() === TileState.LOADED) {\r\n      this.loaded = true;\r\n      this.uploadTile();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./Helper.js\").default} helper The WebGL helper.\r\n   */\r\n  setHelper(helper) {\r\n    this.helper = helper;\r\n    if (this.helper && this.loaded) {\r\n      this.uploadTile();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    this.setHelper(null);\r\n    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\r\n  }\r\n}\r\n\r\nexport default BaseTileRepresentation;\r\n","/**\r\n * @module CME2D/webgl\r\n */\r\n\r\nimport {SAFARI_BUG_237906} from './has.js';\r\n\r\n/**\r\n * Constants taken from goog.webgl\r\n */\r\n\r\n/**\r\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as\r\n * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer\r\n * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const ARRAY_BUFFER = 0x8892;\r\n\r\n/**\r\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.\r\n * Index buffers are essentially lists of references to vertices defined in a vertex buffer\r\n * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const ELEMENT_ARRAY_BUFFER = 0x8893;\r\n\r\n/**\r\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const STREAM_DRAW = 0x88e0;\r\n\r\n/**\r\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const STATIC_DRAW = 0x88e4;\r\n\r\n/**\r\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\r\n * @const\r\n * @type {number}\r\n * @api\r\n */\r\nexport const DYNAMIC_DRAW = 0x88e8;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const UNSIGNED_BYTE = 0x1401;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const UNSIGNED_SHORT = 0x1403;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const UNSIGNED_INT = 0x1405;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const FLOAT = 0x1406;\r\n\r\n/** end of goog.webgl constants\r\n */\r\n\r\n/**\r\n * @const\r\n * @type {Array<string>}\r\n */\r\nconst CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];\r\n\r\n/**\r\n * @param {HTMLCanvasElement} canvas Canvas.\r\n * @param {Object} [attributes] Attributes.\r\n * @return {WebGLRenderingContext|null} WebGL rendering context.\r\n */\r\nexport function getContext(canvas, attributes) {\r\n  attributes = Object.assign(\r\n    {\r\n      preserveDrawingBuffer: true,\r\n      antialias: SAFARI_BUG_237906 ? false : true, // https://bugs.webkit.org/show_bug.cgi?id=237906\r\n    },\r\n    attributes,\r\n  );\r\n  const ii = CONTEXT_IDS.length;\r\n  for (let i = 0; i < ii; ++i) {\r\n    try {\r\n      const context = canvas.getContext(CONTEXT_IDS[i], attributes);\r\n      if (context) {\r\n        return /** @type {!WebGLRenderingContext} */ (context);\r\n      }\r\n    } catch (e) {\r\n      // pass\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * @type {Array<string>|null}\r\n */\r\nlet supportedExtensions = null;\r\n\r\n/**\r\n * @return {Array<string>|null} List of supported WebGL extensions.\r\n */\r\nexport function getSupportedExtensions() {\r\n  if (!supportedExtensions) {\r\n    const canvas = document.createElement('canvas');\r\n    const gl = getContext(canvas);\r\n    if (gl) {\r\n      supportedExtensions = gl.getSupportedExtensions();\r\n    }\r\n  }\r\n  return supportedExtensions;\r\n}\r\n","/**\r\n * @module CME2D/webgl/Buffer\r\n */\r\nimport {\r\n  ARRAY_BUFFER,\r\n  DYNAMIC_DRAW,\r\n  ELEMENT_ARRAY_BUFFER,\r\n  STATIC_DRAW,\r\n  STREAM_DRAW,\r\n} from '../webgl.js';\r\nimport {assert} from '../asserts.js';\r\n\r\n/**\r\n * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`\r\n * or `DYNAMIC_DRAW`.\r\n * @enum {number}\r\n */\r\nexport const BufferUsage = {\r\n  STATIC_DRAW: STATIC_DRAW,\r\n  STREAM_DRAW: STREAM_DRAW,\r\n  DYNAMIC_DRAW: DYNAMIC_DRAW,\r\n};\r\n\r\n/**\r\n * @classdesc\r\n * Object used to store an array of data as well as usage information for that data.\r\n * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on\r\n * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.\r\n *\r\n * To populate the array, you can either use:\r\n * * A size using `#ofSize(buffer)`\r\n * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`\r\n * * A plain array using `#fromArray(array)`\r\n *\r\n * Note:\r\n * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)\r\n * for more info on buffer usage.\r\n */\r\nclass WebGLArrayBuffer {\r\n  /**\r\n   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\r\n   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.\r\n   * Default is `STATIC_DRAW`.\r\n   */\r\n  constructor(type, usage) {\r\n    /**\r\n     * @private\r\n     * @type {Float32Array|Uint32Array|null}\r\n     */\r\n    this.array_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.type_ = type;\r\n\r\n    assert(\r\n      type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER,\r\n      'A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`',\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.usage_ = usage !== undefined ? usage : BufferUsage.STATIC_DRAW;\r\n  }\r\n\r\n  /**\r\n   * Populates the buffer with an array of the given size (all values will be zeroes).\r\n   * @param {number} size Array size\r\n   * @return {WebGLArrayBuffer} This\r\n   */\r\n  ofSize(size) {\r\n    this.array_ = new (getArrayClassForType(this.type_))(size);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Populates the buffer with an array of the given size.\r\n   * @param {Array<number>} array Numerical array\r\n   * @return {WebGLArrayBuffer} This\r\n   */\r\n  fromArray(array) {\r\n    this.array_ = getArrayClassForType(this.type_).from(array);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Populates the buffer with a raw binary array buffer.\r\n   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been\r\n   * initialized for the same typed array class.\r\n   * @return {WebGLArrayBuffer} This\r\n   */\r\n  fromArrayBuffer(buffer) {\r\n    this.array_ = new (getArrayClassForType(this.type_))(buffer);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Buffer type.\r\n   */\r\n  getType() {\r\n    return this.type_;\r\n  }\r\n\r\n  /**\r\n   * Will return null if the buffer was not initialized\r\n   * @return {Float32Array|Uint32Array|null} Array.\r\n   */\r\n  getArray() {\r\n    return this.array_;\r\n  }\r\n\r\n  /**\r\n   * @param {Float32Array|Uint32Array} array Array.\r\n   */\r\n  setArray(array) {\r\n    const ArrayType = getArrayClassForType(this.type_);\r\n    if (!(array instanceof ArrayType)) {\r\n      throw new Error(`Expected ${ArrayType}`);\r\n    }\r\n    this.array_ = array;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Usage.\r\n   */\r\n  getUsage() {\r\n    return this.usage_;\r\n  }\r\n\r\n  /**\r\n   * Will return 0 if the buffer is not initialized\r\n   * @return {number} Array size\r\n   */\r\n  getSize() {\r\n    return this.array_ ? this.array_.length : 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a typed array constructor based on the given buffer type\r\n * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\r\n * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.\r\n */\r\nexport function getArrayClassForType(type) {\r\n  switch (type) {\r\n    case ARRAY_BUFFER:\r\n      return Float32Array;\r\n    case ELEMENT_ARRAY_BUFFER:\r\n      return Uint32Array;\r\n    default:\r\n      return Float32Array;\r\n  }\r\n}\r\n\r\nexport default WebGLArrayBuffer;\r\n","/**\r\n * @module CME2D/webgl/TileTexture\r\n */\r\n\r\nimport BaseTileRepresentation from './BaseTileRepresentation.js';\r\nimport DataTile, {asArrayLike, asImageLike} from '../DataTile.js';\r\nimport ImageTile from '../ImageTile.js';\r\nimport ReprojTile from '../reproj/Tile.js';\r\nimport WebGLArrayBuffer from './Buffer.js';\r\nimport {ARRAY_BUFFER, STATIC_DRAW} from '../webgl.js';\r\nimport {createCanvasContext2D} from '../dom.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @param {WebGLRenderingContext} gl The WebGL context.\r\n * @param {WebGLTexture} texture The texture.\r\n * @param {boolean} interpolate Interpolate when resampling.\r\n */\r\nfunction bindAndConfigure(gl, texture, interpolate) {\r\n  const resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;\r\n  gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);\r\n}\r\n\r\n/**\r\n * @param {WebGLRenderingContext} gl The WebGL context.\r\n * @param {WebGLTexture} texture The texture.\r\n * @param {import(\"../DataTile.js\").ImageLike} image The image.\r\n * @param {boolean} interpolate Interpolate when resampling.\r\n */\r\nfunction uploadImageTexture(gl, texture, image, interpolate) {\r\n  bindAndConfigure(gl, texture, interpolate);\r\n\r\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n}\r\n\r\n/**\r\n * @param {import(\"./Helper.js\").default} helper The WebGL helper.\r\n * @param {WebGLTexture} texture The texture.\r\n * @param {import(\"../DataTile.js\").ArrayLike} data The pixel data.\r\n * @param {import(\"../size.js\").Size} size The pixel size.\r\n * @param {number} bandCount The band count.\r\n * @param {boolean} interpolate Interpolate when resampling.\r\n */\r\nfunction uploadDataTexture(\r\n  helper,\r\n  texture,\r\n  data,\r\n  size,\r\n  bandCount,\r\n  interpolate,\r\n) {\r\n  const gl = helper.getGL();\r\n  let textureType;\r\n  let canInterpolate;\r\n  if (data instanceof Float32Array) {\r\n    textureType = gl.FLOAT;\r\n    helper.getExtension('OES_texture_float');\r\n    const extension = helper.getExtension('OES_texture_float_linear');\r\n    canInterpolate = extension !== null;\r\n  } else {\r\n    textureType = gl.UNSIGNED_BYTE;\r\n    canInterpolate = true;\r\n  }\r\n  bindAndConfigure(gl, texture, interpolate && canInterpolate);\r\n\r\n  const bytesPerRow = data.byteLength / size[1];\r\n  let unpackAlignment = 1;\r\n  if (bytesPerRow % 8 === 0) {\r\n    unpackAlignment = 8;\r\n  } else if (bytesPerRow % 4 === 0) {\r\n    unpackAlignment = 4;\r\n  } else if (bytesPerRow % 2 === 0) {\r\n    unpackAlignment = 2;\r\n  }\r\n\r\n  let format;\r\n  switch (bandCount) {\r\n    case 1: {\r\n      format = gl.LUMINANCE;\r\n      break;\r\n    }\r\n    case 2: {\r\n      format = gl.LUMINANCE_ALPHA;\r\n      break;\r\n    }\r\n    case 3: {\r\n      format = gl.RGB;\r\n      break;\r\n    }\r\n    case 4: {\r\n      format = gl.RGBA;\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error(`Unsupported number of bands: ${bandCount}`);\r\n    }\r\n  }\r\n\r\n  const oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);\r\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\r\n  gl.texImage2D(\r\n    gl.TEXTURE_2D,\r\n    0,\r\n    format,\r\n    size[0],\r\n    size[1],\r\n    0,\r\n    format,\r\n    textureType,\r\n    data,\r\n  );\r\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);\r\n}\r\n\r\n/**\r\n * @type {CanvasRenderingContext2D}\r\n */\r\nlet pixelContext = null;\r\n\r\nfunction createPixelContext() {\r\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\r\n    willReadFrequently: true,\r\n  });\r\n}\r\n\r\n/**\r\n * @typedef {import(\"../DataTile.js\").default|ImageTile|ReprojTile} TileType\r\n */\r\n\r\n/**\r\n * @extends {BaseTileRepresentation<TileType>}\r\n */\r\nclass TileTexture extends BaseTileRepresentation {\r\n  /**\r\n   * @param {import(\"./BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options The tile texture options.\r\n   */\r\n  constructor(options) {\r\n    super(options);\r\n\r\n    /**\r\n     * @type {Array<WebGLTexture>}\r\n     */\r\n    this.textures = [];\r\n\r\n    /**\r\n     * @type {import(\"../size.js\").Size}\r\n     * @private\r\n     */\r\n    this.renderSize_ = toSize(\r\n      options.grid.getTileSize(options.tile.tileCoord[0]),\r\n    );\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.bandCount = NaN;\r\n\r\n    const coords = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\r\n    coords.fromArray([\r\n      0, // P0\r\n      1,\r\n      1, // P1\r\n      1,\r\n      1, // P2\r\n      0,\r\n      0, // P3\r\n      0,\r\n    ]);\r\n    this.helper.flushBufferData(coords);\r\n\r\n    /**\r\n     * @type {WebGLArrayBuffer}\r\n     */\r\n    this.coords = coords;\r\n\r\n    this.setTile(options.tile);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @param {import(\"./Helper.js\").default} helper The WebGL helper.\r\n   */\r\n  setHelper(helper) {\r\n    const gl = this.helper?.getGL();\r\n    if (gl) {\r\n      this.helper.deleteBuffer(this.coords);\r\n      for (let i = 0; i < this.textures.length; ++i) {\r\n        gl.deleteTexture(this.textures[i]);\r\n      }\r\n    }\r\n\r\n    super.setHelper(helper);\r\n\r\n    if (helper) {\r\n      helper.flushBufferData(this.coords);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  uploadTile() {\r\n    const helper = this.helper;\r\n    const gl = helper.getGL();\r\n    const tile = this.tile;\r\n\r\n    this.textures.length = 0;\r\n\r\n    /**\r\n     * @type {import(\"../DataTile.js\").Data}\r\n     */\r\n    let data;\r\n\r\n    if (tile instanceof ImageTile || tile instanceof ReprojTile) {\r\n      data = tile.getImage();\r\n    } else {\r\n      data = tile.getData();\r\n    }\r\n\r\n    const image = asImageLike(data);\r\n    if (image) {\r\n      const texture = gl.createTexture();\r\n      this.textures.push(texture);\r\n      this.bandCount = 4;\r\n      uploadImageTexture(gl, texture, image, tile.interpolate);\r\n      this.setReady();\r\n      return;\r\n    }\r\n\r\n    data = asArrayLike(data);\r\n\r\n    const sourceTileSize = /** @type {DataTile} */ (tile).getSize();\r\n    const pixelSize = [\r\n      sourceTileSize[0] + 2 * this.gutter,\r\n      sourceTileSize[1] + 2 * this.gutter,\r\n    ];\r\n    const isFloat = data instanceof Float32Array;\r\n    const pixelCount = pixelSize[0] * pixelSize[1];\r\n    const DataType = isFloat ? Float32Array : Uint8Array;\r\n    const bytesPerElement = DataType.BYTES_PER_ELEMENT;\r\n    const bytesPerRow = data.byteLength / pixelSize[1];\r\n\r\n    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\r\n    const textureCount = Math.ceil(this.bandCount / 4);\r\n\r\n    if (textureCount === 1) {\r\n      const texture = gl.createTexture();\r\n      this.textures.push(texture);\r\n      uploadDataTexture(\r\n        helper,\r\n        texture,\r\n        data,\r\n        pixelSize,\r\n        this.bandCount,\r\n        tile.interpolate,\r\n      );\r\n      this.setReady();\r\n      return;\r\n    }\r\n\r\n    const textureDataArrays = new Array(textureCount);\r\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\r\n      const texture = gl.createTexture();\r\n      this.textures.push(texture);\r\n\r\n      const bandCount =\r\n        textureIndex < textureCount - 1 ? 4 : ((this.bandCount - 1) % 4) + 1;\r\n      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);\r\n    }\r\n\r\n    let dataIndex = 0;\r\n    let rowOffset = 0;\r\n    const colCount = pixelSize[0] * this.bandCount;\r\n    for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\r\n      for (let colIndex = 0; colIndex < colCount; ++colIndex) {\r\n        const dataValue = data[rowOffset + colIndex];\r\n\r\n        const pixelIndex = Math.floor(dataIndex / this.bandCount);\r\n        const bandIndex = colIndex % this.bandCount;\r\n        const textureIndex = Math.floor(bandIndex / 4);\r\n        const textureData = textureDataArrays[textureIndex];\r\n        const bandCount = textureData.length / pixelCount;\r\n        const textureBandIndex = bandIndex % 4;\r\n        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;\r\n\r\n        ++dataIndex;\r\n      }\r\n      rowOffset += bytesPerRow / bytesPerElement;\r\n    }\r\n\r\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\r\n      const texture = this.textures[textureIndex];\r\n      const textureData = textureDataArrays[textureIndex];\r\n      const bandCount = textureData.length / pixelCount;\r\n      uploadDataTexture(\r\n        helper,\r\n        texture,\r\n        textureData,\r\n        pixelSize,\r\n        bandCount,\r\n        tile.interpolate,\r\n      );\r\n    }\r\n\r\n    this.setReady();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../DataTile.js\").ImageLike} image The image.\r\n   * @param {number} renderCol The column index (in rendered tile space).\r\n   * @param {number} renderRow The row index (in rendered tile space).\r\n   * @return {Uint8ClampedArray|null} The data.\r\n   * @private\r\n   */\r\n  getImagePixelData_(image, renderCol, renderRow) {\r\n    const gutter = this.gutter;\r\n    const renderWidth = this.renderSize_[0];\r\n    const renderHeight = this.renderSize_[1];\r\n\r\n    if (!pixelContext) {\r\n      createPixelContext();\r\n    }\r\n    pixelContext.clearRect(0, 0, 1, 1);\r\n\r\n    const sourceWidth = image.width;\r\n    const sourceHeight = image.height;\r\n\r\n    const sourceWidthWithoutGutter = sourceWidth - 2 * gutter;\r\n    const sourceHeightWithoutGutter = sourceHeight - 2 * gutter;\r\n\r\n    const sourceCol =\r\n      gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\r\n\r\n    const sourceRow =\r\n      gutter +\r\n      Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\r\n\r\n    let data;\r\n    try {\r\n      pixelContext.drawImage(image, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);\r\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\r\n    } catch (err) {\r\n      pixelContext = null;\r\n      return null;\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../DataTile.js\").ArrayLike} data The data.\r\n   * @param {import(\"../size.js\").Size} sourceSize The size.\r\n   * @param {number} renderCol The column index (in rendered tile space).\r\n   * @param {number} renderRow The row index (in rendered tile space).\r\n   * @return {import(\"../DataTile.js\").ArrayLike|null} The data.\r\n   * @private\r\n   */\r\n  getArrayPixelData_(data, sourceSize, renderCol, renderRow) {\r\n    const gutter = this.gutter;\r\n    const renderWidth = this.renderSize_[0];\r\n    const renderHeight = this.renderSize_[1];\r\n\r\n    const sourceWidthWithoutGutter = sourceSize[0];\r\n    const sourceHeightWithoutGutter = sourceSize[1];\r\n    const sourceWidth = sourceWidthWithoutGutter + 2 * gutter;\r\n    const sourceHeight = sourceHeightWithoutGutter + 2 * gutter;\r\n\r\n    const sourceCol =\r\n      gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\r\n\r\n    const sourceRow =\r\n      gutter +\r\n      Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\r\n\r\n    if (data instanceof DataView) {\r\n      const bytesPerPixel = data.byteLength / (sourceWidth * sourceHeight);\r\n      const offset = bytesPerPixel * (sourceRow * sourceWidth + sourceCol);\r\n      const buffer = data.buffer.slice(offset, offset + bytesPerPixel);\r\n      return new DataView(buffer);\r\n    }\r\n\r\n    const offset = this.bandCount * (sourceRow * sourceWidth + sourceCol);\r\n    return data.slice(offset, offset + this.bandCount);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel.  If the tile is not loaded, null is returned.\r\n   * @param {number} renderCol The column index (in rendered tile space).\r\n   * @param {number} renderRow The row index (in rendered tile space).\r\n   * @return {import(\"../DataTile.js\").ArrayLike|null} The data.\r\n   */\r\n  getPixelData(renderCol, renderRow) {\r\n    if (!this.loaded) {\r\n      return null;\r\n    }\r\n\r\n    if (this.tile instanceof DataTile) {\r\n      const data = this.tile.getData();\r\n      const arrayData = asArrayLike(data);\r\n      if (arrayData) {\r\n        const sourceSize = this.tile.getSize();\r\n        return this.getArrayPixelData_(\r\n          arrayData,\r\n          sourceSize,\r\n          renderCol,\r\n          renderRow,\r\n        );\r\n      }\r\n      return this.getImagePixelData_(asImageLike(data), renderCol, renderRow);\r\n    }\r\n\r\n    return this.getImagePixelData_(this.tile.getImage(), renderCol, renderRow);\r\n  }\r\n}\r\n\r\nexport default TileTexture;\r\n","/**\r\n * @module CME2D/renderer/Layer\r\n */\r\nimport EventType from '../events/EventType.js';\r\nimport ImageState from '../ImageState.js';\r\nimport Observable from '../Observable.js';\r\nimport {abstract} from '../util.js';\r\n\r\nconst maxStaleKeys = 5;\r\n\r\n/**\r\n * @template {import(\"../layer/Layer.js\").default} LayerType\r\n */\r\nclass LayerRenderer extends Observable {\r\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   */\r\n  constructor(layer) {\r\n    super();\r\n\r\n    /**\r\n     * The renderer is initialized and ready to render.\r\n     * @type {boolean}\r\n     */\r\n    this.ready = true;\r\n\r\n    /** @private */\r\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\r\n\r\n    /**\r\n     * @private\r\n     * @type {LayerType}\r\n     */\r\n    this.layer_ = layer;\r\n\r\n    /**\r\n     * @type {Array<string>}\r\n     * @private\r\n     */\r\n    this.staleKeys_ = new Array();\r\n\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.maxStaleKeys = maxStaleKeys;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<string>} Get the list of stale keys.\r\n   */\r\n  getStaleKeys() {\r\n    return this.staleKeys_;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key The new stale key.\r\n   */\r\n  prependStaleKey(key) {\r\n    this.staleKeys_.unshift(key);\r\n    if (this.staleKeys_.length > this.maxStaleKeys) {\r\n      this.staleKeys_.length = this.maxStaleKeys;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Asynchronous layer level hit detection.\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\r\n   * an array of features.\r\n   */\r\n  getFeatures(pixel) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   */\r\n  getData(pixel) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @abstract\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   */\r\n  prepareFrame(frameState) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @abstract\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement|null} target Target that may be used to render content to.\r\n   * @return {HTMLElement|null} The rendered element.\r\n   */\r\n  renderFrame(frameState, target) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {number} hitTolerance Hit tolerance in pixels.\r\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\r\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\r\n   * @return {T|undefined} Callback result.\r\n   * @template T\r\n   */\r\n  forEachFeatureAtCoordinate(\r\n    coordinate,\r\n    frameState,\r\n    hitTolerance,\r\n    callback,\r\n    matches,\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * @return {LayerType} Layer.\r\n   */\r\n  getLayer() {\r\n    return this.layer_;\r\n  }\r\n\r\n  /**\r\n   * Perform action necessary to get the layer rendered after new fonts have loaded\r\n   * @abstract\r\n   */\r\n  handleFontsChanged() {}\r\n\r\n  /**\r\n   * Handle changes in image state.\r\n   * @param {import(\"../events/Event.js\").default} event Image change event.\r\n   * @private\r\n   */\r\n  handleImageChange_(event) {\r\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\r\n    if (\r\n      image.getState() === ImageState.LOADED ||\r\n      image.getState() === ImageState.ERROR\r\n    ) {\r\n      this.renderIfReadyAndVisible();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load the image if not already loaded, and register the image change\r\n   * listener if needed.\r\n   * @param {import(\"../Image.js\").default} image Image.\r\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\r\n   * @protected\r\n   */\r\n  loadImage(image) {\r\n    let imageState = image.getState();\r\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\r\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\r\n    }\r\n    if (imageState == ImageState.IDLE) {\r\n      image.load();\r\n      imageState = image.getState();\r\n    }\r\n    return imageState == ImageState.LOADED;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  renderIfReadyAndVisible() {\r\n    const layer = this.getLayer();\r\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\r\n      layer.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\r\n  renderDeferred(frameState) {}\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    delete this.layer_;\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default LayerRenderer;\r\n","/**\r\n * @module CME2D/render/Event\r\n */\r\n\r\nimport Event from '../events/Event.js';\r\n\r\nclass RenderEvent extends Event {\r\n  /**\r\n   * @param {import(\"./EventType.js\").default} type Type.\r\n   * @param {import(\"../transform.js\").Transform} [inversePixelTransform] Transform for\r\n   *     CSS pixels to rendered pixels.\r\n   * @param {import(\"../Map.js\").FrameState} [frameState] Frame state.\r\n   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.\r\n   */\r\n  constructor(type, inversePixelTransform, frameState, context) {\r\n    super(type);\r\n\r\n    /**\r\n     * Transform from CSS pixels (relative to the top-left corner of the map viewport)\r\n     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.\r\n     * @type {import(\"../transform.js\").Transform|undefined}\r\n     * @api\r\n     */\r\n    this.inversePixelTransform = inversePixelTransform;\r\n\r\n    /**\r\n     * An object representing the current render frame state.\r\n     * @type {import(\"../Map.js\").FrameState|undefined}\r\n     * @api\r\n     */\r\n    this.frameState = frameState;\r\n\r\n    /**\r\n     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,\r\n     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL\r\n     * context.\r\n     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}\r\n     * @api\r\n     */\r\n    this.context = context;\r\n  }\r\n}\r\n\r\nexport default RenderEvent;\r\n","/**\r\n * @module CME2D/webgl/ContextEventType\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  LOST: 'webglcontextlost',\r\n  RESTORED: 'webglcontextrestored',\r\n};\r\n","/**\r\n * @module CME2D/webgl/PostProcessingPass\r\n */\r\n\r\nimport {getUid} from '../util.js';\r\n\r\nconst DEFAULT_VERTEX_SHADER = `\r\n  precision mediump float;\r\n\r\n  attribute vec2 a_position;\r\n  varying vec2 v_texCoord;\r\n  varying vec2 v_screenCoord;\r\n\r\n  uniform vec2 u_screenSize;\r\n\r\n  void main() {\r\n    v_texCoord = a_position * 0.5 + 0.5;\r\n    v_screenCoord = v_texCoord * u_screenSize;\r\n    gl_Position = vec4(a_position, 0.0, 1.0);\r\n  }\r\n`;\r\n\r\nconst DEFAULT_FRAGMENT_SHADER = `\r\n  precision mediump float;\r\n\r\n  uniform sampler2D u_image;\r\n  uniform float u_opacity;\r\n\r\n  varying vec2 v_texCoord;\r\n\r\n  void main() {\r\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\r\n  }\r\n`;\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\r\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\r\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\r\n * @property {string} [vertexShader] Vertex shader source\r\n * @property {string} [fragmentShader] Fragment shader source\r\n * @property {Object<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\r\n */\r\n\r\n/**\r\n * @typedef {Object} UniformInternalDescription\r\n * @property {import(\"./Helper\").UniformValue} value Value\r\n * @property {WebGLUniformLocation} location Location\r\n * @property {WebGLTexture} [texture] Texture\r\n * @private\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * This class is used to define Post Processing passes with custom shaders and uniforms.\r\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\r\n *\r\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\r\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\r\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\r\n *\r\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\r\n * premultiplied.\r\n *\r\n * Default shaders are shown hereafter:\r\n *\r\n * * Vertex shader:\r\n *\r\n *   ```\r\n *   precision mediump float;\r\n *\r\n *   attribute vec2 a_position;\r\n *   varying vec2 v_texCoord;\r\n *   varying vec2 v_screenCoord;\r\n *\r\n *   uniform vec2 u_screenSize;\r\n *\r\n *   void main() {\r\n *     v_texCoord = a_position * 0.5 + 0.5;\r\n *     v_screenCoord = v_texCoord * u_screenSize;\r\n *     gl_Position = vec4(a_position, 0.0, 1.0);\r\n *   }\r\n *   ```\r\n *\r\n * * Fragment shader:\r\n *\r\n *   ```\r\n *   precision mediump float;\r\n *\r\n *   uniform sampler2D u_image;\r\n *   uniform float u_opacity;\r\n *\r\n *   varying vec2 v_texCoord;\r\n *\r\n *   void main() {\r\n *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\r\n *   }\r\n *   ```\r\n */\r\nclass WebGLPostProcessingPass {\r\n  /**\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @private\r\n     */\r\n    this.gl_ = options.webGlContext;\r\n    const gl = this.gl_;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.scaleRatio_ = options.scaleRatio || 1;\r\n\r\n    /**\r\n     * @type {WebGLTexture}\r\n     * @private\r\n     */\r\n    this.renderTargetTexture_ = gl.createTexture();\r\n\r\n    /**\r\n     * @type {import('../size.js').Size|null}\r\n     * @private\r\n     */\r\n    this.renderTargetTextureSize_ = null;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.frameBuffer_ = gl.createFramebuffer();\r\n    /**\r\n     * @private\r\n     */\r\n    this.depthBuffer_ = gl.createRenderbuffer();\r\n\r\n    // compile the program for the frame buffer\r\n    // TODO: make compilation errors show up\r\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n    gl.shaderSource(\r\n      vertexShader,\r\n      options.vertexShader || DEFAULT_VERTEX_SHADER,\r\n    );\r\n    gl.compileShader(vertexShader);\r\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(\r\n      fragmentShader,\r\n      options.fragmentShader || DEFAULT_FRAGMENT_SHADER,\r\n    );\r\n    gl.compileShader(fragmentShader);\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetProgram_ = gl.createProgram();\r\n    gl.attachShader(this.renderTargetProgram_, vertexShader);\r\n    gl.attachShader(this.renderTargetProgram_, fragmentShader);\r\n    gl.linkProgram(this.renderTargetProgram_);\r\n\r\n    // bind the vertices buffer for the frame buffer\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetVerticesBuffer_ = gl.createBuffer();\r\n    const verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\r\n    gl.bufferData(\r\n      gl.ARRAY_BUFFER,\r\n      new Float32Array(verticesArray),\r\n      gl.STATIC_DRAW,\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetAttribLocation_ = gl.getAttribLocation(\r\n      this.renderTargetProgram_,\r\n      'a_position',\r\n    );\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetUniformLocation_ = gl.getUniformLocation(\r\n      this.renderTargetProgram_,\r\n      'u_screenSize',\r\n    );\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetOpacityLocation_ = gl.getUniformLocation(\r\n      this.renderTargetProgram_,\r\n      'u_opacity',\r\n    );\r\n    /**\r\n     * @private\r\n     */\r\n    this.renderTargetTextureLocation_ = gl.getUniformLocation(\r\n      this.renderTargetProgram_,\r\n      'u_image',\r\n    );\r\n\r\n    /**\r\n     * Holds info about custom uniforms used in the post processing pass\r\n     * @type {Array<UniformInternalDescription>}\r\n     * @private\r\n     */\r\n    this.uniforms_ = [];\r\n    options.uniforms &&\r\n      Object.keys(options.uniforms).forEach((name) => {\r\n        this.uniforms_.push({\r\n          value: options.uniforms[name],\r\n          location: gl.getUniformLocation(this.renderTargetProgram_, name),\r\n        });\r\n      });\r\n  }\r\n\r\n  getRenderTargetTexture() {\r\n    return this.renderTargetTexture_;\r\n  }\r\n\r\n  /**\r\n   * Get the WebGL rendering context\r\n   * @return {WebGLRenderingContext} The rendering context.\r\n   */\r\n  getGL() {\r\n    return this.gl_;\r\n  }\r\n\r\n  /**\r\n   * Initialize the render target texture of the post process, make sure it is at the\r\n   * right size and bind it as a render target for the next draw calls.\r\n   * The last step to be initialized will be the one where the primitives are rendered.\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   */\r\n  init(frameState) {\r\n    const gl = this.getGL();\r\n    const textureSize = [\r\n      gl.drawingBufferWidth * this.scaleRatio_,\r\n      gl.drawingBufferHeight * this.scaleRatio_,\r\n    ];\r\n\r\n    // rendering goes to my buffer\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\r\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.getDepthBuffer());\r\n    gl.viewport(0, 0, textureSize[0], textureSize[1]);\r\n\r\n    // if size has changed: adjust canvas & render target texture\r\n    if (\r\n      !this.renderTargetTextureSize_ ||\r\n      this.renderTargetTextureSize_[0] !== textureSize[0] ||\r\n      this.renderTargetTextureSize_[1] !== textureSize[1]\r\n    ) {\r\n      this.renderTargetTextureSize_ = textureSize;\r\n\r\n      // create a new texture\r\n      const level = 0;\r\n      const internalFormat = gl.RGBA;\r\n      const border = 0;\r\n      const format = gl.RGBA;\r\n      const type = gl.UNSIGNED_BYTE;\r\n      const data = null;\r\n      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        level,\r\n        internalFormat,\r\n        textureSize[0],\r\n        textureSize[1],\r\n        border,\r\n        format,\r\n        type,\r\n        data,\r\n      );\r\n\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n      // bind the texture to the framebuffer\r\n      gl.framebufferTexture2D(\r\n        gl.FRAMEBUFFER,\r\n        gl.COLOR_ATTACHMENT0,\r\n        gl.TEXTURE_2D,\r\n        this.renderTargetTexture_,\r\n        0,\r\n      );\r\n\r\n      gl.renderbufferStorage(\r\n        gl.RENDERBUFFER,\r\n        gl.DEPTH_COMPONENT16,\r\n        textureSize[0],\r\n        textureSize[1],\r\n      );\r\n      gl.framebufferRenderbuffer(\r\n        gl.FRAMEBUFFER,\r\n        gl.DEPTH_ATTACHMENT,\r\n        gl.RENDERBUFFER,\r\n        this.depthBuffer_,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render to the next postprocessing pass (or to the canvas if final pass).\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\r\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\r\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\r\n   */\r\n  apply(frameState, nextPass, preCompose, postCompose) {\r\n    const gl = this.getGL();\r\n    const size = frameState.size;\r\n\r\n    gl.bindFramebuffer(\r\n      gl.FRAMEBUFFER,\r\n      nextPass ? nextPass.getFrameBuffer() : null,\r\n    );\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\r\n\r\n    if (!nextPass) {\r\n      // clear the canvas if we are the first to render to it\r\n      // and preserveDrawingBuffer is true\r\n      const canvasId = getUid(gl.canvas);\r\n      if (!frameState.renderTargets[canvasId]) {\r\n        const attributes = gl.getContextAttributes();\r\n        if (attributes && attributes.preserveDrawingBuffer) {\r\n          gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n          gl.clearDepth(1.0);\r\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        }\r\n\r\n        frameState.renderTargets[canvasId] = true;\r\n      }\r\n    }\r\n\r\n    gl.disable(gl.DEPTH_TEST);\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\r\n\r\n    gl.useProgram(this.renderTargetProgram_);\r\n    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\r\n    gl.vertexAttribPointer(\r\n      this.renderTargetAttribLocation_,\r\n      2,\r\n      gl.FLOAT,\r\n      false,\r\n      0,\r\n      0,\r\n    );\r\n    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\r\n    gl.uniform1i(this.renderTargetTextureLocation_, 0);\r\n\r\n    const opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;\r\n    gl.uniform1f(this.renderTargetOpacityLocation_, opacity);\r\n\r\n    this.applyUniforms(frameState);\r\n\r\n    if (preCompose) {\r\n      preCompose(gl, frameState);\r\n    }\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    if (postCompose) {\r\n      postCompose(gl, frameState);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {WebGLFramebuffer} Frame buffer\r\n   */\r\n  getFrameBuffer() {\r\n    return this.frameBuffer_;\r\n  }\r\n\r\n  /**\r\n   * @return {WebGLRenderbuffer} Depth buffer\r\n   */\r\n  getDepthBuffer() {\r\n    return this.depthBuffer_;\r\n  }\r\n\r\n  /**\r\n   * Sets the custom uniforms based on what was given in the constructor.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @private\r\n   */\r\n  applyUniforms(frameState) {\r\n    const gl = this.getGL();\r\n\r\n    let value;\r\n    let textureSlot = 1;\r\n    this.uniforms_.forEach(function (uniform) {\r\n      value =\r\n        typeof uniform.value === 'function'\r\n          ? uniform.value(frameState)\r\n          : uniform.value;\r\n\r\n      // apply value based on type\r\n      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\r\n        // create a texture & put data\r\n        if (!uniform.texture) {\r\n          uniform.texture = gl.createTexture();\r\n        }\r\n        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);\r\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        if (value instanceof ImageData) {\r\n          gl.texImage2D(\r\n            gl.TEXTURE_2D,\r\n            0,\r\n            gl.RGBA,\r\n            gl.RGBA,\r\n            value.width,\r\n            value.height,\r\n            0,\r\n            gl.UNSIGNED_BYTE,\r\n            new Uint8Array(value.data),\r\n          );\r\n        } else {\r\n          gl.texImage2D(\r\n            gl.TEXTURE_2D,\r\n            0,\r\n            gl.RGBA,\r\n            gl.RGBA,\r\n            gl.UNSIGNED_BYTE,\r\n            value,\r\n          );\r\n        }\r\n\r\n        // fill texture slots\r\n        gl.uniform1i(uniform.location, textureSlot++);\r\n      } else if (Array.isArray(value)) {\r\n        switch (value.length) {\r\n          case 2:\r\n            gl.uniform2f(uniform.location, value[0], value[1]);\r\n            return;\r\n          case 3:\r\n            gl.uniform3f(uniform.location, value[0], value[1], value[2]);\r\n            return;\r\n          case 4:\r\n            gl.uniform4f(\r\n              uniform.location,\r\n              value[0],\r\n              value[1],\r\n              value[2],\r\n              value[3],\r\n            );\r\n            return;\r\n          default:\r\n            return;\r\n        }\r\n      } else if (typeof value === 'number') {\r\n        gl.uniform1f(uniform.location, value);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default WebGLPostProcessingPass;\r\n","/**\r\n * @module CME2D/vec/mat4\r\n */\r\n\r\n/**\r\n * @return {Array<number>} \"4x4 matrix representing a 3D identity transform.\"\r\n */\r\nexport function create() {\r\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\r\n}\r\n\r\n/**\r\n * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.\r\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\r\n * @return {Array<number>} \"2D transformation matrix as flattened 4x4 matrix.\"\r\n */\r\nexport function fromTransform(mat4, transform) {\r\n  mat4[0] = transform[0];\r\n  mat4[1] = transform[1];\r\n  mat4[4] = transform[2];\r\n  mat4[5] = transform[3];\r\n  mat4[12] = transform[4];\r\n  mat4[13] = transform[5];\r\n  return mat4;\r\n}\r\n","/**\r\n * @module CME2D/webgl/Helper\r\n */\r\nimport ContextEventType from '../webgl/ContextEventType.js';\r\nimport Disposable from '../Disposable.js';\r\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\r\nimport {\r\n  FLOAT,\r\n  UNSIGNED_BYTE,\r\n  UNSIGNED_INT,\r\n  UNSIGNED_SHORT,\r\n  getContext,\r\n} from '../webgl.js';\r\nimport {clear} from '../obj.js';\r\nimport {\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n} from '../transform.js';\r\nimport {create, fromTransform} from '../vec/mat4.js';\r\nimport {getUid} from '../util.js';\r\n\r\n/**\r\n * @typedef {Object} BufferCacheEntry\r\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\r\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\r\n */\r\n\r\n/**\r\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\r\n * @enum {number}\r\n */\r\nexport const ShaderType = {\r\n  FRAGMENT_SHADER: 0x8b30,\r\n  VERTEX_SHADER: 0x8b31,\r\n};\r\n\r\n/**\r\n * Names of uniforms made available to all shaders.\r\n * Please note: changing these *will* break custom shaders!\r\n * @enum {string}\r\n */\r\nexport const DefaultUniform = {\r\n  PROJECTION_MATRIX: 'u_projectionMatrix',\r\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\r\n  TIME: 'u_time',\r\n  ZOOM: 'u_zoom',\r\n  RESOLUTION: 'u_resolution',\r\n  ROTATION: 'u_rotation',\r\n  VIEWPORT_SIZE_PX: 'u_viewportSizePx',\r\n  PIXEL_RATIO: 'u_pixelRatio',\r\n  HIT_DETECTION: 'u_hitDetection',\r\n};\r\n\r\n/**\r\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\r\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\r\n * @enum {number}\r\n */\r\nexport const AttributeType = {\r\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\r\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\r\n  UNSIGNED_INT: UNSIGNED_INT,\r\n  FLOAT: FLOAT,\r\n};\r\n\r\n/**\r\n * Description of an attribute in a buffer\r\n * @typedef {Object} AttributeDescription\r\n * @property {string} name Attribute name to use in shaders\r\n * @property {number} size Number of components per attributes\r\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\r\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\r\n * Default is `FLOAT`.\r\n */\r\n\r\n/**\r\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|WebGLTexture|import(\"../transform\").Transform} UniformLiteralValue\r\n */\r\n\r\n/**\r\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\r\n * one of the previous types.\r\n * @typedef {UniformLiteralValue|function(import(\"../Map.js\").FrameState):UniformLiteralValue} UniformValue\r\n */\r\n\r\n/**\r\n * @typedef {Object} PostProcessesOptions\r\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\r\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\r\n * @property {string} [vertexShader] Vertex shader source\r\n * @property {string} [fragmentShader] Fragment shader source\r\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\r\n * names in the provided or default shaders.\r\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\r\n * @property {string} [canvasCacheKey] The cache key for the canvas.\r\n */\r\n\r\n/**\r\n * @typedef {Object} UniformInternalDescription\r\n * @property {string} name Name\r\n * @property {UniformValue} [value] Value\r\n * @property {UniformValue} [prevValue] The previous value.\r\n * @property {WebGLTexture} [texture] Texture\r\n * @private\r\n */\r\n\r\n/**\r\n * @typedef {Object} CanvasCacheItem\r\n * @property {WebGLRenderingContext} context The context of this canvas.\r\n * @property {number} users The count of users of this canvas.\r\n */\r\n\r\n/**\r\n * @type {Object<string,CanvasCacheItem>}\r\n */\r\nconst canvasCache = {};\r\n\r\n/**\r\n * @param {string} key The cache key for the canvas.\r\n * @return {string} The shared cache key.\r\n */\r\nfunction getSharedCanvasCacheKey(key) {\r\n  return 'shared/' + key;\r\n}\r\n\r\nlet uniqueCanvasCacheKeyCount = 0;\r\n\r\n/**\r\n * @return {string} The unique cache key.\r\n */\r\nfunction getUniqueCanvasCacheKey() {\r\n  const key = 'unique/' + uniqueCanvasCacheKeyCount;\r\n  uniqueCanvasCacheKeyCount += 1;\r\n  return key;\r\n}\r\n\r\n/**\r\n * @param {string} key The cache key for the canvas.\r\n * @return {WebGLRenderingContext} The canvas.\r\n */\r\nfunction getOrCreateContext(key) {\r\n  let cacheItem = canvasCache[key];\r\n  if (!cacheItem) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = 1;\r\n    canvas.height = 1;\r\n    canvas.style.position = 'absolute';\r\n    canvas.style.left = '0';\r\n    const context = getContext(canvas);\r\n    cacheItem = {users: 0, context};\r\n    canvasCache[key] = cacheItem;\r\n  }\r\n\r\n  cacheItem.users += 1;\r\n  return cacheItem.context;\r\n}\r\n\r\n/**\r\n * @param {string} key The cache key for the canvas.\r\n */\r\nfunction releaseCanvas(key) {\r\n  const cacheItem = canvasCache[key];\r\n  if (!cacheItem) {\r\n    return;\r\n  }\r\n\r\n  cacheItem.users -= 1;\r\n  if (cacheItem.users > 0) {\r\n    return;\r\n  }\r\n\r\n  const gl = cacheItem.context;\r\n  const extension = gl.getExtension('WEBGL_lose_context');\r\n  if (extension) {\r\n    extension.loseContext();\r\n  }\r\n  const canvas = gl.canvas;\r\n  canvas.width = 1;\r\n  canvas.height = 1;\r\n\r\n  delete canvasCache[key];\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\r\n * directly the WebGL API should not be required anymore.\r\n *\r\n * Several operations are handled by the `WebGLHelper` class:\r\n *\r\n * ### Define custom shaders and uniforms\r\n *\r\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\r\n *\r\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\r\n *   Outputs are:\r\n *\r\n *   * `gl_Position`: position of the vertex in screen space\r\n *\r\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\r\n *\r\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\r\n *\r\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\r\n *   can be changed at every frame and can be of type float, arrays of float or images.\r\n *\r\n *   Shaders must be compiled and assembled into a program like so:\r\n *   ```js\r\n *   // here we simply create two shaders and assemble them in a program which is then used\r\n *   // for subsequent rendering calls; note how a frameState is required to set up a program,\r\n *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)\r\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\r\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\r\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\r\n *   helper.useProgram(this.program, frameState);\r\n *   ```\r\n *\r\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\r\n *   You can also change their value along the way like so:\r\n *   ```js\r\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\r\n *   ```\r\n *\r\n * ### Defining post processing passes\r\n *\r\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\r\n *   while applying special effects in screen space.\r\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\r\n *\r\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\r\n *   A post process step accepts the following options:\r\n *\r\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\r\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\r\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\r\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\r\n *\r\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\r\n *\r\n * ### Binding WebGL buffers and flushing data into them\r\n *\r\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\r\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\r\n *   This is done using {@link bindBuffer}.\r\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\r\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\r\n *\r\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\r\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\r\n *\r\n *   Examples below:\r\n *   ```js\r\n *   // at initialization phase\r\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\r\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\r\n *\r\n *   // when array values have changed\r\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\r\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n *\r\n *   // at rendering phase\r\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\r\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\r\n *   ```\r\n *\r\n * ### Specifying attributes\r\n *\r\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\r\n *   Attributes are used to specify these uses. Specify the attribute names with\r\n *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).\r\n *\r\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\r\n *   ```js\r\n *   // here we indicate that the data array has the following structure:\r\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\r\n *   helper.enableAttributes([\r\n *     {\r\n *        name: 'a_position',\r\n *        size: 2\r\n *     },\r\n *     {\r\n *       name: 'a_offset',\r\n *       size: 2\r\n *     },\r\n *     {\r\n *       name: 'a_texCoord',\r\n *       size: 2\r\n *     }\r\n *   ])\r\n *   ```\r\n *\r\n * ### Rendering primitives\r\n *\r\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\r\n *   ```js\r\n *   // frame preparation step\r\n *   helper.prepareDraw(frameState);\r\n *\r\n *   // call this for every data array that has to be rendered on screen\r\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\r\n *\r\n *   // finalize the rendering by applying post processes\r\n *   helper.finalizeDraw(frameState);\r\n *   ```\r\n *\r\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\r\n */\r\nclass WebGLHelper extends Disposable {\r\n  /**\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n    options = options || {};\r\n\r\n    /** @private */\r\n    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);\r\n\r\n    /** @private */\r\n    this.boundHandleWebGLContextRestored_ =\r\n      this.handleWebGLContextRestored.bind(this);\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.canvasCacheKey_ = options.canvasCacheKey\r\n      ? getSharedCanvasCacheKey(options.canvasCacheKey)\r\n      : getUniqueCanvasCacheKey();\r\n\r\n    /**\r\n     * @private\r\n     * @type {WebGLRenderingContext}\r\n     */\r\n    this.gl_ = getOrCreateContext(this.canvasCacheKey_);\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, BufferCacheEntry>}\r\n     */\r\n    this.bufferCache_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Object>}\r\n     */\r\n    this.extensionCache_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {WebGLProgram}\r\n     */\r\n    this.currentProgram_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type boolean\r\n     */\r\n    this.needsToBeRecreated_ = false;\r\n\r\n    const canvas = this.gl_.canvas;\r\n\r\n    canvas.addEventListener(\r\n      ContextEventType.LOST,\r\n      this.boundHandleWebGLContextLost_,\r\n    );\r\n    canvas.addEventListener(\r\n      ContextEventType.RESTORED,\r\n      this.boundHandleWebGLContextRestored_,\r\n    );\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../transform.js\").Transform}\r\n     */\r\n    this.offsetRotateMatrix_ = createTransform();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../transform.js\").Transform}\r\n     */\r\n    this.offsetScaleMatrix_ = createTransform();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this.tmpMat4_ = create();\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Object<string, WebGLUniformLocation>>}\r\n     */\r\n    this.uniformLocationsByProgram_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object<string, Object<string, number>>}\r\n     */\r\n    this.attribLocationsByProgram_ = {};\r\n\r\n    /**\r\n     * Holds info about custom uniforms used in the post processing pass.\r\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\r\n     * @type {Array<UniformInternalDescription>}\r\n     * @private\r\n     */\r\n    this.uniforms_ = [];\r\n    if (options.uniforms) {\r\n      this.setUniforms(options.uniforms);\r\n    }\r\n\r\n    /**\r\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\r\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\r\n     * the frame buffer logic).\r\n     * @type {Array<WebGLPostProcessingPass>}\r\n     * @private\r\n     */\r\n    this.postProcessPasses_ = options.postProcesses\r\n      ? options.postProcesses.map(\r\n          (options) =>\r\n            new WebGLPostProcessingPass({\r\n              webGlContext: this.gl_,\r\n              scaleRatio: options.scaleRatio,\r\n              vertexShader: options.vertexShader,\r\n              fragmentShader: options.fragmentShader,\r\n              uniforms: options.uniforms,\r\n            }),\r\n        )\r\n      : [new WebGLPostProcessingPass({webGlContext: this.gl_})];\r\n\r\n    /**\r\n     * @type {string|null}\r\n     * @private\r\n     */\r\n    this.shaderCompileErrors_ = null;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.startTime_ = Date.now();\r\n  }\r\n\r\n  /**\r\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\r\n   */\r\n  setUniforms(uniforms) {\r\n    this.uniforms_ = [];\r\n    this.addUniforms(uniforms);\r\n  }\r\n\r\n  /**\r\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\r\n   */\r\n  addUniforms(uniforms) {\r\n    for (const name in uniforms) {\r\n      this.uniforms_.push({\r\n        name: name,\r\n        value: uniforms[name],\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} canvasCacheKey The canvas cache key.\r\n   * @return {boolean} The provided key matches the one this helper was constructed with.\r\n   */\r\n  canvasCacheKeyMatches(canvasCacheKey) {\r\n    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);\r\n  }\r\n\r\n  /**\r\n   * Get a WebGL extension.  If the extension is not supported, null is returned.\r\n   * Extensions are cached after they are enabled for the first time.\r\n   * @param {string} name The extension name.\r\n   * @return {Object|null} The extension or null if not supported.\r\n   */\r\n  getExtension(name) {\r\n    if (name in this.extensionCache_) {\r\n      return this.extensionCache_[name];\r\n    }\r\n    const extension = this.gl_.getExtension(name);\r\n    this.extensionCache_[name] = extension;\r\n    return extension;\r\n  }\r\n\r\n  /**\r\n   * Just bind the buffer if it's in the cache. Otherwise create\r\n   * the WebGL buffer, bind it, populate it, and add an entry to\r\n   * the cache.\r\n   * @param {import(\"./Buffer\").default} buffer Buffer.\r\n   */\r\n  bindBuffer(buffer) {\r\n    const gl = this.gl_;\r\n    const bufferKey = getUid(buffer);\r\n    let bufferCache = this.bufferCache_[bufferKey];\r\n    if (!bufferCache) {\r\n      const webGlBuffer = gl.createBuffer();\r\n      bufferCache = {\r\n        buffer: buffer,\r\n        webGlBuffer: webGlBuffer,\r\n      };\r\n      this.bufferCache_[bufferKey] = bufferCache;\r\n    }\r\n    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\r\n  }\r\n\r\n  /**\r\n   * Update the data contained in the buffer array; this is required for the\r\n   * new data to be rendered\r\n   * @param {import(\"./Buffer\").default} buffer Buffer.\r\n   */\r\n  flushBufferData(buffer) {\r\n    const gl = this.gl_;\r\n    this.bindBuffer(buffer);\r\n    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"./Buffer.js\").default} buf Buffer.\r\n   */\r\n  deleteBuffer(buf) {\r\n    const bufferKey = getUid(buf);\r\n    // Note: gl.deleteBuffer is not called here since we let WebGL garbage collect it automatically\r\n    delete this.bufferCache_[bufferKey];\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    const canvas = this.gl_.canvas;\r\n    canvas.removeEventListener(\r\n      ContextEventType.LOST,\r\n      this.boundHandleWebGLContextLost_,\r\n    );\r\n    canvas.removeEventListener(\r\n      ContextEventType.RESTORED,\r\n      this.boundHandleWebGLContextRestored_,\r\n    );\r\n\r\n    releaseCanvas(this.canvasCacheKey_);\r\n\r\n    delete this.gl_;\r\n  }\r\n\r\n  /**\r\n   * Clear the buffer & set the viewport to draw.\r\n   * Post process passes will be initialized here, the first one being bound as a render target for\r\n   * subsequent draw calls.\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\r\n   * @param {boolean} [enableDepth] If true, enables depth testing.\r\n   */\r\n  prepareDraw(frameState, disableAlphaBlend, enableDepth) {\r\n    const gl = this.gl_;\r\n    const canvas = this.getCanvas();\r\n    const size = frameState.size;\r\n    const pixelRatio = frameState.pixelRatio;\r\n\r\n    if (\r\n      canvas.width !== size[0] * pixelRatio ||\r\n      canvas.height !== size[1] * pixelRatio\r\n    ) {\r\n      canvas.width = size[0] * pixelRatio;\r\n      canvas.height = size[1] * pixelRatio;\r\n      canvas.style.width = size[0] + 'px';\r\n      canvas.style.height = size[1] + 'px';\r\n    }\r\n\r\n    // loop backwards in post processes list\r\n    for (let i = this.postProcessPasses_.length - 1; i >= 0; i--) {\r\n      this.postProcessPasses_[i].init(frameState);\r\n    }\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n\r\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n    gl.depthRange(0.0, 1.0);\r\n    gl.clearDepth(1.0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\r\n    if (enableDepth) {\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.depthFunc(gl.LEQUAL);\r\n    } else {\r\n      gl.disable(gl.DEPTH_TEST);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLFramebuffer|null} frameBuffer The frame buffer.\r\n   * @param {WebGLTexture} [texture] The texture.\r\n   */\r\n  bindFrameBuffer(frameBuffer, texture) {\r\n    const gl = this.getGL();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\r\n    if (texture) {\r\n      gl.framebufferTexture2D(\r\n        gl.FRAMEBUFFER,\r\n        gl.COLOR_ATTACHMENT0,\r\n        gl.TEXTURE_2D,\r\n        texture,\r\n        0,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bind the frame buffer from the initial render.\r\n   */\r\n  bindInitialFrameBuffer() {\r\n    const gl = this.getGL();\r\n    const frameBuffer = this.postProcessPasses_[0].getFrameBuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\r\n    const texture = this.postProcessPasses_[0].getRenderTargetTexture();\r\n    gl.framebufferTexture2D(\r\n      gl.FRAMEBUFFER,\r\n      gl.COLOR_ATTACHMENT0,\r\n      gl.TEXTURE_2D,\r\n      texture,\r\n      0,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Prepare a program to use a texture.\r\n   * @param {WebGLTexture} texture The texture.\r\n   * @param {number} slot The texture slot.\r\n   * @param {string} uniformName The corresponding uniform name.\r\n   */\r\n  bindTexture(texture, slot, uniformName) {\r\n    const gl = this.gl_;\r\n    gl.activeTexture(gl.TEXTURE0 + slot);\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.uniform1i(this.getUniformLocation(uniformName), slot);\r\n  }\r\n\r\n  /**\r\n   * Set up an attribute array buffer for use in the vertex shader.\r\n   * @param {import(\"./Buffer\").default} buffer The buffer.\r\n   * @param {string} attributeName The attribute name.\r\n   * @param {number} size The number of components per attribute vertex.\r\n   */\r\n  bindAttribute(buffer, attributeName, size) {\r\n    const gl = this.getGL();\r\n    this.bindBuffer(buffer);\r\n    const index = this.getAttributeLocation(attributeName);\r\n    gl.enableVertexAttribArray(index);\r\n    gl.vertexAttribPointer(index, size, gl.FLOAT, false, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Clear the render target & bind it for future draw operations.\r\n   * This is similar to `prepareDraw`, only post processes will not be applied.\r\n   * Note: the whole viewport will be drawn to the render target, regardless of its size.\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\r\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\r\n   * @param {boolean} [enableDepth] If true, enables depth testing.\r\n   */\r\n  prepareDrawToRenderTarget(\r\n    frameState,\r\n    renderTarget,\r\n    disableAlphaBlend,\r\n    enableDepth,\r\n  ) {\r\n    const gl = this.gl_;\r\n    const size = renderTarget.getSize();\r\n\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\r\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderTarget.getDepthbuffer());\r\n    gl.viewport(0, 0, size[0], size[1]);\r\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\r\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n    gl.depthRange(0.0, 1.0);\r\n    gl.clearDepth(1.0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\r\n    if (enableDepth) {\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.depthFunc(gl.LEQUAL);\r\n    } else {\r\n      gl.disable(gl.DEPTH_TEST);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute a draw call based on the currently bound program, texture, buffers, attributes.\r\n   * @param {number} start Start index.\r\n   * @param {number} end End index.\r\n   */\r\n  drawElements(start, end) {\r\n    const gl = this.gl_;\r\n    this.getExtension('OES_element_index_uint');\r\n\r\n    const elementType = gl.UNSIGNED_INT;\r\n    const elementSize = 4;\r\n\r\n    const numItems = end - start;\r\n    const offsetInBytes = start * elementSize;\r\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\r\n  }\r\n\r\n  /**\r\n   * Apply the successive post process passes which will eventually render to the actual canvas.\r\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\r\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\r\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\r\n   */\r\n  finalizeDraw(frameState, preCompose, postCompose) {\r\n    // apply post processes using the next one as target\r\n    for (let i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {\r\n      if (i === ii - 1) {\r\n        this.postProcessPasses_[i].apply(\r\n          frameState,\r\n          null,\r\n          preCompose,\r\n          postCompose,\r\n        );\r\n      } else {\r\n        this.postProcessPasses_[i].apply(\r\n          frameState,\r\n          this.postProcessPasses_[i + 1],\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Canvas.\r\n   */\r\n  getCanvas() {\r\n    return /** @type {HTMLCanvasElement} */ (this.gl_.canvas);\r\n  }\r\n\r\n  /**\r\n   * Get the WebGL rendering context\r\n   * @return {WebGLRenderingContext} The rendering context.\r\n   */\r\n  getGL() {\r\n    return this.gl_;\r\n  }\r\n\r\n  /**\r\n   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\r\n  applyFrameState(frameState) {\r\n    const size = frameState.size;\r\n    const rotation = frameState.viewState.rotation;\r\n    const pixelRatio = frameState.pixelRatio;\r\n\r\n    this.setUniformFloatValue(\r\n      DefaultUniform.TIME,\r\n      (Date.now() - this.startTime_) * 0.001,\r\n    );\r\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\r\n    this.setUniformFloatValue(\r\n      DefaultUniform.RESOLUTION,\r\n      frameState.viewState.resolution,\r\n    );\r\n    this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);\r\n    this.setUniformFloatVec2(DefaultUniform.VIEWPORT_SIZE_PX, [\r\n      size[0],\r\n      size[1],\r\n    ]);\r\n    this.setUniformFloatValue(DefaultUniform.ROTATION, rotation);\r\n  }\r\n\r\n  /**\r\n   * Sets the `u_hitDetection` uniform.\r\n   * @param {boolean} enabled Whether to enable the hit detection code path\r\n   */\r\n  applyHitDetectionUniform(enabled) {\r\n    const loc = this.getUniformLocation(DefaultUniform.HIT_DETECTION);\r\n    this.getGL().uniform1i(loc, enabled ? 1 : 0);\r\n\r\n    // hit detection uses a fixed pixel ratio\r\n    if (enabled) {\r\n      this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, 0.5);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   */\r\n  applyUniforms(frameState) {\r\n    const gl = this.gl_;\r\n\r\n    let value;\r\n    let textureSlot = 0;\r\n    this.uniforms_.forEach((uniform) => {\r\n      value =\r\n        typeof uniform.value === 'function'\r\n          ? uniform.value(frameState)\r\n          : uniform.value;\r\n\r\n      // apply value based on type\r\n      if (\r\n        value instanceof HTMLCanvasElement ||\r\n        value instanceof HTMLImageElement ||\r\n        value instanceof ImageData ||\r\n        value instanceof WebGLTexture\r\n      ) {\r\n        // create a texture & put data\r\n        if (value instanceof WebGLTexture && !uniform.texture) {\r\n          uniform.prevValue = undefined;\r\n          uniform.texture = value;\r\n        } else if (!uniform.texture) {\r\n          uniform.prevValue = undefined;\r\n          uniform.texture = gl.createTexture();\r\n        }\r\n        this.bindTexture(uniform.texture, textureSlot, uniform.name);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        const imageReady =\r\n          !(value instanceof HTMLImageElement) ||\r\n          /** @type {HTMLImageElement} */ (value).complete;\r\n        if (\r\n          !(value instanceof WebGLTexture) &&\r\n          imageReady &&\r\n          uniform.prevValue !== value\r\n        ) {\r\n          uniform.prevValue = value;\r\n          gl.texImage2D(\r\n            gl.TEXTURE_2D,\r\n            0,\r\n            gl.RGBA,\r\n            gl.RGBA,\r\n            gl.UNSIGNED_BYTE,\r\n            value,\r\n          );\r\n        }\r\n        textureSlot++;\r\n      } else if (Array.isArray(value) && value.length === 6) {\r\n        this.setUniformMatrixValue(\r\n          uniform.name,\r\n          fromTransform(this.tmpMat4_, value),\r\n        );\r\n      } else if (Array.isArray(value) && value.length <= 4) {\r\n        switch (value.length) {\r\n          case 2:\r\n            gl.uniform2f(\r\n              this.getUniformLocation(uniform.name),\r\n              value[0],\r\n              value[1],\r\n            );\r\n            return;\r\n          case 3:\r\n            gl.uniform3f(\r\n              this.getUniformLocation(uniform.name),\r\n              value[0],\r\n              value[1],\r\n              value[2],\r\n            );\r\n            return;\r\n          case 4:\r\n            gl.uniform4f(\r\n              this.getUniformLocation(uniform.name),\r\n              value[0],\r\n              value[1],\r\n              value[2],\r\n              value[3],\r\n            );\r\n            return;\r\n          default:\r\n            return;\r\n        }\r\n      } else if (typeof value === 'number') {\r\n        gl.uniform1f(this.getUniformLocation(uniform.name), value);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set up a program for use. The program will be set as the current one. Then, the uniforms used\r\n   * in the program will be set based on the current frame state and the helper configuration.\r\n   * @param {WebGLProgram} program Program.\r\n   * @param {import(\"../Map.js\").FrameState} [frameState] Frame state.\r\n   */\r\n  useProgram(program, frameState) {\r\n    const gl = this.gl_;\r\n    gl.useProgram(program);\r\n    this.currentProgram_ = program;\r\n    if (frameState) {\r\n      this.applyFrameState(frameState);\r\n      this.applyUniforms(frameState);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Will attempt to compile a vertex or fragment shader based on source\r\n   * On error, the shader will be returned but\r\n   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\r\n   * Use `gl.getShaderInfoLog(shader)` to have details\r\n   * @param {string} source Shader source\r\n   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\r\n   * @return {WebGLShader} Shader object\r\n   */\r\n  compileShader(source, type) {\r\n    const gl = this.gl_;\r\n    const shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    return shader;\r\n  }\r\n\r\n  /**\r\n   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\r\n   * @param {string} fragmentShaderSource Fragment shader source.\r\n   * @param {string} vertexShaderSource Vertex shader source.\r\n   * @return {WebGLProgram} Program\r\n   */\r\n  getProgram(fragmentShaderSource, vertexShaderSource) {\r\n    const gl = this.gl_;\r\n\r\n    const fragmentShader = this.compileShader(\r\n      fragmentShaderSource,\r\n      gl.FRAGMENT_SHADER,\r\n    );\r\n\r\n    const vertexShader = this.compileShader(\r\n      vertexShaderSource,\r\n      gl.VERTEX_SHADER,\r\n    );\r\n\r\n    const program = gl.createProgram();\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.attachShader(program, vertexShader);\r\n    gl.linkProgram(program);\r\n\r\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n      const message = `Fragment shader compilation failed: ${gl.getShaderInfoLog(\r\n        fragmentShader,\r\n      )}`;\r\n      throw new Error(message);\r\n    }\r\n    gl.deleteShader(fragmentShader);\r\n\r\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n      const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(\r\n        vertexShader,\r\n      )}`;\r\n      throw new Error(message);\r\n    }\r\n    gl.deleteShader(vertexShader);\r\n\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n      const message = `GL program linking failed: ${gl.getProgramInfoLog(\r\n        program,\r\n      )}`;\r\n      throw new Error(message);\r\n    }\r\n\r\n    return program;\r\n  }\r\n\r\n  /**\r\n   * Will get the location from the shader or the cache\r\n   * @param {string} name Uniform name\r\n   * @return {WebGLUniformLocation} uniformLocation\r\n   */\r\n  getUniformLocation(name) {\r\n    const programUid = getUid(this.currentProgram_);\r\n    if (this.uniformLocationsByProgram_[programUid] === undefined) {\r\n      this.uniformLocationsByProgram_[programUid] = {};\r\n    }\r\n    if (this.uniformLocationsByProgram_[programUid][name] === undefined) {\r\n      this.uniformLocationsByProgram_[programUid][name] =\r\n        this.gl_.getUniformLocation(this.currentProgram_, name);\r\n    }\r\n    return this.uniformLocationsByProgram_[programUid][name];\r\n  }\r\n\r\n  /**\r\n   * Will get the location from the shader or the cache\r\n   * @param {string} name Attribute name\r\n   * @return {number} attribLocation\r\n   */\r\n  getAttributeLocation(name) {\r\n    const programUid = getUid(this.currentProgram_);\r\n    if (this.attribLocationsByProgram_[programUid] === undefined) {\r\n      this.attribLocationsByProgram_[programUid] = {};\r\n    }\r\n    if (this.attribLocationsByProgram_[programUid][name] === undefined) {\r\n      this.attribLocationsByProgram_[programUid][name] =\r\n        this.gl_.getAttribLocation(this.currentProgram_, name);\r\n    }\r\n    return this.attribLocationsByProgram_[programUid][name];\r\n  }\r\n\r\n  /**\r\n   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.\r\n   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../transform\").Transform} transform Transform to update.\r\n   * @return {import(\"../transform\").Transform} The updated transform object.\r\n   */\r\n  makeProjectionTransform(frameState, transform) {\r\n    const size = frameState.size;\r\n    const rotation = frameState.viewState.rotation;\r\n    const resolution = frameState.viewState.resolution;\r\n    const center = frameState.viewState.center;\r\n    composeTransform(\r\n      transform,\r\n      0,\r\n      0,\r\n      2 / (resolution * size[0]),\r\n      2 / (resolution * size[1]),\r\n      -rotation,\r\n      -center[0],\r\n      -center[1],\r\n    );\r\n    return transform;\r\n  }\r\n\r\n  /**\r\n   * Give a value for a standard float uniform\r\n   * @param {string} uniform Uniform name\r\n   * @param {number} value Value\r\n   */\r\n  setUniformFloatValue(uniform, value) {\r\n    this.gl_.uniform1f(this.getUniformLocation(uniform), value);\r\n  }\r\n\r\n  /**\r\n   * Give a value for a vec2 uniform\r\n   * @param {string} uniform Uniform name\r\n   * @param {Array<number>} value Array of length 4.\r\n   */\r\n  setUniformFloatVec2(uniform, value) {\r\n    this.gl_.uniform2fv(this.getUniformLocation(uniform), value);\r\n  }\r\n\r\n  /**\r\n   * Give a value for a vec4 uniform\r\n   * @param {string} uniform Uniform name\r\n   * @param {Array<number>} value Array of length 4.\r\n   */\r\n  setUniformFloatVec4(uniform, value) {\r\n    this.gl_.uniform4fv(this.getUniformLocation(uniform), value);\r\n  }\r\n\r\n  /**\r\n   * Give a value for a standard matrix4 uniform\r\n   * @param {string} uniform Uniform name\r\n   * @param {Array<number>} value Matrix value\r\n   */\r\n  setUniformMatrixValue(uniform, value) {\r\n    this.gl_.uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\r\n  }\r\n\r\n  /**\r\n   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\r\n   * internally.\r\n   * @param {string} attribName Attribute name\r\n   * @param {number} size Number of components per attributes\r\n   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\r\n   * @param {number} stride Stride in bytes (0 means attribs are packed)\r\n   * @param {number} offset Offset in bytes\r\n   * @private\r\n   */\r\n  enableAttributeArray_(attribName, size, type, stride, offset) {\r\n    const location = this.getAttributeLocation(attribName);\r\n    // the attribute has not been found in the shaders or is not used; do not enable it\r\n    if (location < 0) {\r\n      return;\r\n    }\r\n    this.gl_.enableVertexAttribArray(location);\r\n    this.gl_.vertexAttribPointer(location, size, type, false, stride, offset);\r\n  }\r\n\r\n  /**\r\n   * Will enable the following attributes to be read from the currently bound buffer,\r\n   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\r\n   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\r\n   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\r\n   */\r\n  enableAttributes(attributes) {\r\n    const stride = computeAttributesStride(attributes);\r\n    let offset = 0;\r\n    for (let i = 0; i < attributes.length; i++) {\r\n      const attr = attributes[i];\r\n      this.enableAttributeArray_(\r\n        attr.name,\r\n        attr.size,\r\n        attr.type || FLOAT,\r\n        stride,\r\n        offset,\r\n      );\r\n      offset += attr.size * getByteSizeFromType(attr.type);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * WebGL context was lost\r\n   * @param {WebGLContextEvent} event The context loss event.\r\n   * @private\r\n   */\r\n  handleWebGLContextLost(event) {\r\n    clear(this.bufferCache_);\r\n    this.currentProgram_ = null;\r\n\r\n    event.preventDefault();\r\n  }\r\n\r\n  /**\r\n   * WebGL context was restored\r\n   * @private\r\n   */\r\n  handleWebGLContextRestored() {\r\n    this.needsToBeRecreated_ = true;\r\n  }\r\n\r\n  /**\r\n   * Returns whether this helper needs to be recreated, as the context was lost and then restored.\r\n   * @return {boolean} Whether this helper needs to be recreated.\r\n   */\r\n  needsToBeRecreated() {\r\n    return this.needsToBeRecreated_;\r\n  }\r\n\r\n  /**\r\n   * Will create or reuse a given webgl texture and apply the given size. If no image data\r\n   * specified, the texture will be empty, otherwise image data will be used and the `size`\r\n   * parameter will be ignored.  If a Uint8Array is provided for data, a size must also be provided.\r\n   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\r\n   * @param {Array<number>} size Expected size of the texture\r\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|Uint8Array|null} data Image data/object to bind to the texture\r\n   * @param {WebGLTexture} [texture] Existing texture to reuse\r\n   * @param {boolean} [nearest] Use gl.NEAREST for min/mag filter.\r\n   * @return {WebGLTexture} The generated texture\r\n   */\r\n  createTexture(size, data, texture, nearest) {\r\n    const gl = this.gl_;\r\n    texture = texture || gl.createTexture();\r\n    const filter = nearest ? gl.NEAREST : gl.LINEAR;\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    const level = 0;\r\n    const internalFormat = gl.RGBA;\r\n    const border = 0;\r\n    const format = gl.RGBA;\r\n    const type = gl.UNSIGNED_BYTE;\r\n\r\n    if (data instanceof Uint8Array) {\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        level,\r\n        internalFormat,\r\n        size[0],\r\n        size[1],\r\n        border,\r\n        format,\r\n        type,\r\n        data,\r\n      );\r\n    } else if (data) {\r\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);\r\n    } else {\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        level,\r\n        internalFormat,\r\n        size[0],\r\n        size[1],\r\n        border,\r\n        format,\r\n        type,\r\n        null,\r\n      );\r\n    }\r\n    return texture;\r\n  }\r\n}\r\n\r\n/**\r\n * Compute a stride in bytes based on a list of attributes\r\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\r\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\r\n */\r\nexport function computeAttributesStride(attributes) {\r\n  let stride = 0;\r\n  for (let i = 0; i < attributes.length; i++) {\r\n    const attr = attributes[i];\r\n    stride += attr.size * getByteSizeFromType(attr.type);\r\n  }\r\n  return stride;\r\n}\r\n\r\n/**\r\n * Computes the size in byte of an attribute type.\r\n * @param {AttributeType} type Attribute type\r\n * @return {number} The size in bytes\r\n */\r\nfunction getByteSizeFromType(type) {\r\n  switch (type) {\r\n    case AttributeType.UNSIGNED_BYTE:\r\n      return Uint8Array.BYTES_PER_ELEMENT;\r\n    case AttributeType.UNSIGNED_SHORT:\r\n      return Uint16Array.BYTES_PER_ELEMENT;\r\n    case AttributeType.UNSIGNED_INT:\r\n      return Uint32Array.BYTES_PER_ELEMENT;\r\n    case AttributeType.FLOAT:\r\n    default:\r\n      return Float32Array.BYTES_PER_ELEMENT;\r\n  }\r\n}\r\n\r\nexport default WebGLHelper;\r\n","/**\r\n * @module CME2D/renderer/webgl/Layer\r\n */\r\nimport LayerProperty from '../../layer/Property.js';\r\nimport LayerRenderer from '../Layer.js';\r\nimport RenderEvent from '../../render/Event.js';\r\nimport RenderEventType from '../../render/EventType.js';\r\nimport WebGLHelper from '../../webgl/Helper.js';\r\nimport {\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n} from '../../transform.js';\r\n\r\n/**\r\n * @typedef {Object} PostProcessesOptions\r\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\r\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\r\n * @property {string} [vertexShader] Vertex shader source\r\n * @property {string} [fragmentShader] Fragment shader source\r\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\r\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base WebGL renderer class.\r\n * Holds all logic related to data manipulation & some common rendering logic\r\n * @template {import(\"../../layer/Layer.js\").default} LayerType\r\n * @extends {LayerRenderer<LayerType>}\r\n */\r\nclass WebGLLayerRenderer extends LayerRenderer {\r\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(layer, options) {\r\n    super(layer);\r\n\r\n    options = options || {};\r\n\r\n    /**\r\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\r\n     * set before dispatching rendering events.\r\n     * @private\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.inversePixelTransform_ = createTransform();\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.postProcesses_ = options.postProcesses;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.uniforms_ = options.uniforms;\r\n\r\n    /**\r\n     * @type {WebGLHelper}\r\n     * @protected\r\n     */\r\n    this.helper;\r\n\r\n    this.onMapChanged_ = () => {\r\n      this.clearCache();\r\n      this.removeHelper();\r\n    };\r\n\r\n    layer.addChangeListener(LayerProperty.MAP, this.onMapChanged_);\r\n\r\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\r\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  dispatchPreComposeEvent(context, frameState) {\r\n    const layer = this.getLayer();\r\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\r\n      const event = new RenderEvent(\r\n        RenderEventType.PRECOMPOSE,\r\n        undefined,\r\n        frameState,\r\n        context,\r\n      );\r\n      layer.dispatchEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  dispatchPostComposeEvent(context, frameState) {\r\n    const layer = this.getLayer();\r\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\r\n      const event = new RenderEvent(\r\n        RenderEventType.POSTCOMPOSE,\r\n        undefined,\r\n        frameState,\r\n        context,\r\n      );\r\n      layer.dispatchEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset options (only handles uniforms).\r\n   * @param {Options} options Options.\r\n   */\r\n  reset(options) {\r\n    this.uniforms_ = options.uniforms;\r\n    if (this.helper) {\r\n      this.helper.setUniforms(this.uniforms_);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  removeHelper() {\r\n    if (this.helper) {\r\n      this.helper.dispose();\r\n      delete this.helper;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine whether renderFrame should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   * @override\r\n   */\r\n  prepareFrame(frameState) {\r\n    if (this.getLayer().getRenderSource()) {\r\n      let incrementGroup = true;\r\n      let groupNumber = -1;\r\n      let className;\r\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\r\n        const layer = frameState.layerStatesArray[i].layer;\r\n        const renderer = layer.getRenderer();\r\n        if (!(renderer instanceof WebGLLayerRenderer)) {\r\n          incrementGroup = true;\r\n          continue;\r\n        }\r\n        const layerClassName = layer.getClassName();\r\n        if (incrementGroup || layerClassName !== className) {\r\n          groupNumber += 1;\r\n          incrementGroup = false;\r\n        }\r\n        className = layerClassName;\r\n        if (renderer === this) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      const canvasCacheKey =\r\n        'map/' + frameState.mapId + '/group/' + groupNumber;\r\n\r\n      if (\r\n        !this.helper ||\r\n        !this.helper.canvasCacheKeyMatches(canvasCacheKey) ||\r\n        this.helper.needsToBeRecreated()\r\n      ) {\r\n        this.removeHelper();\r\n\r\n        this.helper = new WebGLHelper({\r\n          postProcesses: this.postProcesses_,\r\n          uniforms: this.uniforms_,\r\n          canvasCacheKey: canvasCacheKey,\r\n        });\r\n\r\n        if (className) {\r\n          this.helper.getCanvas().className = className;\r\n        }\r\n\r\n        this.afterHelperCreated();\r\n      }\r\n    }\r\n\r\n    return this.prepareFrameInternal(frameState);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  afterHelperCreated() {}\r\n\r\n  /**\r\n   * Determine whether renderFrame should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   * @protected\r\n   */\r\n  prepareFrameInternal(frameState) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  clearCache() {}\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    this.clearCache();\r\n    this.removeHelper();\r\n    this.getLayer()?.removeChangeListener(\r\n      LayerProperty.MAP,\r\n      this.onMapChanged_,\r\n    );\r\n    super.disposeInternal();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\r\n   * @param {WebGLRenderingContext} context The rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @private\r\n   */\r\n  dispatchRenderEvent_(type, context, frameState) {\r\n    const layer = this.getLayer();\r\n    if (layer.hasListener(type)) {\r\n      composeTransform(\r\n        this.inversePixelTransform_,\r\n        0,\r\n        0,\r\n        frameState.pixelRatio,\r\n        -frameState.pixelRatio,\r\n        0,\r\n        0,\r\n        -frameState.size[1],\r\n      );\r\n\r\n      const event = new RenderEvent(\r\n        type,\r\n        this.inversePixelTransform_,\r\n        frameState,\r\n        context,\r\n      );\r\n      layer.dispatchEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} context The rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  preRender(context, frameState) {\r\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} context The rendering context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  postRender(context, frameState) {\r\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\r\n  }\r\n}\r\n\r\nexport default WebGLLayerRenderer;\r\n","/**\r\n * @module CME2D/renderer/webgl/TileLayerBase\r\n */\r\nimport LRUCache from '../../structs/LRUCache.js';\r\nimport ReprojDataTile from '../../reproj/DataTile.js';\r\nimport ReprojTile from '../../reproj/Tile.js';\r\nimport TileRange from '../../TileRange.js';\r\nimport TileState from '../../TileState.js';\r\nimport WebGLLayerRenderer from './Layer.js';\r\nimport {abstract, getUid} from '../../util.js';\r\nimport {create as createMat4} from '../../vec/mat4.js';\r\nimport {\r\n  createOrUpdate as createTileCoord,\r\n  getKey as getTileCoordKey,\r\n} from '../../tilecoord.js';\r\nimport {\r\n  create as createTransform,\r\n  reset as resetTransform,\r\n  rotate as rotateTransform,\r\n  scale as scaleTransform,\r\n  translate as translateTransform,\r\n} from '../../transform.js';\r\nimport {descending} from '../../array.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\nimport {getIntersection, isEmpty} from '../../extent.js';\r\nimport {toSize} from '../../size.js';\r\n\r\nexport const Uniforms = {\r\n  TILE_TRANSFORM: 'u_tileTransform',\r\n  TRANSITION_ALPHA: 'u_transitionAlpha',\r\n  DEPTH: 'u_depth',\r\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\r\n  PATTERN_ORIGIN: 'u_patternOrigin',\r\n  RESOLUTION: 'u_resolution',\r\n  ZOOM: 'u_zoom',\r\n  GLOBAL_ALPHA: 'u_globalAlpha',\r\n  PROJECTION_MATRIX: 'u_projectionMatrix',\r\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\r\n};\r\n\r\n/**\r\n * @type {Object<string, boolean>}\r\n */\r\nconst empty = {};\r\n\r\n/**\r\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\r\n * have a depth trending towards 0\r\n * @param {number} z A zoom level.\r\n * @return {number} A depth value.\r\n */\r\nfunction depthForZ(z) {\r\n  return 1 / (z + 2);\r\n}\r\n\r\n/**\r\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\r\n */\r\n/**\r\n * @typedef {Object} TileRepresentationLookup\r\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\r\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\r\n */\r\n\r\n/**\r\n * @return {TileRepresentationLookup} A new tile representation lookup.\r\n */\r\nexport function newTileRepresentationLookup() {\r\n  return {tileIds: new Set(), representationsByZ: {}};\r\n}\r\n\r\n/**\r\n * Check if a tile is already in the tile representation lookup.\r\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\r\n * @param {import(\"../../Tile.js\").default} tile A tile.\r\n * @return {boolean} The tile is already in the lookup.\r\n */\r\nfunction lookupHasTile(tileRepresentationLookup, tile) {\r\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\r\n}\r\n\r\n/**\r\n * Add a tile representation to the lookup.\r\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\r\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\r\n * @param {number} z The zoom level.\r\n */\r\nfunction addTileRepresentationToLookup(\r\n  tileRepresentationLookup,\r\n  tileRepresentation,\r\n  z,\r\n) {\r\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\r\n  if (!(z in representationsByZ)) {\r\n    representationsByZ[z] = new Set();\r\n  }\r\n  representationsByZ[z].add(tileRepresentation);\r\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\r\n}\r\n\r\n/**\r\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\r\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\r\n */\r\nfunction getRenderExtent(frameState, extent) {\r\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n  if (layerState.extent) {\r\n    extent = getIntersection(\r\n      extent,\r\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\r\n    );\r\n  }\r\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\r\n    layerState.layer.getRenderSource()\r\n  );\r\n  if (!source.getWrapX()) {\r\n    const gridExtent = source\r\n      .getTileGridForProjection(frameState.viewState.projection)\r\n      .getExtent();\r\n    if (gridExtent) {\r\n      extent = getIntersection(extent, gridExtent);\r\n    }\r\n  }\r\n  return extent;\r\n}\r\n\r\nexport function getCacheKey(source, tileCoord) {\r\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\r\n}\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\r\n * made available to shaders.\r\n * @property {number} [cacheSize=512] The tile representation cache size.\r\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base WebGL renderer for tile layers.\r\n * @template {BaseLayerType} LayerType\r\n * @template {import(\"../../Tile.js\").default} TileType\r\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\r\n * @extends {WebGLLayerRenderer<LayerType>}\r\n */\r\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\r\n  /**\r\n   * @param {LayerType} tileLayer Tile layer.\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(tileLayer, options) {\r\n    super(tileLayer, {\r\n      uniforms: options.uniforms,\r\n      postProcesses: options.postProcesses,\r\n    });\r\n\r\n    /**\r\n     * The last call to `renderFrame` was completed with all tiles loaded\r\n     * @type {boolean}\r\n     */\r\n    this.renderComplete = false;\r\n\r\n    /**\r\n     * This transform converts representation coordinates to screen coordinates.\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     * @private\r\n     */\r\n    this.tileTransform_ = createTransform();\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     * @protected\r\n     */\r\n    this.tempMat4 = createMat4();\r\n\r\n    /**\r\n     * @type {import(\"../../TileRange.js\").default}\r\n     * @private\r\n     */\r\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\r\n\r\n    /**\r\n     * @type {import(\"../../tilecoord.js\").TileCoord}\r\n     * @private\r\n     */\r\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\r\n\r\n    /**\r\n     * @type {import(\"../../size.js\").Size}\r\n     * @private\r\n     */\r\n    this.tempSize_ = [0, 0];\r\n\r\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\r\n    /**\r\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\r\n     * @protected\r\n     */\r\n    this.tileRepresentationCache = new LRUCache(cacheSize);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../Map.js\").FrameState|null}\r\n     */\r\n    this.frameState = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../../proj/Projection.js\").default}\r\n     */\r\n    this.projection_ = undefined;\r\n  }\r\n\r\n  /**\r\n   * @param {Options} options Options.\r\n   * @override\r\n   */\r\n  reset(options) {\r\n    super.reset({\r\n      uniforms: options.uniforms,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Determine whether renderFrame should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   * @override\r\n   */\r\n  prepareFrameInternal(frameState) {\r\n    if (!this.projection_) {\r\n      this.projection_ = frameState.viewState.projection;\r\n    } else if (frameState.viewState.projection !== this.projection_) {\r\n      this.clearCache();\r\n      this.projection_ = frameState.viewState.projection;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const source = layer.getRenderSource();\r\n    if (!source) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\r\n      return false;\r\n    }\r\n    return source.getState() === 'ready';\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\r\n   * @return {TileRepresentation} A new tile representation\r\n   * @protected\r\n   */\r\n  createTileRepresentation(options) {\r\n    return abstract();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\r\n   * @param {number} initialZ The zoom level.\r\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\r\n   * @param {number} preload Number of additional levels to load.\r\n   */\r\n  enqueueTiles(\r\n    frameState,\r\n    extent,\r\n    initialZ,\r\n    tileRepresentationLookup,\r\n    preload,\r\n  ) {\r\n    const viewState = frameState.viewState;\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getRenderSource();\r\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\r\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\r\n\r\n    const tileSourceKey = getUid(tileSource);\r\n    if (!(tileSourceKey in frameState.wantedTiles)) {\r\n      frameState.wantedTiles[tileSourceKey] = {};\r\n    }\r\n\r\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\r\n    const tileRepresentationCache = this.tileRepresentationCache;\r\n\r\n    const map = tileLayer.getMapInternal();\r\n    const minZ = Math.max(\r\n      initialZ - preload,\r\n      tileGrid.getMinZoom(),\r\n      tileGrid.getZForResolution(\r\n        Math.min(\r\n          tileLayer.getMaxResolution(),\r\n          map\r\n            ? map\r\n                .getView()\r\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\r\n            : tileGrid.getResolution(0),\r\n        ),\r\n        tileSource.zDirection,\r\n      ),\r\n    );\r\n    for (let z = initialZ; z >= minZ; --z) {\r\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\r\n        extent,\r\n        z,\r\n        this.tempTileRange_,\r\n      );\r\n\r\n      const tileResolution = tileGrid.getResolution(z);\r\n\r\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\r\n          const cacheKey = getCacheKey(tileSource, tileCoord);\r\n\r\n          /** @type {TileRepresentation} */\r\n          let tileRepresentation;\r\n\r\n          /** @type {TileType} */\r\n          let tile;\r\n\r\n          if (tileRepresentationCache.containsKey(cacheKey)) {\r\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\r\n            tile = tileRepresentation.tile;\r\n          }\r\n          if (\r\n            !tileRepresentation ||\r\n            tileRepresentation.tile.key !== tileSource.getKey()\r\n          ) {\r\n            tile = tileSource.getTile(\r\n              z,\r\n              x,\r\n              y,\r\n              frameState.pixelRatio,\r\n              viewState.projection,\r\n            );\r\n            if (!tile) {\r\n              continue;\r\n            }\r\n          }\r\n\r\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\r\n            continue;\r\n          }\r\n\r\n          if (!tileRepresentation) {\r\n            tileRepresentation = this.createTileRepresentation({\r\n              tile: tile,\r\n              grid: tileGrid,\r\n              helper: this.helper,\r\n              gutter: gutter,\r\n            });\r\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\r\n          } else {\r\n            tileRepresentation.setTile(tile);\r\n          }\r\n\r\n          addTileRepresentationToLookup(\r\n            tileRepresentationLookup,\r\n            tileRepresentation,\r\n            z,\r\n          );\r\n\r\n          const tileQueueKey = tile.getKey();\r\n          wantedTiles[tileQueueKey] = true;\r\n\r\n          if (tile.getState() === TileState.IDLE) {\r\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\r\n              frameState.tileQueue.enqueue([\r\n                tile,\r\n                tileSourceKey,\r\n                tileGrid.getTileCoordCenter(tileCoord),\r\n                tileResolution,\r\n              ]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\r\n   * @protected\r\n   */\r\n  beforeTilesRender(frameState, tilesWithAlpha) {\r\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} If returns false, tile mask rendering will be skipped\r\n   * @protected\r\n   */\r\n  beforeTilesMaskRender(frameState) {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @param {TileRepresentation} tileRepresentation Tile representation\r\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\r\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\r\n   * @param {number} tileResolution Tile resolution\r\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\r\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\r\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\r\n   * @param {number} depth Depth\r\n   * @param {number} gutter Gutter\r\n   * @param {number} alpha Alpha\r\n   * @protected\r\n   */\r\n  renderTile(\r\n    tileRepresentation,\r\n    tileTransform,\r\n    frameState,\r\n    renderExtent,\r\n    tileResolution,\r\n    tileSize,\r\n    tileOrigin,\r\n    tileExtent,\r\n    depth,\r\n    gutter,\r\n    alpha,\r\n  ) {}\r\n\r\n  /**\r\n   * @param {TileRepresentation} tileRepresentation Tile representation\r\n   * @param {number} tileZ Tile Z\r\n   * @param {import(\"../../extent.js\").Extent} extent Render extent\r\n   * @param {number} depth Depth\r\n   * @protected\r\n   */\r\n  renderTileMask(tileRepresentation, tileZ, extent, depth) {}\r\n\r\n  drawTile_(\r\n    frameState,\r\n    tileRepresentation,\r\n    tileZ,\r\n    gutter,\r\n    extent,\r\n    alphaLookup,\r\n    tileGrid,\r\n  ) {\r\n    if (!tileRepresentation.ready) {\r\n      return;\r\n    }\r\n    const tile = tileRepresentation.tile;\r\n    const tileCoord = tile.tileCoord;\r\n    const tileCoordKey = getTileCoordKey(tileCoord);\r\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\r\n\r\n    const tileResolution = tileGrid.getResolution(tileZ);\r\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\r\n    const tileOrigin = tileGrid.getOrigin(tileZ);\r\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\r\n    // tiles with alpha are rendered last to allow blending\r\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\r\n    if (alpha < 1) {\r\n      frameState.animate = true;\r\n    }\r\n\r\n    const viewState = frameState.viewState;\r\n    const centerX = viewState.center[0];\r\n    const centerY = viewState.center[1];\r\n\r\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\r\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\r\n\r\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\r\n\r\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\r\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\r\n\r\n    const tileScale = viewState.resolution / tileResolution;\r\n\r\n    const tileCenterI = tileCoord[1];\r\n    const tileCenterJ = tileCoord[2];\r\n\r\n    resetTransform(this.tileTransform_);\r\n    scaleTransform(\r\n      this.tileTransform_,\r\n      2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\r\n      -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter),\r\n    );\r\n    rotateTransform(this.tileTransform_, viewState.rotation);\r\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\r\n    translateTransform(\r\n      this.tileTransform_,\r\n      (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter,\r\n      (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter,\r\n    );\r\n\r\n    this.renderTile(\r\n      /** @type {TileRepresentation} */ (tileRepresentation),\r\n      this.tileTransform_,\r\n      frameState,\r\n      extent,\r\n      tileResolution,\r\n      tileSize,\r\n      tileOrigin,\r\n      tileExtent,\r\n      depth,\r\n      gutter,\r\n      alpha,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {HTMLElement} The rendered element.\r\n   * @override\r\n   */\r\n  renderFrame(frameState) {\r\n    this.frameState = frameState;\r\n    this.renderComplete = true;\r\n    const gl = this.helper.getGL();\r\n    this.preRender(gl, frameState);\r\n\r\n    const viewState = frameState.viewState;\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getRenderSource();\r\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\r\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\r\n    const extent = getRenderExtent(frameState, frameState.extent);\r\n    const z = tileGrid.getZForResolution(\r\n      viewState.resolution,\r\n      tileSource.zDirection,\r\n    );\r\n    /**\r\n     * @type {TileRepresentationLookup}\r\n     */\r\n    const tileRepresentationLookup = newTileRepresentationLookup();\r\n\r\n    const preload = tileLayer.getPreload();\r\n    if (frameState.nextExtent) {\r\n      const targetZ = tileGrid.getZForResolution(\r\n        viewState.nextResolution,\r\n        tileSource.zDirection,\r\n      );\r\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\r\n      this.enqueueTiles(\r\n        frameState,\r\n        nextExtent,\r\n        targetZ,\r\n        tileRepresentationLookup,\r\n        preload,\r\n      );\r\n    }\r\n\r\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\r\n    if (preload > 0) {\r\n      setTimeout(() => {\r\n        this.enqueueTiles(\r\n          frameState,\r\n          extent,\r\n          z - 1,\r\n          tileRepresentationLookup,\r\n          preload - 1,\r\n        );\r\n      }, 0);\r\n    }\r\n\r\n    /**\r\n     * A lookup of alpha values for tiles at the target rendering resolution\r\n     * for tiles that are in transition.  If a tile coord key is absent from\r\n     * this lookup, the tile should be rendered at alpha 1.\r\n     * @type {Object<string, number>}\r\n     */\r\n    const alphaLookup = {};\r\n\r\n    const uid = getUid(this);\r\n    const time = frameState.time;\r\n    let blend = false;\r\n\r\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\r\n\r\n    // look for cached tiles to use if a target tile is not ready\r\n    if (z in representationsByZ) {\r\n      for (const tileRepresentation of representationsByZ[z]) {\r\n        const tile = tileRepresentation.tile;\r\n        if (\r\n          (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\r\n          tile.getState() === TileState.EMPTY\r\n        ) {\r\n          continue;\r\n        }\r\n        const tileCoord = tile.tileCoord;\r\n\r\n        if (tileRepresentation.ready) {\r\n          const alpha = tile.getAlpha(uid, time);\r\n          if (alpha === 1) {\r\n            // no need to look for alt tiles\r\n            tile.endTransition(uid);\r\n            continue;\r\n          }\r\n          blend = true;\r\n          const tileCoordKey = getTileCoordKey(tileCoord);\r\n          alphaLookup[tileCoordKey] = alpha;\r\n        }\r\n        this.renderComplete = false;\r\n\r\n        // first look for child tiles (at z + 1)\r\n        const coveredByChildren = this.findAltTiles_(\r\n          tileGrid,\r\n          tileCoord,\r\n          z + 1,\r\n          tileRepresentationLookup,\r\n        );\r\n\r\n        if (coveredByChildren) {\r\n          continue;\r\n        }\r\n\r\n        // next look for parent tiles\r\n        const minZoom = tileGrid.getMinZoom();\r\n        for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\r\n          const coveredByParent = this.findAltTiles_(\r\n            tileGrid,\r\n            tileCoord,\r\n            parentZ,\r\n            tileRepresentationLookup,\r\n          );\r\n\r\n          if (coveredByParent) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\r\n\r\n    const renderTileMask = this.beforeTilesMaskRender(frameState);\r\n\r\n    if (renderTileMask) {\r\n      for (let j = 0, jj = zs.length; j < jj; ++j) {\r\n        const tileZ = zs[j];\r\n        for (const tileRepresentation of representationsByZ[tileZ]) {\r\n          const tileCoord = tileRepresentation.tile.tileCoord;\r\n          const tileCoordKey = getTileCoordKey(tileCoord);\r\n          // do not render the tile mask if alpha < 1\r\n          if (tileCoordKey in alphaLookup) {\r\n            continue;\r\n          }\r\n          const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\r\n          this.renderTileMask(\r\n            /** @type {TileRepresentation} */ (tileRepresentation),\r\n            tileZ,\r\n            tileExtent,\r\n            depthForZ(tileZ),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    this.beforeTilesRender(frameState, blend);\r\n\r\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\r\n      const tileZ = zs[j];\r\n      for (const tileRepresentation of representationsByZ[tileZ]) {\r\n        const tileCoord = tileRepresentation.tile.tileCoord;\r\n        const tileCoordKey = getTileCoordKey(tileCoord);\r\n        if (tileCoordKey in alphaLookup) {\r\n          continue;\r\n        }\r\n\r\n        this.drawTile_(\r\n          frameState,\r\n          tileRepresentation,\r\n          tileZ,\r\n          gutter,\r\n          extent,\r\n          alphaLookup,\r\n          tileGrid,\r\n        );\r\n      }\r\n    }\r\n\r\n    if (z in representationsByZ) {\r\n      for (const tileRepresentation of representationsByZ[z]) {\r\n        const tileCoord = tileRepresentation.tile.tileCoord;\r\n        const tileCoordKey = getTileCoordKey(tileCoord);\r\n        if (tileCoordKey in alphaLookup) {\r\n          this.drawTile_(\r\n            frameState,\r\n            tileRepresentation,\r\n            z,\r\n            gutter,\r\n            extent,\r\n            alphaLookup,\r\n            tileGrid,\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    this.beforeFinalize(frameState);\r\n    this.helper.finalizeDraw(\r\n      frameState,\r\n      this.dispatchPreComposeEvent,\r\n      this.dispatchPostComposeEvent,\r\n    );\r\n\r\n    const canvas = this.helper.getCanvas();\r\n\r\n    const tileRepresentationCache = this.tileRepresentationCache;\r\n    while (tileRepresentationCache.canExpireCache()) {\r\n      const tileRepresentation = tileRepresentationCache.pop();\r\n      tileRepresentation.dispose();\r\n    }\r\n\r\n    // TODO: let the renderers manage their own cache instead of managing the source cache\r\n    /**\r\n     * Here we unconditionally expire the source cache since the renderer maintains\r\n     * its own cache.\r\n     * @param {import(\"../../Map.js\").default} map Map.\r\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n     */\r\n    const postRenderFunction = function (map, frameState) {\r\n      tileSource.expireCache(frameState.viewState.projection, empty);\r\n    };\r\n\r\n    frameState.postRenderFunctions.push(postRenderFunction);\r\n\r\n    this.postRender(gl, frameState);\r\n    return canvas;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  beforeFinalize(frameState) {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Look for tiles covering the provided tile coordinate at an alternate\r\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\r\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\r\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\r\n   * @param {number} altZ The alternate zoom level.\r\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\r\n   * tile representations by zoom level.\r\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\r\n   * @private\r\n   */\r\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\r\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\r\n      tileCoord,\r\n      altZ,\r\n      this.tempTileRange_,\r\n    );\r\n\r\n    if (!tileRange) {\r\n      return false;\r\n    }\r\n\r\n    let covered = true;\r\n    const tileRepresentationCache = this.tileRepresentationCache;\r\n    const source = this.getLayer().getRenderSource();\r\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\r\n        let loaded = false;\r\n        if (tileRepresentationCache.containsKey(cacheKey)) {\r\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\r\n          if (\r\n            tileRepresentation.ready &&\r\n            !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)\r\n          ) {\r\n            addTileRepresentationToLookup(\r\n              tileRepresentationLookup,\r\n              tileRepresentation,\r\n              altZ,\r\n            );\r\n            loaded = true;\r\n          }\r\n        }\r\n        if (!loaded) {\r\n          covered = false;\r\n        }\r\n      }\r\n    }\r\n    return covered;\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  clearCache() {\r\n    super.clearCache();\r\n\r\n    const tileRepresentationCache = this.tileRepresentationCache;\r\n    tileRepresentationCache.forEach((tileRepresentation) =>\r\n      tileRepresentation.dispose(),\r\n    );\r\n    tileRepresentationCache.clear();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  afterHelperCreated() {\r\n    super.afterHelperCreated();\r\n\r\n    this.tileRepresentationCache.forEach((tileRepresentation) =>\r\n      tileRepresentation.setHelper(this.helper),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    super.disposeInternal();\r\n    delete this.frameState;\r\n  }\r\n}\r\n\r\nexport default WebGLBaseTileLayerRenderer;\r\n","/**\r\n * @module CME2D/renderer/webgl/TileLayer\r\n */\r\nimport ReprojDataTile from '../../reproj/DataTile.js';\r\nimport ReprojTile from '../../reproj/Tile.js';\r\nimport TileState from '../../TileState.js';\r\nimport TileTexture from '../../webgl/TileTexture.js';\r\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\r\nimport WebGLBaseTileLayerRenderer, {\r\n  Uniforms as BaseUniforms,\r\n  getCacheKey,\r\n} from './TileLayerBase.js';\r\nimport {AttributeType} from '../../webgl/Helper.js';\r\nimport {ELEMENT_ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\r\nimport {apply as applyTransform} from '../../transform.js';\r\nimport {\r\n  boundingExtent,\r\n  containsCoordinate,\r\n  getIntersection,\r\n} from '../../extent.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\nimport {fromTransform as mat4FromTransform} from '../../vec/mat4.js';\r\nimport {toSize} from '../../size.js';\r\n\r\nexport const Uniforms = {\r\n  ...BaseUniforms,\r\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\r\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\r\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\r\n  TEXTURE_RESOLUTION: 'u_textureResolution', // map units per texture pixel\r\n  TEXTURE_ORIGIN_X: 'u_textureOriginX', // map x coordinate of left edge of texture\r\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY', // map y coordinate of top edge of texture\r\n};\r\n\r\nexport const Attributes = {\r\n  TEXTURE_COORD: 'a_textureCoord',\r\n};\r\n\r\n/**\r\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\r\n */\r\nconst attributeDescriptions = [\r\n  {\r\n    name: Attributes.TEXTURE_COORD,\r\n    size: 2,\r\n    type: AttributeType.FLOAT,\r\n  },\r\n];\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} vertexShader Vertex shader source.\r\n * @property {string} fragmentShader Fragment shader source.\r\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\r\n * made available to shaders.\r\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\r\n * @property {number} [cacheSize=512] The texture cache size.\r\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../webgl/TileTexture.js\").TileType} TileTextureType\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../webgl/TileTexture.js\").default} TileTextureRepresentation\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * WebGL renderer for tile layers.\r\n * @template {import(\"../../layer/WebGLTile.js\").default|import(\"../../layer/Flow.js\").default} LayerType\r\n * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}\r\n * @api\r\n */\r\nclass WebGLTileLayerRenderer extends WebGLBaseTileLayerRenderer {\r\n  /**\r\n   * @param {LayerType} tileLayer Tile layer.\r\n   * @param {Options} options Options.\r\n   */\r\n  constructor(tileLayer, options) {\r\n    super(tileLayer, options);\r\n\r\n    /**\r\n     * @type {WebGLProgram}\r\n     * @private\r\n     */\r\n    this.program_;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.vertexShader_ = options.vertexShader;\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    this.fragmentShader_ = options.fragmentShader;\r\n\r\n    /**\r\n     * Tiles are rendered as a quad with the following structure:\r\n     *\r\n     *  [P3]---------[P2]\r\n     *   |`           |\r\n     *   |  `     B   |\r\n     *   |    `       |\r\n     *   |      `     |\r\n     *   |   A    `   |\r\n     *   |          ` |\r\n     *  [P0]---------[P1]\r\n     *\r\n     * Triangle A: P0, P1, P3\r\n     * Triangle B: P1, P2, P3\r\n     *\r\n     * @private\r\n     */\r\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\r\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\r\n\r\n    /**\r\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\r\n     * @private\r\n     */\r\n    this.paletteTextures_ = options.paletteTextures || [];\r\n  }\r\n\r\n  /**\r\n   * @param {Options} options Options.\r\n   * @override\r\n   */\r\n  reset(options) {\r\n    super.reset(options);\r\n    if (this.helper) {\r\n      const gl = this.helper.getGL();\r\n      for (const paletteTexture of this.paletteTextures_) {\r\n        paletteTexture.delete(gl);\r\n      }\r\n    }\r\n\r\n    this.vertexShader_ = options.vertexShader;\r\n    this.fragmentShader_ = options.fragmentShader;\r\n    this.paletteTextures_ = options.paletteTextures || [];\r\n\r\n    if (this.helper) {\r\n      this.program_ = this.helper.getProgram(\r\n        this.fragmentShader_,\r\n        this.vertexShader_,\r\n      );\r\n      const gl = this.helper.getGL();\r\n      for (const paletteTexture of this.paletteTextures_) {\r\n        // upload the texture data\r\n        paletteTexture.getTexture(gl);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  afterHelperCreated() {\r\n    super.afterHelperCreated();\r\n\r\n    const gl = this.helper.getGL();\r\n    for (const paletteTexture of this.paletteTextures_) {\r\n      // upload the texture data\r\n      paletteTexture.getTexture(gl);\r\n    }\r\n\r\n    this.program_ = this.helper.getProgram(\r\n      this.fragmentShader_,\r\n      this.vertexShader_,\r\n    );\r\n    this.helper.flushBufferData(this.indices_);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  removeHelper() {\r\n    if (this.helper) {\r\n      const gl = this.helper.getGL();\r\n      for (const paletteTexture of this.paletteTextures_) {\r\n        paletteTexture.delete(gl);\r\n      }\r\n    }\r\n\r\n    super.removeHelper();\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  createTileRepresentation(options) {\r\n    return new TileTexture(options);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  beforeTilesRender(frameState, tilesWithAlpha) {\r\n    super.beforeTilesRender(frameState, tilesWithAlpha);\r\n    this.helper.useProgram(this.program_, frameState);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  renderTile(\r\n    tileTexture,\r\n    tileTransform,\r\n    frameState,\r\n    renderExtent,\r\n    tileResolution,\r\n    tileSize,\r\n    tileOrigin,\r\n    tileExtent,\r\n    depth,\r\n    gutter,\r\n    alpha,\r\n  ) {\r\n    const gl = this.helper.getGL();\r\n    this.helper.bindBuffer(tileTexture.coords);\r\n    this.helper.bindBuffer(this.indices_);\r\n    this.helper.enableAttributes(attributeDescriptions);\r\n\r\n    let textureSlot = 0;\r\n    while (textureSlot < tileTexture.textures.length) {\r\n      const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\r\n      this.helper.bindTexture(\r\n        tileTexture.textures[textureSlot],\r\n        textureSlot,\r\n        uniformName,\r\n      );\r\n      ++textureSlot;\r\n    }\r\n\r\n    for (\r\n      let paletteIndex = 0;\r\n      paletteIndex < this.paletteTextures_.length;\r\n      ++paletteIndex\r\n    ) {\r\n      const paletteTexture = this.paletteTextures_[paletteIndex];\r\n      const texture = paletteTexture.getTexture(gl);\r\n      this.helper.bindTexture(texture, textureSlot, paletteTexture.name);\r\n      ++textureSlot;\r\n    }\r\n\r\n    const viewState = frameState.viewState;\r\n\r\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\r\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\r\n\r\n    const tile = tileTexture.tile;\r\n    const tileCoord = tile.tileCoord;\r\n\r\n    const tileCenterI = tileCoord[1];\r\n    const tileCenterJ = tileCoord[2];\r\n\r\n    this.helper.setUniformMatrixValue(\r\n      Uniforms.TILE_TRANSFORM,\r\n      mat4FromTransform(this.tempMat4, tileTransform),\r\n    );\r\n\r\n    this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\r\n    this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\r\n\r\n    let gutterExtent = renderExtent;\r\n    if (gutter > 0) {\r\n      gutterExtent = tileExtent;\r\n      getIntersection(gutterExtent, renderExtent, gutterExtent);\r\n    }\r\n    this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\r\n\r\n    this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\r\n    this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\r\n\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_PIXEL_WIDTH,\r\n      tileWidthWithGutter,\r\n    );\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_PIXEL_HEIGHT,\r\n      tileHeightWithGutter,\r\n    );\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_RESOLUTION,\r\n      tileResolution,\r\n    );\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_ORIGIN_X,\r\n      tileOrigin[0] +\r\n        tileCenterI * tileSize[0] * tileResolution -\r\n        gutter * tileResolution,\r\n    );\r\n    this.helper.setUniformFloatValue(\r\n      Uniforms.TEXTURE_ORIGIN_Y,\r\n      tileOrigin[1] -\r\n        tileCenterJ * tileSize[1] * tileResolution +\r\n        gutter * tileResolution,\r\n    );\r\n\r\n    this.helper.drawElements(0, this.indices_.getSize());\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    const gl = this.helper.getGL();\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    const frameState = this.frameState;\r\n    if (!frameState) {\r\n      return null;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const coordinate = applyTransform(\r\n      frameState.pixelToCoordinateTransform,\r\n      pixel.slice(),\r\n    );\r\n\r\n    const viewState = frameState.viewState;\r\n    const layerExtent = layer.getExtent();\r\n    if (layerExtent) {\r\n      if (\r\n        !containsCoordinate(\r\n          fromUserExtent(layerExtent, viewState.projection),\r\n          coordinate,\r\n        )\r\n      ) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // determine last source suitable for rendering at coordinate\r\n    const sources = layer.getSources(\r\n      boundingExtent([coordinate]),\r\n      viewState.resolution,\r\n    );\r\n    let i, source, tileGrid;\r\n    for (i = sources.length - 1; i >= 0; --i) {\r\n      source = sources[i];\r\n      if (source.getState() === 'ready') {\r\n        tileGrid = source.getTileGridForProjection(viewState.projection);\r\n        if (source.getWrapX()) {\r\n          break;\r\n        }\r\n        const gridExtent = tileGrid.getExtent();\r\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (i < 0) {\r\n      return null;\r\n    }\r\n\r\n    const tileTextureCache = this.tileRepresentationCache;\r\n    for (\r\n      let z = tileGrid.getZForResolution(viewState.resolution);\r\n      z >= tileGrid.getMinZoom();\r\n      --z\r\n    ) {\r\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\r\n      const cacheKey = getCacheKey(source, tileCoord);\r\n      if (!tileTextureCache.containsKey(cacheKey)) {\r\n        continue;\r\n      }\r\n      const tileTexture = tileTextureCache.get(cacheKey);\r\n      const tile = tileTexture.tile;\r\n      if (\r\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\r\n        tile.getState() === TileState.EMPTY\r\n      ) {\r\n        return null;\r\n      }\r\n      if (!tileTexture.loaded) {\r\n        continue;\r\n      }\r\n      const tileOrigin = tileGrid.getOrigin(z);\r\n      const tileSize = toSize(tileGrid.getTileSize(z));\r\n      const tileResolution = tileGrid.getResolution(z);\r\n\r\n      const col =\r\n        (coordinate[0] - tileOrigin[0]) / tileResolution -\r\n        tileCoord[1] * tileSize[0];\r\n\r\n      const row =\r\n        (tileOrigin[1] - coordinate[1]) / tileResolution -\r\n        tileCoord[2] * tileSize[1];\r\n\r\n      return tileTexture.getPixelData(col, row);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    const helper = this.helper;\r\n    if (helper) {\r\n      const gl = helper.getGL();\r\n      for (const paletteTexture of this.paletteTextures_) {\r\n        paletteTexture.delete(gl);\r\n      }\r\n      this.paletteTextures_.length = 0;\r\n\r\n      gl.deleteProgram(this.program_);\r\n      delete this.program_;\r\n      helper.deleteBuffer(this.indices_);\r\n    }\r\n    super.disposeInternal();\r\n    delete this.indices_;\r\n  }\r\n}\r\n\r\nexport default WebGLTileLayerRenderer;\r\n","/**\n * RGB space.\n *\n * @module  color-space/rgb\n */\n\nexport default {\n\tname: 'rgb',\n\tmin: [0,0,0],\n\tmax: [255,255,255],\n\tchannel: ['red', 'green', 'blue'],\n\talias: ['RGB']\n};\n","/**\n * CIE XYZ\n *\n * @module  color-space/xyz\n */\nimport rgb from './rgb.js';\n\nvar xyz = {\n\tname: 'xyz',\n\tmin: [0,0,0],\n\tchannel: ['X','Y','Z'],\n\talias: ['XYZ', 'ciexyz', 'cie1931']\n};\n\n\n/**\n * Whitepoint reference values with observer/illuminant\n *\n * http://en.wikipedia.org/wiki/Standard_illuminant\n */\nxyz.whitepoint = {\n\t//1931 2°\n\t2: {\n\t\t//incadescent\n\t\tA:[109.85, 100, 35.585],\n\t\t// B:[],\n\t\tC: [98.074, 100, 118.232],\n\t\tD50: [96.422, 100, 82.521],\n\t\tD55: [95.682, 100, 92.149],\n\t\t//daylight\n\t\tD65: [95.045592705167, 100, 108.9057750759878],\n\t\tD75: [94.972, 100, 122.638],\n\t\t//flourescent\n\t\t// F1: [],\n\t\tF2: [99.187, 100, 67.395],\n\t\t// F3: [],\n\t\t// F4: [],\n\t\t// F5: [],\n\t\t// F6:[],\n\t\tF7: [95.044, 100, 108.755],\n\t\t// F8: [],\n\t\t// F9: [],\n\t\t// F10: [],\n\t\tF11: [100.966, 100, 64.370],\n\t\t// F12: [],\n\t\tE: [100,100,100]\n\t},\n\n\t//1964  10°\n\t10: {\n\t\t//incadescent\n\t\tA:[111.144, 100, 35.200],\n\t\tC: [97.285, 100, 116.145],\n\t\tD50: [96.720, 100, 81.427],\n\t\tD55: [95.799, 100, 90.926],\n\t\t//daylight\n\t\tD65: [94.811, 100, 107.304],\n\t\tD75: [94.416, 100, 120.641],\n\t\t//flourescent\n\t\tF2: [103.280, 100, 69.026],\n\t\tF7: [95.792, 100, 107.687],\n\t\tF11: [103.866, 100, 65.627],\n\t\tE: [100,100,100]\n\t}\n};\n\n\n/**\n * Top values are the whitepoint’s top values, default are D65\n */\nxyz.max = xyz.whitepoint[2].D65;\n\n\n/**\n * Transform xyz to rgb\n *\n * @param {Array} xyz Array of xyz values\n *\n * @return {Array} RGB values\n */\nxyz.rgb = function (_xyz, white) {\n\t//FIXME: make sure we have to divide like this. Probably we have to replace matrix as well then\n\twhite = white || xyz.whitepoint[2].E;\n\n\tvar x = _xyz[0] / white[0],\n\t\ty = _xyz[1] / white[1],\n\t\tz = _xyz[2] / white[2],\n\t\tr, g, b;\n\n\t// assume sRGB\n\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\tr = (x * 3.240969941904521) + (y * -1.537383177570093) + (z * -0.498610760293);\n\tg = (x * -0.96924363628087) + (y * 1.87596750150772) + (z * 0.041555057407175);\n\tb = (x * 0.055630079696993) + (y * -0.20397695888897) + (z * 1.056971514242878);\n\n\tr = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r = (r * 12.92);\n\n\tg = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g = (g * 12.92);\n\n\tb = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b = (b * 12.92);\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n}\n\n\n\n/**\n * RGB to XYZ\n *\n * @param {Array} rgb RGB channels\n *\n * @return {Array} XYZ channels\n */\nrgb.xyz = function(rgb, white) {\n\tvar r = rgb[0] / 255,\n\t\t\tg = rgb[1] / 255,\n\t\t\tb = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.41239079926595) + (g * 0.35758433938387) + (b * 0.18048078840183);\n\tvar y = (r * 0.21263900587151) + (g * 0.71516867876775) + (b * 0.072192315360733);\n\tvar z = (r * 0.019330818715591) + (g * 0.11919477979462) + (b * 0.95053215224966);\n\n\twhite = white || xyz.whitepoint[2].E;\n\n\treturn [x * white[0], y * white[1], z * white[2]];\n};\n\n\n\nexport default xyz;\n","/**\n * CIE LUV (C'est la vie)\n *\n * @module color-space/luv\n */\n import xyz from './xyz.js';\n\nexport default {\n\tname: 'luv',\n\t//NOTE: luv has no rigidly defined limits\n\t//easyrgb fails to get proper coords\n\t//boronine states no rigid limits\n\t//colorMine refers this ones:\n\tmin: [0,-134,-140],\n\tmax: [100,224,122],\n\tchannel: ['lightness', 'u', 'v'],\n\talias: ['LUV', 'cieluv', 'cie1976'],\n\n\txyz: function(arg, i, o){\n\t\tvar _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;\n\t\tl = arg[0], u = arg[1], v = arg[2];\n\n\t\tif (l === 0) return [0,0,0];\n\n\t\t//get constants\n\t\t//var e = 0.008856451679035631; //(6/29)^3\n\t\tvar k = 0.0011070564598794539; //(3/29)^3\n\n\t\t//get illuminant/observer\n\t\ti = i || 'D65';\n\t\to = o || 2;\n\n\t\txn = xyz.whitepoint[o][i][0];\n\t\tyn = xyz.whitepoint[o][i][1];\n\t\tzn = xyz.whitepoint[o][i][2];\n\n\t\tun = (4 * xn) / (xn + (15 * yn) + (3 * zn));\n\t\tvn = (9 * yn) / (xn + (15 * yn) + (3 * zn));\n\t\t// un = 0.19783000664283;\n\t\t// vn = 0.46831999493879;\n\n\n\t\t_u = u / (13 * l) + un || 0;\n\t\t_v = v / (13 * l) + vn || 0;\n\n\t\ty = l > 8 ? yn * Math.pow( (l + 16) / 116 , 3) : yn * l * k;\n\n\t\t//wikipedia method\n\t\tx = y * 9 * _u / (4 * _v) || 0;\n\t\tz = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;\n\n\t\t//boronine method\n\t\t//https://github.com/boronine/husl/blob/master/husl.coffee#L201\n\t\t// x = 0 - (9 * y * _u) / ((_u - 4) * _v - _u * _v);\n\t\t// z = (9 * y - (15 * _v * y) - (_v * x)) / (3 * _v);\n\n\t\treturn [x, y, z];\n\t}\n};\n\n// http://www.brucelindbloom.com/index.html?Equations.html\n// https://github.com/boronine/husl/blob/master/husl.coffee\n//i - illuminant\n//o - observer\nxyz.luv = function(arg, i, o) {\n\tvar _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;\n\n\t//get constants\n\tvar e = 0.008856451679035631; //(6/29)^3\n\tvar k = 903.2962962962961; //(29/3)^3\n\n\t//get illuminant/observer coords\n\ti = i || 'D65';\n\to = o || 2;\n\n\txn = xyz.whitepoint[o][i][0];\n\tyn = xyz.whitepoint[o][i][1];\n\tzn = xyz.whitepoint[o][i][2];\n\n\tun = (4 * xn) / (xn + (15 * yn) + (3 * zn));\n\tvn = (9 * yn) / (xn + (15 * yn) + (3 * zn));\n\n\n\tx = arg[0], y = arg[1], z = arg[2];\n\n\n\t_u = (4 * x) / (x + (15 * y) + (3 * z)) || 0;\n\t_v = (9 * y) / (x + (15 * y) + (3 * z)) || 0;\n\n\tvar yr = y/yn;\n\n\tl = yr <= e ? k * yr : 116 * Math.pow(yr, 1/3) - 16;\n\n\tu = 13 * l * (_u - un);\n\tv = 13 * l * (_v - vn);\n\n\treturn [l, u, v];\n};\n","/**\n * Cylindrical CIE LUV\n *\n * @module color-space/lchuv\n */\nimport luv from './luv.js';\nimport xyz from './xyz.js';\n\n//cylindrical luv\nvar lchuv = {\n\tname: 'lchuv',\n\tchannel: ['lightness', 'chroma', 'hue'],\n\talias: ['LCHuv', 'cielchuv'],\n\tmin: [0,0,0],\n\tmax: [100,100,360],\n\n\tluv: function(luv){\n\t\tvar l = luv[0],\n\t\tc = luv[1],\n\t\th = luv[2],\n\t\tu, v, hr;\n\n\t\thr = h / 360 * 2 * Math.PI;\n\t\tu = c * Math.cos(hr);\n\t\tv = c * Math.sin(hr);\n\t\treturn [l, u, v];\n\t},\n\n\txyz: function(arg) {\n\t\treturn luv.xyz(lchuv.luv(arg));\n\t}\n};\n\nexport default lchuv;\n\nluv.lchuv = function(luv){\n\tvar l = luv[0], u = luv[1], v = luv[2];\n\n\tvar c = Math.sqrt(u*u + v*v);\n\tvar hr = Math.atan2(v,u);\n\tvar h = hr * 360 / 2 / Math.PI;\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\treturn [l,c,h]\n};\n\nxyz.lchuv = function(arg){\n  return luv.lchuv(xyz.luv(arg));\n};\n","export default {\n\taliceblue: [240, 248, 255],\n\tantiquewhite: [250, 235, 215],\n\taqua: [0, 255, 255],\n\taquamarine: [127, 255, 212],\n\tazure: [240, 255, 255],\n\tbeige: [245, 245, 220],\n\tbisque: [255, 228, 196],\n\tblack: [0, 0, 0],\n\tblanchedalmond: [255, 235, 205],\n\tblue: [0, 0, 255],\n\tblueviolet: [138, 43, 226],\n\tbrown: [165, 42, 42],\n\tburlywood: [222, 184, 135],\n\tcadetblue: [95, 158, 160],\n\tchartreuse: [127, 255, 0],\n\tchocolate: [210, 105, 30],\n\tcoral: [255, 127, 80],\n\tcornflowerblue: [100, 149, 237],\n\tcornsilk: [255, 248, 220],\n\tcrimson: [220, 20, 60],\n\tcyan: [0, 255, 255],\n\tdarkblue: [0, 0, 139],\n\tdarkcyan: [0, 139, 139],\n\tdarkgoldenrod: [184, 134, 11],\n\tdarkgray: [169, 169, 169],\n\tdarkgreen: [0, 100, 0],\n\tdarkgrey: [169, 169, 169],\n\tdarkkhaki: [189, 183, 107],\n\tdarkmagenta: [139, 0, 139],\n\tdarkolivegreen: [85, 107, 47],\n\tdarkorange: [255, 140, 0],\n\tdarkorchid: [153, 50, 204],\n\tdarkred: [139, 0, 0],\n\tdarksalmon: [233, 150, 122],\n\tdarkseagreen: [143, 188, 143],\n\tdarkslateblue: [72, 61, 139],\n\tdarkslategray: [47, 79, 79],\n\tdarkslategrey: [47, 79, 79],\n\tdarkturquoise: [0, 206, 209],\n\tdarkviolet: [148, 0, 211],\n\tdeeppink: [255, 20, 147],\n\tdeepskyblue: [0, 191, 255],\n\tdimgray: [105, 105, 105],\n\tdimgrey: [105, 105, 105],\n\tdodgerblue: [30, 144, 255],\n\tfirebrick: [178, 34, 34],\n\tfloralwhite: [255, 250, 240],\n\tforestgreen: [34, 139, 34],\n\tfuchsia: [255, 0, 255],\n\tgainsboro: [220, 220, 220],\n\tghostwhite: [248, 248, 255],\n\tgold: [255, 215, 0],\n\tgoldenrod: [218, 165, 32],\n\tgray: [128, 128, 128],\n\tgreen: [0, 128, 0],\n\tgreenyellow: [173, 255, 47],\n\tgrey: [128, 128, 128],\n\thoneydew: [240, 255, 240],\n\thotpink: [255, 105, 180],\n\tindianred: [205, 92, 92],\n\tindigo: [75, 0, 130],\n\tivory: [255, 255, 240],\n\tkhaki: [240, 230, 140],\n\tlavender: [230, 230, 250],\n\tlavenderblush: [255, 240, 245],\n\tlawngreen: [124, 252, 0],\n\tlemonchiffon: [255, 250, 205],\n\tlightblue: [173, 216, 230],\n\tlightcoral: [240, 128, 128],\n\tlightcyan: [224, 255, 255],\n\tlightgoldenrodyellow: [250, 250, 210],\n\tlightgray: [211, 211, 211],\n\tlightgreen: [144, 238, 144],\n\tlightgrey: [211, 211, 211],\n\tlightpink: [255, 182, 193],\n\tlightsalmon: [255, 160, 122],\n\tlightseagreen: [32, 178, 170],\n\tlightskyblue: [135, 206, 250],\n\tlightslategray: [119, 136, 153],\n\tlightslategrey: [119, 136, 153],\n\tlightsteelblue: [176, 196, 222],\n\tlightyellow: [255, 255, 224],\n\tlime: [0, 255, 0],\n\tlimegreen: [50, 205, 50],\n\tlinen: [250, 240, 230],\n\tmagenta: [255, 0, 255],\n\tmaroon: [128, 0, 0],\n\tmediumaquamarine: [102, 205, 170],\n\tmediumblue: [0, 0, 205],\n\tmediumorchid: [186, 85, 211],\n\tmediumpurple: [147, 112, 219],\n\tmediumseagreen: [60, 179, 113],\n\tmediumslateblue: [123, 104, 238],\n\tmediumspringgreen: [0, 250, 154],\n\tmediumturquoise: [72, 209, 204],\n\tmediumvioletred: [199, 21, 133],\n\tmidnightblue: [25, 25, 112],\n\tmintcream: [245, 255, 250],\n\tmistyrose: [255, 228, 225],\n\tmoccasin: [255, 228, 181],\n\tnavajowhite: [255, 222, 173],\n\tnavy: [0, 0, 128],\n\toldlace: [253, 245, 230],\n\tolive: [128, 128, 0],\n\tolivedrab: [107, 142, 35],\n\torange: [255, 165, 0],\n\torangered: [255, 69, 0],\n\torchid: [218, 112, 214],\n\tpalegoldenrod: [238, 232, 170],\n\tpalegreen: [152, 251, 152],\n\tpaleturquoise: [175, 238, 238],\n\tpalevioletred: [219, 112, 147],\n\tpapayawhip: [255, 239, 213],\n\tpeachpuff: [255, 218, 185],\n\tperu: [205, 133, 63],\n\tpink: [255, 192, 203],\n\tplum: [221, 160, 221],\n\tpowderblue: [176, 224, 230],\n\tpurple: [128, 0, 128],\n\trebeccapurple: [102, 51, 153],\n\tred: [255, 0, 0],\n\trosybrown: [188, 143, 143],\n\troyalblue: [65, 105, 225],\n\tsaddlebrown: [139, 69, 19],\n\tsalmon: [250, 128, 114],\n\tsandybrown: [244, 164, 96],\n\tseagreen: [46, 139, 87],\n\tseashell: [255, 245, 238],\n\tsienna: [160, 82, 45],\n\tsilver: [192, 192, 192],\n\tskyblue: [135, 206, 235],\n\tslateblue: [106, 90, 205],\n\tslategray: [112, 128, 144],\n\tslategrey: [112, 128, 144],\n\tsnow: [255, 250, 250],\n\tspringgreen: [0, 255, 127],\n\tsteelblue: [70, 130, 180],\n\ttan: [210, 180, 140],\n\tteal: [0, 128, 128],\n\tthistle: [216, 191, 216],\n\ttomato: [255, 99, 71],\n\tturquoise: [64, 224, 208],\n\tviolet: [238, 130, 238],\n\twheat: [245, 222, 179],\n\twhite: [255, 255, 255],\n\twhitesmoke: [245, 245, 245],\n\tyellow: [255, 255, 0],\n\tyellowgreen: [154, 205, 50]\n}\n","/**\n * @module color-parse\n */\nimport names from 'color-name'\n\nexport default parse\n\n/**\n * Base hues\n * http://dev.w3.org/csswg/css-color/#typedef-named-hue\n */\n//FIXME: use external hue detector\nvar baseHues = {\n\tred: 0,\n\torange: 60,\n\tyellow: 120,\n\tgreen: 180,\n\tblue: 240,\n\tpurple: 300\n}\n\n/**\n * Parse color from the string passed\n *\n * @return {Object} A space indicator `space`, an array `values` and `alpha`\n */\nfunction parse(cstr) {\n\tvar m, parts = [], alpha = 1, space\n\n\t//numeric case\n\tif (typeof cstr === 'number') {\n\t\treturn { space: 'rgb', values: [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff], alpha: 1 }\n\t}\n\tif (typeof cstr === 'number') return { space: 'rgb', values: [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff], alpha: 1 }\n\n\tcstr = String(cstr).toLowerCase();\n\n\t//keyword\n\tif (names[cstr]) {\n\t\tparts = names[cstr].slice()\n\t\tspace = 'rgb'\n\t}\n\n\t//reserved words\n\telse if (cstr === 'transparent') {\n\t\talpha = 0\n\t\tspace = 'rgb'\n\t\tparts = [0, 0, 0]\n\t}\n\n\t//hex\n\telse if (cstr[0] === '#') {\n\t\tvar base = cstr.slice(1)\n\t\tvar size = base.length\n\t\tvar isShort = size <= 4\n\t\talpha = 1\n\n\t\tif (isShort) {\n\t\t\tparts = [\n\t\t\t\tparseInt(base[0] + base[0], 16),\n\t\t\t\tparseInt(base[1] + base[1], 16),\n\t\t\t\tparseInt(base[2] + base[2], 16)\n\t\t\t]\n\t\t\tif (size === 4) {\n\t\t\t\talpha = parseInt(base[3] + base[3], 16) / 255\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tparts = [\n\t\t\t\tparseInt(base[0] + base[1], 16),\n\t\t\t\tparseInt(base[2] + base[3], 16),\n\t\t\t\tparseInt(base[4] + base[5], 16)\n\t\t\t]\n\t\t\tif (size === 8) {\n\t\t\t\talpha = parseInt(base[6] + base[7], 16) / 255\n\t\t\t}\n\t\t}\n\n\t\tif (!parts[0]) parts[0] = 0\n\t\tif (!parts[1]) parts[1] = 0\n\t\tif (!parts[2]) parts[2] = 0\n\n\t\tspace = 'rgb'\n\t}\n\n\t// color space\n\telse if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\\s*\\(([^\\)]*)\\)/.exec(cstr)) {\n\t\tvar name = m[1]\n\t\tspace = name.replace(/a$/, '')\n\t\tvar dims = space === 'cmyk' ? 4 : space === 'gray' ? 1 : 3\n\t\tparts = m[2].trim().split(/\\s*[,\\/]\\s*|\\s+/)\n\n\t\t// color(srgb-linear x x x) -> srgb-linear(x x x)\n\t\tif (space === 'color') space = parts.shift()\n\n\t\tparts = parts.map(function (x, i) {\n\t\t\t//<percentage>\n\t\t\tif (x[x.length - 1] === '%') {\n\t\t\t\tx = parseFloat(x) / 100\n\t\t\t\t// alpha -> 0..1\n\t\t\t\tif (i === 3) return x\n\t\t\t\t// rgb -> 0..255\n\t\t\t\tif (space === 'rgb') return x * 255\n\t\t\t\t// hsl, hwb H -> 0..100\n\t\t\t\tif (space[0] === 'h') return x * 100\n\t\t\t\t// lch, lab L -> 0..100\n\t\t\t\tif (space[0] === 'l' && !i) return x * 100\n\t\t\t\t// lab A B -> -125..125\n\t\t\t\tif (space === 'lab') return x * 125\n\t\t\t\t// lch C -> 0..150, H -> 0..360\n\t\t\t\tif (space === 'lch') return i < 2 ? x * 150 : x * 360\n\t\t\t\t// oklch/oklab L -> 0..1\n\t\t\t\tif (space[0] === 'o' && !i) return x\n\t\t\t\t// oklab A B -> -0.4..0.4\n\t\t\t\tif (space === 'oklab') return x * 0.4\n\t\t\t\t// oklch C -> 0..0.4, H -> 0..360\n\t\t\t\tif (space === 'oklch') return i < 2 ? x * 0.4 : x * 360\n\t\t\t\t// color(xxx) -> 0..1\n\t\t\t\treturn x\n\t\t\t}\n\n\t\t\t//hue\n\t\t\tif (space[i] === 'h' || (i === 2 && space[space.length - 1] === 'h')) {\n\t\t\t\t//<base-hue>\n\t\t\t\tif (baseHues[x] !== undefined) return baseHues[x]\n\t\t\t\t//<deg>\n\t\t\t\tif (x.endsWith('deg')) return parseFloat(x)\n\t\t\t\t//<turn>\n\t\t\t\tif (x.endsWith('turn')) return parseFloat(x) * 360\n\t\t\t\tif (x.endsWith('grad')) return parseFloat(x) * 360 / 400\n\t\t\t\tif (x.endsWith('rad')) return parseFloat(x) * 180 / Math.PI\n\t\t\t}\n\t\t\tif (x === 'none') return 0\n\t\t\treturn parseFloat(x)\n\t\t});\n\n\t\talpha = parts.length > dims ? parts.pop() : 1\n\t}\n\n\t//named channels case\n\telse if (/[0-9](?:\\s|\\/|,)/.test(cstr)) {\n\t\tparts = cstr.match(/([0-9]+)/g).map(function (value) {\n\t\t\treturn parseFloat(value)\n\t\t})\n\n\t\tspace = cstr.match(/([a-z])/ig)?.join('')?.toLowerCase() || 'rgb'\n\t}\n\n\treturn {\n\t\tspace,\n\t\tvalues: parts,\n\t\talpha\n\t}\n}\n","/**\n * @module color-space/hsl\n */\nimport rgb from './rgb.js';\n\nexport default {\n\tname: 'hsl',\n\tmin: [0,0,0],\n\tmax: [360,100,100],\n\tchannel: ['hue', 'saturation', 'lightness'],\n\talias: ['HSL'],\n\n\trgb: function(hsl) {\n\t\tvar h = hsl[0]/360, s = hsl[1]/100, l = hsl[2]/100, t1, t2, t3, rgb, val, i=0;\n\n\t\tif (s === 0) return val = l * 255, [val, val, val];\n\n\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n\t\tt1 = 2 * l - t2;\n\n\t\trgb = [0, 0, 0];\n\t\tfor (;i<3;) {\n\t\t\tt3 = h + 1 / 3 * - (i - 1);\n\t\t\tt3 < 0 ? t3++ : t3 > 1 && t3--;\n\t\t\tval = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 :\n\t\t\t2 * t3 < 1 ? t2 :\n\t\t\t3 * t3 < 2 ?  t1 + (t2 - t1) * (2 / 3 - t3) * 6 :\n\t\t\tt1;\n\t\t\trgb[i++] = val * 255;\n\t\t}\n\n\t\treturn rgb;\n\t}\n};\n\n\n//extend rgb\nrgb.hsl = function(rgb) {\n\tvar r = rgb[0]/255,\n\t\t\tg = rgb[1]/255,\n\t\t\tb = rgb[2]/255,\n\t\t\tmin = Math.min(r, g, b),\n\t\t\tmax = Math.max(r, g, b),\n\t\t\tdelta = max - min,\n\t\t\th, s, l;\n\n\tif (max === min) {\n\t\th = 0;\n\t}\n\telse if (r === max) {\n\t\th = (g - b) / delta;\n\t}\n\telse if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t}\n\telse if (b === max) {\n\t\th = 4 + (r - g)/ delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t}\n\telse if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t}\n\telse {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n","/** @module  color-rgba */\nimport parse from 'color-parse'\nimport rgb from 'color-space/rgb.js'\nimport hsl from 'color-space/hsl.js'\n\nexport default function rgba(color) {\n\t// template literals\n\tif (Array.isArray(color) && color.raw) color = String.raw(...arguments)\n\tif (color instanceof Number) color = +color\n\n\tvar values, i, l\n\n\t//attempt to parse non-array arguments\n\tvar parsed = parse(color)\n\n\tif (!parsed.space) return []\n\n\tconst min = parsed.space[0] === 'h' ? hsl.min : rgb.min\n\tconst max = parsed.space[0] === 'h' ? hsl.max : rgb.max\n\n\tvalues = Array(3)\n\tvalues[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0])\n\tvalues[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1])\n\tvalues[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2])\n\n\tif (parsed.space[0] === 'h') {\n\t\tvalues = hsl.rgb(values)\n\t}\n\n\tvalues.push(Math.min(Math.max(parsed.alpha, 0), 1))\n\n\treturn values\n}\n","/**\r\n * @module CME2D/color\r\n */\r\nimport lchuv from 'color-space/lchuv.js';\r\nimport parseRgba from 'color-rgba';\r\nimport rgb from 'color-space/rgb.js';\r\nimport xyz from 'color-space/xyz.js';\r\nimport {clamp} from './math.js';\r\n\r\n/**\r\n * A color represented as a short array [red, green, blue, alpha].\r\n * red, green, and blue should be integers in the range 0..255 inclusive.\r\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\r\n * given then `1` will be used.\r\n * @typedef {Array<number>} Color\r\n * @api\r\n */\r\n\r\n/**\r\n * Color to indicate that no color should be rendered. This is meant to be used for per-reference\r\n * comparisons only.\r\n * @type {Color}\r\n */\r\nexport const NO_COLOR = [NaN, NaN, NaN, 0];\r\n\r\n/**\r\n * Return the color as an rgba string.\r\n * @param {Color|string} color Color.\r\n * @return {string} Rgba string.\r\n * @api\r\n */\r\nexport function asString(color) {\r\n  if (typeof color === 'string') {\r\n    return color;\r\n  }\r\n  return toString(color);\r\n}\r\n\r\n/**\r\n * @type {number}\r\n */\r\nconst MAX_CACHE_SIZE = 1024;\r\n\r\n/**\r\n * We maintain a small cache of parsed strings.  Whenever the cache grows too large,\r\n * we delete an arbitrary set of the entries.\r\n *\r\n * @type {Object<string, Color>}\r\n */\r\nconst cache = {};\r\n\r\n/**\r\n * @type {number}\r\n */\r\nlet cacheSize = 0;\r\n\r\n/**\r\n * @param {Color} color A color that may or may not have an alpha channel.\r\n * @return {Color} The input color with an alpha channel.  If the input color has\r\n * an alpha channel, the input color will be returned unchanged.  Otherwise, a new\r\n * array will be returned with the input color and an alpha channel of 1.\r\n */\r\nexport function withAlpha(color) {\r\n  if (color.length === 4) {\r\n    return color;\r\n  }\r\n  const output = color.slice();\r\n  output[3] = 1;\r\n  return output;\r\n}\r\n\r\n/**\r\n * @param {Color} color RGBA color.\r\n * @return {Color} LCHuv color with alpha.\r\n */\r\nexport function rgbaToLcha(color) {\r\n  const output = xyz.lchuv(rgb.xyz(color));\r\n  output[3] = color[3];\r\n  return output;\r\n}\r\n\r\n/**\r\n * @param {Color} color LCHuv color with alpha.\r\n * @return {Color} RGBA color.\r\n */\r\nexport function lchaToRgba(color) {\r\n  const output = xyz.rgb(lchuv.xyz(color));\r\n  output[3] = color[3];\r\n  return output;\r\n}\r\n\r\n/**\r\n * @param {string} s String.\r\n * @return {Color} Color.\r\n */\r\nexport function fromString(s) {\r\n  if (s === 'none') {\r\n    return NO_COLOR;\r\n  }\r\n  if (cache.hasOwnProperty(s)) {\r\n    return cache[s];\r\n  }\r\n  if (cacheSize >= MAX_CACHE_SIZE) {\r\n    let i = 0;\r\n    for (const key in cache) {\r\n      if ((i++ & 3) === 0) {\r\n        delete cache[key];\r\n        --cacheSize;\r\n      }\r\n    }\r\n  }\r\n\r\n  const color = parseRgba(s);\r\n  if (color.length !== 4) {\r\n    throw new Error('failed to parse \"' + s + '\" as color');\r\n  }\r\n  for (const c of color) {\r\n    if (isNaN(c)) {\r\n      throw new Error('failed to parse \"' + s + '\" as color');\r\n    }\r\n  }\r\n  normalize(color);\r\n  cache[s] = color;\r\n  ++cacheSize;\r\n  return color;\r\n}\r\n\r\n/**\r\n * Return the color as an array. This function maintains a cache of calculated\r\n * arrays which means the result should not be modified.\r\n * @param {Color|string} color Color.\r\n * @return {Color} Color.\r\n * @api\r\n */\r\nexport function asArray(color) {\r\n  if (Array.isArray(color)) {\r\n    return color;\r\n  }\r\n  return fromString(color);\r\n}\r\n\r\n/**\r\n * Exported for the tests.\r\n * @param {Color} color Color.\r\n * @return {Color} Clamped color.\r\n */\r\nexport function normalize(color) {\r\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\r\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\r\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\r\n  color[3] = clamp(color[3], 0, 1);\r\n  return color;\r\n}\r\n\r\n/**\r\n * @param {Color} color Color.\r\n * @return {string} String.\r\n */\r\nexport function toString(color) {\r\n  let r = color[0];\r\n  if (r != (r | 0)) {\r\n    r = (r + 0.5) | 0;\r\n  }\r\n  let g = color[1];\r\n  if (g != (g | 0)) {\r\n    g = (g + 0.5) | 0;\r\n  }\r\n  let b = color[2];\r\n  if (b != (b | 0)) {\r\n    b = (b + 0.5) | 0;\r\n  }\r\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 1000) / 1000;\r\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\r\n}\r\n\r\n/**\r\n * @param {string} s String.\r\n * @return {boolean} Whether the string is actually a valid color\r\n */\r\nexport function isStringColor(s) {\r\n  try {\r\n    fromString(s);\r\n    return true;\r\n  } catch (_) {\r\n    return false;\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/expr/expression\r\n */\r\nimport {ascending} from '../array.js';\r\nimport {fromString as colorFromString} from '../color.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\r\n * The result of parsing an encoded expression is one of the specific expression classes.\r\n * During parsing, information is added to the parsing context about the data accessed by the\r\n * expression.\r\n */\r\n\r\n/**\r\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\r\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\r\n *\r\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\r\n *\r\n * * Reading operators:\r\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\r\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\r\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\r\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\r\n *     of bands, depending on the underlying data source and\r\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\r\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\r\n *   * `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.\r\n *   * `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a\r\n *     feature property. The result is `undefined` when there is nothing at the specified key or index.\r\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\r\n *     `Multi*` values are returned as their singular equivalent\r\n *     `Circle` geometries are returned as 'Polygon'\r\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\r\n *   * `['resolution']` returns the current resolution\r\n *   * `['time']` The time in seconds since the creation of the layer (WebGL only).\r\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\r\n *   * `['zoom']` The current zoom level (WebGL only).\r\n *   * `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line\r\n *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.\r\n *      Please note that the M component will be linearly interpolated between the two points composing a segment.\r\n *\r\n * * Math operators:\r\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\r\n *   * `['/', value1, value2]` divides `value1` by `value2`\r\n *   * `['+', value1, value2, ...]` adds the values\r\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\r\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\r\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\r\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\r\n *   * `['abs', value1]` returns the absolute value of `value1`\r\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\r\n *   * `['round', value1]` returns the nearest integer to `value1`\r\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\r\n *   * `['sin', value1]` returns the sine of `value1`\r\n *   * `['cos', value1]` returns the cosine of `value1`\r\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\r\n *   * `['sqrt', value1]` returns the square root of `value1`\r\n *\r\n * * Transform operators:\r\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\r\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\r\n *     All conditions should be `boolean`, output and fallback can be any kind.\r\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\r\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\r\n *     returns the `fallback` value.\r\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\r\n *     `fallback` values must be of the same type, and can be of any kind.\r\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\r\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\r\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\r\n *     of 1 is equivalent to `['linear']`.\r\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\r\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\r\n *     between `output1` and `outputN`.\r\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\r\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\r\n *     (Canvas only).\r\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\r\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\r\n *     (Canvas only).\r\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\r\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\r\n *     (Canvas only).\r\n *\r\n * * Logical operators:\r\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\r\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\r\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\r\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\r\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\r\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\r\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\r\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\r\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\r\n *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,\r\n *     `false` otherwise.\r\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\r\n *     (inclusively), or `false` otherwise.\r\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\r\n *     `false` otherwise.\r\n *     This operator has the following limitations:\r\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\r\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\r\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\r\n *     `['literal', ['abc', 'def', 'ghi']]`\r\n *\r\n * * Conversion operators:\r\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\r\n *     values can currently only be 2, 3 or 4 (WebGL only).\r\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\r\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\r\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\r\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\r\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\r\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\r\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\r\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\r\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\r\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\r\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\r\n *\r\n * Values can either be literals or another operator, as they will be evaluated recursively.\r\n * Literal values can be of the following types:\r\n * * `boolean`\r\n * * `number`\r\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\r\n * * `string`\r\n * * {@link module:ol/color~Color}\r\n *\r\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\r\n * @api\r\n */\r\n\r\nlet numTypes = 0;\r\nexport const NoneType = 0;\r\nexport const BooleanType = 1 << numTypes++;\r\nexport const NumberType = 1 << numTypes++;\r\nexport const StringType = 1 << numTypes++;\r\nexport const ColorType = 1 << numTypes++;\r\nexport const NumberArrayType = 1 << numTypes++;\r\nexport const SizeType = 1 << numTypes++;\r\nexport const AnyType = Math.pow(2, numTypes) - 1;\r\n\r\nconst typeNames = {\r\n  [BooleanType]: 'boolean',\r\n  [NumberType]: 'number',\r\n  [StringType]: 'string',\r\n  [ColorType]: 'color',\r\n  [NumberArrayType]: 'number[]',\r\n  [SizeType]: 'size',\r\n};\r\n\r\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\r\n\r\n/**\r\n * @param {number} type The type.\r\n * @return {boolean} The type is one of the specific types (not any or a union type).\r\n */\r\nfunction isSpecific(type) {\r\n  return type in typeNames;\r\n}\r\n\r\n/**\r\n * Get a string representation for a type.\r\n * @param {number} type The type.\r\n * @return {string} The type name.\r\n */\r\nexport function typeName(type) {\r\n  const names = [];\r\n  for (const namedType of namedTypes) {\r\n    if (includesType(type, namedType)) {\r\n      names.push(typeNames[namedType]);\r\n    }\r\n  }\r\n  if (names.length === 0) {\r\n    return 'untyped';\r\n  }\r\n  if (names.length < 3) {\r\n    return names.join(' or ');\r\n  }\r\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\r\n}\r\n\r\n/**\r\n * @param {number} broad The broad type.\r\n * @param {number} specific The specific type.\r\n * @return {boolean} The broad type includes the specific type.\r\n */\r\nexport function includesType(broad, specific) {\r\n  return (broad & specific) === specific;\r\n}\r\n\r\n/**\r\n * @param {number} oneType One type.\r\n * @param {number} otherType Another type.\r\n * @return {boolean} The set of types overlap (share a common specific type)\r\n */\r\nexport function overlapsType(oneType, otherType) {\r\n  return !!(oneType & otherType);\r\n}\r\n\r\n/**\r\n * @param {number} type The type.\r\n * @param {number} expected The expected type.\r\n * @return {boolean} The given type is exactly the expected type.\r\n */\r\nexport function isType(type, expected) {\r\n  return type === expected;\r\n}\r\n\r\n/**\r\n * @typedef {boolean|number|string|Array<number>} LiteralValue\r\n */\r\n\r\nexport class LiteralExpression {\r\n  /**\r\n   * @param {number} type The value type.\r\n   * @param {LiteralValue} value The literal value.\r\n   */\r\n  constructor(type, value) {\r\n    if (!isSpecific(type)) {\r\n      throw new Error(\r\n        `literal expressions must have a specific type, got ${typeName(type)}`,\r\n      );\r\n    }\r\n    this.type = type;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\nexport class CallExpression {\r\n  /**\r\n   * @param {number} type The return type.\r\n   * @param {string} operator The operator.\r\n   * @param {...Expression} args The arguments.\r\n   */\r\n  constructor(type, operator, ...args) {\r\n    this.type = type;\r\n    this.operator = operator;\r\n    this.args = args;\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {LiteralExpression|CallExpression} Expression\r\n */\r\n\r\n/**\r\n * @typedef {Object} ParsingContext\r\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\r\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\r\n * @property {boolean} featureId The style uses the feature id.\r\n * @property {boolean} geometryType The style uses the feature geometry type.\r\n */\r\n\r\n/**\r\n * @return {ParsingContext} A new parsing context.\r\n */\r\nexport function newParsingContext() {\r\n  return {\r\n    variables: new Set(),\r\n    properties: new Set(),\r\n    featureId: false,\r\n    geometryType: false,\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {LiteralValue|Array} EncodedExpression\r\n */\r\n\r\n/**\r\n * @param {EncodedExpression} encoded The encoded expression.\r\n * @param {number} expectedType The expected type.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {Expression} The parsed expression result.\r\n */\r\nexport function parse(encoded, expectedType, context) {\r\n  switch (typeof encoded) {\r\n    case 'boolean': {\r\n      if (isType(expectedType, StringType)) {\r\n        return new LiteralExpression(StringType, encoded ? 'true' : 'false');\r\n      }\r\n      if (!includesType(expectedType, BooleanType)) {\r\n        throw new Error(\r\n          `got a boolean, but expected ${typeName(expectedType)}`,\r\n        );\r\n      }\r\n      return new LiteralExpression(BooleanType, encoded);\r\n    }\r\n    case 'number': {\r\n      if (isType(expectedType, SizeType)) {\r\n        return new LiteralExpression(SizeType, toSize(encoded));\r\n      }\r\n      if (isType(expectedType, BooleanType)) {\r\n        return new LiteralExpression(BooleanType, !!encoded);\r\n      }\r\n      if (isType(expectedType, StringType)) {\r\n        return new LiteralExpression(StringType, encoded.toString());\r\n      }\r\n      if (!includesType(expectedType, NumberType)) {\r\n        throw new Error(`got a number, but expected ${typeName(expectedType)}`);\r\n      }\r\n      return new LiteralExpression(NumberType, encoded);\r\n    }\r\n    case 'string': {\r\n      if (isType(expectedType, ColorType)) {\r\n        return new LiteralExpression(ColorType, colorFromString(encoded));\r\n      }\r\n      if (isType(expectedType, BooleanType)) {\r\n        return new LiteralExpression(BooleanType, !!encoded);\r\n      }\r\n      if (!includesType(expectedType, StringType)) {\r\n        throw new Error(`got a string, but expected ${typeName(expectedType)}`);\r\n      }\r\n      return new LiteralExpression(StringType, encoded);\r\n    }\r\n    default: {\r\n      // pass\r\n    }\r\n  }\r\n\r\n  if (!Array.isArray(encoded)) {\r\n    throw new Error('expression must be an array or a primitive value');\r\n  }\r\n\r\n  if (encoded.length === 0) {\r\n    throw new Error('empty expression');\r\n  }\r\n\r\n  if (typeof encoded[0] === 'string') {\r\n    return parseCallExpression(encoded, expectedType, context);\r\n  }\r\n\r\n  for (const item of encoded) {\r\n    if (typeof item !== 'number') {\r\n      throw new Error('expected an array of numbers');\r\n    }\r\n  }\r\n\r\n  if (isType(expectedType, SizeType)) {\r\n    if (encoded.length !== 2) {\r\n      throw new Error(\r\n        `expected an array of two values for a size, got ${encoded.length}`,\r\n      );\r\n    }\r\n    return new LiteralExpression(SizeType, encoded);\r\n  }\r\n\r\n  if (isType(expectedType, ColorType)) {\r\n    if (encoded.length === 3) {\r\n      return new LiteralExpression(ColorType, [...encoded, 1]);\r\n    }\r\n    if (encoded.length === 4) {\r\n      return new LiteralExpression(ColorType, encoded);\r\n    }\r\n    throw new Error(\r\n      `expected an array of 3 or 4 values for a color, got ${encoded.length}`,\r\n    );\r\n  }\r\n\r\n  if (!includesType(expectedType, NumberArrayType)) {\r\n    throw new Error(\r\n      `got an array of numbers, but expected ${typeName(expectedType)}`,\r\n    );\r\n  }\r\n\r\n  return new LiteralExpression(NumberArrayType, encoded);\r\n}\r\n\r\n/**\r\n * @type {Object<string, string>}\r\n */\r\nexport const Ops = {\r\n  Get: 'get',\r\n  Var: 'var',\r\n  Concat: 'concat',\r\n  GeometryType: 'geometry-type',\r\n  LineMetric: 'line-metric',\r\n  Any: 'any',\r\n  All: 'all',\r\n  Not: '!',\r\n  Resolution: 'resolution',\r\n  Zoom: 'zoom',\r\n  Time: 'time',\r\n  Equal: '==',\r\n  NotEqual: '!=',\r\n  GreaterThan: '>',\r\n  GreaterThanOrEqualTo: '>=',\r\n  LessThan: '<',\r\n  LessThanOrEqualTo: '<=',\r\n  Multiply: '*',\r\n  Divide: '/',\r\n  Add: '+',\r\n  Subtract: '-',\r\n  Clamp: 'clamp',\r\n  Mod: '%',\r\n  Pow: '^',\r\n  Abs: 'abs',\r\n  Floor: 'floor',\r\n  Ceil: 'ceil',\r\n  Round: 'round',\r\n  Sin: 'sin',\r\n  Cos: 'cos',\r\n  Atan: 'atan',\r\n  Sqrt: 'sqrt',\r\n  Match: 'match',\r\n  Between: 'between',\r\n  Interpolate: 'interpolate',\r\n  Coalesce: 'coalesce',\r\n  Case: 'case',\r\n  In: 'in',\r\n  Number: 'number',\r\n  String: 'string',\r\n  Array: 'array',\r\n  Color: 'color',\r\n  Id: 'id',\r\n  Band: 'band',\r\n  Palette: 'palette',\r\n  ToString: 'to-string',\r\n  Has: 'has',\r\n};\r\n\r\n/**\r\n * @typedef {function(Array, number, ParsingContext):Expression} Parser\r\n *\r\n * Second argument is the expected type.\r\n */\r\n\r\n/**\r\n * @type {Object<string, Parser>}\r\n */\r\nconst parsers = {\r\n  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\r\n  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),\r\n  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\r\n  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),\r\n  [Ops.Concat]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfType(StringType),\r\n  ),\r\n  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),\r\n  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),\r\n  [Ops.Resolution]: createCallExpressionParser(withNoArgs),\r\n  [Ops.Zoom]: createCallExpressionParser(withNoArgs),\r\n  [Ops.Time]: createCallExpressionParser(withNoArgs),\r\n  [Ops.Any]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfType(BooleanType),\r\n  ),\r\n  [Ops.All]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfType(BooleanType),\r\n  ),\r\n  [Ops.Not]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(BooleanType),\r\n  ),\r\n  [Ops.Equal]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(AnyType),\r\n  ),\r\n  [Ops.NotEqual]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(AnyType),\r\n  ),\r\n  [Ops.GreaterThan]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.LessThan]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.LessThanOrEqualTo]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Multiply]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfReturnType,\r\n  ),\r\n  [Ops.Coalesce]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfReturnType,\r\n  ),\r\n  [Ops.Divide]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Add]: createCallExpressionParser(\r\n    hasArgsCount(2, Infinity),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Subtract]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Clamp]: createCallExpressionParser(\r\n    hasArgsCount(3, 3),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Mod]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Pow]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Abs]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Floor]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Ceil]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Round]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Sin]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Cos]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Atan]: createCallExpressionParser(\r\n    hasArgsCount(1, 2),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Sqrt]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Match]: createCallExpressionParser(\r\n    hasArgsCount(4, Infinity),\r\n    hasEvenArgs,\r\n    withMatchArgs,\r\n  ),\r\n  [Ops.Between]: createCallExpressionParser(\r\n    hasArgsCount(3, 3),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Interpolate]: createCallExpressionParser(\r\n    hasArgsCount(6, Infinity),\r\n    hasEvenArgs,\r\n    withInterpolateArgs,\r\n  ),\r\n  [Ops.Case]: createCallExpressionParser(\r\n    hasArgsCount(3, Infinity),\r\n    hasOddArgs,\r\n    withCaseArgs,\r\n  ),\r\n  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),\r\n  [Ops.Number]: createCallExpressionParser(\r\n    hasArgsCount(1, Infinity),\r\n    withArgsOfType(AnyType),\r\n  ),\r\n  [Ops.String]: createCallExpressionParser(\r\n    hasArgsCount(1, Infinity),\r\n    withArgsOfType(AnyType),\r\n  ),\r\n  [Ops.Array]: createCallExpressionParser(\r\n    hasArgsCount(1, Infinity),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Color]: createCallExpressionParser(\r\n    hasArgsCount(1, 4),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Band]: createCallExpressionParser(\r\n    hasArgsCount(1, 3),\r\n    withArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Palette]: createCallExpressionParser(\r\n    hasArgsCount(2, 2),\r\n    withPaletteArgs,\r\n  ),\r\n  [Ops.ToString]: createCallExpressionParser(\r\n    hasArgsCount(1, 1),\r\n    withArgsOfType(BooleanType | NumberType | StringType | ColorType),\r\n  ),\r\n};\r\n\r\n/**\r\n * @typedef {function(Array<EncodedExpression>, number, ParsingContext):Array<Expression>|void} ArgValidator\r\n *\r\n * An argument validator applies various checks to an encoded expression arguments and\r\n * returns the parsed arguments if any.  The second argument is the return type of the call expression.\r\n */\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withGetArgs(encoded, returnType, context) {\r\n  const argsCount = encoded.length - 1;\r\n  const args = new Array(argsCount);\r\n  for (let i = 0; i < argsCount; ++i) {\r\n    const key = encoded[i + 1];\r\n    switch (typeof key) {\r\n      case 'number': {\r\n        args[i] = new LiteralExpression(NumberType, key);\r\n        break;\r\n      }\r\n      case 'string': {\r\n        args[i] = new LiteralExpression(StringType, key);\r\n        break;\r\n      }\r\n      default: {\r\n        throw new Error(\r\n          `expected a string key or numeric array index for a get operation, got ${key}`,\r\n        );\r\n      }\r\n    }\r\n    if (i === 0) {\r\n      context.properties.add(String(key));\r\n    }\r\n  }\r\n  return args;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withVarArgs(encoded, returnType, context) {\r\n  const name = encoded[1];\r\n  if (typeof name !== 'string') {\r\n    throw new Error('expected a string argument for var operation');\r\n  }\r\n  context.variables.add(name);\r\n\r\n  return [new LiteralExpression(StringType, name)];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction usesFeatureId(encoded, returnType, context) {\r\n  context.featureId = true;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction usesGeometryType(encoded, returnType, context) {\r\n  context.geometryType = true;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withNoArgs(encoded, returnType, context) {\r\n  const operation = encoded[0];\r\n  if (encoded.length !== 1) {\r\n    throw new Error(`expected no arguments for ${operation} operation`);\r\n  }\r\n  return [];\r\n}\r\n\r\n/**\r\n * @param {number} minArgs The minimum number of arguments.\r\n * @param {number} maxArgs The maximum number of arguments.\r\n * @return {ArgValidator} The argument validator\r\n */\r\nfunction hasArgsCount(minArgs, maxArgs) {\r\n  return function (encoded, returnType, context) {\r\n    const operation = encoded[0];\r\n    const argCount = encoded.length - 1;\r\n    if (minArgs === maxArgs) {\r\n      if (argCount !== minArgs) {\r\n        const plural = minArgs === 1 ? '' : 's';\r\n        throw new Error(\r\n          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`,\r\n        );\r\n      }\r\n    } else if (argCount < minArgs || argCount > maxArgs) {\r\n      const range =\r\n        maxArgs === Infinity\r\n          ? `${minArgs} or more`\r\n          : `${minArgs} to ${maxArgs}`;\r\n      throw new Error(\r\n        `expected ${range} arguments for ${operation}, got ${argCount}`,\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * @type {ArgValidator}\r\n */\r\nfunction withArgsOfReturnType(encoded, returnType, context) {\r\n  const argCount = encoded.length - 1;\r\n  /**\r\n   * @type {Array<Expression>}\r\n   */\r\n  const args = new Array(argCount);\r\n  for (let i = 0; i < argCount; ++i) {\r\n    const expression = parse(encoded[i + 1], returnType, context);\r\n    args[i] = expression;\r\n  }\r\n  return args;\r\n}\r\n\r\n/**\r\n * @param {number} argType The argument type.\r\n * @return {ArgValidator} The argument validator\r\n */\r\nfunction withArgsOfType(argType) {\r\n  return function (encoded, returnType, context) {\r\n    const argCount = encoded.length - 1;\r\n    /**\r\n     * @type {Array<Expression>}\r\n     */\r\n    const args = new Array(argCount);\r\n    for (let i = 0; i < argCount; ++i) {\r\n      const expression = parse(encoded[i + 1], argType, context);\r\n      args[i] = expression;\r\n    }\r\n    return args;\r\n  };\r\n}\r\n\r\n/**\r\n * @type {ArgValidator}\r\n */\r\nfunction hasOddArgs(encoded, returnType, context) {\r\n  const operation = encoded[0];\r\n  const argCount = encoded.length - 1;\r\n  if (argCount % 2 === 0) {\r\n    throw new Error(\r\n      `expected an odd number of arguments for ${operation}, got ${argCount} instead`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @type {ArgValidator}\r\n */\r\nfunction hasEvenArgs(encoded, returnType, context) {\r\n  const operation = encoded[0];\r\n  const argCount = encoded.length - 1;\r\n  if (argCount % 2 === 1) {\r\n    throw new Error(\r\n      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withMatchArgs(encoded, returnType, context) {\r\n  const argsCount = encoded.length - 1;\r\n\r\n  const inputType = StringType | NumberType | BooleanType;\r\n\r\n  const input = parse(encoded[1], inputType, context);\r\n\r\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\r\n\r\n  const args = new Array(argsCount - 2);\r\n  for (let i = 0; i < argsCount - 2; i += 2) {\r\n    try {\r\n      const match = parse(encoded[i + 2], input.type, context);\r\n      args[i] = match;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 1} of match expression: ${err.message}`,\r\n      );\r\n    }\r\n    try {\r\n      const output = parse(encoded[i + 3], fallback.type, context);\r\n      args[i + 1] = output;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 2} of match expression: ${err.message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  return [input, ...args, fallback];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withInterpolateArgs(encoded, returnType, context) {\r\n  const interpolationType = encoded[1];\r\n  /**\r\n   * @type {number}\r\n   */\r\n  let base;\r\n  switch (interpolationType[0]) {\r\n    case 'linear':\r\n      base = 1;\r\n      break;\r\n    case 'exponential':\r\n      const b = interpolationType[1];\r\n      if (typeof b !== 'number' || b <= 0) {\r\n        throw new Error(\r\n          `expected a number base for exponential interpolation` +\r\n            `, got ${JSON.stringify(b)} instead`,\r\n        );\r\n      }\r\n      base = b;\r\n      break;\r\n    default:\r\n      throw new Error(\r\n        `invalid interpolation type: ${JSON.stringify(interpolationType)}`,\r\n      );\r\n  }\r\n\r\n  const interpolation = new LiteralExpression(NumberType, base);\r\n\r\n  let input;\r\n  try {\r\n    input = parse(encoded[2], NumberType, context);\r\n  } catch (err) {\r\n    throw new Error(\r\n      `failed to parse argument 1 in interpolate expression: ${err.message}`,\r\n    );\r\n  }\r\n\r\n  const args = new Array(encoded.length - 3);\r\n  for (let i = 0; i < args.length; i += 2) {\r\n    try {\r\n      const stop = parse(encoded[i + 3], NumberType, context);\r\n      args[i] = stop;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 2} for interpolate expression: ${err.message}`,\r\n      );\r\n    }\r\n    try {\r\n      const output = parse(encoded[i + 4], returnType, context);\r\n      args[i + 1] = output;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 3} for interpolate expression: ${err.message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  return [interpolation, input, ...args];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withCaseArgs(encoded, returnType, context) {\r\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\r\n\r\n  const args = new Array(encoded.length - 1);\r\n  for (let i = 0; i < args.length - 1; i += 2) {\r\n    try {\r\n      const condition = parse(encoded[i + 1], BooleanType, context);\r\n      args[i] = condition;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i} of case expression: ${err.message}`,\r\n      );\r\n    }\r\n    try {\r\n      const output = parse(encoded[i + 2], fallback.type, context);\r\n      args[i + 1] = output;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse argument ${i + 1} of case expression: ${err.message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  args[args.length - 1] = fallback;\r\n  return args;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withInArgs(encoded, returnType, context) {\r\n  let haystack = encoded[2];\r\n  if (!Array.isArray(haystack)) {\r\n    throw new Error(\r\n      `the second argument for the \"in\" operator must be an array`,\r\n    );\r\n  }\r\n  /**\r\n   * @type {number}\r\n   */\r\n  let needleType;\r\n  if (typeof haystack[0] === 'string') {\r\n    if (haystack[0] !== 'literal') {\r\n      throw new Error(\r\n        `for the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions`,\r\n      );\r\n    }\r\n    if (!Array.isArray(haystack[1])) {\r\n      throw new Error(\r\n        `failed to parse \"in\" expression: the literal operator must be followed by an array`,\r\n      );\r\n    }\r\n    haystack = haystack[1];\r\n    needleType = StringType;\r\n  } else {\r\n    needleType = NumberType;\r\n  }\r\n\r\n  const args = new Array(haystack.length);\r\n  for (let i = 0; i < args.length; i++) {\r\n    try {\r\n      const arg = parse(haystack[i], needleType, context);\r\n      args[i] = arg;\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse haystack item ${i} for \"in\" expression: ${err.message}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  const needle = parse(encoded[1], needleType, context);\r\n  return [needle, ...args];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withPaletteArgs(encoded, returnType, context) {\r\n  let index;\r\n  try {\r\n    index = parse(encoded[1], NumberType, context);\r\n  } catch (err) {\r\n    throw new Error(\r\n      `failed to parse first argument in palette expression: ${err.message}`,\r\n    );\r\n  }\r\n  const colors = encoded[2];\r\n  if (!Array.isArray(colors)) {\r\n    throw new Error('the second argument of palette must be an array');\r\n  }\r\n  const parsedColors = new Array(colors.length);\r\n  for (let i = 0; i < parsedColors.length; i++) {\r\n    let color;\r\n    try {\r\n      color = parse(colors[i], ColorType, context);\r\n    } catch (err) {\r\n      throw new Error(\r\n        `failed to parse color at index ${i} in palette expression: ${err.message}`,\r\n      );\r\n    }\r\n    if (!(color instanceof LiteralExpression)) {\r\n      throw new Error(\r\n        `the palette color at index ${i} must be a literal value`,\r\n      );\r\n    }\r\n    parsedColors[i] = color;\r\n  }\r\n  return [index, ...parsedColors];\r\n}\r\n\r\n/**\r\n * @param {Array<ArgValidator>} validators A chain of argument validators.  The last validator is expected\r\n * to return the parsed arguments.\r\n * @return {Parser} The parser.\r\n */\r\nfunction createCallExpressionParser(...validators) {\r\n  return function (encoded, returnType, context) {\r\n    const operator = encoded[0];\r\n\r\n    /**\r\n     * @type {Array<Expression>}\r\n     */\r\n    let args;\r\n    for (let i = 0; i < validators.length; i++) {\r\n      const parsed = validators[i](encoded, returnType, context);\r\n      if (i == validators.length - 1) {\r\n        if (!parsed) {\r\n          throw new Error(\r\n            'expected last argument validator to return the parsed args',\r\n          );\r\n        }\r\n        args = parsed;\r\n      }\r\n    }\r\n    return new CallExpression(returnType, operator, ...args);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {Array} encoded The encoded expression.\r\n * @param {number} returnType The expected return type of the call expression.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {Expression} The parsed expression.\r\n */\r\nfunction parseCallExpression(encoded, returnType, context) {\r\n  const operator = encoded[0];\r\n\r\n  const parser = parsers[operator];\r\n  if (!parser) {\r\n    throw new Error(`unknown operator: ${operator}`);\r\n  }\r\n  return parser(encoded, returnType, context);\r\n}\r\n\r\n/**\r\n * Returns a simplified geometry type suited for the `geometry-type` operator\r\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\r\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\r\n */\r\nexport function computeGeometryType(geometry) {\r\n  if (!geometry) {\r\n    return '';\r\n  }\r\n  const type = geometry.getType();\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'LineString':\r\n    case 'Polygon':\r\n      return type;\r\n    case 'MultiPoint':\r\n    case 'MultiLineString':\r\n    case 'MultiPolygon':\r\n      return /** @type {'Point'|'LineString'|'Polygon'} */ (type.substring(5));\r\n    case 'Circle':\r\n      return 'Polygon';\r\n    case 'GeometryCollection':\r\n      return computeGeometryType(\r\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries()[0],\r\n      );\r\n    default:\r\n      return '';\r\n  }\r\n}\r\n","/**\r\n * @module CME2D/webgl/PaletteTexture\r\n */\r\n\r\nclass PaletteTexture {\r\n  /**\r\n   * @param {string} name The name of the texture.\r\n   * @param {Uint8Array} data The texture data.\r\n   */\r\n  constructor(name, data) {\r\n    this.name = name;\r\n    this.data = data;\r\n\r\n    /**\r\n     * @type {WebGLTexture|null}\r\n     * @private\r\n     */\r\n    this.texture_ = null;\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} gl Rendering context.\r\n   * @return {WebGLTexture} The texture.\r\n   */\r\n  getTexture(gl) {\r\n    if (!this.texture_) {\r\n      const texture = gl.createTexture();\r\n      gl.bindTexture(gl.TEXTURE_2D, texture);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        0,\r\n        gl.RGBA,\r\n        this.data.length / 4,\r\n        1,\r\n        0,\r\n        gl.RGBA,\r\n        gl.UNSIGNED_BYTE,\r\n        this.data,\r\n      );\r\n      this.texture_ = texture;\r\n    }\r\n    return this.texture_;\r\n  }\r\n\r\n  /**\r\n   * @param {WebGLRenderingContext} gl Rendering context.\r\n   */\r\n  delete(gl) {\r\n    if (this.texture_) {\r\n      gl.deleteTexture(this.texture_);\r\n    }\r\n    this.texture_ = null;\r\n  }\r\n}\r\n\r\nexport default PaletteTexture;\r\n","/**\r\n * @module CME2D/expr/gpu\r\n */\r\nimport PaletteTexture from '../webgl/PaletteTexture.js';\r\nimport {\r\n  BooleanType,\r\n  CallExpression,\r\n  ColorType,\r\n  NumberArrayType,\r\n  NumberType,\r\n  Ops,\r\n  SizeType,\r\n  StringType,\r\n  computeGeometryType,\r\n  parse,\r\n  typeName,\r\n} from './expression.js';\r\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\r\nimport {asArray} from '../color.js';\r\nimport {toSize} from '../size.js';\r\n\r\n/**\r\n * @param {string} operator Operator\r\n * @param {CompilationContext} context Compilation context\r\n * @return {string} A function name based on the operator, unique in the given context\r\n */\r\nfunction computeOperatorFunctionName(operator, context) {\r\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\r\n}\r\n\r\n/**\r\n * Will return the number as a float with a dot separator, which is required by GLSL.\r\n * @param {number} v Numerical value.\r\n * @return {string} The value as string.\r\n */\r\nexport function numberToGlsl(v) {\r\n  const s = v.toString();\r\n  return s.includes('.') ? s : s + '.0';\r\n}\r\n\r\n/**\r\n * Will return the number array as a float with a dot separator, concatenated with ', '.\r\n * @param {Array<number>} array Numerical values array.\r\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\r\n */\r\nexport function arrayToGlsl(array) {\r\n  if (array.length < 2 || array.length > 4) {\r\n    throw new Error(\r\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.',\r\n    );\r\n  }\r\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\r\n}\r\n\r\n/**\r\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\r\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\r\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\r\n * Note that the final array will always have 4 components.\r\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\r\n */\r\nexport function colorToGlsl(color) {\r\n  const array = asArray(color);\r\n  const alpha = array.length > 3 ? array[3] : 1;\r\n  return arrayToGlsl([array[0] / 255, array[1] / 255, array[2] / 255, alpha]);\r\n}\r\n\r\n/**\r\n * Normalizes and converts a number or array toa `vec2` array compatible with GLSL.\r\n * @param {number|import('../size.js').Size} size Size.\r\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\r\n */\r\nexport function sizeToGlsl(size) {\r\n  const array = toSize(size);\r\n  return arrayToGlsl(array);\r\n}\r\n\r\n/** @type {Object<string, number>} */\r\nconst stringToFloatMap = {};\r\nlet stringToFloatCounter = 0;\r\n\r\n/**\r\n * Returns a stable equivalent number for the string literal.\r\n * @param {string} string String literal value\r\n * @return {number} Number equivalent\r\n */\r\nexport function getStringNumberEquivalent(string) {\r\n  if (!(string in stringToFloatMap)) {\r\n    stringToFloatMap[string] = stringToFloatCounter++;\r\n  }\r\n  return stringToFloatMap[string];\r\n}\r\n\r\n/**\r\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\r\n * converted to be a GLSL-compatible string.\r\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\r\n * @param {string} string String literal value\r\n * @return {string} GLSL-compatible string containing a number\r\n */\r\nexport function stringToGlsl(string) {\r\n  return numberToGlsl(getStringNumberEquivalent(string));\r\n}\r\n\r\n/**\r\n * Get the uniform name given a variable name.\r\n * @param {string} variableName The variable name.\r\n * @return {string} The uniform name.\r\n */\r\nexport function uniformNameForVariable(variableName) {\r\n  return 'u_var_' + variableName;\r\n}\r\n\r\n/**\r\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\r\n */\r\n/**\r\n *\r\n * @typedef {import(\"./expression.js\").Expression} Expression\r\n */\r\n/**\r\n *\r\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompilationContextProperty\r\n * @property {string} name Name\r\n * @property {number} type Resolved property type\r\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompilationContextVariable\r\n * @property {string} name Name\r\n * @property {number} type Resolved variable type\r\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompilationContext\r\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\r\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\r\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\r\n * @property {Object<string, string>} functions Lookup of functions used by the style.\r\n * @property {number} [bandCount] Number of bands per pixel.\r\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\r\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\r\n */\r\n\r\n/**\r\n * @return {CompilationContext} A new compilation context.\r\n */\r\nexport function newCompilationContext() {\r\n  return {\r\n    inFragmentShader: false,\r\n    variables: {},\r\n    properties: {},\r\n    functions: {},\r\n    bandCount: 0,\r\n    style: {},\r\n  };\r\n}\r\n\r\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\r\n\r\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\r\n\r\n/**\r\n * @typedef {string} CompiledExpression\r\n */\r\n\r\n/**\r\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\r\n * Third argument is the expected value types\r\n */\r\n\r\n/**\r\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\r\n * @param {number} type The expected type.\r\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\r\n * @param {CompilationContext} compilationContext An existing compilation context\r\n * @return {CompiledExpression} The compiled expression.\r\n */\r\nexport function buildExpression(\r\n  encoded,\r\n  type,\r\n  parsingContext,\r\n  compilationContext,\r\n) {\r\n  const expression = parse(encoded, type, parsingContext);\r\n  return compile(expression, type, compilationContext);\r\n}\r\n\r\n/**\r\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\r\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\r\n */\r\nfunction createCompiler(output) {\r\n  return (context, expression, type) => {\r\n    const length = expression.args.length;\r\n    const args = new Array(length);\r\n    for (let i = 0; i < length; ++i) {\r\n      args[i] = compile(expression.args[i], type, context);\r\n    }\r\n    return output(args, context);\r\n  };\r\n}\r\n\r\n/**\r\n * @type {Object<string, Compiler>}\r\n */\r\nconst compilers = {\r\n  [Ops.Get]: (context, expression) => {\r\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\r\n    const propName = /** @type {string} */ (firstArg.value);\r\n    const isExisting = propName in context.properties;\r\n    if (!isExisting) {\r\n      context.properties[propName] = {\r\n        name: propName,\r\n        type: expression.type,\r\n      };\r\n    }\r\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\r\n    return prefix + propName;\r\n  },\r\n  [Ops.GeometryType]: (context, expression, type) => {\r\n    const propName = 'geometryType';\r\n    const isExisting = propName in context.properties;\r\n    if (!isExisting) {\r\n      context.properties[propName] = {\r\n        name: propName,\r\n        type: StringType,\r\n        evaluator: (feature) => {\r\n          return computeGeometryType(feature.getGeometry());\r\n        },\r\n      };\r\n    }\r\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\r\n    return prefix + propName;\r\n  },\r\n  [Ops.LineMetric]: () => 'currentLineMetric', // this variable is assumed to always be present in shaders, default is 0.\r\n  [Ops.Var]: (context, expression) => {\r\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\r\n    const varName = /** @type {string} */ (firstArg.value);\r\n    const isExisting = varName in context.variables;\r\n    if (!isExisting) {\r\n      context.variables[varName] = {\r\n        name: varName,\r\n        type: expression.type,\r\n      };\r\n    }\r\n    return uniformNameForVariable(varName);\r\n  },\r\n  [Ops.Resolution]: () => 'u_resolution',\r\n  [Ops.Zoom]: () => 'u_zoom',\r\n  [Ops.Time]: () => 'u_time',\r\n  [Ops.Any]: createCompiler((compiledArgs) => `(${compiledArgs.join(` || `)})`),\r\n  [Ops.All]: createCompiler((compiledArgs) => `(${compiledArgs.join(` && `)})`),\r\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\r\n  [Ops.Equal]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`,\r\n  ),\r\n  [Ops.NotEqual]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`,\r\n  ),\r\n  [Ops.GreaterThan]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`,\r\n  ),\r\n  [Ops.GreaterThanOrEqualTo]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`,\r\n  ),\r\n  [Ops.LessThan]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`,\r\n  ),\r\n  [Ops.LessThanOrEqualTo]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`,\r\n  ),\r\n  [Ops.Multiply]: createCompiler(\r\n    (compiledArgs) => `(${compiledArgs.join(' * ')})`,\r\n  ),\r\n  [Ops.Divide]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`,\r\n  ),\r\n  [Ops.Add]: createCompiler((compiledArgs) => `(${compiledArgs.join(' + ')})`),\r\n  [Ops.Subtract]: createCompiler(\r\n    ([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`,\r\n  ),\r\n  [Ops.Clamp]: createCompiler(\r\n    ([value, min, max]) => `clamp(${value}, ${min}, ${max})`,\r\n  ),\r\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\r\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\r\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\r\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\r\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\r\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\r\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\r\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\r\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\r\n    return secondValue !== undefined\r\n      ? `atan(${firstValue}, ${secondValue})`\r\n      : `atan(${firstValue})`;\r\n  }),\r\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\r\n  [Ops.Match]: createCompiler((compiledArgs) => {\r\n    const input = compiledArgs[0];\r\n    const fallback = compiledArgs[compiledArgs.length - 1];\r\n    let result = null;\r\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\r\n      const match = compiledArgs[i];\r\n      const output = compiledArgs[i + 1];\r\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\r\n    }\r\n    return result;\r\n  }),\r\n  [Ops.Between]: createCompiler(\r\n    ([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`,\r\n  ),\r\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\r\n    let result = '';\r\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\r\n      const stop1 = compiledArgs[i];\r\n      const output1 = result || compiledArgs[i + 1];\r\n      const stop2 = compiledArgs[i + 2];\r\n      const output2 = compiledArgs[i + 3];\r\n      let ratio;\r\n      if (exponent === numberToGlsl(1)) {\r\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\r\n      } else {\r\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\r\n      }\r\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\r\n    }\r\n    return result;\r\n  }),\r\n  [Ops.Case]: createCompiler((compiledArgs) => {\r\n    const fallback = compiledArgs[compiledArgs.length - 1];\r\n    let result = null;\r\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\r\n      const condition = compiledArgs[i];\r\n      const output = compiledArgs[i + 1];\r\n      result = `(${condition} ? ${output} : ${result || fallback})`;\r\n    }\r\n    return result;\r\n  }),\r\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\r\n    const funcName = computeOperatorFunctionName('in', context);\r\n    const tests = [];\r\n    for (let i = 0; i < haystack.length; i += 1) {\r\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\r\n    }\r\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\r\n${tests.join('\\n')}\r\n  return false;\r\n}`;\r\n    return `${funcName}(${needle})`;\r\n  }),\r\n  [Ops.Array]: createCompiler(\r\n    (args) => `vec${args.length}(${args.join(', ')})`,\r\n  ),\r\n  [Ops.Color]: createCompiler((compiledArgs) => {\r\n    if (compiledArgs.length === 1) {\r\n      //grayscale\r\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), 1.0)`;\r\n    }\r\n    if (compiledArgs.length === 2) {\r\n      //grayscale with alpha\r\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), ${compiledArgs[1]})`;\r\n    }\r\n    const rgb = compiledArgs.slice(0, 3).map((color) => `${color} / 255.0`);\r\n    if (compiledArgs.length === 3) {\r\n      return `vec4(${rgb.join(', ')}, 1.0)`;\r\n    }\r\n    const alpha = compiledArgs[3];\r\n    return `vec4(${rgb.join(', ')}, ${alpha})`;\r\n  }),\r\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\r\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\r\n      let ifBlocks = '';\r\n      const bandCount = context.bandCount || 1;\r\n      for (let i = 0; i < bandCount; i++) {\r\n        const colorIndex = Math.floor(i / 4);\r\n        let bandIndex = i % 4;\r\n        if (i === bandCount - 1 && bandIndex === 1) {\r\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\r\n          bandIndex = 3;\r\n        }\r\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\r\n        ifBlocks += `  if (band == ${i + 1}.0) {\r\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\r\n  }\r\n`;\r\n      }\r\n\r\n      context.functions[GET_BAND_VALUE_FUNC] =\r\n        `float getBandValue(float band, float xOffset, float yOffset) {\r\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\r\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\r\n${ifBlocks}\r\n}`;\r\n    }\r\n\r\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${\r\n      yOffset ?? '0.0'\r\n    })`;\r\n  }),\r\n  [Ops.Palette]: (context, expression) => {\r\n    const [index, ...colors] = expression.args;\r\n    const numColors = colors.length;\r\n    const palette = new Uint8Array(numColors * 4);\r\n    for (let i = 0; i < colors.length; i++) {\r\n      const parsedValue = /** @type {string | Array<number>} */ (\r\n        /** @type {LiteralExpression} */ (colors[i]).value\r\n      );\r\n      const color = asArray(parsedValue);\r\n      const offset = i * 4;\r\n      palette[offset] = color[0];\r\n      palette[offset + 1] = color[1];\r\n      palette[offset + 2] = color[2];\r\n      palette[offset + 3] = color[3] * 255;\r\n    }\r\n    if (!context.paletteTextures) {\r\n      context.paletteTextures = [];\r\n    }\r\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\r\n    const paletteTexture = new PaletteTexture(paletteName, palette);\r\n    context.paletteTextures.push(paletteTexture);\r\n    const compiledIndex = compile(index, NumberType, context);\r\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\r\n  },\r\n  // TODO: unimplemented\r\n  // Ops.Number\r\n  // Ops.String\r\n  // Ops.Coalesce\r\n  // Ops.Concat\r\n  // Ops.ToString\r\n};\r\n\r\n/**\r\n * @param {Expression} expression The expression.\r\n * @param {number} returnType The expected return type.\r\n * @param {CompilationContext} context The compilation context.\r\n * @return {CompiledExpression} The compiled expression\r\n */\r\nfunction compile(expression, returnType, context) {\r\n  // operator\r\n  if (expression instanceof CallExpression) {\r\n    const compiler = compilers[expression.operator];\r\n    if (compiler === undefined) {\r\n      throw new Error(\r\n        `No compiler defined for this operator: ${JSON.stringify(\r\n          expression.operator,\r\n        )}`,\r\n      );\r\n    }\r\n    return compiler(context, expression, returnType);\r\n  }\r\n\r\n  if ((expression.type & NumberType) > 0) {\r\n    return numberToGlsl(/** @type {number} */ (expression.value));\r\n  }\r\n\r\n  if ((expression.type & BooleanType) > 0) {\r\n    return expression.value.toString();\r\n  }\r\n\r\n  if ((expression.type & StringType) > 0) {\r\n    return stringToGlsl(expression.value.toString());\r\n  }\r\n\r\n  if ((expression.type & ColorType) > 0) {\r\n    return colorToGlsl(\r\n      /** @type {Array<number> | string} */ (expression.value),\r\n    );\r\n  }\r\n\r\n  if ((expression.type & NumberArrayType) > 0) {\r\n    return arrayToGlsl(/** @type {Array<number>} */ (expression.value));\r\n  }\r\n\r\n  if ((expression.type & SizeType) > 0) {\r\n    return sizeToGlsl(\r\n      /** @type {number|import('../size.js').Size} */ (expression.value),\r\n    );\r\n  }\r\n\r\n  throw new Error(\r\n    `Unexpected expression ${expression.value} (expected type ${typeName(\r\n      returnType,\r\n    )})`,\r\n  );\r\n}\r\n","/**\r\n * Utilities for parsing literal style objects\r\n * @module CME2D/webgl/styleparser\r\n */\r\nimport {\r\n  BooleanType,\r\n  ColorType,\r\n  NumberArrayType,\r\n  NumberType,\r\n  SizeType,\r\n  StringType,\r\n  newParsingContext,\r\n} from '../expr/expression.js';\r\nimport {ShaderBuilder} from './ShaderBuilder.js';\r\nimport {asArray} from '../color.js';\r\nimport {\r\n  buildExpression,\r\n  getStringNumberEquivalent,\r\n  stringToGlsl,\r\n  uniformNameForVariable,\r\n} from '../expr/gpu.js';\r\n\r\n/**\r\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\r\n * will be read and modified during the parsing operation.\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\r\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\r\n * @param {number} [expectedType] Expected final type (can be several types combined)\r\n * @return {string} GLSL-compatible output\r\n */\r\nexport function expressionToGlsl(compilationContext, value, expectedType) {\r\n  const parsingContext = newParsingContext();\r\n  return buildExpression(\r\n    value,\r\n    expectedType,\r\n    parsingContext,\r\n    compilationContext,\r\n  );\r\n}\r\n\r\n/**\r\n * Packs all components of a color into a two-floats array\r\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\r\n * @return {Array<number>} Vec2 array containing the color in compressed form\r\n */\r\nexport function packColor(color) {\r\n  const array = asArray(color);\r\n  const r = array[0] * 256;\r\n  const g = array[1];\r\n  const b = array[2] * 256;\r\n  const a = Math.round(array[3] * 255);\r\n  return [r + g, b + a];\r\n}\r\n\r\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\r\n  return vec4(\r\n    fract(floor(packedColor[0] / 256.0) / 256.0),\r\n    fract(packedColor[0] / 256.0),\r\n    fract(floor(packedColor[1] / 256.0) / 256.0),\r\n    fract(packedColor[1] / 256.0)\r\n  );\r\n}`;\r\n\r\n/**\r\n * @param {number} type Value type\r\n * @return {1|2|3|4} The amount of components for this value\r\n */\r\nfunction getGlslSizeFromType(type) {\r\n  if (type === ColorType || type === SizeType) {\r\n    return 2;\r\n  }\r\n  if (type === NumberArrayType) {\r\n    return 4;\r\n  }\r\n  return 1;\r\n}\r\n\r\n/**\r\n * @param {number} type Value type\r\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\r\n */\r\nfunction getGlslTypeFromType(type) {\r\n  const size = getGlslSizeFromType(type);\r\n  if (size > 1) {\r\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\r\n  }\r\n  return 'float';\r\n}\r\n\r\n/**\r\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\n * @param {Object|string} input The hash input, either an object or string\r\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\r\n */\r\nexport function computeHash(input) {\r\n  const hash = JSON.stringify(input)\r\n    .split('')\r\n    .reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\r\n  return (hash >>> 0).toString();\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\r\n */\r\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\r\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\r\n    let radius = expressionToGlsl(\r\n      vertContext,\r\n      style[`${prefix}radius`],\r\n      NumberType,\r\n    );\r\n    if (`${prefix}radius2` in style) {\r\n      const radius2 = expressionToGlsl(\r\n        vertContext,\r\n        style[`${prefix}radius2`],\r\n        NumberType,\r\n      );\r\n      radius = `max(${radius}, ${radius2})`;\r\n    }\r\n    if (`${prefix}stroke-width` in style) {\r\n      radius = `(${radius} + ${expressionToGlsl(\r\n        vertContext,\r\n        style[`${prefix}stroke-width`],\r\n        NumberType,\r\n      )} * 0.5)`;\r\n    }\r\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\r\n  }\r\n  if (`${prefix}scale` in style) {\r\n    const scale = expressionToGlsl(\r\n      vertContext,\r\n      style[`${prefix}scale`],\r\n      SizeType,\r\n    );\r\n    builder.setSymbolSizeExpression(\r\n      `${builder.getSymbolSizeExpression()} * ${scale}`,\r\n    );\r\n  }\r\n  if (`${prefix}displacement` in style) {\r\n    builder.setSymbolOffsetExpression(\r\n      expressionToGlsl(\r\n        vertContext,\r\n        style[`${prefix}displacement`],\r\n        NumberArrayType,\r\n      ),\r\n    );\r\n  }\r\n  if (`${prefix}rotation` in style) {\r\n    builder.setSymbolRotationExpression(\r\n      expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType),\r\n    );\r\n  }\r\n  if (`${prefix}rotate-with-view` in style) {\r\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} distanceField The distance field expression\r\n * @param {string|null} fillColor The fill color expression; null if no fill\r\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\r\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\r\n * @param {string|null} opacity The opacity expression; null if no stroke\r\n * @return {string} The final color expression, based on the distance field and given params\r\n */\r\nfunction getColorFromDistanceField(\r\n  distanceField,\r\n  fillColor,\r\n  strokeColor,\r\n  strokeWidth,\r\n  opacity,\r\n) {\r\n  let color = 'vec4(0.)';\r\n  if (fillColor !== null) {\r\n    color = fillColor;\r\n  }\r\n  if (strokeColor !== null && strokeWidth !== null) {\r\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\r\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\r\n  }\r\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\r\n  let result = `${color} * vec4(1.0, 1.0, 1.0, ${shapeOpacity})`;\r\n  if (opacity !== null) {\r\n    result = `${result} * vec4(1.0, 1.0, 1.0, ${opacity})`;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * This will parse an image property provided by `<prefix>-src`\r\n * The image size expression in GLSL will be returned\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\r\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\r\n * @return {string} The image size expression\r\n */\r\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\r\n  const image = new Image();\r\n  image.crossOrigin =\r\n    style[`${prefix}cross-origin`] === undefined\r\n      ? 'anonymous'\r\n      : style[`${prefix}cross-origin`];\r\n  image.src = style[`${prefix}src`];\r\n\r\n  // the size is provided asynchronously using a uniform\r\n  uniforms[`u_texture${textureId}_size`] = () => {\r\n    return image.complete ? [image.width, image.height] : [0, 0];\r\n  };\r\n  builder.addUniform(`vec2 u_texture${textureId}_size`);\r\n  const size = `u_texture${textureId}_size`;\r\n\r\n  uniforms[`u_texture${textureId}`] = image;\r\n  builder.addUniform(`sampler2D u_texture${textureId}`);\r\n  return size;\r\n}\r\n\r\n/**\r\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\r\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\r\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\r\n * @return {string} The offset expression\r\n */\r\nfunction parseImageOffsetProperties(\r\n  style,\r\n  prefix,\r\n  context,\r\n  imageSize,\r\n  sampleSize,\r\n) {\r\n  let offsetExpression = expressionToGlsl(\r\n    context,\r\n    style[`${prefix}offset`],\r\n    NumberArrayType,\r\n  );\r\n  if (`${prefix}offset-origin` in style) {\r\n    switch (style[`${prefix}offset-origin`]) {\r\n      case 'top-right':\r\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\r\n        break;\r\n      case 'bottom-left':\r\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\r\n        break;\r\n      case 'bottom-right':\r\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\r\n        break;\r\n      default: // pass\r\n    }\r\n  }\r\n  return offsetExpression;\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseCircleProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  // this function takes in screen coordinates in pixels and returns the signed distance field\r\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\r\n  fragContext.functions['circleDistanceField'] =\r\n    `float circleDistanceField(vec2 point, float radius) {\r\n  return length(point) - radius;\r\n}`;\r\n\r\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\r\n\r\n  // OPACITY\r\n  let opacity = null;\r\n  if ('circle-opacity' in style) {\r\n    opacity = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-opacity'],\r\n      NumberType,\r\n    );\r\n  }\r\n\r\n  // SCALE\r\n  let currentPoint = 'coordsPx';\r\n  if ('circle-scale' in style) {\r\n    const scale = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-scale'],\r\n      SizeType,\r\n    );\r\n    currentPoint = `coordsPx / ${scale}`;\r\n  }\r\n\r\n  // FILL COLOR\r\n  let fillColor = null;\r\n  if ('circle-fill-color' in style) {\r\n    fillColor = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-fill-color'],\r\n      ColorType,\r\n    );\r\n  }\r\n\r\n  // STROKE COLOR\r\n  let strokeColor = null;\r\n  if ('circle-stroke-color' in style) {\r\n    strokeColor = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-stroke-color'],\r\n      ColorType,\r\n    );\r\n  }\r\n\r\n  // RADIUS\r\n  let radius = expressionToGlsl(\r\n    fragContext,\r\n    style['circle-radius'],\r\n    NumberType,\r\n  );\r\n\r\n  // STROKE WIDTH\r\n  let strokeWidth = null;\r\n  if ('circle-stroke-width' in style) {\r\n    strokeWidth = expressionToGlsl(\r\n      fragContext,\r\n      style['circle-stroke-width'],\r\n      NumberType,\r\n    );\r\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\r\n  }\r\n\r\n  // FINAL COLOR\r\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\r\n  const colorExpression = getColorFromDistanceField(\r\n    distanceField,\r\n    fillColor,\r\n    strokeColor,\r\n    strokeWidth,\r\n    opacity,\r\n  );\r\n  builder.setSymbolColorExpression(colorExpression);\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseShapeProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  fragContext.functions['round'] = `float round(float v) {\r\n  return sign(v) * floor(abs(v) + 0.5);\r\n}`;\r\n\r\n  // these functions take in screen coordinates in pixels and returns the signed distance field\r\n  // (0 on the boundary, negative inside the polygon, positive outside, values in pixels)\r\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\r\n  fragContext.functions['starDistanceField'] =\r\n    `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {\r\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\r\n  float c = cos(startAngle);\r\n  float s = sin(startAngle);\r\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\r\n  float alpha = TWO_PI / numPoints; // the angle of one sector\r\n  float beta = atan(pointRotated.y, pointRotated.x);\r\n  float gamma = round(beta / alpha) * alpha; // angle in sector\r\n  c = cos(-gamma);\r\n  s = sin(-gamma);\r\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\r\n  vec2 tipToPoint = inSector + vec2(-radius, 0.);\r\n  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);\r\n  return dot(normalize(edgeNormal), tipToPoint);\r\n}`;\r\n  fragContext.functions['regularDistanceField'] =\r\n    `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\r\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\r\n  float c = cos(startAngle);\r\n  float s = sin(startAngle);\r\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\r\n  float alpha = TWO_PI / numPoints; // the angle of one sector\r\n  float radiusIn = radius * cos(PI / numPoints);\r\n  float beta = atan(pointRotated.y, pointRotated.x);\r\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\r\n  c = cos(-gamma);\r\n  s = sin(-gamma);\r\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\r\n  return inSector.x - radiusIn;\r\n}`;\r\n\r\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\r\n\r\n  // OPACITY\r\n  let opacity = null;\r\n  if ('shape-opacity' in style) {\r\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\r\n  }\r\n\r\n  // SCALE\r\n  let currentPoint = 'coordsPx';\r\n  if ('shape-scale' in style) {\r\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], SizeType);\r\n    currentPoint = `coordsPx / ${scale}`;\r\n  }\r\n\r\n  // FILL COLOR\r\n  let fillColor = null;\r\n  if ('shape-fill-color' in style) {\r\n    fillColor = expressionToGlsl(\r\n      fragContext,\r\n      style['shape-fill-color'],\r\n      ColorType,\r\n    );\r\n  }\r\n\r\n  // STROKE COLOR\r\n  let strokeColor = null;\r\n  if ('shape-stroke-color' in style) {\r\n    strokeColor = expressionToGlsl(\r\n      fragContext,\r\n      style['shape-stroke-color'],\r\n      ColorType,\r\n    );\r\n  }\r\n\r\n  // STROKE WIDTH\r\n  let strokeWidth = null;\r\n  if ('shape-stroke-width' in style) {\r\n    strokeWidth = expressionToGlsl(\r\n      fragContext,\r\n      style['shape-stroke-width'],\r\n      NumberType,\r\n    );\r\n  }\r\n\r\n  // SHAPE TYPE\r\n  const numPoints = expressionToGlsl(\r\n    fragContext,\r\n    style['shape-points'],\r\n    NumberType,\r\n  );\r\n  let angle = '0.';\r\n  if ('shape-angle' in style) {\r\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\r\n  }\r\n  let shapeField;\r\n  let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\r\n  if (strokeWidth !== null) {\r\n    radius = `${radius} + ${strokeWidth} * 0.5`;\r\n  }\r\n  if ('shape-radius2' in style) {\r\n    let radius2 = expressionToGlsl(\r\n      fragContext,\r\n      style['shape-radius2'],\r\n      NumberType,\r\n    );\r\n    if (strokeWidth !== null) {\r\n      radius2 = `${radius2} + ${strokeWidth} * 0.5`;\r\n    }\r\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${radius2}, ${angle})`;\r\n  } else {\r\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\r\n  }\r\n\r\n  // FINAL COLOR\r\n  const colorExpression = getColorFromDistanceField(\r\n    shapeField,\r\n    fillColor,\r\n    strokeColor,\r\n    strokeWidth,\r\n    opacity,\r\n  );\r\n  builder.setSymbolColorExpression(colorExpression);\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseIconProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  // COLOR\r\n  let color = 'vec4(1.0)';\r\n  if ('icon-color' in style) {\r\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\r\n  }\r\n\r\n  // OPACITY\r\n  if ('icon-opacity' in style) {\r\n    color = `${color} * vec4(1.0, 1.0, 1.0, ${expressionToGlsl(\r\n      fragContext,\r\n      style['icon-opacity'],\r\n      NumberType,\r\n    )})`;\r\n  }\r\n\r\n  // IMAGE & SIZE\r\n  const textureId = computeHash(style['icon-src']);\r\n  const sizeExpression = parseImageProperties(\r\n    style,\r\n    builder,\r\n    uniforms,\r\n    'icon-',\r\n    textureId,\r\n  );\r\n  builder\r\n    .setSymbolColorExpression(\r\n      `${color} * texture2D(u_texture${textureId}, v_texCoord)`,\r\n    )\r\n    .setSymbolSizeExpression(sizeExpression);\r\n\r\n  // override size if width/height were specified\r\n  if ('icon-width' in style && 'icon-height' in style) {\r\n    builder.setSymbolSizeExpression(\r\n      `vec2(${expressionToGlsl(\r\n        vertContext,\r\n        style['icon-width'],\r\n        NumberType,\r\n      )}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`,\r\n    );\r\n  }\r\n\r\n  // tex coord\r\n  if ('icon-offset' in style && 'icon-size' in style) {\r\n    const sampleSize = expressionToGlsl(\r\n      vertContext,\r\n      style['icon-size'],\r\n      NumberArrayType,\r\n    );\r\n    const fullsize = builder.getSymbolSizeExpression();\r\n    builder.setSymbolSizeExpression(sampleSize);\r\n    const offset = parseImageOffsetProperties(\r\n      style,\r\n      'icon-',\r\n      vertContext,\r\n      'v_quadSizePx',\r\n      sampleSize,\r\n    );\r\n    builder.setTextureCoordinateExpression(\r\n      `(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`,\r\n    );\r\n  }\r\n\r\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\r\n\r\n  if ('icon-anchor' in style) {\r\n    const anchor = expressionToGlsl(\r\n      vertContext,\r\n      style['icon-anchor'],\r\n      NumberArrayType,\r\n    );\r\n    let scale = `1.0`;\r\n    if (`icon-scale` in style) {\r\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], SizeType);\r\n    }\r\n    let shiftPx;\r\n    if (\r\n      style['icon-anchor-x-units'] === 'pixels' &&\r\n      style['icon-anchor-y-units'] === 'pixels'\r\n    ) {\r\n      shiftPx = `${anchor} * ${scale}`;\r\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\r\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\r\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\r\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\r\n    } else {\r\n      shiftPx = `${anchor} * v_quadSizePx`;\r\n    }\r\n    // default origin is top-left\r\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\r\n    if ('icon-anchor-origin' in style) {\r\n      switch (style['icon-anchor-origin']) {\r\n        case 'top-right':\r\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\r\n          break;\r\n        case 'bottom-left':\r\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\r\n          break;\r\n        case 'bottom-right':\r\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\r\n          break;\r\n        default: // pass\r\n      }\r\n    }\r\n    builder.setSymbolOffsetExpression(\r\n      `${builder.getSymbolOffsetExpression()} + ${offsetPx}`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader Builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseStrokeProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  if ('stroke-color' in style) {\r\n    builder.setStrokeColorExpression(\r\n      expressionToGlsl(fragContext, style['stroke-color'], ColorType),\r\n    );\r\n  }\r\n  if ('stroke-pattern-src' in style) {\r\n    const textureId = computeHash(style['stroke-pattern-src']);\r\n    const sizeExpression = parseImageProperties(\r\n      style,\r\n      builder,\r\n      uniforms,\r\n      'stroke-pattern-',\r\n      textureId,\r\n    );\r\n    let sampleSizeExpression = sizeExpression;\r\n    let offsetExpression = 'vec2(0.)';\r\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\r\n      sampleSizeExpression = expressionToGlsl(\r\n        fragContext,\r\n        style[`stroke-pattern-size`],\r\n        NumberArrayType,\r\n      );\r\n      offsetExpression = parseImageOffsetProperties(\r\n        style,\r\n        'stroke-pattern-',\r\n        fragContext,\r\n        sizeExpression,\r\n        sampleSizeExpression,\r\n      );\r\n    }\r\n    let spacingExpression = '0.';\r\n    if ('stroke-pattern-spacing' in style) {\r\n      spacingExpression = expressionToGlsl(\r\n        fragContext,\r\n        style['stroke-pattern-spacing'],\r\n        NumberType,\r\n      );\r\n    }\r\n    fragContext.functions['sampleStrokePattern'] =\r\n      `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {\r\n  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;\r\n  float spacingScaled = spacingPx * sampleSize.y / lineWidth;\r\n  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\r\n  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\r\n  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);\r\n  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\r\n  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\r\n  return texture2D(texture, texCoord);\r\n}`;\r\n    const textureName = `u_texture${textureId}`;\r\n    let tintExpression = '1.';\r\n    if ('stroke-color' in style) {\r\n      tintExpression = builder.getStrokeColorExpression();\r\n    }\r\n    builder.setStrokeColorExpression(\r\n      `${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio, v_width)`,\r\n    );\r\n  }\r\n\r\n  if ('stroke-width' in style) {\r\n    builder.setStrokeWidthExpression(\r\n      expressionToGlsl(vertContext, style['stroke-width'], NumberType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-offset' in style) {\r\n    builder.setStrokeOffsetExpression(\r\n      expressionToGlsl(vertContext, style['stroke-offset'], NumberType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-line-cap' in style) {\r\n    builder.setStrokeCapExpression(\r\n      expressionToGlsl(vertContext, style['stroke-line-cap'], StringType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-line-join' in style) {\r\n    builder.setStrokeJoinExpression(\r\n      expressionToGlsl(vertContext, style['stroke-line-join'], StringType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-miter-limit' in style) {\r\n    builder.setStrokeMiterLimitExpression(\r\n      expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType),\r\n    );\r\n  }\r\n\r\n  if ('stroke-line-dash' in style) {\r\n    fragContext.functions['getSingleDashDistance'] =\r\n      `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\r\n  float localDistance = mod(distance, dashLengthTotal);\r\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\r\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\r\n  if (capType == ${stringToGlsl('square')}) {\r\n    distanceSegment -= v_width * 0.5;\r\n  } else if (capType == ${stringToGlsl('round')}) {\r\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\r\n  }\r\n  return distanceSegment;\r\n}`;\r\n\r\n    let dashPattern = style['stroke-line-dash'].map((v) =>\r\n      expressionToGlsl(fragContext, v, NumberType),\r\n    );\r\n    // if pattern has odd length, concatenate it with itself to be even\r\n    if (dashPattern.length % 2 === 1) {\r\n      dashPattern = [...dashPattern, ...dashPattern];\r\n    }\r\n\r\n    let offsetExpression = '0.';\r\n    if ('stroke-line-dash-offset' in style) {\r\n      offsetExpression = expressionToGlsl(\r\n        vertContext,\r\n        style['stroke-line-dash-offset'],\r\n        NumberType,\r\n      );\r\n    }\r\n\r\n    // define a function for this dash specifically\r\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\r\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\r\n\r\n    const dashLengthsDef = dashPattern.map(\r\n      (v, i) => `float dashLength${i} = ${v};`,\r\n    );\r\n    const totalLengthDef = dashPattern\r\n      .map((v, i) => `dashLength${i}`)\r\n      .join(' + ');\r\n    let currentDashOffset = '0.';\r\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\r\n    for (let i = 2; i < dashPattern.length; i += 2) {\r\n      currentDashOffset = `${currentDashOffset} + dashLength${\r\n        i - 2\r\n      } + dashLength${i - 1}`;\r\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\r\n    }\r\n\r\n    fragContext.functions[dashFunctionName] =\r\n      `float ${dashFunctionName}(float distance, float radius, float capType) {\r\n  ${dashLengthsDef.join('\\n  ')}\r\n  float totalDashLength = ${totalLengthDef};\r\n  return ${distanceExpression};\r\n}`;\r\n    builder.setStrokeDistanceFieldExpression(\r\n      `${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\r\n * @param {ShaderBuilder} builder Shader Builder\r\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\r\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\r\n */\r\nfunction parseFillProperties(\r\n  style,\r\n  builder,\r\n  uniforms,\r\n  vertContext,\r\n  fragContext,\r\n) {\r\n  if ('fill-color' in style) {\r\n    builder.setFillColorExpression(\r\n      expressionToGlsl(fragContext, style['fill-color'], ColorType),\r\n    );\r\n  }\r\n  if ('fill-pattern-src' in style) {\r\n    const textureId = computeHash(style['fill-pattern-src']);\r\n    const sizeExpression = parseImageProperties(\r\n      style,\r\n      builder,\r\n      uniforms,\r\n      'fill-pattern-',\r\n      textureId,\r\n    );\r\n    let sampleSizeExpression = sizeExpression;\r\n    let offsetExpression = 'vec2(0.)';\r\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\r\n      sampleSizeExpression = expressionToGlsl(\r\n        fragContext,\r\n        style[`fill-pattern-size`],\r\n        NumberArrayType,\r\n      );\r\n      offsetExpression = parseImageOffsetProperties(\r\n        style,\r\n        'fill-pattern-',\r\n        fragContext,\r\n        sizeExpression,\r\n        sampleSizeExpression,\r\n      );\r\n    }\r\n    fragContext.functions['sampleFillPattern'] =\r\n      `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\r\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\r\n  vec2 pxRelativePos = pxPosition - pxOrigin;\r\n  // rotate the relative position from origin by the current view rotation\r\n  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));\r\n  // sample position is computed according to the sample offset & size\r\n  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);\r\n  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\r\n  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));\r\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\r\n  return texture2D(texture, (samplePos + textureOffset) / textureSize);\r\n}`;\r\n    const textureName = `u_texture${textureId}`;\r\n    let tintExpression = '1.';\r\n    if ('fill-color' in style) {\r\n      tintExpression = builder.getFillColorExpression();\r\n    }\r\n    builder.setFillColorExpression(\r\n      `${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} StyleParseResult\r\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\r\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\r\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\r\n */\r\n\r\n/**\r\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\r\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\r\n * arrays to be fed to the `WebGLPointsRenderer` class.\r\n *\r\n * Also returns `uniforms` and `attributes` properties as expected by the\r\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\r\n *\r\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\r\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\r\n */\r\nexport function parseLiteralStyle(style) {\r\n  /**\r\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\r\n   */\r\n  const vertContext = {\r\n    inFragmentShader: false,\r\n    properties: {},\r\n    variables: {},\r\n    functions: {},\r\n    style,\r\n  };\r\n\r\n  /**\r\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\r\n   */\r\n  const fragContext = {\r\n    inFragmentShader: true,\r\n    variables: vertContext.variables,\r\n    properties: {},\r\n    functions: {},\r\n    style,\r\n  };\r\n\r\n  const builder = new ShaderBuilder();\r\n\r\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\r\n  const uniforms = {};\r\n\r\n  if ('icon-src' in style) {\r\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\r\n  } else if ('shape-points' in style) {\r\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\r\n  } else if ('circle-radius' in style) {\r\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\r\n  }\r\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\r\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\r\n\r\n  if (style.filter) {\r\n    const parsedFilter = expressionToGlsl(\r\n      fragContext,\r\n      style.filter,\r\n      BooleanType,\r\n    );\r\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\r\n  }\r\n\r\n  // define one uniform per variable\r\n  for (const varName in fragContext.variables) {\r\n    const variable = fragContext.variables[varName];\r\n    const uniformName = uniformNameForVariable(variable.name);\r\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\r\n\r\n    uniforms[uniformName] = () => {\r\n      const value = style.variables[variable.name];\r\n      if (typeof value === 'number') {\r\n        return value;\r\n      }\r\n      if (typeof value === 'boolean') {\r\n        return value ? 1 : 0;\r\n      }\r\n      if (variable.type === ColorType) {\r\n        return packColor([...asArray(value || '#eee')]);\r\n      }\r\n      if (typeof value === 'string') {\r\n        return getStringNumberEquivalent(value);\r\n      }\r\n      return value;\r\n    };\r\n  }\r\n\r\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\r\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\r\n  for (const propName in fragContext.properties) {\r\n    const property = fragContext.properties[propName];\r\n    if (!vertContext.properties[propName]) {\r\n      vertContext.properties[propName] = property;\r\n    }\r\n    let type = getGlslTypeFromType(property.type);\r\n    let expression = `a_prop_${property.name}`;\r\n    if (property.type === ColorType) {\r\n      type = 'vec4';\r\n      expression = `unpackColor(${expression})`;\r\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\r\n    }\r\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\r\n  }\r\n\r\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\r\n  for (const propName in vertContext.properties) {\r\n    const property = vertContext.properties[propName];\r\n    builder.addAttribute(\r\n      `${getGlslTypeFromType(property.type)} a_prop_${property.name}`,\r\n    );\r\n  }\r\n\r\n  // add functions that were collected in the compilation contexts\r\n  for (const functionName in vertContext.functions) {\r\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\r\n  }\r\n  for (const functionName in fragContext.functions) {\r\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\r\n  }\r\n\r\n  /**\r\n   * @type {import('../render/webgl/VectorStyleRenderer.js').AttributeDefinitions}\r\n   */\r\n  const attributes = {};\r\n  for (const propName in vertContext.properties) {\r\n    const property = vertContext.properties[propName];\r\n    let callback;\r\n    if (property.evaluator) {\r\n      callback = property.evaluator;\r\n    } else {\r\n      callback = (feature) => {\r\n        const value = feature.get(property.name);\r\n        if (property.type === ColorType) {\r\n          return packColor([...asArray(value || '#eee')]);\r\n        }\r\n        if (typeof value === 'string') {\r\n          return getStringNumberEquivalent(value);\r\n        }\r\n        if (typeof value === 'boolean') {\r\n          return value ? 1 : 0;\r\n        }\r\n        return value;\r\n      };\r\n    }\r\n\r\n    attributes[property.name] = {\r\n      size: getGlslSizeFromType(property.type),\r\n      callback,\r\n    };\r\n  }\r\n\r\n  return {builder, attributes, uniforms};\r\n}\r\n","/**\r\n * @module CME2D/layer/WebGLTile\r\n */\r\nimport BaseTileLayer from './BaseTile.js';\r\nimport LayerProperty from '../layer/Property.js';\r\nimport WebGLTileLayerRenderer, {\r\n  Attributes,\r\n  Uniforms,\r\n} from '../renderer/webgl/TileLayer.js';\r\nimport {ColorType, NumberType} from '../expr/expression.js';\r\nimport {\r\n  PALETTE_TEXTURE_ARRAY,\r\n  getStringNumberEquivalent,\r\n  newCompilationContext,\r\n  uniformNameForVariable,\r\n} from '../expr/gpu.js';\r\nimport {expressionToGlsl} from '../webgl/styleparser.js';\r\n\r\n/**\r\n * @typedef {import(\"../source/DataTile.js\").default<import(\"../DataTile.js\").default|import(\"../ImageTile.js\").default>} SourceType\r\n */\r\n\r\n/**\r\n * @typedef {Object} Style\r\n * Translates tile data to rendered pixels.\r\n *\r\n * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These\r\n * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`\r\n * {@link import(\"../expr/expression.js\").ExpressionValue expressions}, using the `['var', 'varName']` operator.\r\n * To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [color] An expression applied to color values.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [brightness=0] Value used to decrease or increase\r\n * the layer brightness.  Values range from -1 to 1.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [contrast=0] Value used to decrease or increase\r\n * the layer contrast.  Values range from -1 to 1.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [exposure=0] Value used to decrease or increase\r\n * the layer exposure.  Values range from -1 to 1.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [saturation=0] Value used to decrease or increase\r\n * the layer saturation.  Values range from -1 to 1.\r\n * @property {import(\"../expr/expression.js\").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.\r\n * Values range from 0 to infinity.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Style} [style] Style to apply to the layer.\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\r\n * means no preloading.\r\n * @property {SourceType} [source] Source for this layer.\r\n * @property {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>} [sources] Array\r\n * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that\r\n * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See\r\n * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a\r\n * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link module:ol/Map~Map#addLayer}.\r\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\r\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\r\n * two zoom levels worth of tiles.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ParsedStyle\r\n * @property {string} vertexShader The vertex shader.\r\n * @property {string} fragmentShader The fragment shader.\r\n * @property {Object<string,import(\"../webgl/Helper.js\").UniformValue>} uniforms Uniform definitions.\r\n * @property {Array<import(\"../webgl/PaletteTexture.js\").default>} paletteTextures Palette textures.\r\n */\r\n\r\n/**\r\n * @param {Style} style The layer style.\r\n * @param {number} [bandCount] The number of bands.\r\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\r\n */\r\nfunction parseStyle(style, bandCount) {\r\n  const vertexShader = `\r\n    attribute vec2 ${Attributes.TEXTURE_COORD};\r\n    uniform mat4 ${Uniforms.TILE_TRANSFORM};\r\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\r\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\r\n    uniform float ${Uniforms.TEXTURE_RESOLUTION};\r\n    uniform float ${Uniforms.TEXTURE_ORIGIN_X};\r\n    uniform float ${Uniforms.TEXTURE_ORIGIN_Y};\r\n    uniform float ${Uniforms.DEPTH};\r\n\r\n    varying vec2 v_textureCoord;\r\n    varying vec2 v_mapCoord;\r\n\r\n    void main() {\r\n      v_textureCoord = ${Attributes.TEXTURE_COORD};\r\n      v_mapCoord = vec2(\r\n        ${Uniforms.TEXTURE_ORIGIN_X} + ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\r\n        ${Uniforms.TEXTURE_ORIGIN_Y} - ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\r\n      );\r\n      gl_Position = ${Uniforms.TILE_TRANSFORM} * vec4(${Attributes.TEXTURE_COORD}, ${Uniforms.DEPTH}, 1.0);\r\n    }\r\n  `;\r\n\r\n  /**\r\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\r\n   */\r\n  const context = {\r\n    ...newCompilationContext(),\r\n    inFragmentShader: true,\r\n    bandCount: bandCount,\r\n    style: style,\r\n  };\r\n\r\n  const pipeline = [];\r\n\r\n  if (style.color !== undefined) {\r\n    const color = expressionToGlsl(context, style.color, ColorType);\r\n    pipeline.push(`color = ${color};`);\r\n  }\r\n\r\n  if (style.contrast !== undefined) {\r\n    const contrast = expressionToGlsl(context, style.contrast, NumberType);\r\n    pipeline.push(\r\n      `color.rgb = clamp((${contrast} + 1.0) * color.rgb - (${contrast} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\r\n    );\r\n  }\r\n\r\n  if (style.exposure !== undefined) {\r\n    const exposure = expressionToGlsl(context, style.exposure, NumberType);\r\n    pipeline.push(\r\n      `color.rgb = clamp((${exposure} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\r\n    );\r\n  }\r\n\r\n  if (style.saturation !== undefined) {\r\n    const saturation = expressionToGlsl(context, style.saturation, NumberType);\r\n    pipeline.push(`\r\n      float saturation = ${saturation} + 1.0;\r\n      float sr = (1.0 - saturation) * 0.2126;\r\n      float sg = (1.0 - saturation) * 0.7152;\r\n      float sb = (1.0 - saturation) * 0.0722;\r\n      mat3 saturationMatrix = mat3(\r\n        sr + saturation, sr, sr,\r\n        sg, sg + saturation, sg,\r\n        sb, sb, sb + saturation\r\n      );\r\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\r\n    `);\r\n  }\r\n\r\n  if (style.gamma !== undefined) {\r\n    const gamma = expressionToGlsl(context, style.gamma, NumberType);\r\n    pipeline.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${gamma}));`);\r\n  }\r\n\r\n  if (style.brightness !== undefined) {\r\n    const brightness = expressionToGlsl(context, style.brightness, NumberType);\r\n    pipeline.push(\r\n      `color.rgb = clamp(color.rgb + ${brightness}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\r\n    );\r\n  }\r\n\r\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\r\n  const uniforms = {};\r\n\r\n  const numVariables = Object.keys(context.variables).length;\r\n  if (numVariables > 1 && !style.variables) {\r\n    throw new Error(\r\n      `Missing variables in style (expected ${context.variables})`,\r\n    );\r\n  }\r\n\r\n  for (let i = 0; i < numVariables; ++i) {\r\n    const variable = context.variables[Object.keys(context.variables)[i]];\r\n    if (!(variable.name in style.variables)) {\r\n      throw new Error(`Missing '${variable.name}' in style variables`);\r\n    }\r\n    const uniformName = uniformNameForVariable(variable.name);\r\n    uniforms[uniformName] = function () {\r\n      let value = style.variables[variable.name];\r\n      if (typeof value === 'string') {\r\n        value = getStringNumberEquivalent(value);\r\n      }\r\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\r\n    };\r\n  }\r\n\r\n  const uniformDeclarations = Object.keys(uniforms).map(function (name) {\r\n    return `uniform float ${name};`;\r\n  });\r\n\r\n  const textureCount = Math.ceil(bandCount / 4);\r\n  uniformDeclarations.push(\r\n    `uniform sampler2D ${Uniforms.TILE_TEXTURE_ARRAY}[${textureCount}];`,\r\n  );\r\n\r\n  if (context.paletteTextures) {\r\n    uniformDeclarations.push(\r\n      `uniform sampler2D ${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}];`,\r\n    );\r\n  }\r\n\r\n  const functionDefintions = Object.keys(context.functions).map(\r\n    function (name) {\r\n      return context.functions[name];\r\n    },\r\n  );\r\n\r\n  const fragmentShader = `\r\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\r\n    precision highp float;\r\n    #else\r\n    precision mediump float;\r\n    #endif\r\n\r\n    varying vec2 v_textureCoord;\r\n    varying vec2 v_mapCoord;\r\n    uniform vec4 ${Uniforms.RENDER_EXTENT};\r\n    uniform float ${Uniforms.TRANSITION_ALPHA};\r\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\r\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\r\n    uniform float ${Uniforms.RESOLUTION};\r\n    uniform float ${Uniforms.ZOOM};\r\n\r\n    ${uniformDeclarations.join('\\n')}\r\n\r\n    ${functionDefintions.join('\\n')}\r\n\r\n    void main() {\r\n      if (\r\n        v_mapCoord[0] < ${Uniforms.RENDER_EXTENT}[0] ||\r\n        v_mapCoord[1] < ${Uniforms.RENDER_EXTENT}[1] ||\r\n        v_mapCoord[0] > ${Uniforms.RENDER_EXTENT}[2] ||\r\n        v_mapCoord[1] > ${Uniforms.RENDER_EXTENT}[3]\r\n      ) {\r\n        discard;\r\n      }\r\n\r\n      vec4 color = texture2D(${\r\n        Uniforms.TILE_TEXTURE_ARRAY\r\n      }[0],  v_textureCoord);\r\n\r\n      ${pipeline.join('\\n')}\r\n\r\n      gl_FragColor = color;\r\n      gl_FragColor.rgb *= gl_FragColor.a;\r\n      gl_FragColor *= ${Uniforms.TRANSITION_ALPHA};\r\n    }`;\r\n\r\n  return {\r\n    vertexShader: vertexShader,\r\n    fragmentShader: fragmentShader,\r\n    uniforms: uniforms,\r\n    paletteTextures: context.paletteTextures,\r\n  };\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>\r\n * @fires import(\"../render/Event.js\").RenderEvent\r\n * @api\r\n */\r\nclass WebGLTileLayer extends BaseTileLayer {\r\n  /**\r\n   * @param {Options} options Tile layer options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? Object.assign({}, options) : {};\r\n\r\n    const style = options.style || {};\r\n    delete options.style;\r\n\r\n    super(options);\r\n\r\n    /**\r\n     * @type {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>}\r\n     * @private\r\n     */\r\n    this.sources_ = options.sources;\r\n\r\n    /**\r\n     * @type {SourceType|null}\r\n     * @private\r\n     */\r\n    this.renderedSource_ = null;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.renderedResolution_ = NaN;\r\n\r\n    /**\r\n     * @type {Style}\r\n     * @private\r\n     */\r\n    this.style_ = style;\r\n\r\n    /**\r\n     * @type {Object<string, (string|number)>}\r\n     * @private\r\n     */\r\n    this.styleVariables_ = this.style_.variables || {};\r\n\r\n    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);\r\n  }\r\n\r\n  /**\r\n   * Gets the sources for this layer, for a given extent and resolution.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @return {Array<SourceType>} Sources.\r\n   */\r\n  getSources(extent, resolution) {\r\n    const source = this.getSource();\r\n    return this.sources_\r\n      ? typeof this.sources_ === 'function'\r\n        ? this.sources_(extent, resolution)\r\n        : this.sources_\r\n      : source\r\n        ? [source]\r\n        : [];\r\n  }\r\n\r\n  /**\r\n   * @return {SourceType} The source being rendered.\r\n   * @override\r\n   */\r\n  getRenderSource() {\r\n    return this.renderedSource_ || this.getSource();\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../source/Source.js\").State} Source state.\r\n   * @override\r\n   */\r\n  getSourceState() {\r\n    const source = this.getRenderSource();\r\n    return source ? source.getState() : 'undefined';\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  handleSourceUpdate_() {\r\n    if (this.hasRenderer()) {\r\n      this.getRenderer().clearCache();\r\n    }\r\n    if (this.getSource()) {\r\n      this.setStyle(this.style_);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @return {number} The number of source bands.\r\n   */\r\n  getSourceBandCount_() {\r\n    const max = Number.MAX_SAFE_INTEGER;\r\n    const sources = this.getSources([-max, -max, max, max], max);\r\n    return sources && sources.length && 'bandCount' in sources[0]\r\n      ? sources[0].bandCount\r\n      : 4;\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  createRenderer() {\r\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\r\n\r\n    return new WebGLTileLayerRenderer(this, {\r\n      vertexShader: parsedStyle.vertexShader,\r\n      fragmentShader: parsedStyle.fragmentShader,\r\n      uniforms: parsedStyle.uniforms,\r\n      cacheSize: this.getCacheSize(),\r\n      paletteTextures: parsedStyle.paletteTextures,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../Map\").FrameState} frameState Frame state.\r\n   * @param {Array<SourceType>} sources Sources.\r\n   * @return {HTMLElement} Canvas.\r\n   */\r\n  renderSources(frameState, sources) {\r\n    const layerRenderer = this.getRenderer();\r\n    let canvas;\r\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\r\n      this.renderedSource_ = sources[i];\r\n      if (layerRenderer.prepareFrame(frameState)) {\r\n        canvas = layerRenderer.renderFrame(frameState);\r\n      }\r\n    }\r\n    return canvas;\r\n  }\r\n\r\n  /**\r\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\r\n   * for rendering its content.\r\n   * @return {HTMLElement} The rendered element.\r\n   * @override\r\n   */\r\n  render(frameState, target) {\r\n    this.rendered = true;\r\n    const viewState = frameState.viewState;\r\n    const sources = this.getSources(frameState.extent, viewState.resolution);\r\n    let ready = true;\r\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\r\n      const source = sources[i];\r\n      const sourceState = source.getState();\r\n      if (sourceState == 'loading') {\r\n        const onChange = () => {\r\n          if (source.getState() == 'ready') {\r\n            source.removeEventListener('change', onChange);\r\n            this.changed();\r\n          }\r\n        };\r\n        source.addEventListener('change', onChange);\r\n      }\r\n      ready = ready && sourceState == 'ready';\r\n    }\r\n    const canvas = this.renderSources(frameState, sources);\r\n    if (this.getRenderer().renderComplete && ready) {\r\n      // Fully rendered, done.\r\n      this.renderedResolution_ = viewState.resolution;\r\n      return canvas;\r\n    }\r\n    // Render sources from previously fully rendered frames\r\n    if (this.renderedResolution_ > 0.5 * viewState.resolution) {\r\n      const altSources = this.getSources(\r\n        frameState.extent,\r\n        this.renderedResolution_,\r\n      ).filter((source) => !sources.includes(source));\r\n      if (altSources.length > 0) {\r\n        return this.renderSources(frameState, altSources);\r\n      }\r\n    }\r\n    return canvas;\r\n  }\r\n\r\n  /**\r\n   * Update the layer style.  The `updateStyleVariables` function is a more efficient\r\n   * way to update layer rendering.  In cases where the whole style needs to be updated,\r\n   * this method may be called instead.  Note that calling this method will also replace\r\n   * any previously set variables, so the new style also needs to include new variables,\r\n   * if needed.\r\n   * @param {Style} style The new style.\r\n   */\r\n  setStyle(style) {\r\n    this.styleVariables_ = style.variables || {};\r\n    this.style_ = style;\r\n    if (this.hasRenderer()) {\r\n      const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\r\n      const renderer = this.getRenderer();\r\n      renderer.reset({\r\n        vertexShader: parsedStyle.vertexShader,\r\n        fragmentShader: parsedStyle.fragmentShader,\r\n        uniforms: parsedStyle.uniforms,\r\n        paletteTextures: parsedStyle.paletteTextures,\r\n      });\r\n      this.changed();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update any variables used by the layer style and trigger a re-render.\r\n   * @param {Object<string, number>} variables Variables to update.\r\n   * @api\r\n   */\r\n  updateStyleVariables(variables) {\r\n    Object.assign(this.styleVariables_, variables);\r\n    this.changed();\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up underlying WebGL resources.\r\n * @function\r\n * @api\r\n */\r\nWebGLTileLayer.prototype.dispose;\r\n\r\nexport default WebGLTileLayer;\r\n","/**\r\n * @module CME2D/CME2DCore/layer/common/commonLayerUnit\r\n */\r\n//  /**\r\n//      * 在x和y方向上将地图平移指定像素。\r\n//      *\r\n//      * @param {Object} map - 地图对象。\r\n//      * @param {number} x - 在x方向上平移的像素数。\r\n//      * @param {number} y - 在y方向上平移的像素数。\r\n//      */\r\nimport commonStyle from \"../../style/commonStyle.js\";\r\n\r\nfunction PanByPixel(map, x, y) {\r\n  // console.log(\"map.getView\", map.getView);\r\n  // console.log(\"map.getView()\", map.getView());\r\n  // if( !map.getView())\r\n  //   return;\r\n\r\n  const map_center = map.getView().getCenter(); //获取当前地图中心点（投影坐标）\r\n  const centerPixel = map.getPixelFromCoordinate(map_center); //投影坐标转为像素坐标\r\n  const newX = centerPixel[0] - x; //平移横坐标\r\n  const newY = centerPixel[1] - y; //平移纵坐标\r\n  map.getView().animate({\r\n    center: map.getCoordinateFromPixel([newX, newY]), //平移后的像素坐标转投影坐标\r\n    duration: 1000,\r\n    zoom: map.getView().getZoom(), //定义比例尺\r\n  }); //如果不需要动画效果，也可以直接用setCenter和setZoom方法移动地图\r\n}\r\n\r\nfunction handlerColor(legend, scala, radio) {\r\n\r\n  let color1 = [\"case\", [\"!=\", [\"band\", 2], 0]];\r\n  let color = [\"interpolate\", [\"linear\"],\r\n    [\"band\", 1]\r\n  ];\r\n  if (legend == null) {\r\n    return null;\r\n  }\r\n  if (radio == 1) {\r\n\r\n\r\n    for (let i = 0; i < legend.length; i++) {\r\n      color = color.concat([legend[i][0] * scala, legend[i][1]]); // //console.log(legend[i]);\r\n    }\r\n    color1.push(color);\r\n    color1.push([\"color\", 0, 0, 0, 0]);\r\n    console.log(\"-----渐变-------------\");\r\n    // console.log(color);\r\n    console.log(JSON.stringify(color1));\r\n    //  color = color.concat([legend[i][0] * scala, legend[i][1]]); // //console.log(legend[i]);\r\n  } else {\r\n\r\n    const resultArray = [\r\n      \"case\",\r\n      [\"==\", [\"band\", 2], 0],\r\n      [\"color\", 0, 0, 0, 0], // 定义范围之外的值的透明颜色\r\n      [\"<=\", [\"band\", 1], legend[0][0] * scala],\r\n      [\"color\", ...legend[0][1]],\r\n    ];\r\n    // for (let i = 0; i < legend.length; i++) {\r\n    for (let i = 0; i < legend.length; i++) {\r\n      const [value, color] = legend[i];\r\n      const [value1, color1] =\r\n      i >= legend.length - 1 ? legend[i] : legend[i + 1];\r\n      resultArray.push([\"between\", [\"band\", 1], value * scala, value1 * scala]);\r\n      // resultArray.push([\"color\", ...color1]);\r\n      resultArray.push([\"color\", ...color]);\r\n    }\r\n    resultArray[resultArray.length] = [\r\n      \"color\",\r\n      ...legend[legend.length - 1][1],\r\n    ];\r\n    color1 = resultArray;\r\n  }\r\n  console.log(\"JSON.stringify(color1)\");\r\n  console.log(JSON.stringify(color1) );\r\n  return color1;\r\n}\r\n\r\nfunction addCommonStyle(style, styleCommon) {\r\n  style = [];\r\n\r\n  // let styleCollection = [];\r\n  for (let key in styleCommon) {\r\n\r\n    style[key] = commonStyle(styleCommon[key]);\r\n  }\r\n  return style;\r\n}\r\n\r\n// function getLayerStyle(options) {\r\n//   let style = options.style; //cogtifLayer图层样式\r\n//   if (options.style) {\r\n//     // 设置cogtifLayer图层样式\r\n//     if (options.source) {\r\n//       if (!options.source.normalize) {\r\n//         let bandsNumber = style.bandsNumber;\r\n//       let offset=Number(style.offset) ||0; \r\n\r\n//         let color = [];\r\n//         // uv 通道的渲染\r\n//         if (bandsNumber == 2) {\r\n//           let value1 = ['-',  [\"band\", 1], offset];\r\n//           let value2 = ['-',  [\"band\", 2], offset];\r\n//           let n1 = [\r\n//             \"+\",\r\n//             [\"*\", value1,value1],\r\n//             [\"*\", value2, value2],\r\n//           ];\r\n//            color = handlerColor(style.color, style.scala, style.radio);\r\n\r\n//            if (style.radio == 1) {\r\n//             let colorGradient = color[2];\r\n\r\n//             colorGradient[2]=[\"sqrt\", n1]\r\n\r\n//            } \r\n//            else {\r\n\r\n//             for (let i = 3; i < color.length-1; i=i+2) {\r\n//               color[i][1] = [\"sqrt\", n1];\r\n//             }\r\n//            }\r\n\r\n//         } else {\r\n//           color = handlerColor(style.color, style.scala, style.radio);\r\n//         }\r\n\r\n//         // color = handlerColor(style.color, style.scala, style.radio);\r\n//         options.style.color = color;\r\n//       } else {\r\n//         options.style = null;\r\n//       }\r\n//     } else {\r\n//       options.style = null;\r\n//     }\r\n//   }\r\n//   return options;\r\n// }\r\n\r\n/**\r\n * 获取图层样式的函数。\r\n *\r\n * @param {object} options - 选项对象\r\n * @return {object} 更新后的选项对象\r\n */\r\nfunction getLayerStyle(options) {\r\n  let style = options.style; //cogtifLayer图层样式\r\n  // this.layerConfig = JSON.parse(JSON.stringify(options))\r\n  if (options.style) {\r\n    // 设置cogtifLayer图层样式\r\n    if (options.source) {\r\n      if (!options.source.normalize) {\r\n        // this.scala = style.scala;\r\n        let bandsNumber = style.bandsNumber;\r\n        let offset = Number(style.offset) || 0;\r\n        let color = [];\r\n        // uv 通道的渲染\r\n        if (bandsNumber == 2) {\r\n\r\n          let value1 = ['-', [\"band\", 1], offset];\r\n          let value2 = ['-', [\"band\", 2], offset];\r\n          let n1 = [\r\n            \"+\",\r\n            [\"*\", value1, value1],\r\n            [\"*\", value2, value2],\r\n          ];\r\n          color = handlerColor(style.color, style.scala, style.radio);\r\n          if (style.radio == 1) {\r\n            let colorGradient = color[2];\r\n            colorGradient[2] = [\"sqrt\", n1]\r\n          } else {\r\n            for (let i = 3; i < color.length - 1; i = i + 2) {\r\n              color[i][1] = [\"sqrt\", n1];\r\n            }\r\n          }\r\n          // console.log(\"color--渲染样式-----------------\");\r\n          // console.log(JSON.stringify(color));\r\n        } else if (bandsNumber == 1) {\r\n\r\n          if (style.unit == \"K\") {\r\n\r\n            color = handlerColor(style.color, style.scala, style.radio);\r\n\r\n          } else if (style.unit == \"℃\") {\r\n\r\n            let value1 = ['/', [\"band\", 1], style.scala];\r\n            let n1 = ['-', value1, 273.15];\r\n\r\n\r\n            color = handlerColor(style.color, style.scala / 10, style.radio);\r\n            if (style.radio == 1) {\r\n              color[2][2] = n1\r\n            } else {\r\n              for (let i = 3; i < color.length - 1; i = i + 2) {\r\n                color[i][1] = n1;\r\n              }\r\n            }\r\n          } else {\r\n            color = handlerColor(style.color, style.scala, style.radio);\r\n          }\r\n        } else {\r\n          color = handlerColor(style.color, style.scala, style.radio);\r\n        }\r\n\r\n        // color = handlerColor(style.color, style.scala, style.radio);\r\n        options.style.color = color;\r\n      } else {\r\n        options.style = null;\r\n      }\r\n    } else {\r\n      options.style = null;\r\n    }\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction getUpdateLayerStyle(options) {\r\n\r\n  // this.scala = 1; //cogtifLayer图层样式scala 值\r\n  // this.map = options.map; //map图层的参数相关信息\r\n  let style = options.style; //cogtifLayer图层样式\r\n  // this.layerConfig = JSON.parse(JSON.stringify(options))\r\n  if (options.style) {\r\n    options.style.color = handlerColor(style.color, style.scala, style.radio);\r\n\r\n    // console.log(JSON.stringify(options.style.color))\r\n\r\n  }\r\n  return options;\r\n}\r\n\r\n/**\r\n * 递归地将两个对象合并为一个新对象，新对象包含两个对象中的所有属性。\r\n * 如果一个属性在两个对象中都存在，并且其值是一个对象，则函数会递归合并这两个对象。\r\n * 如果一个属性只存在于其中一个对象中，则将其添加到合并后的对象中。\r\n * 如果一个属性在两个对象中都存在，并且其值不是一个对象，则第二个对象中的值将覆盖第一个对象中的值。\r\n *\r\n * @param {Object} obj1 - 要合并的第一个对象。\r\n * @param {Object} obj2 - 要合并的第二个对象。\r\n * @return {Object} 合并后的对象。\r\n */\r\n// function mergeObjects(obj1, obj2) {\r\n//   // 创建一个新的对象来存储合并后的结果\r\n//   const mergedObj = {};\r\n//   // 遍历第一个对象的属性\r\n//   for (let prop in obj1) {\r\n//     // 如果属性值是对象，则递归调用mergeObjects函数\r\n//     if (typeof obj1[prop] === 'object' && typeof obj2[prop] === 'object') {\r\n//       mergedObj[prop] = mergeObjects(obj1[prop], obj2[prop]);\r\n//     } else {\r\n//       mergedObj[prop] = obj1[prop];\r\n//     }\r\n//   }\r\n\r\n//   // 遍历第二个对象的属性\r\n//   for (let prop in obj2) {\r\n//     // 如果属性值是对象，且在第一个对象中不存在对应的属性，则直接添加到合并后的对象中\r\n//     if (typeof obj2[prop] === 'object' && !obj1[prop]) {\r\n//       mergedObj[prop] = obj2[prop];\r\n//     } else {\r\n//       // 否则，如果属性已经存在于mergedObj中，将被obj2中的值覆盖\r\n//       // mergedObj[prop] = obj2[prop];\r\n//       mergedObj[prop] = Object.assign({},  mergedObj[prop], obj2[prop])\r\n//     }\r\n//   }\r\n//   return mergedObj;\r\n// }\r\n\r\nfunction mergeObjects(obj1, obj2) {\r\n  const mergedObj = {};\r\n\r\n  // 遍历obj1的根属性\r\n  for (let prop in obj1) {\r\n    if (obj1.hasOwnProperty(prop)) {\r\n      // 如果属性值是对象，则进行合并\r\n      if (typeof obj1[prop] === 'object' && obj1[prop] !== null) {\r\n        mergedObj[prop] = Object.assign({}, obj1[prop]);\r\n      } else {\r\n        mergedObj[prop] = obj1[prop];\r\n      }\r\n    }\r\n  }\r\n\r\n  // 遍历obj2的根属性\r\n  for (let prop in obj2) {\r\n    if (obj2.hasOwnProperty(prop)) {\r\n      // 如果属性在mergedObj中已存在，使用Object.assign()合并值\r\n      if (mergedObj.hasOwnProperty(prop) && typeof mergedObj[prop] === 'object' && mergedObj[prop] !== null) {\r\n        mergedObj[prop] = Object.assign({}, mergedObj[prop], obj2[prop]);\r\n      } else {\r\n        // 否则直接赋值\r\n        mergedObj[prop] = obj2[prop];\r\n      }\r\n    }\r\n  }\r\n\r\n  return mergedObj;\r\n}\r\n\r\n\r\n// // function calculateWindDirection(du, dv) {\r\n// //   const u = parseFloat(du);\r\n// //   const v = parseFloat(dv);\r\n// //   if (u === 0 && v === 0) {\r\n// //       return 999.9;\r\n// //   }\r\n// //   let fx = 0;\r\n// //   if (u > 0 && v > 0) {\r\n// //       fx = 270 * Math.atan(v / u) * (180 / Math.PI);\r\n// //   } else if (u < 0 && v > 0) {\r\n// //       fx = 90 - Math.atan(v / u) * 180 / Math.PI;\r\n// //   } else if (u < 0 && v < 0) {\r\n// //       fx = 90 * Math.atan(v / u) * (180 / Math.PI);\r\n// //   } else if (u > 0 && v < 0) {\r\n// //       fx = 270 * Math.atan(v / u) * (180 / Math.PI);\r\n// //   } else if (u === 0 && v > 0) {\r\n// //       fx = 180;\r\n// //   } else if (u === 0 && v < 0) {\r\n// //       fx = 0;\r\n// //   } else if (u > 0 && v === 0) {\r\n// //       fx = 270;\r\n// //   } else if (u < 0 && v === 0) {\r\n// //       fx = 90;\r\n// //   } else {\r\n// //       fx = 0;\r\n// //   }\r\n\r\n// //   return fx;\r\n// // }\r\n\r\n\r\n// //原来的计算风向 风速的代码\r\n// // /**\r\n//  * 根据给定的u和v分量计算风速和方向。\r\n//  *\r\n//  * @param {number} u - 风向矢量的u分量\r\n//  * @param {number} v - 风向矢量的v分量\r\n//  * @return {object} 包含风速和方向的对象\r\n//  */\r\nfunction getWindSpeedAndDirection(u, v) {\r\n  let data = {}\r\n  const speed = Math.sqrt(u * u + v * v)\r\n  let dir = 270.0 - Math.atan2(v, u) * 180.0 / Math.PI\r\n  if (dir >= 360) dir = dir - 360\r\n  data.speed = speed;\r\n  data.direction = dir.toString();\r\n  return data;\r\n};\r\n\r\n// // // /**\r\n// //  * 根据给定的u和v分量计算风速和方向。\r\n// //  *\r\n// //  * @param {number} du - 风向矢量的u分量\r\n// //  * @param {number} dv - 风向矢量的v分量\r\n// //  * @return {object} 包含风速和方向的对象\r\n// //  */\r\n// function getWindSpeedAndDirection(du, dv) {\r\n//   const u = parseFloat(du);\r\n//   const v = parseFloat(dv);\r\n//   const data = {};\r\n//   const speed = Math.sqrt(u * u + v * v);\r\n//   // let dir=0;\r\n//   let fx = 0;\r\n//   if (u === 0 && v === 0) {\r\n//       // return 999.9;\r\n//       fx=999.9\r\n//   }\r\n//   if (u > 0 && v > 0) {\r\n//       fx = 270 * Math.atan(v / u) * (180 / Math.PI);\r\n//   } else if (u < 0 && v > 0) {\r\n//       fx = 90 - Math.atan(v / u) * 180 / Math.PI;\r\n//   } else if (u < 0 && v < 0) {\r\n//       fx = 90 * Math.atan(v / u) * (180 / Math.PI);\r\n//   } else if (u > 0 && v < 0) {\r\n//       fx = 270 * Math.atan(v / u) * (180 / Math.PI);\r\n//   } else if (u === 0 && v > 0) {\r\n//       fx = 180;\r\n//   } else if (u === 0 && v < 0) {\r\n//       fx = 0;\r\n//   } else if (u > 0 && v === 0) {\r\n//       fx = 270;\r\n//   } else if (u < 0 && v === 0) {\r\n//       fx = 90;\r\n//   } else {\r\n//       fx = 0;\r\n//   }\r\n\r\n//   data.speed = speed;\r\n//   data.direction = fx.toString();\r\n//   return data;\r\n//   // return fx;\r\n// }\r\n\r\nexport {\r\n  PanByPixel,\r\n  handlerColor,\r\n  getLayerStyle,\r\n  addCommonStyle,\r\n  getUpdateLayerStyle,\r\n  mergeObjects,\r\n  getWindSpeedAndDirection\r\n};","// @ts-ignore\r\n/**\r\n * @module CME2D/source/cme_GeoTIFFSource\r\n */\r\n// import DataTile from '../../DataTile.js';\r\nimport GeoTIFF from './../../source/GeoTIFF.js';\r\nimport { TileGrid } from './../../tilegrid.js';\r\nimport { toUserCoordinate, toUserExtent } from './../../proj.js';\r\nimport { getCenter, getIntersection } from './../../extent.js';\r\n\r\n/**\r\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\r\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\r\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\r\n * @param {string} message The error message.\r\n * @param {function(Error):void} rejector A function to be called with any error.\r\n */\r\nfunction assertEqual(expected, got, tolerance, message, rejector) {\r\n  if (Array.isArray(expected)) {\r\n    const length = expected.length;\r\n    if (!Array.isArray(got) || length != got.length) {\r\n      const error = new Error(message);\r\n      rejector(error);\r\n      throw error;\r\n    }\r\n    for (let i = 0; i < length; ++i) {\r\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\r\n    }\r\n    return;\r\n  }\r\n\r\n  got = /** @type {number} */ (got);\r\n  if (Math.abs(expected - got) > tolerance * expected) {\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\n/**\r\n * Determine if an image type is a mask.\r\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} image The image.\r\n * @return {boolean} The image is a mask.\r\n */\r\nfunction isMask(image) {\r\n  const fileDirectory = image.fileDirectory;\r\n  const type = fileDirectory.NewSubfileType || 0;\r\n  return (type & 4) === 4;\r\n}\r\n\r\n/**\r\n * Get the bounding box of an image.  If the image does not have an affine transform,\r\n * the pixel bounds are returned.\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} image The image.\r\n * @return {Array<number>} The image bounding box.\r\n */\r\nfunction getBoundingBox(image) {\r\n  try {\r\n    return image.getBoundingBox();\r\n  } catch (_) {\r\n    return [0, 0, image.getWidth(), image.getHeight()];\r\n  }\r\n}\r\n\r\n/**\r\n * Get the origin of an image.  If the image does not have an affine transform,\r\n * the top-left corner of the pixel bounds is returned.\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} image The image.\r\n * @return {Array<number>} The image origin.\r\n */\r\nfunction getOrigin(image) {\r\n  try {\r\n    return image.getOrigin().slice(0, 2);\r\n  } catch (_) {\r\n    return [0, image.getHeight()];\r\n  }\r\n}\r\n\r\n/**\r\n * Get the resolution of an image.  If the image does not have an affine transform,\r\n * the width of the image is compared with the reference image.\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} image The image.\r\n * @param {import('./../../source/GeoTIFF.js').GeoTIFFImage} referenceImage The reference image.\r\n * @return {Array<number>} The map x and y units per pixel.\r\n */\r\nfunction getResolutions(image, referenceImage) {\r\n  try {\r\n    return image.getResolution(referenceImage);\r\n  } catch (_) {\r\n    return [\r\n      referenceImage.getWidth() / image.getWidth(),\r\n      referenceImage.getHeight() / image.getHeight(),\r\n    ];\r\n  }\r\n}\r\n\r\n// 解析xml字符串\r\nfunction parseXML(xmlString) {\r\n  // 创建 DOMParser 对象并将 XML 字符串解析为 DOM 对象\r\n  const parser = new DOMParser();\r\n  const xmlDoc = parser.parseFromString(xmlString, \"text/xml\");\r\n  // 获取 GDALMetadata 元素下的所有 Item 元素\r\n  const itemElements = xmlDoc.querySelectorAll(\"GDALMetadata Item\");\r\n\r\n  // 创建一个对象来存储解析后的数据\r\n  const parsedData = {};\r\n\r\n  // 遍历每个 Item 元素并将其属性和文本内容存储到对象中\r\n  itemElements.forEach((item) => {\r\n    const name = item.getAttribute(\"name\");\r\n    const value = item.textContent.trim();\r\n    parsedData[name] = value;\r\n  });\r\n\r\n  // console.log(parsedData);\r\n\r\n  return parsedData;\r\n  // this.items = items;\r\n}\r\n\r\nconst defaultTileSize = 256;\r\n\r\n/**\r\n * @typedef {Object} GeoTIFFSourceOptions\r\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\r\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\r\n * @property {string} [credentials] How credentials shall be handled. See\r\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\r\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\r\n * By default only a single range is used.\r\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\r\n * requested. Only use this when you know the source image to be small enough to fit in memory.\r\n * @property {number} [blockSize=65536] The block size to use.\r\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {Array<import('../../source/ogcTileUtil.js').SourceInfo>} sources List of information about GeoTIFF sources.\r\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\r\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\r\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\r\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\r\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\r\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\r\n * band from the first source, and 1 band from the second source.\r\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\r\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\r\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\r\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\r\n * CIELab, and ICCLab images will automatically be converted to RGB.\r\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\r\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\r\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\r\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\r\n * @property {boolean} [opaque=false] Whether the layer is opaque.\r\n * @property {import(\"../../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\r\n * will be read for projection information.\r\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\r\n * To disable the opacity transition, pass `transition: 0`.\r\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A source for working with GeoTIFF data.\r\n * **Note for users of the full build**: The `GeoTIFF` source requires the\r\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\r\n *\r\n * @api\r\n */\r\n// @ts-ignore\r\nclass cme_GeoTIFFSource extends GeoTIFF {\r\n  /**\r\n   * @param {Options} options Data tile options.\r\n   */\r\n  constructor(options) {\r\n    super(options);\r\n    this.gdalMetaDatas = {};\r\n    this.extremums = [];\r\n  }\r\n\r\n  parseXMLMetas(sources) {\r\n    if (!sources?.length) return;\r\n    const xmlDataStr = sources[0].fileDirectory?.GDAL_METADATA;\r\n    if (xmlDataStr) {\r\n      this.gdalMetaDatas = parseXML(xmlDataStr);\r\n    }\r\n    // this.getExtremums(sources).then(values => {\r\n    //   console.log('getExtremums =>', values);\r\n    //   this.extremums = values;\r\n    // })\r\n  }\r\n\r\n  getExtremums(sources) {\r\n    return sources[0].readRasters().then(datas => {\r\n      const extremums = datas.map(list => {\r\n        const minValue = list.reduce((v1, v2) => Math.min(v1, v2), 0);\r\n        const maxValue = list.reduce((v1, v2) => Math.max(v1, v2), 0);\r\n        return { minValue, maxValue };\r\n      });\r\n      return extremums;\r\n    });\r\n  }\r\n\r\n  getMetaDatas() {\r\n    // @ts-ignore\r\n    const { metadata_, normalize_, nodataValues_, bandCount, addAlpha_ } = this;\r\n    // @ts-ignore\r\n    const { extent_ } = this.tileGrid;\r\n    // @ts-ignore\r\n    const { code_ } = this.getProjection();\r\n    return {\r\n      metadata: metadata_[0][0],\r\n      nodata: nodataValues_[0][0],\r\n      normalize: normalize_,\r\n      extent: extent_,\r\n      proj: code_,\r\n      // @ts-ignore\r\n      bandCount: bandCount - (addAlpha_ ? 1 : 0),\r\n      ...this.gdalMetaDatas\r\n    };\r\n  }\r\n\r\n  configure_(sources) {\r\n    let extent;\r\n    let origin;\r\n    let commonRenderTileSizes;\r\n    let commonSourceTileSizes;\r\n    let resolutions;\r\n    const samplesPerPixel = new Array(sources.length);\r\n    const nodataValues = new Array(sources.length);\r\n    const metadata = new Array(sources.length);\r\n    let minZoom = 0;\r\n    const sourceCount = sources.length;\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      const images = [];\r\n      const masks = [];\r\n      sources[sourceIndex].forEach((item) => {\r\n        if (isMask(item)) {\r\n          masks.push(item);\r\n        } else {\r\n          images.push(item);\r\n        }\r\n      });\r\n\r\n      const imageCount = images.length;\r\n      if (masks.length > 0 && masks.length !== imageCount) {\r\n        throw new Error(\r\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`,\r\n        );\r\n      }\r\n\r\n      let sourceExtent;\r\n      let sourceOrigin;\r\n      const sourceTileSizes = new Array(imageCount);\r\n      const renderTileSizes = new Array(imageCount);\r\n      const sourceResolutions = new Array(imageCount);\r\n\r\n      nodataValues[sourceIndex] = new Array(imageCount);\r\n      metadata[sourceIndex] = new Array(imageCount);\r\n\r\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\r\n        const image = images[imageIndex];\r\n        const nodataValue = image.getGDALNoData();\r\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\r\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\r\n\r\n        // @ts-ignore\r\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\r\n        samplesPerPixel[sourceIndex] = wantedSamples\r\n          ? wantedSamples.length\r\n          : image.getSamplesPerPixel();\r\n        const level = imageCount - (imageIndex + 1);\r\n\r\n        if (!sourceExtent) {\r\n          sourceExtent = getBoundingBox(image);\r\n        }\r\n\r\n        if (!sourceOrigin) {\r\n          sourceOrigin = getOrigin(image);\r\n        }\r\n\r\n        const imageResolutions = getResolutions(image, images[0]);\r\n        sourceResolutions[level] = imageResolutions[0];\r\n\r\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\r\n\r\n        // request larger blocks for untiled layouts\r\n        if (\r\n          sourceTileSize[0] !== sourceTileSize[1] &&\r\n          sourceTileSize[1] < defaultTileSize\r\n        ) {\r\n          sourceTileSize[0] = defaultTileSize;\r\n          sourceTileSize[1] = defaultTileSize;\r\n        }\r\n\r\n        sourceTileSizes[level] = sourceTileSize;\r\n\r\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\r\n        renderTileSizes[level] = [\r\n          sourceTileSize[0],\r\n          sourceTileSize[1] / aspectRatio,\r\n        ];\r\n      }\r\n\r\n      if (!extent) {\r\n        extent = sourceExtent;\r\n      } else {\r\n        getIntersection(extent, sourceExtent, extent);\r\n      }\r\n\r\n      if (!origin) {\r\n        origin = sourceOrigin;\r\n      } else {\r\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\r\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\r\n      }\r\n\r\n      if (!resolutions) {\r\n        resolutions = sourceResolutions;\r\n        // @ts-ignore\r\n        this.resolutionFactors_[sourceIndex] = 1;\r\n      } else {\r\n        if (resolutions.length - minZoom > sourceResolutions.length) {\r\n          minZoom = resolutions.length - sourceResolutions.length;\r\n        }\r\n        const resolutionFactor =\r\n          resolutions[resolutions.length - 1] /\r\n          sourceResolutions[sourceResolutions.length - 1];\r\n        // @ts-ignore\r\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\r\n        const scaledSourceResolutions = sourceResolutions.map(\r\n          (resolution) => (resolution *= resolutionFactor),\r\n        );\r\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\r\n        assertEqual(\r\n          resolutions.slice(minZoom, resolutions.length),\r\n          scaledSourceResolutions,\r\n          0.02,\r\n          message,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      if (!commonRenderTileSizes) {\r\n        commonRenderTileSizes = renderTileSizes;\r\n      } else {\r\n        assertEqual(\r\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\r\n          renderTileSizes,\r\n          0.01,\r\n          `Tile size mismatch for source ${sourceIndex}`,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n\r\n      if (!commonSourceTileSizes) {\r\n        commonSourceTileSizes = sourceTileSizes;\r\n      } else {\r\n        assertEqual(\r\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\r\n          sourceTileSizes,\r\n          0,\r\n          `Tile size mismatch for source ${sourceIndex}`,\r\n          this.viewRejector,\r\n        );\r\n      }\r\n      // @ts-ignore\r\n      this.sourceImagery_[sourceIndex] = images.reverse();\r\n      // @ts-ignore\r\n      this.sourceMasks_[sourceIndex] = masks.reverse();\r\n    }\r\n    Promise.resolve().then(() => this.parseXMLMetas(sources[0]));\r\n    // @ts-ignore\r\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\r\n      // @ts-ignore\r\n      const sourceImagery = this.sourceImagery_[i];\r\n      while (sourceImagery.length < resolutions.length) {\r\n        sourceImagery.unshift(undefined);\r\n      }\r\n    }\r\n\r\n    if (!this.getProjection()) {\r\n      this.determineProjection(sources);\r\n    }\r\n\r\n    // @ts-ignore\r\n    this.samplesPerPixel_ = samplesPerPixel;\r\n    // @ts-ignore\r\n    this.nodataValues_ = nodataValues;\r\n    // @ts-ignore\r\n    this.metadata_ = metadata;\r\n\r\n    // decide if we need to add an alpha band to handle nodata\r\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      // option 1: source is configured with a nodata value\r\n      // @ts-ignore\r\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\r\n        // @ts-ignore\r\n        this.addAlpha_ = true;\r\n        break;\r\n      }\r\n      // @ts-ignore\r\n      if (this.sourceMasks_[sourceIndex].length) {\r\n        // @ts-ignore\r\n        this.addAlpha_ = true;\r\n        break;\r\n      }\r\n\r\n      const values = nodataValues[sourceIndex];\r\n\r\n      // option 2: check image metadata for limited bands\r\n      // @ts-ignore\r\n      const bands = this.sourceInfo_[sourceIndex].bands;\r\n      if (bands) {\r\n        for (let i = 0; i < bands.length; ++i) {\r\n          if (values[bands[i] - 1] !== null) {\r\n            // @ts-ignore\r\n            this.addAlpha_ = true;\r\n            break outer;\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // option 3: check image metadata for all bands\r\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\r\n        if (values[imageIndex] !== null) {\r\n          // @ts-ignore\r\n          this.addAlpha_ = true;\r\n          break outer;\r\n        }\r\n      }\r\n    }\r\n\r\n    // @ts-ignore\r\n    let bandCount = this.addAlpha_ ? 1 : 0;\r\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\r\n      bandCount += samplesPerPixel[sourceIndex];\r\n    }\r\n    this.bandCount = bandCount;\r\n    const tileGrid = new TileGrid({\r\n      extent: extent,\r\n      minZoom: minZoom,\r\n      origin: origin,\r\n      resolutions: resolutions,\r\n      tileSizes: commonRenderTileSizes,\r\n    });\r\n\r\n    this.tileGrid = tileGrid;\r\n    this.setTileSizes(commonSourceTileSizes);\r\n\r\n    // @ts-ignore\r\n    this.setLoader(this.loadTile_.bind(this));\r\n    this.setState('ready');\r\n\r\n    const zoom = 1;\r\n    if (resolutions.length === 2) {\r\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\r\n    } else if (resolutions.length === 1) {\r\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\r\n    }\r\n\r\n    this.viewResolver({\r\n      showFullExtent: true,\r\n      projection: this.projection,\r\n      resolutions: resolutions,\r\n      center: toUserCoordinate(getCenter(extent), this.projection),\r\n      extent: toUserExtent(extent, this.projection),\r\n      zoom: zoom,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Get a promise for view properties based on the source.  Use the result of this function\r\n * as the `view` option in a map constructor.\r\n *\r\n *     const source = new GeoTIFF(options);\r\n *\r\n *     const map = new Map({\r\n *       target: 'map',\r\n *       layers: [\r\n *         new TileLayer({\r\n *           source: source,\r\n *         }),\r\n *       ],\r\n *       view: source.getView(),\r\n *     });\r\n *\r\n * @function\r\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\r\n * @api\r\n *\r\n */\r\ncme_GeoTIFFSource.prototype.getView;\r\n\r\nexport default cme_GeoTIFFSource;\r\n","/**\r\n * @module CME2D/CME2DCore/layer/cme_cogtifLayer/cme_cogtifLayer2\r\n */\r\nimport GeoTIFF from '../../source/GeoTIFF.js'; // source/GeoTIFF.js';\r\nimport TileLayer from '../../../layer/WebGLTile.js';\r\n\r\n// import { transform } from \"../../../proj.js\";\r\n\r\n// 处理数据使用\r\nimport { getLayerStyle, mergeObjects } from \"../common/commonLayerUnit.js\";\r\n\r\n// import { getCofTifData } from \"./cogtifWorld.js\"\r\n// import GeoTIFF from '../../../source/GeoTIFF.js';\r\n// import TileLayer from '../../../layer/WebGLTile.js';\r\n// import { transform } from \"../../../proj.js\";\r\n// import { fromUrl, Pool } from \"geotiff\";\r\n// import { fromUrl, Pool } from \"geotiff\";\r\nvar cme_cogtifLayer2 = class cogtifLayerClass2 extends TileLayer {\r\n  constructor() {\r\n    let options = {};\r\n    super(options);\r\n    this.legendLimit = 250;\r\n  }\r\n  /**\r\n   * 渲染选项并返回一个解析为true的Promise。\r\n   *\r\n   * @param {Object} options - 要渲染的选项。\r\n   * @return {Promise} 一个解析为true的Promise。\r\n   */\r\n  _render(parfams) {\r\n    let options = JSON.parse(JSON.stringify(parfams));\r\n    let that = this;\r\n    // if (Array.isArray(options?.style?.color)) {\r\n    //   options.style.color.splice(this.legendLimit);\r\n    // }\r\n    if (options.Greater) {\r\n      options.style = this.getStyleOpactiy(options.Greater, options.style)\r\n    }\r\n    if (options.style) {\r\n      if (options.style.color) {\r\n        options.orignColor = JSON.parse(JSON.stringify(options.style.color));\r\n      } else {\r\n        options.orignColor = {};\r\n      }\r\n    }\r\n    if (!options.style) {\r\n      throw Error('\"options.style\"参数缺失');\r\n    }\r\n    options.CustomStyle = options.style;\r\n    if (!options.source) {\r\n      throw Error('\"options.source\"参数缺失');\r\n    }\r\n    return new Promise((resolve) => {\r\n      const sourceObj = new GeoTIFF(options.source);\r\n      sourceObj.getView().then((viewConfig) => {\r\n        const metas = sourceObj.getMetaDatas();\r\n        const { scale, scala, offset, unit } = options.style;\r\n        const proj = {\r\n          extent: metas.extent,\r\n          projection: metas.proj || \"EPSG:4326\",\r\n          unit: unit || metas.unit || ''\r\n        };\r\n        Object.assign(options.style, {\r\n          bandsNumber: +metas.bandCount || 1,\r\n          offset: offset || +metas.offset || 0,\r\n          scala: scale || scala || +metas.scale || 1,\r\n          unit: unit || metas.unit || ''\r\n        });\r\n        options.proj = proj;\r\n        // @ts-ignore\r\n        if (options.style.color) {\r\n          options = getLayerStyle(options);\r\n        }\r\n        that.options = JSON.parse(JSON.stringify(options));// options;\r\n        that.style_ = options.style;\r\n        // 设置属性和数据源\r\n        sourceObj.values_ = options.source;\r\n        that.setProperties({ ...options, source: sourceObj });\r\n        that.once('postrender', () => resolve(metas));\r\n\r\n        // //  that.once('sourceready', function (event) {})\r\n        // //postcompose\r\n        // //rendercomplete\r\n        // that.once(\"postcompose\", function (event) {\r\n\r\n        //   resolve(true);\r\n        // })\r\n\r\n        // that.setSource(options.source)\r\n        // that.setProperties({ CustomStyle: optionsStr.CustomStyle });\r\n        // that.updateStyleVariables({ style: optionsStr.CustomStyle })\r\n      })\r\n    }\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 设置函数的来源。\r\n   *\r\n   * @param {type} paramName - 参数的描述\r\n   * @return {type} 返回值的描述\r\n   */\r\n  _setSource(options) {\r\n    let params = JSON.parse(JSON.stringify(options))\r\n    let that = this;\r\n    if (params.source == null) {\r\n      return new Promise((resolve) => {\r\n        resolve(true);\r\n      });\r\n    }\r\n    return new Promise((resolve) => {\r\n      if (params.source) {\r\n        params.source = new GeoTIFF(params.source);\r\n      } else {\r\n        params.source = new GeoTIFF();\r\n      }\r\n      params.source.getView().then((viewConfig) => {\r\n\r\n        let projCode = \"EPSG:4326\";\r\n        if (viewConfig.projection) {\r\n          projCode = viewConfig.projection.getCode()\r\n\r\n        }\r\n        //   // projCode=viewConfig.projection.getCode()\r\n        // let proj={\r\n        //   extent:viewConfig.extent,\r\n        //   projection: projCode,//viewConfig.projection.getCode(),\r\n        // }\r\n        // // let proj = {\r\n        // //   extent: viewConfig.extent,\r\n        // //   projection: viewConfig.projection.getCode(),\r\n        // // };\r\n        // that.setProperties({\r\n        //   proj: proj\r\n        // });\r\n\r\n\r\n        that.once(\"sourceready\", function (event) {\r\n          resolve(true);\r\n        });\r\n        that.setSource(params.source);\r\n      });\r\n    });\r\n  }\r\n\r\n\r\n  _setSourceMap(map, options) {\r\n    // return this.setTempLayer(map).then((viewConfig) => {\r\n\r\n    console.log(\"CME2D\")\r\n    // console.log(options.source.sources[0].url);\r\n    let params = JSON.parse(JSON.stringify(options));\r\n    console.log(params.source.sources[0].url);\r\n\r\n    let that = this;\r\n    if (params.source == null) {\r\n      return new Promise((resolve) => {\r\n        resolve(true);\r\n      });\r\n    }\r\n    return new Promise((resolve) => {\r\n      if (params.source) {\r\n\r\n        params.source = new GeoTIFF(params.source);\r\n      } else {\r\n        params.source = new GeoTIFF();\r\n      }\r\n      params.source.getView().then((viewConfig) => {\r\n\r\n        let projCode = \"EPSG:4326\";\r\n        if (viewConfig.projection) {\r\n          projCode = viewConfig.projection.getCode()\r\n\r\n        }\r\n        map.once(\"rendercomplete\", function () {\r\n          // that.cogtifLayer.setOpacity(0);\r\n          // console.log(\"图层更新source加载完成\")\r\n          resolve(true);\r\n        });\r\n        that.setSource(params.source);\r\n      });\r\n    });\r\n    // });\r\n  }\r\n  /**\r\n   * 对整个函数的描述。\r\n   *\r\n   * @param {type} paramName - 参数描述\r\n   * @return {type} 返回值描述\r\n   */\r\n  _setStyle(options) {\r\n    // if (Array.isArray(options?.style?.color)) {\r\n    //   options.style.color.splice(this.legendLimit);\r\n    // }\r\n    if (options.Greater) {\r\n      options.style = this.getStyleOpactiy(options.Greater, options.style)\r\n    }\r\n    if (options.style) {\r\n      if (options.style.color) {\r\n        this.options.orignColor = options.style.color;\r\n      } else {\r\n        options.style.color = JSON.parse(JSON.stringify(this.options.orignColor));\r\n      }\r\n    } else {\r\n      options.style.color = JSON.parse(JSON.stringify(this.options.orignColor));\r\n    }\r\n    return new Promise((resolve) => {\r\n      if (options.source && (\"interpolate\" in options.source)) {\r\n        const source = this.getSource();\r\n        const properties = source.getProperties();\r\n        if (properties.interpolate != options.source.interpolate) {\r\n          source.set(\"interpolate\", options.source.interpolate);\r\n          let properties = JSON.parse(JSON.stringify(properties));\r\n          // properties.source.interpolate = options.source.interpolate;\r\n          this.setSource(new GeoTIFF(properties));\r\n          source.setProperties(properties)\r\n        }\r\n      }\r\n      this.options = getLayerStyle(mergeObjects(this.options, options));\r\n      this.style_ = this.options.style;\r\n      this.options.CustomStyle = this.options.style; //    options.style;\r\n      const newStyle = JSON.parse(JSON.stringify(this.options.style));\r\n      this.setStyle(newStyle);\r\n      resolve(true);\r\n    });\r\n  }\r\n\r\n  getStyleOpactiy(params, _style) {\r\n    let style = JSON.parse(JSON.stringify(_style))\r\n    if (params) {\r\n      if (params[0] == 0) {\r\n        let minValue = style.color[0][0];\r\n        minValue = minValue - 0.1;\r\n        style.color.unshift([minValue, [0, 0, 0, 0]]);\r\n        style.color.unshift([-9999, [0, 0, 0, 0]]);\r\n      }\r\n      //  else if(options.params[0]==0){\r\n\r\n      //  }\r\n      if (params[1] == 0) {\r\n\r\n        let maxValue = style.color[style.color.length - 1][0];\r\n        maxValue = maxValue + 0.1;\r\n        style.color.push([maxValue, [0, 0, 0, 0]]);\r\n      }\r\n    }\r\n\r\n    return style;\r\n\r\n  }\r\n\r\n  /**\r\n   * 整个函数的描述。\r\n   *\r\n   */\r\n  _remove() {\r\n    this.dispose();\r\n    // 变量清空\r\n  }\r\n\r\n  computedNewExtent(extent, worldNumber) {\r\n    let mixLng = extent[0] + 360 * worldNumber;\r\n    let maxLng = extent[2] + 360 * worldNumber;\r\n    return [mixLng, extent[1], maxLng, extent[3]];\r\n  }\r\n  getSourceProperties(options) {\r\n\r\n    let sourceOpitions = this.options.source.values_;\r\n    for (let key in sourceOpitions) {\r\n      if (sourceOpitions.hasOwnProperty(key)) { // 确保key是对象自身的属性\r\n        for (let newKey in options.source) {\r\n          if (options.source.hasOwnProperty(newKey)) {\r\n            if (key == newKey)\r\n              sourceOpitions[key] = options.source[newKey];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    let sourceCollection = []\r\n    for (let newKey in sourceOpitions.sources) {\r\n      if (sourceOpitions.sources.hasOwnProperty(newKey)) {\r\n        sourceCollection.push(sourceOpitions.sources[newKey]);\r\n\r\n      }\r\n    }\r\n    sourceOpitions.sources = sourceCollection;\r\n    return sourceOpitions;\r\n  }\r\n}\r\n\r\nexport default cme_cogtifLayer2\r\n","/**\r\n * @module CME2D/render/canvas/ZIndexContext\r\n */\r\n\r\nimport {getSharedCanvasContext2D} from '../../dom.js';\r\n\r\n/** @typedef {CanvasRenderingContext2D & {globalAlpha: any}} ZIndexContextProxy */\r\n\r\n/**\r\n * @extends {CanvasRenderingContext2D}\r\n */\r\nclass ZIndexContext {\r\n  constructor() {\r\n    /**\r\n     * @private\r\n     * @type {Array<Array<*>>}\r\n     */\r\n    this.instructions_ = [];\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.zIndex = 0;\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.offset_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {ZIndexContextProxy}\r\n     */\r\n    this.context_ = /** @type {ZIndexContextProxy} */ (\r\n      new Proxy(getSharedCanvasContext2D(), {\r\n        get: (target, property) => {\r\n          if (\r\n            typeof (/** @type {*} */ (getSharedCanvasContext2D())[property]) !==\r\n            'function'\r\n          ) {\r\n            // we only accept calling functions on the proxy, not accessing properties\r\n            return undefined;\r\n          }\r\n          if (!this.instructions_[this.zIndex + this.offset_]) {\r\n            this.instructions_[this.zIndex + this.offset_] = [];\r\n          }\r\n          this.instructions_[this.zIndex + this.offset_].push(property);\r\n          return this.pushMethodArgs_;\r\n        },\r\n        set: (target, property, value) => {\r\n          if (!this.instructions_[this.zIndex + this.offset_]) {\r\n            this.instructions_[this.zIndex + this.offset_] = [];\r\n          }\r\n          this.instructions_[this.zIndex + this.offset_].push(property, value);\r\n          return true;\r\n        },\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {...*} args Args.\r\n   * @return {ZIndexContext} This.\r\n   */\r\n  pushMethodArgs_ = (...args) => {\r\n    this.instructions_[this.zIndex + this.offset_].push(args);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Push a function that renders to the context directly.\r\n   * @param {function(CanvasRenderingContext2D): void} render Function.\r\n   */\r\n  pushFunction(render) {\r\n    this.instructions_[this.zIndex + this.offset_].push(render);\r\n  }\r\n\r\n  /**\r\n   * Get a proxy for CanvasRenderingContext2D which does not support getting state\r\n   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a\r\n   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,\r\n   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.\r\n   * @return {ZIndexContextProxy} Context.\r\n   */\r\n  getContext() {\r\n    return this.context_;\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   */\r\n  draw(context) {\r\n    this.instructions_.forEach((instructionsAtIndex) => {\r\n      for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {\r\n        const property = instructionsAtIndex[i];\r\n        if (typeof property === 'function') {\r\n          property(context);\r\n          continue;\r\n        }\r\n        const instructionAtIndex = instructionsAtIndex[++i];\r\n        if (typeof (/** @type {*} */ (context)[property]) === 'function') {\r\n          /** @type {*} */ (context)[property](...instructionAtIndex);\r\n        } else {\r\n          if (typeof instructionAtIndex === 'function') {\r\n            /** @type {*} */ (context)[property] = instructionAtIndex(context);\r\n            continue;\r\n          }\r\n          /** @type {*} */ (context)[property] = instructionAtIndex;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  clear() {\r\n    this.instructions_.length = 0;\r\n    this.zIndex = 0;\r\n    this.offset_ = 0;\r\n  }\r\n\r\n  /**\r\n   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to\r\n   * avoid conflicting context.clip() or context.save()/restore() calls.\r\n   */\r\n  offset() {\r\n    this.offset_ = this.instructions_.length;\r\n    this.zIndex = 0;\r\n  }\r\n}\r\n\r\nexport default ZIndexContext;\r\n","/**\r\n * @module CME2D/renderer/canvas/Layer\r\n */\r\nimport LayerRenderer from '../Layer.js';\r\nimport RenderEvent from '../../render/Event.js';\r\nimport RenderEventType from '../../render/EventType.js';\r\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n  create as createTransform,\r\n  makeInverse,\r\n  toString as toTransformString,\r\n} from '../../transform.js';\r\nimport {asArray} from '../../color.js';\r\nimport {createCanvasContext2D} from '../../dom.js';\r\nimport {equals} from '../../array.js';\r\nimport {\r\n  getBottomLeft,\r\n  getBottomRight,\r\n  getHeight,\r\n  getTopLeft,\r\n  getTopRight,\r\n  getWidth,\r\n} from '../../extent.js';\r\n\r\n/**\r\n * @type {Array<HTMLCanvasElement>}\r\n */\r\nexport const canvasPool = [];\r\n\r\n/**\r\n * @type {CanvasRenderingContext2D}\r\n */\r\nlet pixelContext = null;\r\n\r\nfunction createPixelContext() {\r\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\r\n    willReadFrequently: true,\r\n  });\r\n}\r\n\r\n/**\r\n * @abstract\r\n * @template {import(\"../../layer/Layer.js\").default} LayerType\r\n * @extends {LayerRenderer<LayerType>}\r\n */\r\nclass CanvasLayerRenderer extends LayerRenderer {\r\n  /**\r\n   * @param {LayerType} layer Layer.\r\n   */\r\n  constructor(layer) {\r\n    super(layer);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {HTMLElement}\r\n     */\r\n    this.container = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.renderedResolution;\r\n\r\n    /**\r\n     * A temporary transform.  The values in this transform should only be used in a\r\n     * function that sets the values.\r\n     * @protected\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.tempTransform = createTransform();\r\n\r\n    /**\r\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\r\n     * be set when rendering a frame and may be used by other functions after rendering.\r\n     * @protected\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.pixelTransform = createTransform();\r\n\r\n    /**\r\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\r\n     * be set when rendering a frame and may be used by other functions after rendering.\r\n     * @protected\r\n     * @type {import(\"../../transform.js\").Transform}\r\n     */\r\n    this.inversePixelTransform = createTransform();\r\n\r\n    /**\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    this.context = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {ZIndexContext}\r\n     */\r\n    this.deferredContext_ = null;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    this.containerReused = false;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../Map.js\").FrameState|null}\r\n     */\r\n    this.frameState = null;\r\n  }\r\n\r\n  /**\r\n   * @param {import('../../DataTile.js').ImageLike} image Image.\r\n   * @param {number} col The column index.\r\n   * @param {number} row The row index.\r\n   * @return {Uint8ClampedArray|null} The image data.\r\n   */\r\n  getImageData(image, col, row) {\r\n    if (!pixelContext) {\r\n      createPixelContext();\r\n    }\r\n    pixelContext.clearRect(0, 0, 1, 1);\r\n\r\n    let data;\r\n    try {\r\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\r\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\r\n    } catch (err) {\r\n      pixelContext = null;\r\n      return null;\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\r\n   * @return {string} Background color.\r\n   */\r\n  getBackground(frameState) {\r\n    const layer = this.getLayer();\r\n    let background = layer.getBackground();\r\n    if (typeof background === 'function') {\r\n      background = background(frameState.viewState.resolution);\r\n    }\r\n    return background || undefined;\r\n  }\r\n\r\n  /**\r\n   * Get a rendering container from an existing target, if compatible.\r\n   * @param {HTMLElement} target Potential render target.\r\n   * @param {string} transform CSS Transform.\r\n   * @param {string} [backgroundColor] Background color.\r\n   */\r\n  useContainer(target, transform, backgroundColor) {\r\n    const layerClassName = this.getLayer().getClassName();\r\n    let container, context;\r\n    if (\r\n      target &&\r\n      target.className === layerClassName &&\r\n      (!backgroundColor ||\r\n        (target &&\r\n          target.style.backgroundColor &&\r\n          equals(\r\n            asArray(target.style.backgroundColor),\r\n            asArray(backgroundColor),\r\n          )))\r\n    ) {\r\n      const canvas = target.firstElementChild;\r\n      if (canvas instanceof HTMLCanvasElement) {\r\n        context = canvas.getContext('2d');\r\n      }\r\n    }\r\n    if (context && context.canvas.style.transform === transform) {\r\n      // Container of the previous layer renderer can be used.\r\n      this.container = target;\r\n      this.context = context;\r\n      this.containerReused = true;\r\n    } else if (this.containerReused) {\r\n      // Previously reused container cannot be used any more.\r\n      this.container = null;\r\n      this.context = null;\r\n      this.containerReused = false;\r\n    } else if (this.container) {\r\n      this.container.style.backgroundColor = null;\r\n    }\r\n    if (!this.container) {\r\n      container = document.createElement('div');\r\n      container.className = layerClassName;\r\n      let style = container.style;\r\n      style.position = 'absolute';\r\n      style.width = '100%';\r\n      style.height = '100%';\r\n      context = createCanvasContext2D();\r\n      const canvas = context.canvas;\r\n      container.appendChild(canvas);\r\n      style = canvas.style;\r\n      style.position = 'absolute';\r\n      style.left = '0';\r\n      style.transformOrigin = 'top left';\r\n      this.container = container;\r\n      this.context = context;\r\n    }\r\n    if (\r\n      !this.containerReused &&\r\n      backgroundColor &&\r\n      !this.container.style.backgroundColor\r\n    ) {\r\n      this.container.style.backgroundColor = backgroundColor;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\r\n   * @protected\r\n   */\r\n  clipUnrotated(context, frameState, extent) {\r\n    const topLeft = getTopLeft(extent);\r\n    const topRight = getTopRight(extent);\r\n    const bottomRight = getBottomRight(extent);\r\n    const bottomLeft = getBottomLeft(extent);\r\n\r\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\r\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\r\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\r\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\r\n\r\n    const inverted = this.inversePixelTransform;\r\n    applyTransform(inverted, topLeft);\r\n    applyTransform(inverted, topRight);\r\n    applyTransform(inverted, bottomRight);\r\n    applyTransform(inverted, bottomLeft);\r\n\r\n    context.save();\r\n    context.beginPath();\r\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\r\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\r\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\r\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\r\n    context.clip();\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @protected\r\n   */\r\n  prepareContainer(frameState, target) {\r\n    const extent = frameState.extent;\r\n    const resolution = frameState.viewState.resolution;\r\n    const rotation = frameState.viewState.rotation;\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\r\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\r\n    // set forward and inverse pixel transforms\r\n    composeTransform(\r\n      this.pixelTransform,\r\n      frameState.size[0] / 2,\r\n      frameState.size[1] / 2,\r\n      1 / pixelRatio,\r\n      1 / pixelRatio,\r\n      rotation,\r\n      -width / 2,\r\n      -height / 2,\r\n    );\r\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\r\n\r\n    const canvasTransform = toTransformString(this.pixelTransform);\r\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\r\n\r\n    if (!this.containerReused) {\r\n      const canvas = this.context.canvas;\r\n      if (canvas.width != width || canvas.height != height) {\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n      } else {\r\n        this.context.clearRect(0, 0, width, height);\r\n      }\r\n      if (canvasTransform !== canvas.style.transform) {\r\n        canvas.style.transform = canvasTransform;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @private\r\n   */\r\n  dispatchRenderEvent_(type, context, frameState) {\r\n    const layer = this.getLayer();\r\n    if (layer.hasListener(type)) {\r\n      const event = new RenderEvent(\r\n        type,\r\n        this.inversePixelTransform,\r\n        frameState,\r\n        context,\r\n      );\r\n      layer.dispatchEvent(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  preRender(context, frameState) {\r\n    this.frameState = frameState;\r\n    if (frameState.declutter) {\r\n      return;\r\n    }\r\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\r\n  }\r\n\r\n  /**\r\n   * @param {CanvasRenderingContext2D} context Context.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @protected\r\n   */\r\n  postRender(context, frameState) {\r\n    if (frameState.declutter) {\r\n      return;\r\n    }\r\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   */\r\n  renderDeferredInternal(frameState) {}\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.\r\n   */\r\n  getRenderContext(frameState) {\r\n    if (frameState.declutter && !this.deferredContext_) {\r\n      this.deferredContext_ = new ZIndexContext();\r\n    }\r\n    return frameState.declutter\r\n      ? this.deferredContext_.getContext()\r\n      : this.context;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @override\r\n   */\r\n  renderDeferred(frameState) {\r\n    if (!frameState.declutter) {\r\n      return;\r\n    }\r\n    this.dispatchRenderEvent_(\r\n      RenderEventType.PRERENDER,\r\n      this.context,\r\n      frameState,\r\n    );\r\n    if (frameState.declutter && this.deferredContext_) {\r\n      this.deferredContext_.draw(this.context);\r\n      this.deferredContext_.clear();\r\n    }\r\n    this.renderDeferredInternal(frameState);\r\n    this.dispatchRenderEvent_(\r\n      RenderEventType.POSTRENDER,\r\n      this.context,\r\n      frameState,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Creates a transform for rendering to an element that will be rotated after rendering.\r\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} rotation Rotation.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {number} width Width of the rendered element (in pixels).\r\n   * @param {number} height Height of the rendered element (in pixels).\r\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\r\n   * @protected\r\n   * @return {!import(\"../../transform.js\").Transform} Transform.\r\n   */\r\n  getRenderTransform(\r\n    center,\r\n    resolution,\r\n    rotation,\r\n    pixelRatio,\r\n    width,\r\n    height,\r\n    offsetX,\r\n  ) {\r\n    const dx1 = width / 2;\r\n    const dy1 = height / 2;\r\n    const sx = pixelRatio / resolution;\r\n    const sy = -sx;\r\n    const dx2 = -center[0] + offsetX;\r\n    const dy2 = -center[1];\r\n    return composeTransform(\r\n      this.tempTransform,\r\n      dx1,\r\n      dy1,\r\n      sx,\r\n      sy,\r\n      -rotation,\r\n      dx2,\r\n      dy2,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    delete this.frameState;\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default CanvasLayerRenderer;\r\n","/**\r\n * @module CME2D/resolution\r\n */\r\n\r\n/**\r\n * @typedef {number|Array<number>} ResolutionLike\r\n */\r\n\r\n/**\r\n * @param {ResolutionLike} resolution Resolution.\r\n * @return {number} Resolution.\r\n */\r\nexport function fromResolutionLike(resolution) {\r\n  if (Array.isArray(resolution)) {\r\n    return Math.min(...resolution);\r\n  }\r\n  return resolution;\r\n}\r\n","/**\r\n * @module CME2D/reproj/Image\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport EventType from '../events/EventType.js';\r\nimport ImageState from '../ImageState.js';\r\nimport ImageWrapper from '../Image.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {\r\n  calculateSourceResolution,\r\n  render as renderReprojected,\r\n} from '../reproj.js';\r\nimport {fromResolutionLike} from '../resolution.js';\r\nimport {\r\n  getCenter,\r\n  getHeight,\r\n  getIntersection,\r\n  getWidth,\r\n  isEmpty,\r\n} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {function(import(\"../extent.js\").Extent, number, number) : import(\"../Image.js\").default} FunctionType\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected image.\r\n * See {@link module:ol/source/Image~ImageSource}.\r\n */\r\nclass ReprojImage extends ImageWrapper {\r\n  /**\r\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection (of the data).\r\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent.\r\n   * @param {number} targetResolution Target resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {FunctionType} getImageFunction\r\n   *     Function returning source images (extent, resolution, pixelRatio).\r\n   * @param {boolean} interpolate Use linear interpolation when resampling.\r\n   */\r\n  constructor(\r\n    sourceProj,\r\n    targetProj,\r\n    targetExtent,\r\n    targetResolution,\r\n    pixelRatio,\r\n    getImageFunction,\r\n    interpolate,\r\n  ) {\r\n    let maxSourceExtent = sourceProj.getExtent();\r\n    if (maxSourceExtent && sourceProj.canWrapX()) {\r\n      maxSourceExtent = maxSourceExtent.slice();\r\n      maxSourceExtent[0] = -Infinity;\r\n      maxSourceExtent[2] = Infinity;\r\n    }\r\n    let maxTargetExtent = targetProj.getExtent();\r\n    if (maxTargetExtent && targetProj.canWrapX()) {\r\n      maxTargetExtent = maxTargetExtent.slice();\r\n      maxTargetExtent[0] = -Infinity;\r\n      maxTargetExtent[2] = Infinity;\r\n    }\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    const targetCenter = getCenter(limitedTargetExtent);\r\n    const sourceResolution = calculateSourceResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      targetCenter,\r\n      targetResolution,\r\n    );\r\n\r\n    const errorThresholdInPixels = ERROR_THRESHOLD;\r\n\r\n    const triangulation = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution,\r\n    );\r\n\r\n    const sourceExtent = triangulation.calculateSourceExtent();\r\n    const sourceImage = isEmpty(sourceExtent)\r\n      ? null\r\n      : getImageFunction(sourceExtent, sourceResolution, pixelRatio);\r\n    const state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;\r\n    const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;\r\n\r\n    super(targetExtent, targetResolution, sourcePixelRatio, state);\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     */\r\n    this.targetProj_ = targetProj;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.maxSourceExtent_ = maxSourceExtent;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = triangulation;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.targetResolution_ = targetResolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.targetExtent_ = targetExtent;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../Image.js\").default}\r\n     */\r\n    this.sourceImage_ = sourceImage;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourcePixelRatio_ = sourcePixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.interpolate_ = interpolate;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../events.js\").EventsKey}\r\n     */\r\n    this.sourceListenerKey_ = null;\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    if (this.state == ImageState.LOADING) {\r\n      this.unlistenSource_();\r\n    }\r\n    super.disposeInternal();\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Image.\r\n   * @override\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../proj/Projection.js\").default} Projection.\r\n   */\r\n  getProjection() {\r\n    return this.targetProj_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const sourceState = this.sourceImage_.getState();\r\n    if (sourceState == ImageState.LOADED) {\r\n      const width = getWidth(this.targetExtent_) / this.targetResolution_;\r\n      const height = getHeight(this.targetExtent_) / this.targetResolution_;\r\n      this.canvas_ = renderReprojected(\r\n        width,\r\n        height,\r\n        this.sourcePixelRatio_,\r\n        fromResolutionLike(this.sourceImage_.getResolution()),\r\n        this.maxSourceExtent_,\r\n        this.targetResolution_,\r\n        this.targetExtent_,\r\n        this.triangulation_,\r\n        [\r\n          {\r\n            extent: this.sourceImage_.getExtent(),\r\n            image: this.sourceImage_.getImage(),\r\n          },\r\n        ],\r\n        0,\r\n        undefined,\r\n        this.interpolate_,\r\n        true,\r\n      );\r\n    }\r\n    this.state = sourceState;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state == ImageState.IDLE) {\r\n      this.state = ImageState.LOADING;\r\n      this.changed();\r\n\r\n      const sourceState = this.sourceImage_.getState();\r\n      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\r\n        this.reproject_();\r\n      } else {\r\n        this.sourceListenerKey_ = listen(\r\n          this.sourceImage_,\r\n          EventType.CHANGE,\r\n          (e) => {\r\n            const sourceState = this.sourceImage_.getState();\r\n            if (\r\n              sourceState == ImageState.LOADED ||\r\n              sourceState == ImageState.ERROR\r\n            ) {\r\n              this.unlistenSource_();\r\n              this.reproject_();\r\n            }\r\n          },\r\n        );\r\n        this.sourceImage_.load();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSource_() {\r\n    unlistenByKey(\r\n      /** @type {!import(\"../events.js\").EventsKey} */ (\r\n        this.sourceListenerKey_\r\n      ),\r\n    );\r\n    this.sourceListenerKey_ = null;\r\n  }\r\n}\r\n\r\nexport default ReprojImage;\r\n","/**\r\n * @module CME2D/source/common\r\n */\r\n\r\n/**\r\n * Default WMS version.\r\n * @type {string}\r\n */\r\nexport const DEFAULT_WMS_VERSION = '1.3.0';\r\n\r\n/**\r\n * Number of decimal digits to consider in integer values when rounding.\r\n * @type {number}\r\n */\r\nexport const DECIMALS = 4;\r\n","/**\r\n * @module CME2D/source/Image\r\n */\r\nimport Event from '../events/Event.js';\r\nimport EventType from '../events/EventType.js';\r\nimport ImageState from '../ImageState.js';\r\nimport ImageWrapper from '../Image.js';\r\nimport ReprojImage from '../reproj/Image.js';\r\nimport Source from './Source.js';\r\nimport {DECIMALS} from './common.js';\r\nimport {ceil} from '../math.js';\r\nimport {\r\n  containsExtent,\r\n  equals,\r\n  getCenter,\r\n  getForViewAndSize,\r\n  getHeight,\r\n  getWidth,\r\n} from '../extent.js';\r\nimport {equivalent} from '../proj.js';\r\nimport {fromResolutionLike} from '../resolution.js';\r\nimport {linearFindNearest} from '../array.js';\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport const ImageSourceEventType = {\r\n  /**\r\n   * Triggered when an image starts loading.\r\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart\r\n   * @api\r\n   */\r\n  IMAGELOADSTART: 'imageloadstart',\r\n\r\n  /**\r\n   * Triggered when an image finishes loading.\r\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadend\r\n   * @api\r\n   */\r\n  IMAGELOADEND: 'imageloadend',\r\n\r\n  /**\r\n   * Triggered if image loading results in an error.\r\n   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror\r\n   * @api\r\n   */\r\n  IMAGELOADERROR: 'imageloaderror',\r\n};\r\n\r\n/**\r\n * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this\r\n * type.\r\n */\r\nexport class ImageSourceEvent extends Event {\r\n  /**\r\n   * @param {string} type Type.\r\n   * @param {import(\"../Image.js\").default} image The image.\r\n   */\r\n  constructor(type, image) {\r\n    super(type);\r\n\r\n    /**\r\n     * The image related to the event.\r\n     * @type {import(\"../Image.js\").default}\r\n     * @api\r\n     */\r\n    this.image = image;\r\n  }\r\n}\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\r\n *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\r\n * @property {import(\"../Image.js\").Loader} [loader] Loader. Can either be a custom loader, or one of the\r\n * loaders created with a `createLoader()` function ({@link module:ol/source/wms.createLoader wms},\r\n * {@link module:ol/source/arcgisRest.createLoader arcgisRest}, {@link module:ol/source/mapguide.createLoader mapguide},\r\n * {@link module:ol/source/static.createLoader static}).\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\r\n * @property {Array<number>} [resolutions] Resolutions.\r\n * @property {import(\"./Source.js\").State} [state] State.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for sources providing a single image.\r\n * @fires module:ol/source/Image.ImageSourceEvent\r\n * @api\r\n */\r\nclass ImageSource extends Source {\r\n  /**\r\n   * @param {Options} options Single image source options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      attributions: options.attributions,\r\n      projection: options.projection,\r\n      state: options.state,\r\n      interpolate:\r\n        options.interpolate !== undefined ? options.interpolate : true,\r\n    });\r\n\r\n    /***\r\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {ImageSourceOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Image.js\").Loader}\r\n     */\r\n    this.loader = options.loader || null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>|null}\r\n     */\r\n    this.resolutions_ =\r\n      options.resolutions !== undefined ? options.resolutions : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../reproj/Image.js\").default}\r\n     */\r\n    this.reprojectedImage_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.reprojectedRevision_ = 0;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../Image.js\").default}\r\n     */\r\n    this.image = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.wantedExtent_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.wantedResolution_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.static_ = options.loader ? options.loader.length === 0 : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../proj/Projection.js\").default}\r\n     */\r\n    this.wantedProjection_ = null;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<number>|null} Resolutions.\r\n   * @override\r\n   */\r\n  getResolutions() {\r\n    return this.resolutions_;\r\n  }\r\n\r\n  /**\r\n   * @param {Array<number>|null} resolutions Resolutions.\r\n   */\r\n  setResolutions(resolutions) {\r\n    this.resolutions_ = resolutions;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {number} resolution Resolution.\r\n   * @return {number} Resolution.\r\n   */\r\n  findNearestResolution(resolution) {\r\n    const resolutions = this.getResolutions();\r\n    if (resolutions) {\r\n      const idx = linearFindNearest(resolutions, resolution, 0);\r\n      resolution = resolutions[idx];\r\n    }\r\n    return resolution;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../Image.js\").default} Single image.\r\n   */\r\n  getImage(extent, resolution, pixelRatio, projection) {\r\n    const sourceProjection = this.getProjection();\r\n    if (\r\n      !sourceProjection ||\r\n      !projection ||\r\n      equivalent(sourceProjection, projection)\r\n    ) {\r\n      if (sourceProjection) {\r\n        projection = sourceProjection;\r\n      }\r\n\r\n      return this.getImageInternal(extent, resolution, pixelRatio, projection);\r\n    }\r\n    if (this.reprojectedImage_) {\r\n      if (\r\n        this.reprojectedRevision_ == this.getRevision() &&\r\n        equivalent(this.reprojectedImage_.getProjection(), projection) &&\r\n        this.reprojectedImage_.getResolution() == resolution &&\r\n        equals(this.reprojectedImage_.getExtent(), extent)\r\n      ) {\r\n        return this.reprojectedImage_;\r\n      }\r\n      this.reprojectedImage_.dispose();\r\n      this.reprojectedImage_ = null;\r\n    }\r\n\r\n    this.reprojectedImage_ = new ReprojImage(\r\n      sourceProjection,\r\n      projection,\r\n      extent,\r\n      resolution,\r\n      pixelRatio,\r\n      (extent, resolution, pixelRatio) =>\r\n        this.getImageInternal(extent, resolution, pixelRatio, sourceProjection),\r\n      this.getInterpolate(),\r\n    );\r\n    this.reprojectedRevision_ = this.getRevision();\r\n\r\n    return this.reprojectedImage_;\r\n  }\r\n\r\n  /**\r\n   * @abstract\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../Image.js\").default} Single image.\r\n   * @protected\r\n   */\r\n  getImageInternal(extent, resolution, pixelRatio, projection) {\r\n    if (this.loader) {\r\n      const requestExtent = getRequestExtent(extent, resolution, pixelRatio, 1);\r\n      const requestResolution = this.findNearestResolution(resolution);\r\n      if (\r\n        this.image &&\r\n        (this.static_ ||\r\n          (this.wantedProjection_ === projection &&\r\n            ((this.wantedExtent_ &&\r\n              containsExtent(this.wantedExtent_, requestExtent)) ||\r\n              containsExtent(this.image.getExtent(), requestExtent)) &&\r\n            ((this.wantedResolution_ &&\r\n              fromResolutionLike(this.wantedResolution_) ===\r\n                requestResolution) ||\r\n              fromResolutionLike(this.image.getResolution()) ===\r\n                requestResolution)))\r\n      ) {\r\n        return this.image;\r\n      }\r\n      this.wantedProjection_ = projection;\r\n      this.wantedExtent_ = requestExtent;\r\n      this.wantedResolution_ = requestResolution;\r\n      this.image = new ImageWrapper(\r\n        requestExtent,\r\n        requestResolution,\r\n        pixelRatio,\r\n        this.loader,\r\n      );\r\n      this.image.addEventListener(\r\n        EventType.CHANGE,\r\n        this.handleImageChange.bind(this),\r\n      );\r\n    }\r\n    return this.image;\r\n  }\r\n\r\n  /**\r\n   * Handle image change events.\r\n   * @param {import(\"../events/Event.js\").default} event Event.\r\n   * @protected\r\n   */\r\n  handleImageChange(event) {\r\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\r\n    let type;\r\n    switch (image.getState()) {\r\n      case ImageState.LOADING:\r\n        this.loading = true;\r\n        type = ImageSourceEventType.IMAGELOADSTART;\r\n        break;\r\n      case ImageState.LOADED:\r\n        this.loading = false;\r\n        type = ImageSourceEventType.IMAGELOADEND;\r\n        break;\r\n      case ImageState.ERROR:\r\n        this.loading = false;\r\n        type = ImageSourceEventType.IMAGELOADERROR;\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n    if (this.hasListener(type)) {\r\n      this.dispatchEvent(new ImageSourceEvent(type, image));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Default image load function for image sources that use import(\"../Image.js\").Image image\r\n * instances.\r\n * @param {import(\"../Image.js\").default} image Image.\r\n * @param {string} src Source.\r\n */\r\nexport function defaultImageLoadFunction(image, src) {\r\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (image.getImage()).src = src;\r\n}\r\n\r\n/**\r\n * Adjusts the extent so it aligns with pixel boundaries.\r\n * @param {import(\"../extent.js\").Extent} extent Extent.\r\n * @param {number} resolution Reolution.\r\n * @param {number} pixelRatio Pixel ratio.\r\n * @param {number} ratio Ratio between request size and view size.\r\n * @return {import(\"../extent.js\").Extent} Request extent.\r\n */\r\nexport function getRequestExtent(extent, resolution, pixelRatio, ratio) {\r\n  const imageResolution = resolution / pixelRatio;\r\n  const center = getCenter(extent);\r\n  const viewWidth = ceil(getWidth(extent) / imageResolution, DECIMALS);\r\n  const viewHeight = ceil(getHeight(extent) / imageResolution, DECIMALS);\r\n  const marginWidth = ceil(((ratio - 1) * viewWidth) / 2, DECIMALS);\r\n  const requestWidth = viewWidth + 2 * marginWidth;\r\n  const marginHeight = ceil(((ratio - 1) * viewHeight) / 2, DECIMALS);\r\n  const requestHeight = viewHeight + 2 * marginHeight;\r\n  return getForViewAndSize(center, imageResolution, 0, [\r\n    requestWidth,\r\n    requestHeight,\r\n  ]);\r\n}\r\n\r\nexport default ImageSource;\r\n","/**\r\n * @module CME2D/ImageCanvas\r\n */\r\nimport ImageState from './ImageState.js';\r\nimport ImageWrapper from './Image.js';\r\n\r\n/**\r\n * A function that is called to trigger asynchronous canvas drawing.  It is\r\n * called with a \"done\" callback that should be called when drawing is done.\r\n * If any error occurs during drawing, the \"done\" callback should be called with\r\n * that error.\r\n *\r\n * @typedef {function(function(Error=): void): void} Loader\r\n */\r\n\r\nclass ImageCanvas extends ImageWrapper {\r\n  /**\r\n   * @param {import(\"./extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {HTMLCanvasElement} canvas Canvas.\r\n   * @param {Loader} [loader] Optional loader function to\r\n   *     support asynchronous canvas drawing.\r\n   */\r\n  constructor(extent, resolution, pixelRatio, canvas, loader) {\r\n    const state = loader !== undefined ? ImageState.IDLE : ImageState.LOADED;\r\n\r\n    super(extent, resolution, pixelRatio, state);\r\n\r\n    /**\r\n     * Optional canvas loader function.\r\n     * @type {?Loader}\r\n     * @private\r\n     */\r\n    this.loader_ = loader !== undefined ? loader : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    this.canvas_ = canvas;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Error}\r\n     */\r\n    this.error_ = null;\r\n  }\r\n\r\n  /**\r\n   * Get any error associated with asynchronous rendering.\r\n   * @return {?Error} Any error that occurred during rendering.\r\n   */\r\n  getError() {\r\n    return this.error_;\r\n  }\r\n\r\n  /**\r\n   * Handle async drawing complete.\r\n   * @param {Error} [err] Any error during drawing.\r\n   * @private\r\n   */\r\n  handleLoad_(err) {\r\n    if (err) {\r\n      this.error_ = err;\r\n      this.state = ImageState.ERROR;\r\n    } else {\r\n      this.state = ImageState.LOADED;\r\n    }\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state == ImageState.IDLE) {\r\n      this.state = ImageState.LOADING;\r\n      this.changed();\r\n      this.loader_(this.handleLoad_.bind(this));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Canvas element.\r\n   * @override\r\n   */\r\n  getImage() {\r\n    return this.canvas_;\r\n  }\r\n}\r\n\r\nexport default ImageCanvas;\r\n","/**\r\n * @module CME2D/source/ImageCanvas\r\n */\r\n\r\nimport ImageCanvas from '../ImageCanvas.js';\r\nimport ImageSource from './Image.js';\r\nimport {\r\n  containsExtent,\r\n  getHeight,\r\n  getWidth,\r\n  scaleFromCenter,\r\n} from '../extent.js';\r\n\r\n/**\r\n * A function returning the canvas element (`{HTMLCanvasElement}`)\r\n * used by the source as an image. The arguments passed to the function are:\r\n * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,\r\n * `{number}` the pixel ratio of the map, {@link module:ol/size~Size} the image size,\r\n * and {@link module:ol/proj/Projection~Projection} the image projection. The canvas returned by\r\n * this function is cached by the source. The this keyword inside the function\r\n * references the {@link module:ol/source/ImageCanvas~ImageCanvasSource}.\r\n *\r\n * @typedef {function(this:import(\"../ImageCanvas.js\").default, import(\"../extent.js\").Extent, number,\r\n *     number, import(\"../size.js\").Size, import(\"../proj/Projection.js\").default): HTMLCanvasElement} FunctionType\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {FunctionType} [canvasFunction] Canvas function.\r\n * The function returning the canvas element used by the source\r\n * as an image. The arguments passed to the function are: {@link import(\"../extent.js\").Extent} the\r\n * image extent, `{number}` the image resolution, `{number}` the pixel ratio of the map,\r\n * {@link import(\"../size.js\").Size} the image size, and {@link import(\"../proj/Projection.js\").default} the image\r\n * projection. The canvas returned by this function is cached by the source. If\r\n * the value returned by the function is later changed then\r\n * `changed` should be called on the source for the source to\r\n * invalidate the current cached image. See: {@link module:ol/Observable~Observable#changed}\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\r\n * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the\r\n * width and height of the map viewport, and so on. Must be `1` or higher.\r\n * @property {Array<number>} [resolutions] Resolutions.\r\n * If specified, new canvases will be created for these resolutions\r\n * @property {import(\"./Source.js\").State} [state] Source state.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Base class for image sources where a canvas element is the image.\r\n * @api\r\n */\r\nclass ImageCanvasSource extends ImageSource {\r\n  /**\r\n   * @param {Options} [options] ImageCanvas options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    super({\r\n      attributions: options.attributions,\r\n      interpolate: options.interpolate,\r\n      projection: options.projection,\r\n      resolutions: options.resolutions,\r\n      state: options.state,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {FunctionType}\r\n     */\r\n    this.canvasFunction_ = options.canvasFunction;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../ImageCanvas.js\").default}\r\n     */\r\n    this.canvas_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.renderedRevision_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @param {number} resolution Resolution.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\r\n   * @override\r\n   */\r\n  getImageInternal(extent, resolution, pixelRatio, projection) {\r\n    resolution = this.findNearestResolution(resolution);\r\n\r\n    let canvas = this.canvas_;\r\n    if (\r\n      canvas &&\r\n      this.renderedRevision_ == this.getRevision() &&\r\n      canvas.getResolution() == resolution &&\r\n      canvas.getPixelRatio() == pixelRatio &&\r\n      containsExtent(canvas.getExtent(), extent)\r\n    ) {\r\n      return canvas;\r\n    }\r\n\r\n    extent = extent.slice();\r\n    scaleFromCenter(extent, this.ratio_);\r\n    const width = getWidth(extent) / resolution;\r\n    const height = getHeight(extent) / resolution;\r\n    const size = [width * pixelRatio, height * pixelRatio];\r\n\r\n    const canvasElement = this.canvasFunction_.call(\r\n      this,\r\n      extent,\r\n      resolution,\r\n      pixelRatio,\r\n      size,\r\n      projection,\r\n    );\r\n    if (canvasElement) {\r\n      canvas = new ImageCanvas(extent, resolution, pixelRatio, canvasElement);\r\n    }\r\n    this.canvas_ = canvas;\r\n    this.renderedRevision_ = this.getRevision();\r\n\r\n    return canvas;\r\n  }\r\n}\r\n\r\nexport default ImageCanvasSource;\r\n","/**\r\n * @module CME2D/layer/BaseImage\r\n */\r\nimport Layer from './Layer.js';\r\n\r\n/**\r\n * @template {import(\"../source/Image.js\").default} ImageSourceType\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\r\n * @property {ImageSourceType} [source] Source for this layer.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Server-rendered images that are available for arbitrary extents and\r\n * resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Image.js\").default} ImageSourceType\r\n * @template {import(\"../renderer/Layer.js\").default} RendererType\r\n * @extends {Layer<ImageSourceType, RendererType>}\r\n * @api\r\n */\r\nclass BaseImageLayer extends Layer {\r\n  /**\r\n   * @param {Options<ImageSourceType>} [options] Layer options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n    super(options);\r\n  }\r\n}\r\n\r\nexport default BaseImageLayer;\r\n","/**\r\n * @module CME2D/renderer/canvas/ImageLayer\r\n */\r\nimport CanvasLayerRenderer from './Layer.js';\r\nimport ImageState from '../../ImageState.js';\r\nimport ViewHint from '../../ViewHint.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n} from '../../transform.js';\r\nimport {\r\n  containsCoordinate,\r\n  containsExtent,\r\n  getHeight,\r\n  getIntersection,\r\n  getWidth,\r\n  intersects as intersectsExtent,\r\n  isEmpty,\r\n} from '../../extent.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\n\r\n/**\r\n * @classdesc\r\n * Canvas renderer for image layers.\r\n * @api\r\n */\r\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\r\n  /**\r\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\r\n   */\r\n  constructor(imageLayer) {\r\n    super(imageLayer);\r\n\r\n    /**\r\n     * @protected\r\n     * @type {?import(\"../../Image.js\").default}\r\n     */\r\n    this.image = null;\r\n  }\r\n\r\n  /**\r\n   * @return {import('../../DataTile.js').ImageLike} Image.\r\n   */\r\n  getImage() {\r\n    return !this.image ? null : this.image.getImage();\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   * @override\r\n   */\r\n  prepareFrame(frameState) {\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const viewState = frameState.viewState;\r\n    const viewResolution = viewState.resolution;\r\n\r\n    const imageSource = this.getLayer().getSource();\r\n\r\n    const hints = frameState.viewHints;\r\n\r\n    let renderedExtent = frameState.extent;\r\n    if (layerState.extent !== undefined) {\r\n      renderedExtent = getIntersection(\r\n        renderedExtent,\r\n        fromUserExtent(layerState.extent, viewState.projection),\r\n      );\r\n    }\r\n\r\n    if (\r\n      !hints[ViewHint.ANIMATING] &&\r\n      !hints[ViewHint.INTERACTING] &&\r\n      !isEmpty(renderedExtent)\r\n    ) {\r\n      if (imageSource) {\r\n        const projection = viewState.projection;\r\n        const image = imageSource.getImage(\r\n          renderedExtent,\r\n          viewResolution,\r\n          pixelRatio,\r\n          projection,\r\n        );\r\n        if (image) {\r\n          if (this.loadImage(image)) {\r\n            this.image = image;\r\n          } else if (image.getState() === ImageState.EMPTY) {\r\n            this.image = null;\r\n          }\r\n        }\r\n      } else {\r\n        this.image = null;\r\n      }\r\n    }\r\n\r\n    return !!this.image;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray} Data at the pixel location.\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    const frameState = this.frameState;\r\n    if (!frameState) {\r\n      return null;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const coordinate = applyTransform(\r\n      frameState.pixelToCoordinateTransform,\r\n      pixel.slice(),\r\n    );\r\n\r\n    const layerExtent = layer.getExtent();\r\n    if (layerExtent) {\r\n      if (!containsCoordinate(layerExtent, coordinate)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    const imageExtent = this.image.getExtent();\r\n    const img = this.image.getImage();\r\n\r\n    const imageMapWidth = getWidth(imageExtent);\r\n    const col = Math.floor(\r\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth),\r\n    );\r\n    if (col < 0 || col >= img.width) {\r\n      return null;\r\n    }\r\n\r\n    const imageMapHeight = getHeight(imageExtent);\r\n    const row = Math.floor(\r\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight),\r\n    );\r\n    if (row < 0 || row >= img.height) {\r\n      return null;\r\n    }\r\n\r\n    return this.getImageData(img, col, row);\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @return {HTMLElement} The rendered element.\r\n   * @override\r\n   */\r\n  renderFrame(frameState, target) {\r\n    const image = this.image;\r\n    const imageExtent = image.getExtent();\r\n    const imageResolution = image.getResolution();\r\n    const [imageResolutionX, imageResolutionY] = Array.isArray(imageResolution)\r\n      ? imageResolution\r\n      : [imageResolution, imageResolution];\r\n    const imagePixelRatio = image.getPixelRatio();\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const pixelRatio = frameState.pixelRatio;\r\n    const viewState = frameState.viewState;\r\n    const viewCenter = viewState.center;\r\n    const viewResolution = viewState.resolution;\r\n    const scaleX =\r\n      (pixelRatio * imageResolutionX) / (viewResolution * imagePixelRatio);\r\n    const scaleY =\r\n      (pixelRatio * imageResolutionY) / (viewResolution * imagePixelRatio);\r\n\r\n    this.prepareContainer(frameState, target);\r\n\r\n    // desired dimensions of the canvas in pixels\r\n    const width = this.context.canvas.width;\r\n    const height = this.context.canvas.height;\r\n\r\n    const context = this.getRenderContext(frameState);\r\n\r\n    // clipped rendering if layer extent is set\r\n    let clipped = false;\r\n    let render = true;\r\n    if (layerState.extent) {\r\n      const layerExtent = fromUserExtent(\r\n        layerState.extent,\r\n        viewState.projection,\r\n      );\r\n      render = intersectsExtent(layerExtent, frameState.extent);\r\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\r\n      if (clipped) {\r\n        this.clipUnrotated(context, frameState, layerExtent);\r\n      }\r\n    }\r\n\r\n    const img = image.getImage();\r\n\r\n    const transform = composeTransform(\r\n      this.tempTransform,\r\n      width / 2,\r\n      height / 2,\r\n      scaleX,\r\n      scaleY,\r\n      0,\r\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolutionX,\r\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolutionY,\r\n    );\r\n\r\n    this.renderedResolution = (imageResolutionY * pixelRatio) / imagePixelRatio;\r\n\r\n    const dw = img.width * transform[0];\r\n    const dh = img.height * transform[3];\r\n\r\n    if (!this.getLayer().getSource().getInterpolate()) {\r\n      context.imageSmoothingEnabled = false;\r\n    }\r\n\r\n    this.preRender(context, frameState);\r\n    if (render && dw >= 0.5 && dh >= 0.5) {\r\n      const dx = transform[4];\r\n      const dy = transform[5];\r\n      const opacity = layerState.opacity;\r\n      if (opacity !== 1) {\r\n        context.save();\r\n        context.globalAlpha = opacity;\r\n      }\r\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\r\n      if (opacity !== 1) {\r\n        context.restore();\r\n      }\r\n    }\r\n    this.postRender(this.context, frameState);\r\n\r\n    if (clipped) {\r\n      context.restore();\r\n    }\r\n    context.imageSmoothingEnabled = true;\r\n\r\n    return this.container;\r\n  }\r\n}\r\n\r\nexport default CanvasImageLayerRenderer;\r\n","/**\r\n * @module CME2D/layer/Image\r\n */\r\nimport BaseImageLayer from './BaseImage.js';\r\nimport CanvasImageLayerRenderer from '../renderer/canvas/ImageLayer.js';\r\n\r\n/**\r\n * @classdesc\r\n * Server-rendered images that are available for arbitrary extents and\r\n * resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Image.js\").default} ImageSourceType\r\n * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}\r\n * @api\r\n */\r\nclass ImageLayer extends BaseImageLayer {\r\n  /**\r\n   * @param {import(\"./BaseImage.js\").Options<ImageSourceType>} [options] Layer options.\r\n   */\r\n  constructor(options) {\r\n    super(options);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  createRenderer() {\r\n    return new CanvasImageLayerRenderer(this);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the\r\n   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the\r\n   * source's `crossOrigin` property is set.\r\n   *\r\n   * ```js\r\n   * // display layer data on every pointer move\r\n   * map.on('pointermove', (event) => {\r\n   *   console.log(layer.getData(event.pixel));\r\n   * });\r\n   * ```\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   * @api\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    return super.getData(pixel);\r\n  }\r\n}\r\n\r\nexport default ImageLayer;\r\n","// 获取canvas坐标范围\r\nexport function getCanvasExtent(map, extent, padding) {\r\n  const [xmin, ymin] = map.getPixelFromCoordinate([extent[0], extent[3]]);\r\n  const [xmax, ymax] = map.getPixelFromCoordinate([extent[2], extent[1]]);\r\n  const newExtent = [xmin, ymin, xmax, ymax];\r\n  if (!padding) return newExtent;\r\n  return newExtent.map((v, i) => v + (i < 2 ? padding : -padding));\r\n}\r\n\r\nexport function mergeObject(object1, object2) {\r\n  Object.keys(object2).forEach(name => {\r\n    if (object1[name] === null || typeof object1[name] !== 'object') {\r\n      object1[name] = object2[name];\r\n      return;\r\n    }\r\n    mergeObject(object1[name], object2[name]);\r\n  });\r\n  return object1;\r\n}\r\n\r\n// 设置风向杆偏移位置\r\nexport function setArrowOffset(params) {\r\n  if (!params) return null;\r\n  if (params.type == \"arrow\") {\r\n    params.picOffset = 150;\r\n    return params;\r\n  }\r\n  params.picOffset = 84;\r\n  switch (params.typeColor) {\r\n    case \"white\":\r\n      params.picOffset = 20;\r\n      break;\r\n    case \"black\":\r\n      params.picOffset = 52;\r\n      break;\r\n    case \"blue\":\r\n      params.picOffset = 84;\r\n      break;\r\n    case \"orange\":\r\n      params.picOffset = 116;\r\n      break;\r\n    default:\r\n      params.picOffset = 52;\r\n      break;\r\n  }\r\n  return params;\r\n}\r\n\r\n// 判断点p是否在extent范围内\r\nfunction isInExtent(extent, p) {\r\n  const [x0, y0, x1, y1] = extent;\r\n  return p[0] >= x0 && p[0] <= x1 && p[1] >= y0 && p[1] <= y1;\r\n}\r\n\r\n// 获取canvas上的网格坐标\r\nexport function getGridPoints(extent, distance, outExtent, padding) {\r\n  const xyList = [];\r\n  const dx = extent[0] < 0 ? distance - Math.abs(extent[0] % distance) : 0;\r\n  const dy = extent[1] < 0 ? distance - Math.abs(extent[1] % distance) : 0;\r\n  const xMin = Math.max(extent[0], outExtent[0]) + dx;\r\n  const yMin = Math.max(extent[1], outExtent[1]) + dy;\r\n  const xMax = Math.min(extent[2], outExtent[2]);\r\n  const yMax = Math.min(extent[3], outExtent[3]);\r\n  for (let x = xMin; x <= xMax; x += distance) {\r\n    for (let y = yMin; y <= yMax; y += distance) {\r\n      if (!isInExtent(outExtent, [x, y])) continue;\r\n      xyList.push([x, y]);\r\n    }\r\n  }\r\n  return xyList;\r\n}\r\n\r\n\r\n","/**\r\n * @module CME2D/CME2DCore/layer/cme_gridValueLayer/gridNumberSource\r\n */\r\nimport ImageCanvasSource from \"../../../source/ImageCanvas.js\";\r\nimport { getCanvasExtent, getGridPoints, mergeObject } from \"./../cme_gridArrowLayer/gridHelper.js\";\r\n// import {\r\n//     transform\r\n// } from \"../../../proj.js\";\r\n// import {\r\n//     Point\r\n// } from \"../../../geom.js\";\r\n// import Feature from \"../../../Feature.js\";\r\nimport {\r\n    transformExtent\r\n} from '../../../proj.js';\r\n\r\nimport {\r\n    getWindSpeedAndDirection\r\n} from \"../common/commonLayerUnit.js\";\r\n\r\nclass gridNumberSource {\r\n    constructor(map) {\r\n        this.options = null; //params.params;\r\n        this.map = map; //params.this.map;\r\n        this.padding = 10;\r\n        this.canvas = document.createElement('canvas');\r\n    }\r\n\r\n    /**\r\n     * 使用给定参数初始化一个WebGL函数。\r\n     * 这段代码片段初始化了一个用于单个参数的WebGL函数。\r\n     * 它创建了一个具有特定选项和生成画布的函数的画布来源。该函数基于提供的范围、\r\n     * 分辨率、像素比率、大小和投影等参数生成画布。然后，\r\n     * 函数通过操作画布上下文根据选项对象中提供的数据绘制文本和图标。\r\n     *\r\n     * @param {Object} params - WebGL函数的参数。\r\n     * @return {ImageCanvasSource} WebGL函数的画布源。\r\n     */\r\n    InitWebGLFunctionSingle(params) {\r\n        this.options = params;\r\n        const unitList = ['℃', 'C'];\r\n        function inRange(val, range) {\r\n            return val >= range.min && val <= range.max;\r\n        }\r\n        const canvasSource = new ImageCanvasSource({\r\n            ratio: 1,\r\n            projection: this.map.getView().getProjection().getCode(), //'EPSG:4326',\r\n            /**\r\n             * 根据给定的范围、分辨率、像素比率、大小和投影生成画布。\r\n             *\r\n             * @param {type} extent - 参数范围的描述\r\n             * @param {type} resolution - 分辨率参数的描述\r\n             * @param {type} pixelRatio - 像素比率参数的描述\r\n             * @param {type} size - 大小参数的描述\r\n             * @param {type} projection - 投影参数的描述\r\n             * @return {type} 返回值描述\r\n             */\r\n            canvasFunction: (extent, resolution, pixelRatio, size, projection) => {\r\n                const params = this.options;\r\n                const { distanceArrow, fixedPixel, layer, showTextRange, precision } = params;\r\n                const _precision = precision || 1;\r\n                const style = layer.style_;\r\n                const source = layer.getSource();\r\n                const _resolutions = source.getResolutions();\r\n                const rawResolution = _resolutions.slice(-1)[0];\r\n                let _bandCount = 0;\r\n                if (source.getMetaDatas) {\r\n                    const { bandCount } = source.getMetaDatas();\r\n                    _bandCount = bandCount;\r\n                } else {\r\n                    _bandCount = style.bandsNumber || 0;\r\n                }\r\n                const range = Object.assign({ min: -9999, max: 9999 }, showTextRange);\r\n                var canvas = this.canvas;\r\n                canvas.width = size[0];\r\n                canvas.height = size[1];\r\n                var context = canvas.getContext(\"2d\");\r\n                context.scale(pixelRatio, pixelRatio);\r\n                let textSymbol = { //文本样式\r\n                    font: \"14px Calibri,sans-serif\", //字体\r\n                    // textBaseline: \"middle\",//垂直对齐\r\n                    fill: { //填充\r\n                        color: \"#000\", //颜色\r\n                    },\r\n                    stroke: { //边框\r\n                        color: \"#fff\", //颜色\r\n                        width: 4, //宽度\r\n                    },\r\n                };\r\n                // 合并样式选项\r\n                if (params.textStyle) {\r\n                    mergeObject(textSymbol, params.textStyle);\r\n                }\r\n                context.fillStyle = '#00000000';\r\n                context.fillRect(0, 0, size[0], size[1]);\r\n                context.fillStyle = textSymbol.fill?.color || '#000000ff';\r\n                if (textSymbol.stroke) {\r\n                    context.strokeStyle = textSymbol.stroke.strokeStyle || \"#ffffff\"; // 字体边框颜色\r\n                    context.lineWidth = textSymbol.stroke.lineWidth || 1; // 字体边框宽度\r\n                }\r\n                //1. 使用`font`设置字体。\r\n                context.font = textSymbol.font; //\"14px blod serif\";\r\n                context.textAlign = \"center\";\r\n                let mapProject = projection.getCode();\r\n                let proj = layer.getProperties().proj;\r\n                let projCode = proj.projection;\r\n                let offsetNumber = proj.offsetNumber || 0;\r\n                let unit = proj.unit;\r\n                var newExtent = proj.extent;\r\n                if (projCode != mapProject) {\r\n                    newExtent = transformExtent(proj.extent, projCode, mapProject);\r\n                }\r\n                let distance = +distanceArrow || 80;\r\n                if (fixedPixel) {\r\n                    distance = Math.max((rawResolution / resolution), distance);\r\n                }\r\n                this.padding = Math.ceil(distance / 5);\r\n                // 获取外层范围，用以判断canvas数字是否在地图区域之内\r\n                const outExtent = getCanvasExtent(this.map, extent);\r\n                // 获取内层范围，确定canvas绘制范围\r\n                const extent1 = getCanvasExtent(this.map, newExtent, this.padding);\r\n                const xyList = getGridPoints(extent1, distance, outExtent, this.padding);\r\n                const { scala, scale, offset } = style;\r\n                const _scale = scale || scala;\r\n                for (let idx = 0; idx < xyList.length; idx++) {\r\n                    let data = layer.getData(xyList[idx]);\r\n                    if (!(data && data.length)) continue;\r\n                    let drawNum = (data[0] - offset) / _scale;\r\n                    if (_bandCount >= 2) {\r\n                        let uv = getWindSpeedAndDirection(drawNum, (data[1] - offset) / _scale);\r\n                        drawNum = uv.speed; //风速\r\n                    } else if (unitList.includes(unit)) {\r\n                        drawNum -= 273.15;\r\n                    }\r\n                    if (!inRange(drawNum, range)) continue;\r\n                    drawNum = drawNum.toFixed(_precision);\r\n                    let xPixel = xyList[idx][0] - offsetNumber;\r\n                    let yPixel = xyList[idx][1] - offsetNumber;\r\n                    if (textSymbol.stroke) {\r\n                        context.strokeText(drawNum, xPixel, yPixel);\r\n                    }\r\n                    context.fillText(drawNum, xPixel, yPixel);\r\n                    context.fill(); // 填充颜色\r\n                }\r\n                return canvas;\r\n            }\r\n        });\r\n        return canvasSource;\r\n    }\r\n\r\n    setOptions(options) {\r\n        this.options = options;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport { gridNumberSource }","/**  this.canvasSource\r\n * @module CME2D/CME2DCore/layer/cme_gridValueLayer/cme_gridValueLayer\r\n */\r\n\r\nimport ImageLayer from \"../../../layer/Image.js\";\r\nimport {\r\n  gridNumberSource\r\n} from \"./gridNumberSource.js\"\r\nimport {\r\n  PanByPixel,\r\n  mergeObjects\r\n} from \"../common/commonLayerUnit.js\";\r\nvar cme_gridValueLayer = class gridNumberClass extends ImageLayer {\r\n  /**\r\n   * 整个函数的描述。\r\n   *\r\n   * @param {type} options - 参数描述\r\n   * @return {type} 返回值描述\r\n   */\r\n  constructor() {\r\n\r\n    super({});\r\n    this.canvasSource = null;\r\n    this.gridSource = null;\r\n    this.options = null;\r\n\r\n  }\r\n  /**\r\n   * 渲染选项并返回一个解析为true的Promise。\r\n   *\r\n   * @param {Object} options - 要渲染的选项。\r\n   * @return {Promise} 一个解析为true的Promise。\r\n   */\r\n  _render(options) {\r\n    if (!options.params?.layer) {\r\n      throw Error('参数options缺少\"params.layer\"参数');\r\n    }\r\n    this.gridSource = new gridNumberSource(options.map);\r\n    this.options = options;\r\n    let that = this;\r\n    return new Promise((resolve) => {\r\n      that.canvasSource = that.gridSource.InitWebGLFunctionSingle(options.params);\r\n      that.setSource(that.canvasSource)\r\n      for (let key in options.params) {\r\n        const value = options.params[key];\r\n        that.set(key, value)\r\n      }\r\n\r\n\r\n      that.setProperties(options.params)\r\n      that.set(\"params\", options.params)\r\n\r\n      //  that.once('sourceready', function (event) {\r\n      options.map.once(\"rendercomplete\", function () {\r\n        that.canvasSource.changed()\r\n        // PanByPixel(options.map, 0.1, 0.1);\r\n        resolve(true);\r\n      });\r\n    })\r\n\r\n\r\n  }\r\n\r\n  /**\r\n   * 设置函数的来源。\r\n   *\r\n   * @param {type} paramName - 参数的描述\r\n   * @return {type} 返回值的描述\r\n   */\r\n  _setSource(layer) {\r\n    this.options.params.layer = layer;\r\n    let that = this;\r\n    return new Promise((resolve) => {\r\n      // that.canvasSource = new InitWebGLFunctionSingle(this.options);\r\n\r\n      that.canvasSource = that.gridSource.InitWebGLFunctionSingle(that.options.params);\r\n      that.setSource(that.canvasSource)\r\n\r\n      // // that.once('postcompose', function (event) {\r\n      //   // that.once('postrender', function (event) {\r\n      //   that.once('sourceready', function (event) {\r\n      //   that.canvasSource.changed()\r\n      //   PanByPixel(that.options.map, 1, 1);\r\n\r\n      //   resolve(true);\r\n      // })\r\n      that.once('sourceready', function (event) {\r\n\r\n        that.once('postrender', function (event) {\r\n          that.canvasSource.changed()\r\n          // PanByPixel(that.options.map, 0.1, 0.1);\r\n          resolve(true);\r\n        })\r\n\r\n      })\r\n\r\n    })\r\n\r\n\r\n  }\r\n  /**\r\n   * 对整个函数的描述。\r\n   *\r\n   * @param {type} paramName - 参数描述\r\n   * @return {type} 返回值描述\r\n   */\r\n  _setStyle(options) {\r\n\r\n    let tempStyle = {}\r\n    let tempObject = this.values_ || {};\r\n    for (let key in tempObject) {\r\n      const value = tempObject[key];\r\n      if (key != \"layer\") {\r\n        tempStyle[key] = value;\r\n      }\r\n    }\r\n\r\n    let styleobject = mergeObjects(tempStyle, options.params);\r\n    for (let key in styleobject) {\r\n      const value = styleobject[key];\r\n      this.set(key, value)\r\n    }\r\n    // let  styleobject = Object.assign({},  this.getProperties()[\"params\"], options.params);\r\n    this.options.params = styleobject;\r\n    styleobject.layer = tempObject.layer;\r\n    // this.set(\"params\", styleobject);\r\n    this.gridSource.setOptions(styleobject);\r\n    this.canvasSource.changed();\r\n    return Promise.resolve(styleobject);\r\n  }\r\n\r\n  getSource() {\r\n    return this.canvasSource;\r\n  }\r\n  /**\r\n   * 整个函数的描述。\r\n   *\r\n   */\r\n  _remove() {\r\n    this.dispose();\r\n    // 变量清空\r\n  }\r\n}\r\nexport default cme_gridValueLayer","<!--\r\n * @Author: sjz 15103288529@163.com\r\n * @Date: 2024-03-16 15:52:15\r\n * @LastEditors: sjz 15103288529@163.com\r\n * @LastEditTime: 2024-05-27 19:57:25\r\n * @FilePath: \\cme\\src\\components\\cme-application\\RasterRender\\index.vue\r\n * @Description: 渲染栅格数据图层（单通道/多通道）\r\n-->\r\n<script>\r\nimport {\r\n  cme_gridValueLayer,\r\n  cme_cogtifLayer2,\r\n// } from \"CME2D/CME2DCore/index.js\";\r\n} from \"E://0509/cme2d-v1.0-0510/cme2d-v1.0----new/src/CME2D/CME2DCore\";\r\n\r\n\r\nimport { defineComponent } from \"vue\";\r\n// import { getCofTifData } from \"./cogtifWorld.js\";\r\nexport default defineComponent({\r\n  setup() {\r\n    let layerdata = null;\r\n    let mapRef = null;\r\n    const layerRef = { tifLayer: null, textLayer: null };\r\n    const CogTifInfo = {};\r\n    /**\r\n     * @description: 渲染栅格数据图层（单通道/多通道）\r\n     * @param {object} map - 地图实例\r\n     * @param {string} url - 图层url\r\n     * @param {object} data - 配置属性\r\n     * @return {*}\r\n     */\r\n    let addLayer = (map, url, data) => {\r\n      mapRef = map;\r\n      // CogTifInfo.value = res\r\n      CogTifInfo.configUnit = data?.configUnit\r\n      // let bandsNumber = data.bandsNumber || 1; //判断是UV还是普通色斑\r\n      layerdata = data; //存储图层实例变量，方便销毁使用\r\n\r\n\r\n      \r\n      let sources = []; //图例数据\r\n      if (data.normalize) {\r\n          // 多通道\r\n          sources = [\r\n            {\r\n              url: url, //tif文件\r\n            \r\n            },\r\n          ];\r\n\r\n        } else {\r\n          // 单通道\r\n          sources = [\r\n            {\r\n              url: url, //tif文件\r\n              min: -9999,\r\n               max: 9999 \r\n            },\r\n          ];\r\n        }\r\n\r\n      // 图例\r\n      let config = {\r\n        layerName: data.id,\r\n        type: 'grid',\r\n        zIndex: data.zIndex ?? 1,\r\n        source: {\r\n          //图层的数据源\r\n          normalize: data.normalize ?? false, //是否是多通道 true 表示是多通道，false表示单通道\r\n          // sources: [{ url, min: -9999, max: 9999 }], // tif文件路径\r\n\r\n          sources:sources, // tif文件路径\r\n          wrapX: data.wrapX ?? true,\r\n          interpolate: data?.interpolate ?? true,  // 控制图层展示是否平滑\r\n        },\r\n        style: {\r\n          //渲染的样式\r\n          color: data.legendData?.legend ?? [], //颜色\r\n          radio: +data.radio || 2, //颜色拉伸 1表示渐变拉伸，2表示区间值拉伸\r\n          scale: +(data.scale || data.scala) , // data.legendData?.scala ?? 0,//颜色拉伸\r\n          offset: +data.offset || 0,\r\n          unit: data.unit ?? ''\r\n        },\r\n        opacity: data.opacity ?? 0.78, //图层透明度\r\n        sourceOptions: {\r\n          allowFullFile: false,\r\n        },\r\n        mapproj: map.getView().getProjection().getCode()\r\n      };\r\n      // let layer = new cme_cogtifLayer(config); //调用栅格图渲染方法\r\n      let layer = new cme_cogtifLayer2(); //调用栅格图渲染方法\r\n      map.addLayer(layer);\r\n      layerRef.tifLayer = layer;\r\n      return layer._render(config).then((meta) => {\r\n        if (data.showText) {\r\n          addTextLayer(map, layer, data); //添加文本数值图层\r\n        }\r\n        return Promise.resolve(layerRef, meta); // 返回元数据\r\n      });\r\n    };\r\n\r\n    /**\r\n     * @description: 渲染格点显示图层\r\n     * @param {*} map - 地图实例\r\n     * @param {Object} layer - 图层实例\r\n     * @param {Object} data - 配置属性\r\n     * @return {*}\r\n     */\r\n    let addTextLayer = (map, layer, data) => {\r\n      const range = { min: -9999, max: 9999 };\r\n      const legend = (data?.legendData?.legend || []).map(v => v[0]);\r\n      if (legend.length) {\r\n        range.min = legend.reduce((v1, v2) => Math.min(v1, v2), 0) - 10;\r\n        range.max = legend.reduce((v1, v2) => Math.max(v1, v2), 0) + 10;\r\n      }\r\n      let config = {\r\n        map: map, //地图实例\r\n        params: {\r\n          type: 'grid',\r\n          layer: layer, //图层实例\r\n          layerName: data.textId ?? data.id, //文本图层的图层名字,默认是栅格数据id名称加上_Text\r\n          precision: 1, //格网数据显示的小数点的精度\r\n          opacity: 1, //透明度\r\n          maxZoom: 15, // 最大缩放级别\r\n          zIndex: Number(data.zIndex) + 1 ?? 2, //图层层级\r\n          showTextRange: range,\r\n          distanceArrow: data.distanceArrow ?? 80, //距离\r\n          textStyle: data.textStyle ?? {\r\n            //文本样式\r\n            font: \"11px Calibri,sans-serif\", //字体\r\n            fill: {\r\n              color: \"#000000\", //填充颜色\r\n            },\r\n            stroke: {\r\n              // strokeStyle:'white',\r\n              lineWidth: 5\r\n            }\r\n          },\r\n        },\r\n      };\r\n      let lyr = new cme_gridValueLayer(); //调用渲染文本图层方法\r\n      map.addLayer(lyr); //添加图层\r\n      lyr._render(config); //把数据添加到图层上\r\n      layerRef.tifLayer = lyr;\r\n    };\r\n\r\n    const getData = (pixel, layer) => {\r\n      let res = layer.getData(pixel)\r\n      let { scale = 1, unit, offset = 0, nodata, configUnit } = CogTifInfo\r\n      let params = {\r\n        value: null\r\n      }\r\n      if (res !== nodata) {\r\n        try {\r\n          if (configUnit && configUnit === 'k') {\r\n            params.value = (res[0] / scale) + offset\r\n          }\r\n          else if (unit === 'K') {\r\n            if (res[0] === 0) {\r\n              params.value = 0\r\n            }\r\n            else {\r\n              params.value = offset + (res[0] / scale) - 273.15\r\n            }\r\n          }\r\n          else {\r\n            params.value = (res[0] / scale) + offset\r\n          }\r\n        }\r\n        catch (err) {\r\n        }\r\n        return params\r\n      }\r\n      return ''\r\n    };\r\n\r\n    function removeLayer() {\r\n      Object.values(layerRef).forEach(layer => {\r\n        if (!layer) return;\r\n        mapRef && mapRef.removeLayer(layer);\r\n      });\r\n    }\r\n\r\n    return {\r\n      getData,\r\n      addLayer,\r\n      removeLayer\r\n    };\r\n  },\r\n});\r\n</script>\r\n","import GridRender from \"./index.vue\";\r\n// 色斑图组件\r\nGridRender.install = function (Vue) {\r\n  Vue.component(\"CME-GridRender\", GridRender);\r\n};\r\nexport { GridRender };\r\n"],"names":["Disposable","BaseEvent","type","ascending","a","b","descending","linearFindNearest","arr","target","direction","i","candidate","extend","data","extension","length","equals","arr1","arr2","len1","isSorted","func","strict","compare","currentVal","index","res","VOID","memoizeOne","fn","lastResult","lastArgs","lastThis","nextArgs","arrayEquals","toPromise","getter","promiseGetter","value","err","clear","object","property","isEmpty","Target","listener","listeners","listenersForType","event","isString","evt","Event","dispatching","pendingRemovals","propagate","ii","pr","EventType","TileState","abstract","uidCounter_","getUid","obj","easeIn","t","easeOut","inAndOut","Tile","EventTarget","tileCoord","state","options","id","time","start","delta","ua","SAFARI","SAFARI_BUG_237906","WORKER_OFFSCREEN_CANVAS","IMAGE_DECODE","passive","createCanvasContext2D","width","height","canvasPool","settings","canvas","sharedCanvasContext","getSharedCanvasContext2D","releaseCanvas","context","asImageLike","asArrayLike","disposedError","sharedContext","toArray","image","defaultSize","DataTile","imageData","self","error","ERROR_THRESHOLD","Relationship","boundingExtent","coordinates","extent","createEmpty","extendCoordinate","_boundingExtentXYs","xs","ys","dest","minX","minY","maxX","maxY","createOrUpdate","closestSquaredDistanceXY","x","y","dx","dy","containsCoordinate","coordinate","containsXY","containsExtent","extent1","extent2","coordinateRelationship","relationship","createOrUpdateEmpty","createOrUpdateFromCoordinate","createOrUpdateFromFlatCoordinates","flatCoordinates","offset","end","stride","extendFlatCoordinates","extendXY","forEachCorner","callback","val","getBottomLeft","getBottomRight","getTopRight","getTopLeft","getArea","area","getWidth","getHeight","getCenter","getCorner","corner","getForViewAndSize","center","resolution","rotation","size","x0","y0","x1","y1","x2","y2","x3","y3","getRotatedViewport","cosRotation","sinRotation","xCos","xSin","yCos","ySin","getIntersection","intersection","intersects","returnOrUpdate","scaleFromCenter","deltaX","deltaY","intersectsSegment","startRel","endRel","startX","startY","endX","endY","slope","applyTransform","transformFn","stops","wrapX","projection","projectionExtent","worldWidth","wrapAndSliceX","multiWorld","unitByCode","fromCode","code","METERS_PER_UNIT","Projection","global","tileGrid","worldExtent","RADIUS","HALF_SIZE","EXTENT","WORLD_EXTENT","MAX_SAFE_Y","EPSG3857Projection","point","PROJECTIONS","fromEPSG4326","input","output","dimension","toEPSG4326","EPSG4326Projection","axisOrientation","cache","get","add","transforms","source","destination","sourceCode","destinationCode","transform","clamp","min","max","squaredSegmentDistance","squaredDistance","solveLinearSystem","mat","n","maxRow","maxEl","r","absValue","tmp","j","coef","k","l","m","toRadians","angleInDegrees","modulo","lerp","toFixed","decimals","factor","floor","ceil","coordinate1","coordinate2","rotate","angle","cosAngle","sinAngle","DEFAULT_RADIUS","getDistance","c1","c2","radius","lat1","lat2","deltaLatBy2","deltaLonBy2","warn","args","showCoordinateWarning","disableCoordinateWarning","disable","cloneTransform","identityTransform","addProjection","addProj","addTransformFunc","addProjections","projections","projectionLike","getProj","getPointResolution","units","pointResolution","metersPerUnit","projUnits","getTransformFromProjections","vertices","addEquivalentProjections","addEquivalentTransforms","projections1","projections2","forwardTransform","inverseTransform","projection1","projection2","createProjection","defaultCode","equivalent","equalUnits","sourceProjection","destinationProjection","transformFunc","getTransformFunc","getTransform","transformExtent","toUserCoordinate","fromUserCoordinate","destProjection","toUserExtent","fromUserExtent","addCommon","EPSG3857_PROJECTIONS","EPSG4326_PROJECTIONS","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","destinationResolution","transformInvCache","transformInv","c","key","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","leftBound","triangle","newTriangle","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","targetQuadExtent","isNotFinite","centerSrc","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","src","brokenDiagonalRendering_","drawTestTriangle","ctx","u1","v1","u2","v2","verifyBrokenDiagonalRendering","isBrokenDiagonalRendering","calculateSourceResolution","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","sourceMetersPerUnit","sourceExtent","compensationFactor","calculateSourceExtentResolution","render","pixelRatio","triangulation","sources","gutter","renderEdges","interpolate","drawSingle","clipExtent","pixelRound","sourceDataExtent","stitchContext","stitchScale","inverseScale","xPos","yPos","srcWidth","srcHeight","targetTopLeft","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","steps","ud","vd","step","listen","thisArg","once","originalListener","eventsKey","listenOnce","unlistenByKey","ReprojDataTile","sourceProjExtent","sourceTileGridExtent","maxTargetExtent","limitedTargetExtent","errorThresholdInPixels","worldsAway","sourceRange","getTile","srcX","srcY","tile","dataSources","imageLike","tileData","arrayData","pixelSize","isFloat","pixelCount","DataType","tileDataR","bytesPerElement","bytesPerPixel","bytesPerRow","bandCount","packedLength","packedData","dataIndex","rowOffset","colCount","rowIndex","colIndex","_a","z","targetWidth","targetHeight","dataR","dataU","reprojs","reproj","len","dataSource","buffer","renderReprojected","leftToLoad","sourceListenKey","assert","assertion","errorMessage","LRUCache","highWaterMark","keep","f","entry","keys","values","getKeyZXY","getKey","fromKey","withinExtentAndZ","tileRange","TileCache","usedTiles","TileEventType","ObjectEventType","Observable","unByKey","ObjectEvent","oldValue","BaseObject","eventType","silent","Source","getProjection","adaptAttributions","resolve","reject","attributions","attributionLike","frameState","TileRange","DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","forEach","ret","linearRingContainsExtent","linearRingContainsXY","wn","linearRingsContainsXY","ends","intersectsLineString","coordinatesExtent","forEachSegment","point1","point2","intersectsLinearRing","intersectsLinearRingArray","scale","ratio","toSize","tmpTileCoord","DECIMALS","TileGrid","zoomFactor","restrictedTileRange","zoom","jj","tempTileRange","tempExtent","tileCoordExtent","createOrUpdateTileRange","tileCoordZ","tileCoordX","tileCoordY","origin","tileSize","opt_tileCoord","reverseIntersectionPolicy","createOrUpdateTileCoord","opt_direction","viewport","fullTileRanges","getForProjection","createForProjection","extentFromProjection","createForExtent","maxZoom","resolutions","resolutionsFromExtent","createXYZ","xyzOptions","gridOptions","maxResolution","half","TileSource","tileCache","getTileGridForProjection","tilePixelRatio","scaleSize","TileSourceEvent","DataTileSource","tileSizes","thisProj","loader","tileCoordKey","reprojTilePixelRatio","textureSize","sourceTileGrid","targetTileGrid","wrappedTileCoord","newTile","sourceLoader","controller","loaderOptions","requestZ","requestX","requestY","uid","tileState","projKey","tilegrid","proj","usedTileCache","uncurryThis","ReflectApply","uncurryThisGetter","ReflectGetOwnPropertyDescriptor","ReflectConstruct","ReflectDefineProperty","ReflectGet","ReflectGetPrototypeOf","ReflectHas","ReflectOwnKeys","ReflectSet","ReflectSetPrototypeOf","SymbolIterator","SymbolSpecies","SymbolToStringTag","SymbolFor","NativeObject","ObjectCreate","ObjectDefineProperty","ObjectFreeze","ObjectIs","NativeArray","ArrayPrototype","NativeArrayPrototypeSymbolIterator","ArrayPrototypeSymbolIterator","NativeArrayBuffer","ArrayBufferPrototype","NativeSharedArrayBuffer","TypedArray","TypedArrayPrototype","NativeUint8Array","NativeUint16Array","NativeUint32Array","NativeFloat32Array","ArrayIteratorPrototype","ArrayIteratorPrototypeNext","GeneratorPrototypeNext","IteratorPrototype","DataViewPrototype","DataViewPrototypeGetUint16","NativeWeakMap","WeakMapPrototype","WeakMapPrototypeGet","WeakMapPrototypeSet","arrayIterators","SafeIteratorPrototype","arrayIterator","safeIfNeeded","array","safe","generators","DummyArrayIteratorPrototype","generator","floatView","uint32View","baseTable","shiftTable","mantissaTable","e","exponentTable","offsetTable","convertToNumber","float16bits","getFloat16","dataView","byteOffset","opts","getAttribute","tag","attributeName","debug","xml","opening","quotechars","char","pattern","match","getAttributeModule","indexOfMatch","startIndex","indexOfMatchModule","indexOfMatchEnd","indexOfMatchEndModule","countSubstring","string","substring","countSubstringModule","require$$0","require$$1","require$$2","findTagByName","tagName","nested","afterStart","relativeEnd","selfClosing","openings","closings","clip","outer","inner","findTagByNameModule","findTagsByName","tags","findTagsByNameModule","fieldTagNames","fieldTags","arrayFields","fieldTypeNames","fieldTypes","photometricInterpretations","ExtraSamplesValues","LercParameters","LercAddCompression","geoKeyNames","fromWhiteIsZero","raster","rgbRaster","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","fromYCbCr","yCbCrRaster","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","registry","addDecoder","cases","importFn","getDecoder","fileDirectory","Decoder","copyNewSize","samplesPerPixel","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","newArray","cy","cx","resampleBilinear","rawY","yl","yh","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","s","arrayForType","format","bitsPerSample","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","outSize","samplesToTransfer","outArray","bitMask","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","innerBitOffset","raw","GeoTIFFImage","geoKeys","littleEndian","bytes","sampleIndex","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","tiles","byteCount","slice","request","sampleFormat","imageWindow","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","srcSampleOffsets","sampleReaders","promises","yTile","xTile","getPromise","si","promise","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","windowCoordinate","resampled","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","window","enableAlpha","pi","subOptions","red","green","blue","tiePoints","metadata","items","item","modelTransformation","referenceImage","modelPixelScale","refResX","refResY","refResZ","g","h","projected","I","J","pt","DataView64","arrayBuffer","left","right","combined","isNegative","carrying","byte","DataSlice","sliceOffset","bigTiff","defaultPoolSize","Pool","createWorker","module","create","decoder","worker","onMessage","CRLFCRLF","itemsToObject","parseHeaders","text","line","kv","str","parseContentType","rawContentType","rawParams","paramsItems","param","parseContentRange","rawContentRange","total","parseByteRanges","responseArrayBuffer","boundary","out","startBoundary","endBoundary","innerText","endOfHeaders","headers","startOfData","BaseSource","slices","QuickLRU","maxAge","expiry","deleted","newSize","removeCount","oldCacheSize","callbackFunction","thisArgument","wait","milliseconds","zip","A","B","AbortError","params","CustomAggregateError","errors","message","AggregateError","Block","BlockGroup","blockIds","BlockedSource","blockSize","cacheSize","blockId","block","blockRequests","missingBlockIds","allBlockIds","top","fileSize","firstBlockOffset","current","missingRequests","abortedBlockRequests","abortedBlockIds","blocks","failedBlocks","requiredBlocks","groups","groupRequests","groupIndex","group","response","blockOffset","o","sortedBlockIds","lastBlockId","blockIdLow","blockIdHigh","sliceData","sliceView","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView","BaseResponse","headerName","BaseClient","url","FetchResponse","name","FetchClient","credentials","XHRResponse","xhr","XHRClient","fs","HttpResponse","dataPromise","HttpClient","urlMod","http","resolveData","chunks","chunk","RemoteSource","client","maxRanges","allowFullFile","byteRanges","first","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","FileReaderSource","file","blob","makeFileReaderSource","getFieldTypeLength","fieldType","parseGeoKeyDirectory","rawGeoKeyDirectory","geoKeyDirectory","location","count","getValues","dataSlice","readMethod","fieldTypeLength","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","resX","resY","bbox","firstImage","usedImage","imageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","subfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","fallbackSize","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","previousIfd","ifd","hasNext","detectionString","heuristicAreaSize","metadataSize","fullString","headerData","BOM","magicNumber","MultiGeoTIFF","mainFile","overviewFiles","requests","visited","relativeIndex","imageFile","ifds","fromUrl","fromBlob","fromUrls","mainUrl","overviewUrls","isMask","readRGB","preference","interpretation","interpretations","geotiffGlobals.photometricInterpretations","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","getBoundingBox","getOrigin","getResolutions","getCachedProjection","unitsFromCode","getImagesForTIFF","tiff","getImagesForSource","tiffFromBlob","tiffFromUrls","tiffFromUrl","assertEqual","expected","got","tolerance","rejector","getMinForDataType","getMaxForDataType","GeoTIFFSource","numSources","logError","firstSource","commonRenderTileSizes","commonSourceTileSizes","nodataValues","minZoom","sourceCount","sourceIndex","images","masks","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","wantedSamples","level","imageResolutions","sourceTileSize","aspectRatio","resolutionFactor","scaledSourceResolutions","sourceImagery","bands","sourceInfo","pixelBounds","bandNumber","readOptions","maskIndex","mask","sourceSamples","normalize","addAlpha","dataLength","pixelIndex","transparent","gain","bias","stats","sourceValue","nodata","bandIndex","nodataIsNaN","LayerProperty","BaseLayer","properties","managed","zIndex","states","background","minResolution","opacity","visible","zindex","RenderEventType","ViewHint","ViewProperty","createExtent","onlyCenter","smooth","isMoving","centerShift","viewWidth","viewHeight","shiftX","shiftY","none","getViewportClampedResolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","getSmoothClampedResolution","result","createSnapToResolutions","cappedMaxRes","capped","createSnapToPower","power","minZoomLevel","cappedZoomLevel","zoomLevel","newResolution","createMinMaxResolution","createSnapToN","theta","createSnapToZero","tmp_","reset","set","multiply","transform1","transform2","a1","b1","d1","e1","f1","a2","b2","d2","e2","f2","apply","cos","sin","translate","compose","dx1","dy1","sx","sy","dx2","dy2","makeInverse","det","determinant","matrixPrecision","toString","transform2D","destinationStride","anchor","anchorX","anchorY","tmpTransform","createTransform","Geometry","revision","squaredTolerance","clone","closestPoint","minSquaredDistance","coord","inCoordinates","outCoordinates","pixelExtent","projectedExtent","composeTransform","SimpleGeometry","simplifiedGeometry","layout","getStrideForLayout","nesting","getLayoutForStride","assignClosest","offset1","offset2","maxSquaredDelta","squaredDelta","squaredDx","arrayMaxSquaredDelta","assignClosestPoint","maxDelta","isRing","tmpPoint","assignClosestArrayPoint","deflateCoordinate","deflateCoordinates","deflateCoordinatesArray","coordinatess","douglasPeucker","simplifiedFlatCoordinates","simplifiedOffset","markers","stack","last","maxSquaredDistance","snap","quantize","quantizeArray","simplifiedEnds","inflateCoordinates","inflateCoordinatesArray","linearRing","twiceArea","linearRings","LinearRing","linearRingArea","Point","getInteriorPointOfArray","flatCenters","flatCentersOffset","intersections","rr","pointX","maxSegmentLength","segmentLength","linearRingIsClockwise","edge","linearRingsAreOriented","isClockwise","orientLinearRings","reverseCoordinates","Polygon","polygon","linearRingsArea","flatCenter","fromExtent","DEFAULT_MIN_ZOOM","View","resolutionConstraintInfo","createResolutionConstraint","centerConstraint","createCenterConstraint","resolutionConstraint","rotationConstraint","createRotationConstraint","padding","oldPadding","newPadding","offsetX","offsetY","newOptions","var_args","animationCount","animationCallback","series","animation","isNoopAnimation","now","more","seriesComplete","elapsed","fraction","progress","constrainedResolution","constrainedRotation","currentCenter","rotateCoordinate","addCoordinate","currentResolution","w","hints","enabled","logPower","reducedSize","calculateCenterOn","nearest","baseLevel","geometryOrExtent","geometry","polygonFromExtent","coords","minRotX","minRotY","maxRotX","maxRotY","rotX","rotY","rotatedExtent","centerRot","centerX","centerY","position","shiftedCenter","deltaCoordinates","newRotation","hint","doNotCancelAnims","forceMoving","newCenter","duration","resolutionDirection","targetZoom","targetRes","returnValue","centerNone","projExtent","constrainOnlyCenter","defaultMaxResolution","defaultMinResolution","constrainRotation","rotationNone","coordinatesEqual","Layer","baseOptions","pixel","map","layerState","layerExtent","inView","getAttributions","layerRenderer","layerStatesArray","arrayLayerState","viewState","TileProperty","BaseTileLayer","preload","useInterimTilesOnError","ReprojTile","getTileFunction","ImageState","ImageWrapper","stateOrLoader","requestResolution","listenImage","loadHandler","errorHandler","img","listening","decoding","loaded","listenerKeys","ImageTile","crossOrigin","tileLoadFunction","element","getBlankImage","BaseTileRepresentation","helper","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","STREAM_DRAW","STATIC_DRAW","DYNAMIC_DRAW","UNSIGNED_BYTE","UNSIGNED_SHORT","UNSIGNED_INT","FLOAT","CONTEXT_IDS","getContext","attributes","BufferUsage","WebGLArrayBuffer","usage","getArrayClassForType","ArrayType","bindAndConfigure","gl","texture","resampleFilter","uploadImageTexture","uploadDataTexture","textureType","canInterpolate","unpackAlignment","oldUnpackAlignment","pixelContext","createPixelContext","TileTexture","textureCount","textureDataArrays","textureIndex","dataValue","textureData","textureBandIndex","renderCol","renderRow","renderWidth","renderHeight","sourceWidth","sourceHeight","sourceWidthWithoutGutter","sourceHeightWithoutGutter","sourceCol","sourceRow","sourceSize","maxStaleKeys","LayerRenderer","layer","hitTolerance","matches","imageState","RenderEvent","inversePixelTransform","ContextEventType","DEFAULT_VERTEX_SHADER","DEFAULT_FRAGMENT_SHADER","WebGLPostProcessingPass","vertexShader","fragmentShader","verticesArray","internalFormat","border","nextPass","preCompose","postCompose","canvasId","textureSlot","uniform","fromTransform","mat4","DefaultUniform","AttributeType","canvasCache","getSharedCanvasCacheKey","uniqueCanvasCacheKeyCount","getUniqueCanvasCacheKey","getOrCreateContext","cacheItem","WebGLHelper","uniforms","canvasCacheKey","bufferKey","bufferCache","webGlBuffer","buf","disableAlphaBlend","enableDepth","frameBuffer","slot","uniformName","renderTarget","elementType","elementSize","numItems","offsetInBytes","loc","imageReady","program","shader","fragmentShaderSource","vertexShaderSource","programUid","attribName","computeAttributesStride","attr","getByteSizeFromType","filter","WebGLLayerRenderer","incrementGroup","groupNumber","className","renderer","layerClassName","Uniforms","empty","depthForZ","newTileRepresentationLookup","lookupHasTile","tileRepresentationLookup","addTileRepresentationToLookup","tileRepresentation","representationsByZ","getRenderExtent","gridExtent","getCacheKey","getTileCoordKey","WebGLBaseTileLayerRenderer","tileLayer","createMat4","createTileCoord","initialZ","tileSource","tileSourceKey","wantedTiles","tileRepresentationCache","minZ","tileResolution","cacheKey","tileQueueKey","tilesWithAlpha","tileTransform","renderExtent","tileOrigin","tileExtent","depth","alpha","tileZ","alphaLookup","tileWidthWithGutter","tileHeightWithGutter","centerI","centerJ","tileScale","tileCenterI","tileCenterJ","resetTransform","scaleTransform","rotateTransform","translateTransform","targetZ","nextExtent","blend","parentZ","zs","postRenderFunction","altZ","covered","BaseUniforms","Attributes","attributeDescriptions","WebGLTileLayerRenderer","paletteTexture","tileTexture","paletteIndex","mat4FromTransform","gutterExtent","tileTextureCache","col","row","rgb","xyz","_xyz","white","luv","arg","_u","_v","u","v","xn","yn","zn","un","vn","yr","hr","names","baseHues","parse","cstr","parts","space","base","isShort","dims","_b","hsl","t1","t2","t3","rgba","color","parsed","NO_COLOR","MAX_CACHE_SIZE","fromString","parseRgba","asArray","numTypes","BooleanType","NumberType","StringType","ColorType","NumberArrayType","SizeType","AnyType","typeNames","namedTypes","isSpecific","typeName","namedType","includesType","broad","specific","isType","LiteralExpression","CallExpression","operator","newParsingContext","encoded","expectedType","colorFromString","parseCallExpression","Ops","parsers","createCallExpressionParser","hasArgsCount","withGetArgs","withVarArgs","usesFeatureId","withNoArgs","withArgsOfType","usesGeometryType","withArgsOfReturnType","hasEvenArgs","withMatchArgs","withInterpolateArgs","hasOddArgs","withCaseArgs","withInArgs","withPaletteArgs","returnType","argsCount","operation","minArgs","maxArgs","argCount","plural","range","expression","argType","inputType","fallback","interpolationType","interpolation","stop","condition","haystack","needleType","colors","parsedColors","validators","parser","computeGeometryType","PaletteTexture","computeOperatorFunctionName","numberToGlsl","arrayToGlsl","colorToGlsl","sizeToGlsl","stringToFloatMap","stringToFloatCounter","getStringNumberEquivalent","stringToGlsl","uniformNameForVariable","variableName","newCompilationContext","GET_BAND_VALUE_FUNC","PALETTE_TEXTURE_ARRAY","buildExpression","parsingContext","compilationContext","compile","createCompiler","compilers","propName","feature","varName","compiledArgs","firstValue","secondValue","exponent","stop1","output1","stop2","output2","needle","funcName","tests","band","xOffset","yOffset","ifBlocks","colorIndex","textureName","numColors","palette","parsedValue","paletteName","compiledIndex","compiler","expressionToGlsl","parseStyle","style","pipeline","contrast","exposure","saturation","gamma","brightness","numVariables","variable","uniformDeclarations","functionDefintions","WebGLTileLayer","parsedStyle","ready","sourceState","onChange","altSources","variables","TileLayer","handlerColor","legend","scala","radio","color1","resultArray","value1","getLayerStyle","bandsNumber","value2","n1","colorGradient","mergeObjects","obj1","obj2","mergedObj","prop","getWindSpeedAndDirection","speed","dir","parseXML","xmlString","itemElements","parsedData","cme_GeoTIFFSource","xmlDataStr","datas","list","minValue","maxValue","metadata_","normalize_","nodataValues_","addAlpha_","extent_","code_","cme_cogtifLayer2","parfams","that","sourceObj","viewConfig","metas","unit","newStyle","_style","worldNumber","mixLng","maxLng","sourceOpitions","newKey","sourceCollection","ZIndexContext","__publicField","instructionsAtIndex","instructionAtIndex","CanvasLayerRenderer","backgroundColor","container","topLeft","topRight","bottomRight","bottomLeft","inverted","canvasTransform","toTransformString","fromResolutionLike","ReprojImage","getImageFunction","sourceImage","sourcePixelRatio","ImageSourceEventType","ImageSourceEvent","ImageSource","idx","requestExtent","getRequestExtent","imageResolution","marginWidth","requestWidth","marginHeight","requestHeight","ImageCanvas","ImageCanvasSource","canvasElement","BaseImageLayer","CanvasImageLayerRenderer","imageLayer","viewResolution","imageSource","renderedExtent","imageExtent","imageMapWidth","imageMapHeight","imageResolutionX","imageResolutionY","imagePixelRatio","viewCenter","scaleX","scaleY","clipped","intersectsExtent","dw","dh","ImageLayer","ImageLayer$1","getCanvasExtent","xmin","ymin","newExtent","mergeObject","object1","object2","isInExtent","p","getGridPoints","distance","outExtent","xyList","xMin","yMin","xMax","yMax","gridNumberSource","unitList","inRange","distanceArrow","fixedPixel","showTextRange","precision","_precision","rawResolution","_bandCount","textSymbol","mapProject","projCode","offsetNumber","_scale","drawNum","xPixel","yPixel","cme_gridValueLayer","tempStyle","tempObject","styleobject","_sfc_main","defineComponent","mapRef","layerRef","CogTifInfo","addLayer","config","meta","addTextLayer","lyr","getData","configUnit","removeLayer","GridRender","Vue"],"mappings":"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EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA;AAAA,EAGR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA;AAAA,EAGR,KAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA,EACR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA;AAAA,EAGR,OAAQ;AACV,GAEaC,KAAY,CAAA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","x_google_ignoreList":[51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,78,79,80,81,127,128,129,130,131,132,133,134]}