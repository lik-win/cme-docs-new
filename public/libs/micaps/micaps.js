var D6 = Object.defineProperty;
var F6 = (r, t, e) => t in r ? D6(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var fb = (r, t, e) => F6(r, typeof t != "symbol" ? t + "" : t, e);
var lb = Hc;
(function(r, t) {
  for (var e = Hc, n = r(); ; )
    try {
      var i = parseInt(e(274)) / 1 * (parseInt(e(286)) / 2) + -parseInt(e(283)) / 3 + parseInt(e(284)) / 4 + parseInt(e(285)) / 5 * (parseInt(e(278)) / 6) + parseInt(e(272)) / 7 + -parseInt(e(277)) / 8 * (parseInt(e(275)) / 9) + parseInt(e(282)) / 10 * (-parseInt(e(287)) / 11);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Jh, 558884);
class Oo {
  constructor(t) {
    var e = Hc;
    this[e(271)], this[e(273)], this[e(281)] = t, this[e(279)] = null;
  }
  [lb(280)]() {
    var t = lb;
    this[t(273)] = !0;
  }
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
function Hc(r, t) {
  var e = Jh();
  return Hc = function(n, i) {
    n = n - 271;
    var s = e[n];
    return s;
  }, Hc(r, t);
}
function Jh() {
  var r = ["defaultPrevented", "844204QqqHrq", "115677ephZTx", "stopPropagation", "8btLpav", "18QAohsA", "target", "preventDefault", "type", "30YINdSj", "2529357BazfdS", "2767268zLWRpK", "158005AAdBdd", "2IYAIFP", "3144955WpZdyT", "propagationStopped", "4492229HxjnJF"];
  return Jh = function() {
    return r;
  }, Jh();
}
function Zh() {
  var r = ["1mpzvJL", "1856194eulfNi", "12932262NfLNjN", "289854Ulswmt", "9681865UvYiRV", "8376360DsIMJt", "propertychange", "344qqwqpU", "4702101KbXjuY", "25256210uXhbou", "4pDOLWj"];
  return Zh = function() {
    return r;
  }, Zh();
}
function Kh(r, t) {
  var e = Zh();
  return Kh = function(n, i) {
    n = n - 476;
    var s = e[n];
    return s;
  }, Kh(r, t);
}
var k6 = Kh;
(function(r, t) {
  for (var e = Kh, n = r(); ; )
    try {
      var i = -parseInt(e(481)) / 1 * (parseInt(e(482)) / 2) + parseInt(e(478)) / 3 + parseInt(e(480)) / 4 * (parseInt(e(485)) / 5) + parseInt(e(486)) / 6 + -parseInt(e(483)) / 7 + parseInt(e(477)) / 8 * (parseInt(e(484)) / 9) + -parseInt(e(479)) / 10;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Zh, 983474);
const K3 = { PROPERTYCHANGE: k6(476) };
function nx(r, t) {
  var e = jh();
  return nx = function(n, i) {
    n = n - 157;
    var s = e[n];
    return s;
  }, nx(r, t);
}
var B6 = nx;
(function(r, t) {
  for (var e = nx, n = r(); ; )
    try {
      var i = -parseInt(e(162)) / 1 * (parseInt(e(166)) / 2) + -parseInt(e(163)) / 3 + -parseInt(e(165)) / 4 * (parseInt(e(158)) / 5) + -parseInt(e(168)) / 6 * (-parseInt(e(169)) / 7) + parseInt(e(161)) / 8 * (-parseInt(e(159)) / 9) + -parseInt(e(157)) / 10 + parseInt(e(164)) / 11;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(jh, 996600);
function jh() {
  var r = ["disposeInternal", "7245128TFqPua", "547bdrwbr", "585291jbBIOh", "33064790GvFtUc", "3012320tqquYG", "36uRtfQb", "disposed", "222vYYFJB", "215593pvykOk", "3795480liYAvw", "5vwXcPo", "18BtYKJY"];
  return jh = function() {
    return r;
  }, jh();
}
class G6 {
  constructor() {
    var t = nx;
    this[t(167)] = !1;
  }
  dispose() {
    var t = nx;
    !this[t(167)] && (this.disposed = !0, this.disposeInternal());
  }
  [B6(160)]() {
  }
}
(function(r, t) {
  const e = rx, n = r();
  for (; ; )
    try {
      if (parseInt(e(117)) / 1 * (-parseInt(e(104)) / 2) + parseInt(e(105)) / 3 + parseInt(e(113)) / 4 + -parseInt(e(109)) / 5 + parseInt(e(115)) / 6 * (-parseInt(e(116)) / 7) + -parseInt(e(106)) / 8 + parseInt(e(110)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Qh, 496831);
function Y6(r, t, e) {
  const n = rx;
  let i, s;
  e = e || P0;
  let o = 0, a = r[n(107)], u = !1;
  for (; o < a; )
    i = o + (a - o >> 1), s = +e(r[i], t), s < 0 ? o = i + 1 : (a = i, u = !s);
  return u ? o : ~o;
}
function P0(r, t) {
  return r > t ? 1 : r < t ? -1 : 0;
}
function Qh() {
  const r = ["index", "307596bOjfSS", "28EyHmZU", "34OaVFwh", "18548gjlejQ", "2445417XwhqJq", "7273680sboifQ", "length", "every", "889100xDhsKa", "10524303fWMjBr", "value", "function", "478940mHWmKr"];
  return Qh = function() {
    return r;
  }, Qh();
}
function j3(r, t, e) {
  const n = rx;
  if (r[0] <= t) return 0;
  const i = r[n(107)];
  if (t <= r[i - 1]) return i - 1;
  if (typeof e === n(112)) {
    for (let s = 1; s < i; ++s) {
      const o = r[s];
      if (o === t) return s;
      if (o < t)
        return e(t, r[s - 1], o) > 0 ? s - 1 : s;
    }
    return i - 1;
  }
  if (e > 0) {
    for (let s = 1; s < i; ++s)
      if (r[s] < t) return s - 1;
    return i - 1;
  }
  if (e < 0) {
    for (let s = 1; s < i; ++s)
      if (r[s] <= t) return s;
    return i - 1;
  }
  for (let s = 1; s < i; ++s) {
    if (r[s] == t) return s;
    if (r[s] < t)
      return r[s - 1] - t < t - r[s] ? s - 1 : s;
  }
  return i - 1;
}
function X6(r, t, e) {
  for (; t < e; ) {
    const n = r[t];
    r[t] = r[e], r[e] = n, ++t, --e;
  }
}
function ds(r, t) {
  const e = Array.isArray(t) ? t : [t], n = e.length;
  for (let i = 0; i < n; i++)
    r[r.length] = e[i];
}
function uu(r, t) {
  const e = rx, n = r[e(107)];
  if (n !== t[e(107)]) return !1;
  for (let i = 0; i < n; i++)
    if (r[i] !== t[i]) return !1;
  return !0;
}
function rx(r, t) {
  const e = Qh();
  return rx = function(n, i) {
    return n = n - 104, e[n];
  }, rx(r, t);
}
(function(r, t) {
  const e = Jc, n = r();
  for (; ; )
    try {
      if (parseInt(e(233)) / 1 * (-parseInt(e(238)) / 2) + -parseInt(e(229)) / 3 + parseInt(e(232)) / 4 + parseInt(e(240)) / 5 + parseInt(e(235)) / 6 + -parseInt(e(239)) / 7 * (parseInt(e(236)) / 8) + -parseInt(e(237)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})($h, 356918);
function ix() {
  return !0;
}
function x_() {
  return !1;
}
function Jc(r, t) {
  const e = $h();
  return Jc = function(n, i) {
    return n = n - 226, e[n];
  }, Jc(r, t);
}
function $h() {
  const r = ["244424jbynJP", "5499450jZOddN", "110300MkqKdh", "49YwoWjW", "1428450YptOHr", "reject", "slice", "resolve", "394101EKgeyc", "apply", "prototype", "2530148SYnYMy", "2VvPAwV", "call", "3031674WQebLs"];
  return $h = function() {
    return r;
  }, $h();
}
function Zc() {
}
function Q3(r) {
  let t, e, n;
  return function() {
    const i = Jc, s = Array[i(231)][i(227)][i(234)](arguments);
    return (!e || this !== n || !uu(s, e)) && (n = this, e = s, t = r[i(230)](this, arguments)), t;
  };
}
function q6(r) {
  function t() {
    const e = Jc;
    let n;
    try {
      n = r();
    } catch (i) {
      return Promise[e(226)](i);
    }
    return n instanceof Promise ? n : Promise[e(228)](n);
  }
  return t();
}
function ly(r) {
  for (const t in r)
    delete r[t];
}
function sx(r) {
  let t;
  for (t in r)
    return !1;
  return !t;
}
function t1() {
  const r = ["eventTarget_", "715218IwidvJ", "9833740wLUBEN", "splice", "removeEventListener", "dispatchEvent", "string", "175647nCiTst", "dispatching_", "target", "type", "disposeInternal", "hasListener", "4JayOVY", "5728MQKvms", "getListeners", "addEventListener", "16sWsfzO", "2201715pfCDak", "270iWpgtj", "propagationStopped", "call", "listeners_", "length", "2098425vkHvzv", "pendingRemovals_", "120093aiNzYh", "push", "handleEvent", "keys"];
  return t1 = function() {
    return r;
  }, t1();
}
function Kc(r, t) {
  const e = t1();
  return Kc = function(n, i) {
    return n = n - 208, e[n];
  }, Kc(r, t);
}
const is = Kc;
(function(r, t) {
  const e = Kc, n = r();
  for (; ; )
    try {
      if (-parseInt(e(221)) / 1 + -parseInt(e(231)) / 2 * (parseInt(e(210)) / 3) + -parseInt(e(227)) / 4 * (parseInt(e(232)) / 5) + -parseInt(e(215)) / 6 + parseInt(e(208)) / 7 + parseInt(e(228)) / 8 * (parseInt(e(233)) / 9) + parseInt(e(216)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(t1, 249188);
class c_ extends G6 {
  constructor(t) {
    const e = Kc;
    super(), this.eventTarget_ = t, this[e(209)] = null, this[e(222)] = null, this[e(236)] = null;
  }
  [is(230)](t, e) {
    const n = is;
    if (!t || !e) return;
    const i = this.listeners_ || (this.listeners_ = {}), s = i[t] || (i[t] = []);
    !s.includes(e) && s[n(211)](e);
  }
  [is(219)](t) {
    const e = is, n = typeof t === e(220), i = n ? t : t[e(224)], s = this[e(236)] && this[e(236)][i];
    if (!s) return;
    const o = n ? new Oo(t) : t;
    !o.target && (o[e(223)] = this[e(214)] || this);
    const a = this[e(222)] || (this[e(222)] = {}), u = this[e(209)] || (this[e(209)] = {});
    !(i in a) && (a[i] = 0, u[i] = 0), ++a[i];
    let x;
    for (let c = 0, f = s[e(237)]; c < f; ++c)
      if (e(212) in s[c] ? x = s[c][e(212)](o) : x = s[c][e(235)](this, o), x === !1 || o[e(234)]) {
        x = !1;
        break;
      }
    if (--a[i] === 0) {
      let c = u[i];
      for (delete u[i]; c--; )
        this[e(218)](i, Zc);
      delete a[i];
    }
    return x;
  }
  [is(225)]() {
    const t = is;
    this[t(236)] && ly(this[t(236)]);
  }
  [is(229)](t) {
    const e = is;
    return this[e(236)] && this[e(236)][t] || void 0;
  }
  [is(226)](t) {
    const e = is;
    return this[e(236)] ? t ? t in this[e(236)] : Object[e(213)](this[e(236)])[e(237)] > 0 : !1;
  }
  [is(218)](t, e) {
    const n = is;
    if (!this[n(236)]) return;
    const i = this[n(236)][t];
    if (!i) return;
    const s = i.indexOf(e);
    s !== -1 && (this[n(209)] && t in this[n(209)] ? (i[s] = Zc, ++this[n(209)][t]) : (i[n(217)](s, 1), i.length === 0 && delete this[n(236)][t]));
  }
}
function e1(r, t) {
  var e = n1();
  return e1 = function(n, i) {
    n = n - 303;
    var s = e[n];
    return s;
  }, e1(r, t);
}
var Di = e1;
(function(r, t) {
  for (var e = e1, n = r(); ; )
    try {
      var i = parseInt(e(315)) / 1 * (-parseInt(e(325)) / 2) + parseInt(e(310)) / 3 * (-parseInt(e(304)) / 4) + -parseInt(e(307)) / 5 + parseInt(e(311)) / 6 * (-parseInt(e(312)) / 7) + -parseInt(e(303)) / 8 + parseInt(e(319)) / 9 * (parseInt(e(308)) / 10) + parseInt(e(326)) / 11;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(n1, 743320);
const rr = { CHANGE: Di(314), ERROR: Di(316), BLUR: "blur", CLEAR: Di(306), CONTEXTMENU: Di(323), CLICK: "click", DBLCLICK: Di(324), DRAGENTER: Di(305), DRAGOVER: Di(320), DROP: Di(318), FOCUS: "focus", KEYDOWN: Di(309), KEYPRESS: Di(313), LOAD: Di(322), RESIZE: Di(321), TOUCHMOVE: Di(317), WHEEL: "wheel" };
function n1() {
  var r = ["900270THuLYR", "keydown", "128487eNpuyN", "7566lzcoAa", "63TgDdtG", "keypress", "change", "529472vsexOx", "error", "touchmove", "drop", "81tXdTVp", "dragover", "resize", "load", "contextmenu", "dblclick", "4JJZIRx", "32286727LdJVTR", "2798440QddHcD", "84iaxezr", "dragenter", "clear", "3412865TAfnQx"];
  return n1 = function() {
    return r;
  }, n1();
}
(function(r, t) {
  const e = ox, n = r();
  for (; ; )
    try {
      if (-parseInt(e(138)) / 1 * (parseInt(e(134)) / 2) + -parseInt(e(137)) / 3 * (parseInt(e(129)) / 4) + parseInt(e(130)) / 5 + -parseInt(e(125)) / 6 + parseInt(e(141)) / 7 * (-parseInt(e(135)) / 8) + parseInt(e(131)) / 9 * (-parseInt(e(143)) / 10) + -parseInt(e(142)) / 11 * (-parseInt(e(128)) / 12) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(r1, 880289);
function ox(r, t) {
  const e = r1();
  return ox = function(n, i) {
    return n = n - 125, e[n];
  }, ox(r, t);
}
function r1() {
  const r = ["removeEventListener", "155820sUHxwP", "97DWatbj", "addEventListener", "type", "1255058XosASI", "72303jtyYSC", "480aTyOGF", "2308326CZNMEQ", "bind", "target", "6972OkDbqA", "52qirbfl", "8134405RVzpwR", "310887dXtLxe", "apply", "listener", "34396kyrvda", "8HDGzcl"];
  return r1 = function() {
    return r;
  }, r1();
}
function ii(r, t, e, n, i) {
  const s = ox;
  if (i) {
    const a = e;
    e = function() {
      const u = ox;
      r[u(136)](t, e), a[u(132)](n ?? this, arguments);
    };
  } else n && n !== r && (e = e[s(126)](n));
  const o = { target: r, type: t, listener: e };
  return r[s(139)](t, e), o;
}
function hb(r, t, e, n) {
  return ii(r, t, e, n, !0);
}
function gs(r) {
  const t = ox;
  r && r.target && (r[t(127)][t(136)](r[t(140)], r[t(133)]), ly(r));
}
const co = ax;
(function(r, t) {
  const e = ax, n = r();
  for (; ; )
    try {
      if (parseInt(e(308)) / 1 + parseInt(e(310)) / 2 + parseInt(e(314)) / 3 * (parseInt(e(295)) / 4) + -parseInt(e(297)) / 5 + -parseInt(e(304)) / 6 + parseInt(e(300)) / 7 * (-parseInt(e(303)) / 8) + parseInt(e(309)) / 9 * (parseInt(e(302)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(i1, 902473);
class Xc extends c_ {
  constructor() {
    const t = ax;
    super(), this.on = this[t(311)], this.once = this.onceInternal, this.un = this[t(298)], this[t(313)] = 0;
  }
  changed() {
    const t = ax;
    ++this[t(313)], this[t(301)](rr[t(296)]);
  }
  [co(312)]() {
    return this[co(313)];
  }
  [co(311)](t, e) {
    const n = co;
    if (Array[n(293)](t)) {
      const i = t[n(305)], s = new Array(i);
      for (let o = 0; o < i; ++o)
        s[o] = ii(this, t[o], e);
      return s;
    }
    return ii(this, t, e);
  }
  [co(306)](t, e) {
    const n = co;
    let i;
    if (Array[n(293)](t)) {
      const s = t[n(305)];
      i = new Array(s);
      for (let o = 0; o < s; ++o)
        i[o] = hb(this, t[o], e);
    } else i = hb(this, t, e);
    return e.ol_key = i, i;
  }
  [co(298)](t, e) {
    const n = co, i = e[n(307)];
    if (i) qc(i);
    else if (Array[n(293)](t)) for (let s = 0, o = t[n(305)]; s < o; ++s)
      this[n(294)](t[s], e);
    else this[n(294)](t, e);
  }
}
Xc.prototype.on, Xc.prototype[co(299)], Xc.prototype.un;
function ax(r, t) {
  const e = i1();
  return ax = function(n, i) {
    return n = n - 293, e[n];
  }, ax(r, t);
}
function qc(r) {
  const t = co;
  if (Array.isArray(r)) for (let e = 0, n = r[t(305)]; e < n; ++e)
    gs(r[e]);
  else gs(r);
}
function i1() {
  const r = ["1027980xEFIkP", "length", "onceInternal", "ol_key", "663452vDYhsB", "9zSMxhk", "934028HkhJXq", "onInternal", "getRevision", "revision_", "3jToVru", "isArray", "removeEventListener", "1407496uNfxXV", "CHANGE", "4300260YbMpuz", "unInternal", "once", "7vIrmKF", "dispatchEvent", "11360530QDzpgN", "5476304HEZgNV"];
  return i1 = function() {
    return r;
  }, i1();
}
const z6 = ux;
function ux(r, t) {
  const e = s1();
  return ux = function(n, i) {
    return n = n - 249, e[n];
  }, ux(r, t);
}
(function(r, t) {
  const e = ux, n = r();
  for (; ; )
    try {
      if (parseInt(e(259)) / 1 + -parseInt(e(256)) / 2 * (parseInt(e(254)) / 3) + -parseInt(e(255)) / 4 * (parseInt(e(260)) / 5) + parseInt(e(249)) / 6 + -parseInt(e(251)) / 7 * (parseInt(e(253)) / 8) + -parseInt(e(257)) / 9 + parseInt(e(258)) / 10 * (parseInt(e(252)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(s1, 858672);
function qe() {
  const r = ux;
  throw new Error(r(250));
}
let U6 = 0;
function ve(r) {
  const t = ux;
  return r[t(262)] || (r[t(262)] = String(++U6));
}
z6(261);
function s1() {
  const r = ["8789143MpUvfg", "24gCnLLo", "72495aqRVod", "360QhrCMh", "2rrmruZ", "4628232WEdwnv", "20mpJEhM", "797026usxyzh", "78140TFoGoy", "10.1.0-dev", "ol_uid", "8199636AcLupi", "Unimplemented abstract method.", "2235457yAPaFa"];
  return s1 = function() {
    return r;
  }, s1();
}
const fr = xx;
(function(r, t) {
  const e = xx, n = r();
  for (; ; )
    try {
      if (-parseInt(e(472)) / 1 * (-parseInt(e(474)) / 2) + parseInt(e(489)) / 3 + -parseInt(e(484)) / 4 * (-parseInt(e(486)) / 5) + parseInt(e(469)) / 6 * (-parseInt(e(490)) / 7) + -parseInt(e(473)) / 8 * (parseInt(e(477)) / 9) + parseInt(e(476)) / 10 + -parseInt(e(464)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(o1, 135655);
class pb extends Oo {
  constructor(t, e, n) {
    const i = xx;
    super(t), this[i(475)] = e, this[i(466)] = n;
  }
}
class a0 extends Xc {
  constructor(t) {
    const e = xx;
    super(), this.on, this[e(468)], this.un, ve(this), this.values_ = null, t !== void 0 && this[e(482)](t);
  }
  [fr(480)](t) {
    const e = fr;
    let n;
    return this[e(465)] && this[e(465)].hasOwnProperty(t) && (n = this[e(465)][t]), n;
  }
  getKeys() {
    const t = fr;
    return this[t(465)] && Object[t(463)](this.values_) || [];
  }
  [fr(485)]() {
    const t = fr;
    return this[t(465)] && Object[t(461)]({}, this[t(465)]) || {};
  }
  [fr(483)]() {
    return this.values_;
  }
  hasProperties() {
    return !!this[fr(465)];
  }
  notify(t, e) {
    const n = fr;
    let i;
    i = n(479) + t, this.hasListener(i) && this[n(478)](new pb(i, t, e)), i = K3.PROPERTYCHANGE, this[n(487)](i) && this[n(478)](new pb(i, t, e));
  }
  [fr(467)](t, e) {
    const n = fr;
    this[n(462)](n(479) + t, e);
  }
  removeChangeListener(t, e) {
    const n = fr;
    this[n(481)](n(479) + t, e);
  }
  [fr(488)](t, e, n) {
    const i = fr, s = this[i(465)] || (this[i(465)] = {});
    if (n) s[t] = e;
    else {
      const o = s[t];
      s[t] = e, o !== e && this[i(470)](t, o);
    }
  }
  [fr(482)](t, e) {
    const n = fr;
    for (const i in t)
      this[n(488)](i, t[i], e);
  }
  applyProperties(t) {
    const e = fr;
    t[e(465)] && Object.assign(this[e(465)] || (this[e(465)] = {}), t[e(465)]);
  }
  [fr(471)](t, e) {
    const n = fr;
    if (this[n(465)] && t in this.values_) {
      const i = this[n(465)][t];
      delete this.values_[t], sx(this[n(465)]) && (this[n(465)] = null), !e && this[n(470)](t, i);
    }
  }
}
function xx(r, t) {
  const e = o1();
  return xx = function(n, i) {
    return n = n - 461, e[n];
  }, xx(r, t);
}
function o1() {
  const r = ["change:", "get", "removeEventListener", "setProperties", "getPropertiesInternal", "3748iFSRuL", "getProperties", "80adZChy", "hasListener", "set", "574971omVREi", "1001VYNLsk", "assign", "addEventListener", "keys", "3255571lkSXDD", "values_", "oldValue", "addChangeListener", "once", "1158OSDQrC", "notify", "unset", "261279LVIvmz", "100072OiINnE", "2gmrdLl", "key", "2164490JeGfym", "162LdRqMU", "dispatchEvent"];
  return o1 = function() {
    return r;
  }, o1();
}
var db = u1;
function a1() {
  var r = ["5457985dtKhXM", "3069396uVQlpi", "remove", "1460441QFUbue", "203ZpEUGk", "2aDHtGf", "3675432Igwzew", "71991LQPWlC", "add", "2960VcOfYX", "334578adxgdu", "465309AyQzfo"];
  return a1 = function() {
    return r;
  }, a1();
}
(function(r, t) {
  for (var e = u1, n = r(); ; )
    try {
      var i = -parseInt(e(464)) / 1 + parseInt(e(454)) / 2 * (parseInt(e(460)) / 3) + parseInt(e(462)) / 4 + parseInt(e(461)) / 5 + -parseInt(e(459)) / 6 * (parseInt(e(453)) / 7) + -parseInt(e(455)) / 8 + parseInt(e(456)) / 9 * (parseInt(e(458)) / 10);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(a1, 844756);
function u1(r, t) {
  var e = a1();
  return u1 = function(n, i) {
    n = n - 453;
    var s = e[n];
    return s;
  }, u1(r, t);
}
const _i = { ADD: db(457), REMOVE: db(463) }, tn = x1;
(function(r, t) {
  const e = x1, n = r();
  for (; ; )
    try {
      if (-parseInt(e(489)) / 1 * (-parseInt(e(481)) / 2) + -parseInt(e(492)) / 3 + parseInt(e(459)) / 4 * (parseInt(e(466)) / 5) + parseInt(e(464)) / 6 + -parseInt(e(463)) / 7 * (-parseInt(e(483)) / 8) + parseInt(e(476)) / 9 * (parseInt(e(478)) / 10) + -parseInt(e(465)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(c1, 492242);
function x1(r, t) {
  const e = c1();
  return x1 = function(n, i) {
    return n = n - 459, e[n];
  }, x1(r, t);
}
const gb = { LENGTH: tn(491) };
class oh extends Oo {
  constructor(t, e, n) {
    const i = tn;
    super(t), this[i(494)] = e, this.index = n;
  }
}
let aa = class extends a0 {
  constructor(t, e) {
    const n = tn;
    if (super(), this.on, this[n(484)], this.un, e = e || {}, this[n(461)] = !!e.unique, this[n(479)] = t || [], this.unique_) for (let i = 0, s = this.array_[n(491)]; i < s; ++i)
      this[n(472)](this[n(479)][i], i);
    this.updateLength_();
  }
  [tn(487)]() {
    const t = tn;
    for (; this[t(486)]() > 0; )
      this[t(473)]();
  }
  [tn(462)](t) {
    for (let e = 0, n = t.length; e < n; ++e)
      this.push(t[e]);
    return this;
  }
  [tn(471)](t) {
    const e = tn, n = this.array_;
    for (let i = 0, s = n[e(491)]; i < s; ++i)
      t(n[i], i, n);
  }
  [tn(485)]() {
    return this.array_;
  }
  item(t) {
    return this.array_[t];
  }
  [tn(486)]() {
    const t = tn;
    return this[t(493)](gb[t(467)]);
  }
  [tn(460)](t, e) {
    const n = tn;
    if (t < 0 || t > this[n(486)]()) throw new Error("Index out of bounds: " + t);
    this.unique_ && this[n(472)](e), this[n(479)].splice(t, 0, e), this.updateLength_(), this.dispatchEvent(new oh(_i[n(488)], e, t));
  }
  [tn(473)]() {
    const t = tn;
    return this[t(470)](this[t(486)]() - 1);
  }
  push(t) {
    const e = tn;
    this[e(461)] && this[e(472)](t);
    const n = this.getLength();
    return this[e(460)](n, t), this[e(486)]();
  }
  remove(t) {
    const e = tn, n = this.array_;
    for (let i = 0, s = n[e(491)]; i < s; ++i)
      if (n[i] === t) return this[e(470)](i);
  }
  [tn(470)](t) {
    const e = tn;
    if (t < 0 || t >= this.getLength()) return;
    const n = this.array_[t];
    return this[e(479)][e(474)](t, 1), this[e(475)](), this[e(480)](new oh(_i.REMOVE, n, t)), n;
  }
  [tn(469)](t, e) {
    const n = tn, i = this[n(486)]();
    if (t >= i) {
      this[n(460)](t, e);
      return;
    }
    if (t < 0) throw new Error(n(468) + t);
    this[n(461)] && this.assertUnique_(e, t);
    const s = this[n(479)][t];
    this.array_[t] = e, this[n(480)](new oh(_i[n(482)], s, t)), this[n(480)](new oh(_i[n(488)], e, t));
  }
  [tn(475)]() {
    const t = tn;
    this[t(477)](gb[t(467)], this.array_[t(491)]);
  }
  [tn(472)](t, e) {
    const n = tn;
    for (let i = 0, s = this.array_.length; i < s; ++i)
      if (this[n(479)][i] === t && i !== e) throw new Error(n(490));
  }
};
function c1() {
  const r = ["Index out of bounds: ", "setAt", "removeAt", "forEach", "assertUnique_", "pop", "splice", "updateLength_", "80064PtPNAQ", "set", "920CMDWSO", "array_", "dispatchEvent", "257704ihkLQu", "REMOVE", "8UUzdpy", "once", "getArray", "getLength", "clear", "ADD", "4DKiBBW", "Duplicate item added to a unique collection", "length", "1418682BPNmMN", "get", "element", "10756HDcRnz", "insertAt", "unique_", "extend", "2364726AtEpeZ", "137988BHqMwn", "18821055XeBhMc", "1825AiJKlX", "LENGTH"];
  return c1 = function() {
    return r;
  }, c1();
}
function f1(r, t) {
  var e = l1();
  return f1 = function(n, i) {
    n = n - 457;
    var s = e[n];
    return s;
  }, f1(r, t);
}
function l1() {
  var r = ["33207ciTzdg", "active", "27DWUHYb", "452rXpGWu", "1758804irqePW", "20SHLDyn", "10KVZWMb", "31814772oNbGku", "19948uMVfJs", "79DJgQxf", "993592yYpyaJ", "8467753gejZoT", "11171457HeFItm"];
  return l1 = function() {
    return r;
  }, l1();
}
var V6 = f1;
(function(r, t) {
  for (var e = f1, n = r(); ; )
    try {
      var i = parseInt(e(457)) / 1 * (parseInt(e(469)) / 2) + parseInt(e(461)) / 3 * (-parseInt(e(464)) / 4) + -parseInt(e(466)) / 5 * (parseInt(e(465)) / 6) + parseInt(e(459)) / 7 + parseInt(e(458)) / 8 * (-parseInt(e(463)) / 9) + parseInt(e(467)) / 10 * (-parseInt(e(460)) / 11) + parseInt(e(468)) / 12;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(l1, 837339);
const am = { ACTIVE: V6(462) };
(function(r, t) {
  for (var e = um, n = r(); ; )
    try {
      var i = parseInt(e(336)) / 1 * (-parseInt(e(338)) / 2) + parseInt(e(334)) / 3 * (parseInt(e(342)) / 4) + parseInt(e(333)) / 5 * (parseInt(e(340)) / 6) + -parseInt(e(332)) / 7 * (parseInt(e(341)) / 8) + -parseInt(e(343)) / 9 * (parseInt(e(339)) / 10) + parseInt(e(337)) / 11 + -parseInt(e(344)) / 12 * (-parseInt(e(335)) / 13);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(h1, 753617);
function W6(r) {
  return Math.pow(r, 3);
}
function H6(r) {
  return 1 - W6(1 - r);
}
function um(r, t) {
  var e = h1();
  return um = function(n, i) {
    n = n - 332;
    var s = e[n];
    return s;
  }, um(r, t);
}
function J6(r) {
  return 3 * r * r - 2 * r * r * r;
}
function h1() {
  var r = ["668481uKaIDv", "22030DefJfV", "4891030CLQtmc", "24vQZCPD", "200104lpHutC", "4HGKmWy", "27RlzxWo", "7465908ipjHYb", "28XxoDOT", "1656285bvfZXE", "1401690GbFxnY", "13cwSzGX", "14yOSrqd"];
  return h1 = function() {
    return r;
  }, h1();
}
function jc(r, t) {
  const e = p1();
  return jc = function(n, i) {
    return n = n - 307, e[n];
  }, jc(r, t);
}
const Ea = jc;
(function(r, t) {
  const e = jc, n = r();
  for (; ; )
    try {
      if (parseInt(e(310)) / 1 + parseInt(e(329)) / 2 * (parseInt(e(318)) / 3) + -parseInt(e(330)) / 4 * (parseInt(e(316)) / 5) + parseInt(e(313)) / 6 * (-parseInt(e(314)) / 7) + parseInt(e(327)) / 8 + parseInt(e(319)) / 9 + -parseInt(e(311)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(p1, 633251);
class hy extends a0 {
  constructor(t) {
    const e = jc;
    super(), this.on, this[e(308)], this.un, t && t[e(317)] && (this[e(317)] = t[e(317)]), this.map_ = null, this[e(320)](!0);
  }
  [Ea(321)]() {
    return this[Ea(323)](am.ACTIVE);
  }
  [Ea(325)]() {
    return this[Ea(322)];
  }
  handleEvent(t) {
    return !0;
  }
  [Ea(320)](t) {
    const e = Ea;
    this.set(am[e(315)], t);
  }
  [Ea(326)](t) {
    const e = Ea;
    this[e(322)] = t;
  }
}
function p1() {
  const r = ["19133940ZFnPOX", "getZoom", "35322LiXzQX", "427LeCcwQ", "ACTIVE", "3501235EBuhsH", "handleEvent", "3BVIdYw", "10886931TmhbJU", "setActive", "getActive", "map_", "get", "animateInternal", "getMap", "setMap", "9402152xsrlzc", "getCenterInternal", "2180938WgVrMM", "4qJmifj", "animate", "getResolutionForZoom", "once", "cancelAnimations", "130602VQtMYV"];
  return p1 = function() {
    return r;
  }, p1();
}
function $3(r, t, e = 0, n = r.length - 1, i = Z6) {
  for (; n > e; ) {
    if (n - e > 600) {
      const u = n - e + 1, x = t - e + 1, c = Math.log(u), f = 0.5 * Math.exp(2 * c / 3), l = 0.5 * Math.sqrt(c * f * (u - f) / u) * (x - u / 2 < 0 ? -1 : 1), h = Math.max(e, Math.floor(t - x * f / u + l)), p = Math.min(n, Math.floor(t + (u - x) * f / u + l));
      $3(r, t, h, p, i);
    }
    const s = r[t];
    let o = e, a = n;
    for (dc(r, e, t), i(r[n], s) > 0 && dc(r, e, n); o < a; ) {
      for (dc(r, o, a), o++, a--; i(r[o], s) < 0; ) o++;
      for (; i(r[a], s) > 0; ) a--;
    }
    i(r[e], s) === 0 ? dc(r, e, a) : (a++, dc(r, a, n)), a <= t && (e = a + 1), t <= a && (n = a - 1);
  }
}
function dc(r, t, e) {
  const n = r[t];
  r[t] = r[e], r[e] = n;
}
function Z6(r, t) {
  return r < t ? -1 : r > t ? 1 : 0;
}
let t4 = class {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let e = this.data;
    const n = [];
    if (!uh(t, e)) return n;
    const i = this.toBBox, s = [];
    for (; e; ) {
      for (let o = 0; o < e.children.length; o++) {
        const a = e.children[o], u = e.leaf ? i(a) : a;
        uh(t, u) && (e.leaf ? n.push(a) : cv(t, u) ? this._all(a, n) : s.push(a));
      }
      e = s.pop();
    }
    return n;
  }
  collides(t) {
    let e = this.data;
    if (!uh(t, e)) return !1;
    const n = [];
    for (; e; ) {
      for (let i = 0; i < e.children.length; i++) {
        const s = e.children[i], o = e.leaf ? this.toBBox(s) : s;
        if (uh(t, o)) {
          if (e.leaf || cv(t, o)) return !0;
          n.push(s);
        }
      }
      e = n.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let n = 0; n < t.length; n++)
        this.insert(t[n]);
      return this;
    }
    let e = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = e;
    else if (this.data.height === e.height)
      this._splitRoot(this.data, e);
    else {
      if (this.data.height < e.height) {
        const n = this.data;
        this.data = e, e = n;
      }
      this._insert(e, this.data.height - e.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = Nu([]), this;
  }
  remove(t, e) {
    if (!t) return this;
    let n = this.data;
    const i = this.toBBox(t), s = [], o = [];
    let a, u, x;
    for (; n || s.length; ) {
      if (n || (n = s.pop(), u = s[s.length - 1], a = o.pop(), x = !0), n.leaf) {
        const c = K6(t, n.children, e);
        if (c !== -1)
          return n.children.splice(c, 1), s.push(n), this._condense(s), this;
      }
      !x && !n.leaf && cv(n, i) ? (s.push(n), o.push(a), a = 0, u = n, n = n.children[0]) : u ? (a++, n = u.children[a], x = !1) : n = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, e) {
    return t.minX - e.minX;
  }
  compareMinY(t, e) {
    return t.minY - e.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, e) {
    const n = [];
    for (; t; )
      t.leaf ? e.push(...t.children) : n.push(...t.children), t = n.pop();
    return e;
  }
  _build(t, e, n, i) {
    const s = n - e + 1;
    let o = this._maxEntries, a;
    if (s <= o)
      return a = Nu(t.slice(e, n + 1)), gu(a, this.toBBox), a;
    i || (i = Math.ceil(Math.log(s) / Math.log(o)), o = Math.ceil(s / Math.pow(o, i - 1))), a = Nu([]), a.leaf = !1, a.height = i;
    const u = Math.ceil(s / o), x = u * Math.ceil(Math.sqrt(o));
    yb(t, e, n, x, this.compareMinX);
    for (let c = e; c <= n; c += x) {
      const f = Math.min(c + x - 1, n);
      yb(t, c, f, u, this.compareMinY);
      for (let l = c; l <= f; l += u) {
        const h = Math.min(l + u - 1, f);
        a.children.push(this._build(t, l, h, i - 1));
      }
    }
    return gu(a, this.toBBox), a;
  }
  _chooseSubtree(t, e, n, i) {
    for (; i.push(e), !(e.leaf || i.length - 1 === n); ) {
      let s = 1 / 0, o = 1 / 0, a;
      for (let u = 0; u < e.children.length; u++) {
        const x = e.children[u], c = xv(x), f = $6(t, x) - c;
        f < o ? (o = f, s = c < s ? c : s, a = x) : f === o && c < s && (s = c, a = x);
      }
      e = a || e.children[0];
    }
    return e;
  }
  _insert(t, e, n) {
    const i = n ? t : this.toBBox(t), s = [], o = this._chooseSubtree(i, this.data, e, s);
    for (o.children.push(t), Cc(o, i); e >= 0 && s[e].children.length > this._maxEntries; )
      this._split(s, e), e--;
    this._adjustParentBBoxes(i, s, e);
  }
  // split overflowed node into two
  _split(t, e) {
    const n = t[e], i = n.children.length, s = this._minEntries;
    this._chooseSplitAxis(n, s, i);
    const o = this._chooseSplitIndex(n, s, i), a = Nu(n.children.splice(o, n.children.length - o));
    a.height = n.height, a.leaf = n.leaf, gu(n, this.toBBox), gu(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a);
  }
  _splitRoot(t, e) {
    this.data = Nu([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, gu(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, e, n) {
    let i, s = 1 / 0, o = 1 / 0;
    for (let a = e; a <= n - e; a++) {
      const u = Sc(t, 0, a, this.toBBox), x = Sc(t, a, n, this.toBBox), c = t8(u, x), f = xv(u) + xv(x);
      c < s ? (s = c, i = a, o = f < o ? f : o) : c === s && f < o && (o = f, i = a);
    }
    return i || n - e;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, e, n) {
    const i = t.leaf ? this.compareMinX : j6, s = t.leaf ? this.compareMinY : Q6, o = this._allDistMargin(t, e, n, i), a = this._allDistMargin(t, e, n, s);
    o < a && t.children.sort(i);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, e, n, i) {
    t.children.sort(i);
    const s = this.toBBox, o = Sc(t, 0, e, s), a = Sc(t, n - e, n, s);
    let u = ah(o) + ah(a);
    for (let x = e; x < n - e; x++) {
      const c = t.children[x];
      Cc(o, t.leaf ? s(c) : c), u += ah(o);
    }
    for (let x = n - e - 1; x >= e; x--) {
      const c = t.children[x];
      Cc(a, t.leaf ? s(c) : c), u += ah(a);
    }
    return u;
  }
  _adjustParentBBoxes(t, e, n) {
    for (let i = n; i >= 0; i--)
      Cc(e[i], t);
  }
  _condense(t) {
    for (let e = t.length - 1, n; e >= 0; e--)
      t[e].children.length === 0 ? e > 0 ? (n = t[e - 1].children, n.splice(n.indexOf(t[e]), 1)) : this.clear() : gu(t[e], this.toBBox);
  }
};
function K6(r, t, e) {
  if (!e) return t.indexOf(r);
  for (let n = 0; n < t.length; n++)
    if (e(r, t[n])) return n;
  return -1;
}
function gu(r, t) {
  Sc(r, 0, r.children.length, t, r);
}
function Sc(r, t, e, n, i) {
  i || (i = Nu(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (let s = t; s < e; s++) {
    const o = r.children[s];
    Cc(i, r.leaf ? n(o) : o);
  }
  return i;
}
function Cc(r, t) {
  return r.minX = Math.min(r.minX, t.minX), r.minY = Math.min(r.minY, t.minY), r.maxX = Math.max(r.maxX, t.maxX), r.maxY = Math.max(r.maxY, t.maxY), r;
}
function j6(r, t) {
  return r.minX - t.minX;
}
function Q6(r, t) {
  return r.minY - t.minY;
}
function xv(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function ah(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function $6(r, t) {
  return (Math.max(t.maxX, r.maxX) - Math.min(t.minX, r.minX)) * (Math.max(t.maxY, r.maxY) - Math.min(t.minY, r.minY));
}
function t8(r, t) {
  const e = Math.max(r.minX, t.minX), n = Math.max(r.minY, t.minY), i = Math.min(r.maxX, t.maxX), s = Math.min(r.maxY, t.maxY);
  return Math.max(0, i - e) * Math.max(0, s - n);
}
function cv(r, t) {
  return r.minX <= t.minX && r.minY <= t.minY && t.maxX <= r.maxX && t.maxY <= r.maxY;
}
function uh(r, t) {
  return t.minX <= r.maxX && t.minY <= r.maxY && t.maxX >= r.minX && t.maxY >= r.minY;
}
function Nu(r) {
  return {
    children: r,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function yb(r, t, e, n, i) {
  const s = [t, e];
  for (; s.length; ) {
    if (e = s.pop(), t = s.pop(), e - t <= n) continue;
    const o = t + Math.ceil((e - t) / n / 2) * n;
    $3(r, o, t, e, i), s.push(t, o, o, e);
  }
}
(function(r, t) {
  for (var e = xm, n = r(); ; )
    try {
      var i = -parseInt(e(318)) / 1 * (parseInt(e(317)) / 2) + parseInt(e(315)) / 3 + -parseInt(e(314)) / 4 * (parseInt(e(310)) / 5) + -parseInt(e(319)) / 6 * (parseInt(e(311)) / 7) + -parseInt(e(321)) / 8 * (parseInt(e(309)) / 9) + parseInt(e(316)) / 10 * (-parseInt(e(320)) / 11) + parseInt(e(312)) / 12 * (parseInt(e(313)) / 13);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(d1, 286678);
function d1() {
  var r = ["84ewDGPq", "11AqAKOS", "8mPFXkf", "1191438SZYXwV", "4855FnhIil", "178444DYuSPR", "24lmKNVu", "9637277PorjVQ", "1060zMBeIC", "414837iUlUek", "3773280qKgkXL", "4yjnJOA", "105173GEytmw"];
  return d1 = function() {
    return r;
  }, d1();
}
function xm(r, t) {
  var e = d1();
  return xm = function(n, i) {
    n = n - 309;
    var s = e[n];
    return s;
  }, xm(r, t);
}
const hr = { UNKNOWN: 0, INTERSECTING: 1, ABOVE: 2, RIGHT: 4, BELOW: 8, LEFT: 16 };
(function(r, t) {
  const e = _s, n = r();
  for (; ; )
    try {
      if (-parseInt(e(489)) / 1 + parseInt(e(493)) / 2 + -parseInt(e(470)) / 3 + parseInt(e(488)) / 4 * (-parseInt(e(494)) / 5) + parseInt(e(498)) / 6 * (-parseInt(e(473)) / 7) + -parseInt(e(476)) / 8 * (-parseInt(e(474)) / 9) + parseInt(e(468)) / 10 * (parseInt(e(479)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(g1, 928675);
function di(r) {
  const t = _s, e = Hs();
  for (let n = 0, i = r[t(480)]; n < i; ++n)
    n4(e, r[n]);
  return e;
}
function ec(r, t, e) {
  return e ? (e[0] = r[0] - t, e[1] = r[1] - t, e[2] = r[2] + t, e[3] = r[3] + t, e) : [r[0] - t, r[1] - t, r[2] + t, r[3] + t];
}
function e8(r, t) {
  return r[_s(481)]();
}
function xu(r, t, e) {
  let n, i;
  return t < r[0] ? n = r[0] - t : r[2] < t ? n = t - r[2] : n = 0, e < r[1] ? i = r[1] - e : r[3] < e ? i = e - r[3] : i = 0, n * n + i * i;
}
function cm(r, t) {
  return f_(r, t[0], t[1]);
}
function Fu(r, t) {
  return r[0] <= t[0] && t[2] <= r[2] && r[1] <= t[1] && t[3] <= r[3];
}
function f_(r, t, e) {
  return r[0] <= t && t <= r[2] && r[1] <= e && e <= r[3];
}
function fm(r, t) {
  const e = _s, n = r[0], i = r[1], s = r[2], o = r[3], a = t[0], u = t[1];
  let x = hr[e(477)];
  return a < n ? x = x | hr[e(500)] : a > s && (x = x | hr[e(486)]), u < i ? x = x | hr[e(499)] : u > o && (x = x | hr[e(496)]), x === hr.UNKNOWN && (x = hr[e(469)]), x;
}
function Hs() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function N0(r, t, e, n, i) {
  return i ? (i[0] = r, i[1] = t, i[2] = e, i[3] = n, i) : [r, t, e, n];
}
function l_(r) {
  return N0(1 / 0, 1 / 0, -1 / 0, -1 / 0, r);
}
function zc(r, t) {
  const e = r[0], n = r[1];
  return N0(e, n, e, n, t);
}
function h_(r, t, e, n, i) {
  const s = l_(i);
  return r4(s, r, t, e, n);
}
function e4(r, t) {
  return r[0] == t[0] && r[2] == t[2] && r[1] == t[1] && r[3] == t[3];
}
function kh(r, t) {
  return t[0] < r[0] && (r[0] = t[0]), t[2] > r[2] && (r[2] = t[2]), t[1] < r[1] && (r[1] = t[1]), t[3] > r[3] && (r[3] = t[3]), r;
}
function n4(r, t) {
  t[0] < r[0] && (r[0] = t[0]), t[0] > r[2] && (r[2] = t[0]), t[1] < r[1] && (r[1] = t[1]), t[1] > r[3] && (r[3] = t[1]);
}
function r4(r, t, e, n, i) {
  for (; e < n; e += i)
    n8(r, t[e], t[e + 1]);
  return r;
}
function n8(r, t, e) {
  const n = _s;
  r[0] = Math[n(490)](r[0], t), r[1] = Math.min(r[1], e), r[2] = Math[n(483)](r[2], t), r[3] = Math.max(r[3], e);
}
function i4(r, t) {
  let e;
  return e = t(s4(r)), e || (e = t(o4(r)), e) || (e = t(u4(r)), e) || (e = t(a4(r)), e) ? e : !1;
}
function s4(r) {
  return [r[0], r[1]];
}
function o4(r) {
  return [r[2], r[1]];
}
function ua(r) {
  return [(r[0] + r[2]) / 2, (r[1] + r[3]) / 2];
}
function r8(r, t, e, n, i) {
  const s = _s, [o, a, u, x, c, f, l, h] = i8(r, t, e, n);
  return N0(Math[s(490)](o, u, c, l), Math[s(490)](a, x, f, h), Math[s(483)](o, u, c, l), Math.max(a, x, f, h), i);
}
function i8(r, t, e, n) {
  const i = _s, s = t * n[0] / 2, o = t * n[1] / 2, a = Math[i(485)](e), u = Math[i(475)](e), x = s * a, c = s * u, f = o * a, l = o * u, h = r[0], p = r[1];
  return [h - x + l, p - c - f, h - x - l, p - c + f, h + x - l, p + c + f, h + x + l, p + c - f, h - x + l, p - c - f];
}
function xa(r) {
  return r[3] - r[1];
}
function a4(r) {
  return [r[0], r[3]];
}
function u4(r) {
  return [r[2], r[3]];
}
function vi(r) {
  return r[2] - r[0];
}
function hs(r, t) {
  return r[0] <= t[2] && r[2] >= t[0] && r[1] <= t[3] && r[3] >= t[1];
}
function _s(r, t) {
  const e = g1();
  return _s = function(n, i) {
    return n = n - 468, e[n];
  }, _s(r, t);
}
function x4(r) {
  return r[2] < r[0] || r[3] < r[1];
}
function s8(r, t) {
  return t ? (t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t) : r;
}
function o8(r, t, e) {
  const n = _s;
  let i = !1;
  const s = fm(r, t), o = fm(r, e);
  if (s === hr[n(469)] || o === hr.INTERSECTING) i = !0;
  else {
    const a = r[0], u = r[1], x = r[2], c = r[3], f = t[0], l = t[1], h = e[0], p = e[1], y = (p - l) / (h - f);
    let v, m;
    o & hr[n(496)] && !(s & hr[n(496)]) && (v = h - (p - c) / y, i = v >= a && v <= x), !i && o & hr.RIGHT && !(s & hr[n(486)]) && (m = p - (h - x) * y, i = m >= u && m <= c), !i && o & hr[n(499)] && !(s & hr[n(499)]) && (v = h - (p - u) / y, i = v >= a && v <= x), !i && o & hr[n(500)] && !(s & hr[n(500)]) && (m = p - (h - a) * y, i = m >= u && m <= c);
  }
  return i;
}
function c4(r, t) {
  const e = _s, n = t[e(471)](), i = ua(r);
  if (t[e(497)]() && (i[0] < n[0] || i[0] >= n[2])) {
    const s = vi(n), o = Math[e(487)]((i[0] - n[0]) / s), a = o * s;
    r[0] -= a, r[2] -= a;
  }
  return r;
}
function g1() {
  const r = ["35HZJwxj", "abs", "ABOVE", "canWrapX", "2010mPUFlw", "BELOW", "LEFT", "3810ENuGdg", "INTERSECTING", "5172144LNesfq", "getExtent", "bottom-left", "17563OIwaxQ", "191115pQSJeE", "sin", "392EDYVlL", "UNKNOWN", "top-left", "123783MlIxww", "length", "slice", "bottom-right", "max", "apply", "cos", "RIGHT", "floor", "510652QoMjjk", "1131722bcZLSP", "min", "Invalid corner", "push", "381386IjgZGs"];
  return g1 = function() {
    return r;
  }, g1();
}
function a8(r, t, e) {
  const n = _s;
  if (t[n(497)]()) {
    const i = t[n(471)]();
    if (!isFinite(r[0]) || !isFinite(r[2])) return [[i[0], r[1], i[2], r[3]]];
    c4(r, t);
    const s = vi(i);
    if (vi(r) > s && !e) return [[i[0], r[1], i[2], r[3]]];
    if (r[0] < i[0]) return [[r[0] + s, r[1], i[2], r[3]], [i[0], r[1], r[2], r[3]]];
    if (r[2] > i[2]) return [[r[0], r[1], i[2], r[3]], [i[0], r[1], r[2] - s, r[3]]];
  }
  return [r];
}
const dn = Qc;
(function(r, t) {
  const e = Qc, n = r();
  for (; ; )
    try {
      if (parseInt(e(422)) / 1 + parseInt(e(415)) / 2 + -parseInt(e(418)) / 3 * (parseInt(e(426)) / 4) + -parseInt(e(435)) / 5 * (-parseInt(e(416)) / 6) + parseInt(e(441)) / 7 * (-parseInt(e(420)) / 8) + parseInt(e(436)) / 9 + -parseInt(e(429)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(v1, 834301);
function Qc(r, t) {
  const e = v1();
  return Qc = function(n, i) {
    return n = n - 411, e[n];
  }, Qc(r, t);
}
let y1 = class {
  constructor(t) {
    const e = Qc;
    this[e(419)] = new t4(t), this.items_ = {};
  }
  [dn(437)](t, e) {
    const n = dn, i = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3], value: e };
    this[n(419)][n(437)](i), this.items_[ve(e)] = i;
  }
  [dn(421)](t, e) {
    const n = dn, i = new Array(e[n(432)]);
    for (let s = 0, o = e[n(432)]; s < o; s++) {
      const a = t[s], u = e[s], x = { minX: a[0], minY: a[1], maxX: a[2], maxY: a[3], value: u };
      i[s] = x, this[n(433)][ve(u)] = x;
    }
    this.rbush_.load(i);
  }
  [dn(438)](t) {
    const e = dn, n = ve(t), i = this.items_[n];
    return delete this[e(433)][n], this[e(419)].remove(i) !== null;
  }
  [dn(439)](t, e) {
    const n = dn, i = this.items_[ve(e)], s = [i[n(414)], i[n(428)], i.maxX, i.maxY];
    !e4(s, t) && (this[n(438)](e), this[n(437)](t, e));
  }
  [dn(431)]() {
    const t = dn;
    return this[t(419)][t(427)]()[t(424)](function(n) {
      return n[t(411)];
    });
  }
  [dn(417)](t) {
    const e = dn, n = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3] };
    return this.rbush_[e(430)](n).map(function(s) {
      return s[e(411)];
    });
  }
  [dn(425)](t) {
    const e = dn;
    return this[e(413)](this[e(431)](), t);
  }
  [dn(412)](t, e) {
    const n = dn;
    return this[n(413)](this[n(417)](t), e);
  }
  [dn(413)](t, e) {
    const n = dn;
    let i;
    for (let s = 0, o = t[n(432)]; s < o; s++)
      if (i = e(t[s]), i) return i;
    return i;
  }
  isEmpty() {
    return sx(this[dn(433)]);
  }
  clear() {
    this[dn(419)].clear(), this.items_ = {};
  }
  getExtent(t) {
    const e = dn, n = this[e(419)].toJSON();
    return N0(n[e(414)], n[e(428)], n[e(423)], n[e(440)], t);
  }
  [dn(434)](t) {
    const e = dn;
    this[e(419)].load(t[e(419)][e(427)]());
    for (const n in t[e(433)])
      this[e(433)][n] = t[e(433)][n];
  }
};
function v1() {
  const r = ["300hpHQky", "getInExtent", "120KFzQYX", "rbush_", "84712gyMexv", "load", "1595517cVmwsf", "maxX", "map", "forEach", "128396ygdfYf", "all", "minY", "9022700wPosdY", "search", "getAll", "length", "items_", "concat", "116275FYsOHN", "567414nJaYsl", "insert", "remove", "update", "maxY", "679RizEbJ", "value", "forEachInExtent", "forEach_", "minX", "2452702OOuPrr"];
  return v1 = function() {
    return r;
  }, v1();
}
function dr(r, t) {
  if (!r) throw new Error(t);
}
const Nn = $c;
(function(r, t) {
  const e = $c, n = r();
  for (; ; )
    try {
      if (-parseInt(e(302)) / 1 + parseInt(e(297)) / 2 + parseInt(e(300)) / 3 + parseInt(e(307)) / 4 + parseInt(e(323)) / 5 * (parseInt(e(305)) / 6) + parseInt(e(318)) / 7 * (parseInt(e(292)) / 8) + -parseInt(e(293)) / 9 * (-parseInt(e(321)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(m1, 742989);
function m1() {
  const r = ["CHANGE", "40WRzlgL", "202689MUAqzf", "isArray", "getSimplifiedGeometry", "geometryChangeKey_", "391688KjhDbc", "id_", "changed", "649536IggbuE", "geometry", "1201211aznwUm", "getZIndex", "setGeometry", "6UWFjAR", "styleFunction_", "1807828OIifUO", "getStyleFunction", "removeChangeListener", "getGeometryName", "getStyle", "handleGeometryChange_", "style_", "once", "getId", "Expected an `ol/style/Style` or an array of `ol/style/Style.js`", "handleGeometryChanged_", "996821CXezXZ", "setStyle", "addChangeListener", "130DTkfgA", "set", "375495HQmsJX", "clone", "getProperties", "getGeometry", "function", "geometryName_"];
  return m1 = function() {
    return r;
  }, m1();
}
function $c(r, t) {
  const e = m1();
  return $c = function(n, i) {
    return n = n - 291, e[n];
  }, $c(r, t);
}
class An extends a0 {
  constructor(t) {
    const e = $c;
    if (super(), this.on, this[e(314)], this.un, this[e(298)] = void 0, this[e(328)] = e(301), this[e(313)] = null, this[e(306)] = void 0, this[e(296)] = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t)
      if (typeof t[e(295)] === e(327)) {
        const n = t;
        this.setGeometry(n);
      } else {
        const n = t;
        this.setProperties(n);
      }
  }
  [Nn(324)]() {
    const t = Nn, e = new An(this.hasProperties() ? this[t(325)]() : null);
    e.setGeometryName(this[t(310)]());
    const n = this.getGeometry();
    n && e.setGeometry(n[t(324)]());
    const i = this[t(311)]();
    return i && e[t(319)](i), e;
  }
  [Nn(326)]() {
    return this.get(this.geometryName_);
  }
  [Nn(315)]() {
    return this[Nn(298)];
  }
  [Nn(310)]() {
    return this[Nn(328)];
  }
  [Nn(311)]() {
    return this[Nn(313)];
  }
  [Nn(308)]() {
    return this[Nn(306)];
  }
  [Nn(312)]() {
    this[Nn(299)]();
  }
  [Nn(317)]() {
    const t = Nn;
    this[t(296)] && (gs(this.geometryChangeKey_), this[t(296)] = null);
    const e = this[t(326)]();
    e && (this[t(296)] = ii(e, rr[t(291)], this.handleGeometryChange_, this)), this[t(299)]();
  }
  [Nn(304)](t) {
    const e = Nn;
    this[e(322)](this[e(328)], t);
  }
  [Nn(319)](t) {
    const e = Nn;
    this[e(313)] = t, this[e(306)] = t ? u8(t) : void 0, this[e(299)]();
  }
  setId(t) {
    const e = Nn;
    this[e(298)] = t, this[e(299)]();
  }
  setGeometryName(t) {
    const e = Nn;
    this[e(309)](this[e(328)], this[e(317)]), this.geometryName_ = t, this[e(320)](this[e(328)], this[e(317)]), this[e(317)]();
  }
}
function u8(r) {
  const t = Nn;
  if (typeof r == "function") return r;
  let e;
  return Array[t(294)](r) ? e = r : (dr(typeof r[t(303)] === t(327), t(316)), e = [r]), function() {
    return e;
  };
}
(function(r, t) {
  const e = tf, n = r();
  for (; ; )
    try {
      if (parseInt(e(121)) / 1 * (parseInt(e(129)) / 2) + parseInt(e(113)) / 3 + -parseInt(e(124)) / 4 * (-parseInt(e(122)) / 5) + -parseInt(e(123)) / 6 * (-parseInt(e(120)) / 7) + parseInt(e(119)) / 8 * (-parseInt(e(126)) / 9) + parseInt(e(128)) / 10 * (-parseInt(e(116)) / 11) + -parseInt(e(114)) / 12 * (-parseInt(e(125)) / 13) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(_1, 711876);
new Array(6);
function _1() {
  const r = ["23696xVNlEs", "21IYnDeT", "73174JyGLFH", "4253555orSuUl", "36174TvAtrd", "4uUXJSK", "4345549VuiAVo", "2718PhdlUD", "join", "21740wkVUJx", "16dKjxCK", "matrix(", "3184395tOBHyo", "12Vfqrtz", "round", "6292zHBPho", "sin", "cos"];
  return _1 = function() {
    return r;
  }, _1();
}
function tf(r, t) {
  const e = _1();
  return tf = function(n, i) {
    return n = n - 112, e[n];
  }, tf(r, t);
}
function Qo() {
  return [1, 0, 0, 1, 0, 0];
}
function x8(r, t) {
  return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r;
}
function Gi(r, t) {
  const e = t[0], n = t[1];
  return t[0] = r[0] * e + r[2] * n + r[4], t[1] = r[1] * e + r[3] * n + r[5], t;
}
function O0(r, t, e, n, i, s, o, a) {
  const u = tf, x = Math.sin(s), c = Math[u(118)](s);
  return r[0] = n * c, r[1] = i * x, r[2] = -n * x, r[3] = i * c, r[4] = o * n * c - a * n * x + t, r[5] = o * i * x + a * i * c + e, r;
}
function c8(r, t) {
  const e = f8(t);
  dr(e !== 0, "Transformation matrix cannot be inverted");
  const n = t[0], i = t[1], s = t[2], o = t[3], a = t[4], u = t[5];
  return r[0] = o / e, r[1] = -i / e, r[2] = -s / e, r[3] = n / e, r[4] = (s * u - o * a) / e, r[5] = -(n * u - i * a) / e, r;
}
function f8(r) {
  return r[0] * r[3] - r[1] * r[2];
}
const vb = [1e6, 1e6, 1e6, 1e6, 2, 2];
function l8(r) {
  const t = tf;
  return t(112) + r.map((n, i) => Math[t(115)](n * vb[i]) / vb[i])[t(127)](", ") + ")";
}
const fv = b1;
(function(r, t) {
  const e = b1, n = r();
  for (; ; )
    try {
      if (parseInt(e(199)) / 1 + parseInt(e(202)) / 2 * (-parseInt(e(194)) / 3) + parseInt(e(197)) / 4 + -parseInt(e(198)) / 5 + -parseInt(e(193)) / 6 + -parseInt(e(191)) / 7 * (parseInt(e(196)) / 8) + parseInt(e(192)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(I1, 922758);
fv(200), fv(201), fv(195);
function b1(r, t) {
  const e = I1();
  return b1 = function(n, i) {
    return n = n - 191, e[n];
  }, b1(r, t);
}
function I1() {
  const r = ["20209041fkWhEx", "8045484BPpIqu", "3BZbJDy", "degrees", "8WGcdaE", "7080924oFGWjm", "2795560KXzNbu", "381706rBjrSN", "us-ft", "radians", "291302PnGScw", "10002657rWrvPW"];
  return I1 = function() {
    return r;
  }, I1();
}
const f4 = { radians: 6370997 / (2 * Math.PI), degrees: 2 * Math.PI * 6370997 / 360, ft: 0.3048, m: 1, "us-ft": 1200 / 3937 };
function ef(r, t) {
  var e = w1();
  return ef = function(n, i) {
    n = n - 466;
    var s = e[n];
    return s;
  }, ef(r, t);
}
var an = ef;
function w1() {
  var r = ["getCode", "getAxisOrientation", "canWrapX", "10294544XKfXBC", "axisOrientation_", "axisOrientation", "219934TxmHTY", "6447996OrPCLz", "global_", "code_", "code", "isGlobal", "getUnits", "extent", "getExtent", "enu", "1181036WZEjDQ", "defaultTileGrid_", "getPointResolutionFunc", "4991885vDpfBv", "setWorldExtent", "getPointResolutionFunc_", "setGlobal", "setDefaultTileGrid", "setGetPointResolution", "metersPerUnit_", "units_", "canWrapX_", "getWorldExtent", "1047664XysmDA", "6fJkOkD", "global", "units", "setExtent", "getPointResolution", "8349271ZnTvVg", "worldExtent_", "extent_"];
  return w1 = function() {
    return r;
  }, w1();
}
(function(r, t) {
  for (var e = ef, n = r(); ; )
    try {
      var i = -parseInt(e(501)) / 1 + parseInt(e(478)) / 2 * (-parseInt(e(502)) / 3) + -parseInt(e(488)) / 4 + parseInt(e(491)) / 5 + parseInt(e(479)) / 6 + -parseInt(e(469)) / 7 + parseInt(e(475)) / 8;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(w1, 604251);
class l4 {
  constructor(t) {
    var e = ef;
    this[e(481)] = t[e(482)], this.units_ = t[e(466)], this[e(471)] = t[e(485)] !== void 0 ? t[e(485)] : null, this[e(470)] = t.worldExtent !== void 0 ? t.worldExtent : null, this[e(476)] = t[e(477)] !== void 0 ? t[e(477)] : e(487), this[e(480)] = t.global !== void 0 ? t[e(503)] : !1, this[e(499)] = !!(this[e(480)] && this.extent_), this[e(493)] = t[e(468)], this[e(489)] = null, this[e(497)] = t.metersPerUnit;
  }
  [an(474)]() {
    return this.canWrapX_;
  }
  [an(472)]() {
    var t = an;
    return this[t(481)];
  }
  [an(486)]() {
    var t = an;
    return this[t(471)];
  }
  [an(484)]() {
    return this.units_;
  }
  getMetersPerUnit() {
    var t = an;
    return this[t(497)] || f4[this[t(498)]];
  }
  [an(500)]() {
    var t = an;
    return this[t(470)];
  }
  [an(473)]() {
    var t = an;
    return this[t(476)];
  }
  [an(483)]() {
    return this.global_;
  }
  [an(494)](t) {
    var e = an;
    this[e(480)] = t, this[e(499)] = !!(t && this.extent_);
  }
  getDefaultTileGrid() {
    var t = an;
    return this[t(489)];
  }
  [an(495)](t) {
    var e = an;
    this[e(489)] = t;
  }
  [an(467)](t) {
    var e = an;
    this.extent_ = t, this[e(499)] = !!(this[e(480)] && t);
  }
  [an(492)](t) {
    var e = an;
    this[e(470)] = t;
  }
  [an(496)](t) {
    var e = an;
    this[e(493)] = t;
  }
  [an(490)]() {
    return this.getPointResolutionFunc_;
  }
}
function E1() {
  const r = ["tan", "376409nuQcRG", "EPSG:3857", "2498279BgPOga", "cosh", "554335sfNZJZ", "length", "atan", "993568AaPWRj", "601737mfnFmz", "6eRMgGD", "http://www.opengis.net/def/crs/EPSG/0/3857", "12820vPJKYF", "EPSG:102100", "slice", "log", "exp", "2425248vRAvpc", "2JugKXs", "5292ejnRjD", "http://www.opengis.net/gml/srs/epsg.xml#3857", "EPSG:102113"];
  return E1 = function() {
    return r;
  }, E1();
}
const Ho = nf;
(function(r, t) {
  const e = nf, n = r();
  for (; ; )
    try {
      if (parseInt(e(199)) / 1 + parseInt(e(194)) / 2 * (-parseInt(e(185)) / 3) + parseInt(e(184)) / 4 + -parseInt(e(203)) / 5 + -parseInt(e(186)) / 6 * (-parseInt(e(201)) / 7) + parseInt(e(193)) / 8 + -parseInt(e(195)) / 9 * (parseInt(e(188)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(E1, 219592);
function nf(r, t) {
  const e = E1();
  return nf = function(n, i) {
    return n = n - 183, e[n];
  }, nf(r, t);
}
const Tl = 6378137, ku = Math.PI * Tl, h8 = [-ku, -ku, ku, ku], p8 = [-180, -85, 180, 85], xh = Tl * Math[Ho(191)](Math[Ho(198)](Math.PI / 2));
class yu extends l4 {
  constructor(t) {
    super({ code: t, units: "m", extent: h8, global: !0, worldExtent: p8, getPointResolution: function(e, n) {
      return e / Math[nf(202)](n[1] / Tl);
    } });
  }
}
const mb = [new yu(Ho(200)), new yu(Ho(189)), new yu(Ho(197)), new yu("EPSG:900913"), new yu(Ho(187)), new yu(Ho(196))];
function d8(r, t, e, n) {
  const i = Ho, s = r[i(204)];
  e = e > 1 ? e : 2, n = n ?? e, t === void 0 && (e > 2 ? t = r[i(190)]() : t = new Array(s));
  for (let o = 0; o < s; o += n) {
    t[o] = ku * r[o] / 180;
    let a = Tl * Math.log(Math[i(198)](Math.PI * (+r[o + 1] + 90) / 360));
    a > xh ? a = xh : a < -xh && (a = -xh), t[o + 1] = a;
  }
  return t;
}
function g8(r, t, e, n) {
  const i = Ho, s = r[i(204)];
  e = e > 1 ? e : 2, n = n ?? e, t === void 0 && (e > 2 ? t = r[i(190)]() : t = new Array(s));
  for (let o = 0; o < s; o += n)
    t[o] = 180 * r[o] / ku, t[o + 1] = 360 * Math[i(183)](Math[i(192)](r[o + 1] / Tl)) / Math.PI - 90;
  return t;
}
const vu = rf;
function rf(r, t) {
  const e = S1();
  return rf = function(n, i) {
    return n = n - 328, e[n];
  }, rf(r, t);
}
(function(r, t) {
  const e = rf, n = r();
  for (; ; )
    try {
      if (parseInt(e(333)) / 1 + parseInt(e(331)) / 2 * (-parseInt(e(340)) / 3) + -parseInt(e(339)) / 4 + -parseInt(e(335)) / 5 + -parseInt(e(330)) / 6 * (parseInt(e(338)) / 7) + -parseInt(e(344)) / 8 * (parseInt(e(342)) / 9) + -parseInt(e(329)) / 10 * (-parseInt(e(332)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(S1, 242933);
const y8 = 6378137, _b = [-180, -90, 180, 90], v8 = Math.PI * y8 / 180;
class y0 extends l4 {
  constructor(t, e) {
    const n = rf;
    super({ code: t, units: n(341), extent: _b, axisOrientation: e, global: !0, metersPerUnit: v8, worldExtent: _b });
  }
}
function S1() {
  const r = ["EPSG:4326", "neu", "28dIqPXY", "258092azkidB", "36243YXHKZy", "degrees", "75942JXdmiF", "http://www.opengis.net/def/crs/OGC/1.3/CRS84", "264kfuOKD", "http://www.opengis.net/gml/srs/epsg.xml#4326", "237970UJXTaC", "162084ZCSGcL", "22bPqKtV", "451DodxwY", "279573kgnKsq", "http://www.opengis.net/def/crs/EPSG/0/4326", "2141965crIiox"];
  return S1 = function() {
    return r;
  }, S1();
}
const bb = [new y0("CRS:84"), new y0(vu(336), vu(337)), new y0("urn:ogc:def:crs:OGC:1.3:CRS84"), new y0("urn:ogc:def:crs:OGC:2:84"), new y0(vu(343)), new y0(vu(328), vu(337)), new y0(vu(334), "neu")];
function C1(r, t) {
  const e = M1();
  return C1 = function(n, i) {
    return n = n - 408, e[n];
  }, C1(r, t);
}
(function(r, t) {
  const e = C1, n = r();
  for (; ; )
    try {
      if (-parseInt(e(417)) / 1 + parseInt(e(409)) / 2 + parseInt(e(408)) / 3 * (-parseInt(e(415)) / 4) + parseInt(e(413)) / 5 * (parseInt(e(410)) / 6) + parseInt(e(411)) / 7 * (parseInt(e(414)) / 8) + parseInt(e(418)) / 9 + parseInt(e(419)) / 10 * (-parseInt(e(412)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(M1, 237448);
let lm = {};
function M1() {
  const r = ["760RirWOT", "21396TFMGtH", "replace", "276577uyGvxT", "1479969GIgzBa", "3499670pfhOAs", "129JzOfqQ", "626378EAAFxn", "218574kVTqTg", "15890ZZwFVK", "11dnoSgq", "55vTJZMB"];
  return M1 = function() {
    return r;
  }, M1();
}
function m8(r) {
  const t = C1;
  return lm[r] || lm[r[t(416)](/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function _8(r, t) {
  lm[r] = t;
}
(function(r, t) {
  const e = L1, n = r();
  for (; ; )
    try {
      if (-parseInt(e(483)) / 1 * (parseInt(e(481)) / 2) + -parseInt(e(478)) / 3 * (-parseInt(e(475)) / 4) + parseInt(e(472)) / 5 * (-parseInt(e(482)) / 6) + parseInt(e(476)) / 7 * (parseInt(e(474)) / 8) + parseInt(e(477)) / 9 + parseInt(e(473)) / 10 * (parseInt(e(484)) / 11) + -parseInt(e(480)) / 12 * (parseInt(e(479)) / 13) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(P1, 752580);
function P1() {
  const r = ["160kmHBJg", "1298936qcGAcv", "336182FOBpKm", "1959498XzDVfM", "6ucWzVB", "1142479ewmuXf", "156VnwVsb", "532214uTjlxZ", "1281264NDEOAk", "2tGTotT", "11tEBlyW", "getCode", "10vIqHCF", "10266510aqQhql"];
  return P1 = function() {
    return r;
  }, P1();
}
let Zu = {};
function L1(r, t) {
  const e = P1();
  return L1 = function(n, i) {
    return n = n - 472, e[n];
  }, L1(r, t);
}
function N1(r, t, e) {
  const n = L1, i = r[n(485)](), s = t[n(485)]();
  !(i in Zu) && (Zu[i] = {}), Zu[i][s] = e;
}
function b8(r, t) {
  let e;
  return r in Zu && t in Zu[r] && (e = Zu[r][t]), e;
}
(function(r, t) {
  const e = sf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(329)) / 1 + parseInt(e(327)) / 2 * (parseInt(e(322)) / 3) + parseInt(e(325)) / 4 * (parseInt(e(323)) / 5) + -parseInt(e(324)) / 6 + -parseInt(e(332)) / 7 * (-parseInt(e(335)) / 8) + -parseInt(e(331)) / 9 + parseInt(e(336)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(O1, 902303);
function O1() {
  const r = ["1739582UqrmFv", "length", "897453iLnGqa", "7nwPzsi", "floor", "abs", "3652648pvKkTM", "2765600mHRkxc", "ceil", "round", "36ELSamo", "943545WCcwne", "3349224Cfkpfk", "20Qpoywi", "pow", "270520vgRVbR", "min"];
  return O1 = function() {
    return r;
  }, O1();
}
function Tr(r, t, e) {
  return Math[sf(328)](Math.max(r, t), e);
}
function I8(r, t, e, n, i, s) {
  const o = i - e, a = s - n;
  if (o !== 0 || a !== 0) {
    const u = ((r - e) * o + (t - n) * a) / (o * o + a * a);
    u > 1 ? (e = i, n = s) : u > 0 && (e += o * u, n += a * u);
  }
  return $o(r, t, e, n);
}
function $o(r, t, e, n) {
  const i = e - r, s = n - t;
  return i * i + s * s;
}
function sf(r, t) {
  const e = O1();
  return sf = function(n, i) {
    return n = n - 322, e[n];
  }, sf(r, t);
}
function w8(r) {
  return r * Math.PI / 180;
}
function hm(r, t) {
  const e = r % t;
  return e * t < 0 ? e + t : e;
}
function Yi(r, t, e) {
  return r + e * (t - r);
}
function h4(r, t) {
  const e = sf, n = Math[e(326)](10, t);
  return Math[e(338)](r * n) / n;
}
(function(r, t) {
  const e = Va, n = r();
  for (; ; )
    try {
      if (parseInt(e(201)) / 1 * (parseInt(e(204)) / 2) + parseInt(e(206)) / 3 + parseInt(e(212)) / 4 + parseInt(e(209)) / 5 + -parseInt(e(210)) / 6 * (-parseInt(e(208)) / 7) + -parseInt(e(213)) / 8 + parseInt(e(200)) / 9 * (-parseInt(e(196)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(R1, 846369);
function R1() {
  const r = ["11754408qHUkOI", "getExtent", "cos", "getCenter", "1390BIyUsi", "charAt", "floor", "toFixed", "63729drFRNW", "1663icXARH", "sin", "replace", "1174LnsUzO", "canWrapX", "2863593iuQCNY", "abs", "462CMDbno", "1303840joCKYE", "81168rdnhtI", "sqrt", "862404bJQLPi"];
  return R1 = function() {
    return r;
  }, R1();
}
function E8(r, t) {
  return r[0] += +t[0], r[1] += +t[1], r;
}
function S8(r, t) {
  const e = Va, n = t.getRadius(), i = t[e(195)](), s = i[0], o = i[1], a = r[0], u = r[1];
  let x = a - s;
  const c = u - o;
  x === 0 && c === 0 && (x = 1);
  const f = Math[e(211)](x * x + c * c), l = s + n * x / f, h = o + n * c / f;
  return [l, h];
}
function p_(r, t) {
  const e = r[0], n = r[1], i = t[0], s = t[1], o = i[0], a = i[1], u = s[0], x = s[1], c = u - o, f = x - a, l = c === 0 && f === 0 ? 0 : (c * (e - o) + f * (n - a)) / (c * c + f * f || 0);
  let h, p;
  return l <= 0 ? (h = o, p = a) : l >= 1 ? (h = u, p = x) : (h = o + l * c, p = a + l * f), [h, p];
}
function Va(r, t) {
  const e = R1();
  return Va = function(n, i) {
    return n = n - 193, e[n];
  }, Va(r, t);
}
function Ys(r, t) {
  let e = !0;
  for (let n = r.length - 1; n >= 0; --n)
    if (r[n] != t[n]) {
      e = !1;
      break;
    }
  return e;
}
function C8(r, t) {
  const e = Va, n = Math[e(194)](t), i = Math[e(202)](t), s = r[0] * n - r[1] * i, o = r[1] * n + r[0] * i;
  return r[0] = s, r[1] = o, r;
}
function ta(r, t) {
  const e = r[0] - t[0], n = r[1] - t[1];
  return e * e + n * n;
}
function A1(r, t) {
  return Math[Va(211)](ta(r, t));
}
function M8(r, t) {
  return ta(r, p_(r, t));
}
function P8(r, t) {
  if (t[Va(205)]()) {
    const n = vi(t.getExtent()), i = L8(r, t, n);
    i && (r[0] -= i * n);
  }
  return r;
}
function L8(r, t, e) {
  const n = Va, i = t[n(193)]();
  let s = 0;
  return t.canWrapX() && (r[0] < i[0] || r[0] > i[2]) && (e = e || vi(i), s = Math[n(198)]((r[0] - i[0]) / e)), s;
}
const p4 = T1;
(function(r, t) {
  const e = T1, n = r();
  for (; ; )
    try {
      if (parseInt(e(230)) / 1 * (-parseInt(e(224)) / 2) + -parseInt(e(234)) / 3 * (parseInt(e(223)) / 4) + -parseInt(e(235)) / 5 * (-parseInt(e(232)) / 6) + parseInt(e(236)) / 7 * (-parseInt(e(220)) / 8) + parseInt(e(225)) / 9 + -parseInt(e(233)) / 10 * (parseInt(e(228)) / 11) + -parseInt(e(226)) / 12 * (-parseInt(e(227)) / 13) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(D1, 450417);
const d4 = { info: 1, warn: 2, error: 3, none: 4 };
let N8 = d4[p4(221)];
function T1(r, t) {
  const e = D1();
  return T1 = function(n, i) {
    return n = n - 220, e[n];
  }, T1(r, t);
}
function O8(...r) {
  N8 > d4[p4(231)] || console.warn(...r);
}
function D1() {
  const r = ["error", "92LqdBxa", "2zVgIvU", "6085953HEIeZN", "1572ZQuGWp", "132821DqapOf", "6263444PhxXFu", "log", "82447ojnVGB", "warn", "36ysoOiY", "10xZQWWF", "108183tpweMe", "122505FJsOrZ", "7ejKSOk", "1839832ZyIPFl", "info"];
  return D1 = function() {
    return r;
  }, D1();
}
(function(r, t) {
  const e = Js, n = r();
  for (; ; )
    try {
      if (parseInt(e(118)) / 1 * (parseInt(e(111)) / 2) + parseInt(e(114)) / 3 + -parseInt(e(128)) / 4 * (-parseInt(e(127)) / 5) + parseInt(e(116)) / 6 + parseInt(e(132)) / 7 * (-parseInt(e(112)) / 8) + -parseInt(e(121)) / 9 + -parseInt(e(119)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(F1, 715927);
let pm = !0;
function R8(r) {
  pm = !1;
}
function g4(r, t) {
  const e = Js;
  if (t !== void 0) {
    for (let n = 0, i = r[e(115)]; n < i; ++n)
      t[n] = r[n];
    t = t;
  } else t = r[e(124)]();
  return t;
}
function A8(r, t) {
  if (t !== void 0 && r !== t) {
    for (let e = 0, n = r.length; e < n; ++e)
      t[e] = r[e];
    r = t;
  }
  return r;
}
function T8(r) {
  _8(r[Js(131)](), r), N1(r, r, g4);
}
function D8(r) {
  r.forEach(T8);
}
function R0(r) {
  return typeof r === Js(129) ? m8(r) : r || null;
}
function Ib(r) {
  const t = Js;
  D8(r), r[t(110)](function(e) {
    r[t(110)](function(i) {
      e !== i && N1(e, i, g4);
    });
  });
}
function F8(r, t, e, n) {
  const i = Js;
  r[i(110)](function(s) {
    t[i(110)](function(a) {
      N1(s, a, e), N1(a, s, n);
    });
  });
}
function d_(r, t) {
  const e = Js;
  return r ? typeof r === e(129) ? R0(r) : r : R0(t);
}
function k8(r, t) {
  const e = Js, n = r[e(131)](), i = t[e(131)]();
  let s = b8(n, i);
  return !s && (s = A8), s;
}
function wb(r, t) {
  const e = R0(r), n = R0(t);
  return k8(e, n);
}
function F1() {
  const r = ["getMetersPerUnit", "slice", "EPSG:4326", "canWrapX", "696235mbABDn", "16YmMMud", "string", "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.", "getCode", "5649kQSfiJ", "forEach", "932vlKBTg", "6344GibbWv", "degrees", "2366322NysHfG", "length", "8086452HnRVVN", "getExtent", "2181sxUowL", "17611050DePrnA", "getUnits", "5335803nnSzdd", "EPSG:3857"];
  return F1 = function() {
    return r;
  }, F1();
}
function cx(r, t) {
  return r;
}
function cn(r, t) {
  const e = Js;
  return pm && !Ys(r, [0, 0]) && r[0] >= -180 && r[0] <= 180 && r[1] >= -90 && r[1] <= 90 && (pm = !1, O8(e(130))), r;
}
function Js(r, t) {
  const e = F1();
  return Js = function(n, i) {
    return n = n - 110, e[n];
  }, Js(r, t);
}
function py(r, t) {
  return r;
}
function Bu(r, t) {
  return r;
}
function B8() {
  Ib(mb), Ib(bb), F8(bb, mb, d8, g8);
}
B8();
(function(r, t) {
  const e = A0, n = r();
  for (; ; )
    try {
      if (-parseInt(e(158)) / 1 + -parseInt(e(155)) / 2 * (parseInt(e(160)) / 3) + -parseInt(e(161)) / 4 * (-parseInt(e(159)) / 5) + parseInt(e(154)) / 6 + parseInt(e(156)) / 7 + parseInt(e(153)) / 8 + -parseInt(e(152)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(k1, 269460);
function Ga(r, t, e, n, i, s, o) {
  const a = A0;
  s = s || [], o = o || 2;
  let u = 0;
  for (let x = t; x < e; x += n) {
    const c = r[x], f = r[x + 1];
    s[u++] = i[0] * c + i[2] * f + i[4], s[u++] = i[1] * c + i[3] * f + i[5];
    for (let l = 2; l < o; l++)
      s[u++] = r[x + l];
  }
  return s && s[a(162)] != u && (s[a(162)] = u), s;
}
function g_(r, t, e, n, i, s, o) {
  const a = A0;
  o = o || [];
  const u = Math[a(151)](i), x = Math[a(157)](i), c = s[0], f = s[1];
  let l = 0;
  for (let h = t; h < e; h += n) {
    const p = r[h] - c, y = r[h + 1] - f;
    o[l++] = c + p * u - y * x, o[l++] = f + p * x + y * u;
    for (let v = h + 2; v < h + n; ++v)
      o[l++] = r[v];
  }
  return o && o[a(162)] != l && (o.length = l), o;
}
function G8(r, t, e, n, i, s, o, a) {
  const u = A0;
  a = a || [];
  const x = o[0], c = o[1];
  let f = 0;
  for (let l = t; l < e; l += n) {
    const h = r[l] - x, p = r[l + 1] - c;
    a[f++] = x + i * h, a[f++] = c + s * p;
    for (let y = l + 2; y < l + n; ++y)
      a[f++] = r[y];
  }
  return a && a[u(162)] != f && (a[u(162)] = f), a;
}
function A0(r, t) {
  const e = k1();
  return A0 = function(n, i) {
    return n = n - 151, e[n];
  }, A0(r, t);
}
function Y8(r, t, e, n, i, s, o) {
  const a = A0;
  o = o || [];
  let u = 0;
  for (let x = t; x < e; x += n) {
    o[u++] = r[x] + i, o[u++] = r[x + 1] + s;
    for (let c = x + 2; c < x + n; ++c)
      o[u++] = r[c];
  }
  return o && o[a(162)] != u && (o[a(162)] = u), o;
}
function k1() {
  const r = ["cos", "315180wCmefp", "891928FqdRpT", "147006ydRSxZ", "7314mtOolL", "433048eyDPHm", "sin", "254347KcKhxK", "55oZbgtY", "3XeMLIg", "132592HDFUDQ", "length"];
  return k1 = function() {
    return r;
  }, k1();
}
const On = of;
(function(r, t) {
  const e = of, n = r();
  for (; ; )
    try {
      if (parseInt(e(322)) / 1 + parseInt(e(321)) / 2 * (-parseInt(e(328)) / 3) + parseInt(e(337)) / 4 + -parseInt(e(320)) / 5 * (-parseInt(e(327)) / 6) + parseInt(e(316)) / 7 + -parseInt(e(345)) / 8 * (-parseInt(e(347)) / 9) + -parseInt(e(348)) / 10 * (parseInt(e(343)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(B1, 678465);
function of(r, t) {
  const e = B1();
  return of = function(n, i) {
    return n = n - 315, e[n];
  }, of(r, t);
}
const Eb = Qo();
function B1() {
  const r = ["extentRevision_", "simplifyTransformed", "3628000MuMweN", "containsXY", "getRevision", "transform", "intersectsExtent", "getClosestPoint", "12786587EHZXOe", "getUnits", "384gEYYKH", "getSimplifiedGeometry", "215163BkUSWA", "20tpVjAr", "simplifyTransformedInternal", "9125795RqIMco", "scale", "getType", "intersectsCoordinate", "5oqUghJ", "36700EVGOXT", "325655YfhwUK", "simplify", "closestPointXY", "length", "simplifiedGeometryRevision", "3403338tDHibH", "204aWtYKJ", "applyTransform", "clone", "getWorldExtent", "computeExtent", "extent_", "simplifiedGeometryMaxMinSquaredTolerance"];
  return B1 = function() {
    return r;
  }, B1();
}
let y4 = class extends a0 {
  constructor() {
    const t = of;
    super(), this[t(333)] = Hs(), this[t(335)] = -1, this[t(334)] = 0, this[t(326)] = 0, this[t(315)] = Q3((e, n, i) => {
      const s = t;
      if (!i) return this.getSimplifiedGeometry(n);
      const o = this[s(330)]();
      return o[s(329)](i), o[s(346)](n);
    });
  }
  [On(336)](t, e) {
    return this[On(315)](this.getRevision(), t, e);
  }
  [On(330)]() {
    return qe();
  }
  [On(324)](t, e, n, i) {
    return qe();
  }
  [On(338)](t, e) {
    const n = On, i = this[n(342)]([t, e]);
    return i[0] === t && i[1] === e;
  }
  [On(342)](t, e) {
    const n = On;
    return e = e || [NaN, NaN], this[n(324)](t[0], t[1], e, 1 / 0), e;
  }
  [On(319)](t) {
    return this[On(338)](t[0], t[1]);
  }
  [On(332)](t) {
    return qe();
  }
  getExtent(t) {
    const e = On;
    if (this[e(335)] != this[e(339)]()) {
      const n = this[e(332)](this[e(333)]);
      (isNaN(n[0]) || isNaN(n[1])) && l_(n), this[e(335)] = this[e(339)]();
    }
    return s8(this[e(333)], t);
  }
  rotate(t, e) {
    qe();
  }
  [On(317)](t, e, n) {
    qe();
  }
  [On(323)](t) {
    return this[On(346)](t * t);
  }
  [On(346)](t) {
    return qe();
  }
  [On(318)]() {
    return qe();
  }
  [On(329)](t) {
    qe();
  }
  [On(341)](t) {
    return qe();
  }
  translate(t, e) {
    qe();
  }
  [On(340)](t, e) {
    const n = On, i = R0(t), s = i[n(344)]() == "tile-pixels" ? function(o, a, u) {
      const x = n, c = i.getExtent(), f = i[x(331)](), l = xa(f) / xa(c);
      return O0(Eb, f[0], f[3], l, -l, 0, 0, 0), Ga(o, 0, o[x(325)], u, Eb, a), wb(i, e)(o, a, u);
    } : wb(i, e);
    return this[n(329)](s), this;
  }
};
const mn = af;
(function(r, t) {
  const e = af, n = r();
  for (; ; )
    try {
      if (-parseInt(e(354)) / 1 * (parseInt(e(345)) / 2) + -parseInt(e(334)) / 3 * (parseInt(e(352)) / 4) + parseInt(e(339)) / 5 + parseInt(e(341)) / 6 * (-parseInt(e(337)) / 7) + -parseInt(e(350)) / 8 * (parseInt(e(327)) / 9) + -parseInt(e(349)) / 10 + parseInt(e(325)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(G1, 274888);
function af(r, t) {
  const e = G1();
  return af = function(n, i) {
    return n = n - 323, e[n];
  }, af(r, t);
}
class u0 extends y4 {
  constructor() {
    const t = af;
    super(), this[t(353)] = "XY", this[t(329)] = 2, this[t(355)];
  }
  [mn(328)](t) {
    const e = mn;
    return h_(this.flatCoordinates, 0, this[e(355)][e(330)], this.stride, t);
  }
  [mn(326)]() {
    return qe();
  }
  getFirstCoordinate() {
    const t = mn;
    return this.flatCoordinates[t(344)](0, this[t(329)]);
  }
  [mn(336)]() {
    return this.flatCoordinates;
  }
  getLastCoordinate() {
    const t = mn;
    return this[t(355)][t(344)](this[t(355)][t(330)] - this[t(329)]);
  }
  getLayout() {
    return this[mn(353)];
  }
  [mn(323)](t) {
    const e = mn;
    if (this.simplifiedGeometryRevision !== this[e(342)]() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this[e(333)] = this[e(342)]()), t < 0 || this[e(351)] !== 0 && t <= this[e(351)]) return this;
    const n = this[e(331)](t);
    return n[e(336)]()[e(330)] < this.flatCoordinates.length ? n : (this[e(351)] = t, this);
  }
  [mn(331)](t) {
    return this;
  }
  getStride() {
    return this.stride;
  }
  [mn(338)](t, e) {
    const n = mn;
    this.stride = Y1(t), this[n(353)] = t, this.flatCoordinates = e;
  }
  [mn(343)](t, e) {
    qe();
  }
  setLayout(t, e, n) {
    const i = mn;
    let s;
    if (t) s = Y1(t);
    else {
      for (let o = 0; o < n; ++o) {
        if (e.length === 0) {
          this[i(353)] = "XY", this[i(329)] = 2;
          return;
        }
        e = e[0];
      }
      s = e.length, t = X8(s);
    }
    this[i(353)] = t, this[i(329)] = s;
  }
  [mn(348)](t) {
    const e = mn;
    this[e(355)] && (t(this[e(355)], this[e(355)], this[e(353)][e(324)](e(340)) ? 3 : 2, this[e(329)]), this[e(346)]());
  }
  rotate(t, e) {
    const n = mn, i = this[n(336)]();
    if (i) {
      const s = this[n(347)]();
      g_(i, 0, i[n(330)], s, t, e, i), this[n(346)]();
    }
  }
  scale(t, e, n) {
    const i = mn;
    e === void 0 && (e = t), !n && (n = ua(this.getExtent()));
    const s = this[i(336)]();
    if (s) {
      const o = this[i(347)]();
      G8(s, 0, s[i(330)], o, t, e, n, s), this[i(346)]();
    }
  }
  [mn(332)](t, e) {
    const n = mn, i = this[n(336)]();
    if (i) {
      const s = this.getStride();
      Y8(i, 0, i.length, s, t, e, i), this[n(346)]();
    }
  }
}
function G1() {
  const r = ["10YayjCQ", "changed", "getStride", "applyTransform", "4494500Pskzwx", "24HDbJvo", "simplifiedGeometryMaxMinSquaredTolerance", "327304TvJlrn", "layout", "39031swhGeV", "flatCoordinates", "getSimplifiedGeometry", "startsWith", "11755249ZlSQcT", "getCoordinates", "1173807mywYPB", "computeExtent", "stride", "length", "getSimplifiedGeometryInternal", "translate", "simplifiedGeometryRevision", "6PxKTYo", "XYZM", "getFlatCoordinates", "187754QycCdI", "setFlatCoordinates", "2699325yYOPZv", "XYZ", "30DlFFCd", "getRevision", "setCoordinates", "slice"];
  return G1 = function() {
    return r;
  }, G1();
}
function X8(r) {
  const t = mn;
  let e;
  return r == 2 ? e = "XY" : r == 3 ? e = t(340) : r == 4 && (e = t(335)), e;
}
function Y1(r) {
  const t = mn;
  let e;
  return r == "XY" ? e = 2 : r == "XYZ" || r == "XYM" ? e = 3 : r == t(335) && (e = 4), e;
}
function q8(r, t, e) {
  const n = mn, i = r.getFlatCoordinates();
  if (!i) return null;
  const s = r[n(347)]();
  return Ga(i, 0, i[n(330)], s, t, e);
}
(function(r, t) {
  const e = T0, n = r();
  for (; ; )
    try {
      if (-parseInt(e(394)) / 1 * (parseInt(e(398)) / 2) + -parseInt(e(397)) / 3 * (-parseInt(e(391)) / 4) + -parseInt(e(396)) / 5 + parseInt(e(392)) / 6 + parseInt(e(389)) / 7 * (parseInt(e(393)) / 8) + -parseInt(e(388)) / 9 + parseInt(e(390)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(X1, 226121);
function X1() {
  const r = ["11060BZSPmW", "2440500kdwmKZ", "316CoLncn", "2415210xbNrHS", "1168gdaPYV", "398171XmNoMa", "length", "1376970FNTCZN", "10407sGbmqT", "2wCalwC", "2264670JaqKUB"];
  return X1 = function() {
    return r;
  }, X1();
}
function v4(r, t, e, n) {
  const i = T0;
  for (let s = 0, o = e[i(395)]; s < o; ++s)
    r[t++] = e[s];
  return t;
}
function dy(r, t, e, n) {
  const i = T0;
  for (let s = 0, o = e[i(395)]; s < o; ++s) {
    const a = e[s];
    for (let u = 0; u < n; ++u)
      r[t++] = a[u];
  }
  return t;
}
function T0(r, t) {
  const e = X1();
  return T0 = function(n, i) {
    return n = n - 388, e[n];
  }, T0(r, t);
}
function y_(r, t, e, n, i) {
  const s = T0;
  i = i || [];
  let o = 0;
  for (let a = 0, u = e[s(395)]; a < u; ++a) {
    const x = dy(r, t, e[a], n);
    i[o++] = x, t = x;
  }
  return i.length = o, i;
}
function z8(r, t, e, n, i) {
  const s = T0;
  i = i || [];
  let o = 0;
  for (let a = 0, u = e[s(395)]; a < u; ++a) {
    const x = y_(r, t, e[a], n, i[o]);
    x[s(395)] === 0 && (x[0] = t), i[o++] = x, t = x[x[s(395)] - 1];
  }
  return i[s(395)] = o, i;
}
const Ve = uf;
(function(r, t) {
  const e = uf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(203)) / 1 * (parseInt(e(180)) / 2) + -parseInt(e(212)) / 3 * (parseInt(e(213)) / 4) + -parseInt(e(189)) / 5 + parseInt(e(186)) / 6 * (-parseInt(e(199)) / 7) + parseInt(e(190)) / 8 * (-parseInt(e(183)) / 9) + parseInt(e(178)) / 10 + parseInt(e(195)) / 11 * (parseInt(e(196)) / 12) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(q1, 710307);
let m4 = class _4 extends u0 {
  constructor(t, e, n) {
    const i = uf;
    super(), n !== void 0 && e === void 0 ? this[i(202)](n, t) : (e = e || 0, this[i(174)](t, e, n));
  }
  [Ve(193)]() {
    const t = Ve, e = new _4(this[t(204)][t(205)](), void 0, this[t(176)]);
    return e.applyProperties(this), e;
  }
  closestPointXY(t, e, n, i) {
    const s = Ve, o = this[s(204)], a = t - o[0], u = e - o[1], x = a * a + u * u;
    if (x < i) {
      if (x === 0) for (let c = 0; c < this[s(207)]; ++c)
        n[c] = o[c];
      else {
        const c = this.getRadius() / Math[s(192)](x);
        n[0] = o[0] + c * a, n[1] = o[1] + c * u;
        for (let f = 2; f < this.stride; ++f)
          n[f] = o[f];
      }
      return n[s(210)] = this[s(207)], x;
    }
    return i;
  }
  [Ve(191)](t, e) {
    const n = Ve, i = this[n(204)], s = t - i[0], o = e - i[1];
    return s * s + o * o <= this.getRadiusSquared_();
  }
  [Ve(181)]() {
    const t = Ve;
    return this.flatCoordinates[t(205)](0, this[t(207)]);
  }
  [Ve(206)](t) {
    const e = Ve, n = this[e(204)], i = n[this.stride] - n[0];
    return N0(n[0] - i, n[1] - i, n[0] + i, n[1] + i, t);
  }
  getRadius() {
    return Math[Ve(192)](this.getRadiusSquared_());
  }
  [Ve(209)]() {
    const t = Ve, e = this[t(204)][this.stride] - this.flatCoordinates[0], n = this[t(204)][this[t(207)] + 1] - this[t(204)][1];
    return e * e + n * n;
  }
  [Ve(198)]() {
    return Ve(177);
  }
  [Ve(179)](t) {
    const e = Ve, n = this[e(187)]();
    if (hs(t, n)) {
      const i = this[e(181)]();
      return t[0] <= i[0] && t[2] >= i[0] || t[1] <= i[1] && t[3] >= i[1] ? !0 : i4(t, this[e(200)][e(175)](this));
    }
    return !1;
  }
  setCenter(t) {
    const e = Ve, n = this[e(207)], i = this[e(204)][n] - this.flatCoordinates[0], s = t[e(205)]();
    s[n] = s[0] + i;
    for (let o = 1; o < n; ++o)
      s[n + o] = t[o];
    this[e(202)](this[e(176)], s), this[e(194)]();
  }
  [Ve(174)](t, e, n) {
    const i = Ve;
    this[i(211)](n, t, 0), !this[i(204)] && (this.flatCoordinates = []);
    const s = this[i(204)];
    let o = v4(s, 0, t, this[i(207)]);
    s[o++] = s[0] + e;
    for (let a = 1, u = this.stride; a < u; ++a)
      s[o++] = s[a];
    s[i(210)] = o, this[i(194)]();
  }
  [Ve(185)]() {
    return null;
  }
  [Ve(184)](t, e) {
  }
  [Ve(208)](t) {
    const e = Ve;
    this[e(204)][this[e(207)]] = this[e(204)][0] + t, this[e(194)]();
  }
  [Ve(182)](t, e) {
    const n = Ve, i = this.getCenter(), s = this[n(201)]();
    this[n(197)](g_(i, 0, i[n(210)], s, t, e, i)), this[n(194)]();
  }
};
function q1() {
  const r = ["getCenter", "rotate", "3331773GtSUHA", "setCoordinates", "getCoordinates", "1060734uARAiN", "getExtent", "prototype", "1967815LfttPC", "24FrTRXh", "containsXY", "sqrt", "clone", "changed", "22GtqvKg", "24177588pHHFFA", "setCenter", "getType", "35Tbvklt", "intersectsCoordinate", "getStride", "setFlatCoordinates", "58165TmdNLg", "flatCoordinates", "slice", "computeExtent", "stride", "setRadius", "getRadiusSquared_", "length", "setLayout", "1977yVvwPo", "5128yhZEFY", "transform", "setCenterAndRadius", "bind", "layout", "Circle", "6697910kFdKmz", "intersectsExtent", "26LbFMdf"];
  return q1 = function() {
    return r;
  }, q1();
}
function uf(r, t) {
  const e = q1();
  return uf = function(n, i) {
    return n = n - 174, e[n];
  }, uf(r, t);
}
m4[Ve(188)][Ve(214)];
const oe = xf;
function z1() {
  const r = ["length", "11bRVWMg", "4768hIdvct", "unlistenGeometriesChange_", "disposeInternal", "2424390tdphdL", "concat", "17179657bAIJYf", "68FebSCF", "107016crxbMO", "scale", "clone", "9205maMmGS", "getGeometries", "listenGeometriesChange_", "getSimplifiedGeometry", "map", "containsXY", "changeEventsKeys_", "getType", "50086njxyRx", "simplifiedGeometryRevision", "getGeometriesArray", "getExtent", "computeExtent", "8013470jtWbFb", "9oSEQBe", "intersectsExtent", "GeometryCollection", "translate", "isEmpty", "applyTransform", "getRevision", "getGeometriesArrayRecursive", "push", "CHANGE", "forEach", "setGeometriesArray", "rotate", "closestPointXY", "138903ibeTYa", "simplifiedGeometryMaxMinSquaredTolerance", "changed", "setGeometries", "geometries_"];
  return z1 = function() {
    return r;
  }, z1();
}
function xf(r, t) {
  const e = z1();
  return xf = function(n, i) {
    return n = n - 349, e[n];
  }, xf(r, t);
}
(function(r, t) {
  const e = xf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(371)) / 1 * (-parseInt(e(390)) / 2) + parseInt(e(365)) / 3 * (parseInt(e(378)) / 4) + -parseInt(e(375)) / 5 + parseInt(e(379)) / 6 + -parseInt(e(382)) / 7 * (parseInt(e(372)) / 8) + -parseInt(e(351)) / 9 * (parseInt(e(350)) / 10) + parseInt(e(377)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(z1, 572248);
let U8 = class dm extends y4 {
  constructor(t) {
    const e = xf;
    super(), this[e(369)] = t, this.changeEventsKeys_ = [], this[e(384)]();
  }
  [oe(373)]() {
    const t = oe;
    this[t(388)][t(361)](gs), this[t(388)][t(370)] = 0;
  }
  [oe(384)]() {
    const t = oe, e = this.geometries_;
    for (let n = 0, i = e[t(370)]; n < i; ++n)
      this[t(388)][t(359)](ii(e[n], rr[t(360)], this[t(367)], this));
  }
  [oe(381)]() {
    const t = oe, e = new dm(lv(this[t(369)]));
    return e.applyProperties(this), e;
  }
  [oe(364)](t, e, n, i) {
    const s = oe;
    if (i < xu(this.getExtent(), t, e)) return i;
    const o = this[s(369)];
    for (let a = 0, u = o.length; a < u; ++a)
      i = o[a].closestPointXY(t, e, n, i);
    return i;
  }
  [oe(387)](t, e) {
    const n = oe, i = this.geometries_;
    for (let s = 0, o = i[n(370)]; s < o; ++s)
      if (i[s][n(387)](t, e)) return !0;
    return !1;
  }
  [oe(349)](t) {
    const e = oe;
    l_(t);
    const n = this[e(369)];
    for (let i = 0, s = n[e(370)]; i < s; ++i)
      kh(t, n[i][e(393)]());
    return t;
  }
  [oe(383)]() {
    return lv(this[oe(369)]);
  }
  [oe(392)]() {
    return this[oe(369)];
  }
  [oe(358)]() {
    const t = oe;
    let e = [];
    const n = this[t(369)];
    for (let i = 0, s = n.length; i < s; ++i)
      n[i].getType() === this[t(389)]() ? e = e[t(376)](n[i][t(358)]()) : e[t(359)](n[i]);
    return e;
  }
  [oe(385)](t) {
    const e = oe;
    if (this[e(391)] !== this[e(357)]() && (this[e(366)] = 0, this[e(391)] = this[e(357)]()), t < 0 || this[e(366)] !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance) return this;
    const n = [], i = this[e(369)];
    let s = !1;
    for (let o = 0, a = i.length; o < a; ++o) {
      const u = i[o], x = u.getSimplifiedGeometry(t);
      n.push(x), x !== u && (s = !0);
    }
    return s ? new dm(n) : (this[e(366)] = t, this);
  }
  getType() {
    return oe(353);
  }
  [oe(352)](t) {
    const e = oe, n = this.geometries_;
    for (let i = 0, s = n[e(370)]; i < s; ++i)
      if (n[i][e(352)](t)) return !0;
    return !1;
  }
  [oe(355)]() {
    const t = oe;
    return this[t(369)][t(370)] === 0;
  }
  [oe(363)](t, e) {
    const n = oe, i = this.geometries_;
    for (let s = 0, o = i.length; s < o; ++s)
      i[s][n(363)](t, e);
    this[n(367)]();
  }
  scale(t, e, n) {
    const i = oe;
    !n && (n = ua(this.getExtent()));
    const s = this[i(369)];
    for (let o = 0, a = s[i(370)]; o < a; ++o)
      s[o][i(380)](t, e, n);
    this[i(367)]();
  }
  [oe(368)](t) {
    this.setGeometriesArray(lv(t));
  }
  [oe(362)](t) {
    const e = oe;
    this.unlistenGeometriesChange_(), this[e(369)] = t, this[e(384)](), this[e(367)]();
  }
  applyTransform(t) {
    const e = oe, n = this.geometries_;
    for (let i = 0, s = n.length; i < s; ++i)
      n[i][e(356)](t);
    this[e(367)]();
  }
  [oe(354)](t, e) {
    const n = oe, i = this[n(369)];
    for (let s = 0, o = i[n(370)]; s < o; ++s)
      i[s][n(354)](t, e);
    this[n(367)]();
  }
  [oe(374)]() {
    const t = oe;
    this[t(373)](), super[t(374)]();
  }
};
function lv(r) {
  const t = oe;
  return r[t(386)]((e) => e[t(381)]());
}
(function(r, t) {
  const e = ca, n = r();
  for (; ; )
    try {
      if (parseInt(e(259)) / 1 * (parseInt(e(256)) / 2) + parseInt(e(261)) / 3 * (parseInt(e(254)) / 4) + -parseInt(e(262)) / 5 * (parseInt(e(255)) / 6) + parseInt(e(257)) / 7 + -parseInt(e(263)) / 8 * (-parseInt(e(260)) / 9) + parseInt(e(252)) / 10 * (-parseInt(e(253)) / 11) + parseInt(e(265)) / 12 * (-parseInt(e(264)) / 13) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(U1, 908267);
function ca(r, t) {
  const e = U1();
  return ca = function(n, i) {
    return n = n - 250, e[n];
  }, ca(r, t);
}
function Sb(r, t, e, n, i, s, o) {
  const a = ca, u = r[t], x = r[t + 1], c = r[e] - u, f = r[e + 1] - x;
  let l;
  if (c === 0 && f === 0) l = t;
  else {
    const h = ((i - u) * c + (s - x) * f) / (c * c + f * f);
    if (h > 1) l = e;
    else if (h > 0) {
      for (let p = 0; p < n; ++p)
        o[p] = Yi(r[t + p], r[e + p], h);
      o[a(258)] = n;
      return;
    } else l = t;
  }
  for (let h = 0; h < n; ++h)
    o[h] = r[l + h];
  o.length = n;
}
function v_(r, t, e, n, i) {
  let s = r[t], o = r[t + 1];
  for (t += n; t < e; t += n) {
    const a = r[t], u = r[t + 1], x = $o(s, o, a, u);
    x > i && (i = x), s = a, o = u;
  }
  return i;
}
function m_(r, t, e, n, i) {
  const s = ca;
  for (let o = 0, a = e[s(258)]; o < a; ++o) {
    const u = e[o];
    i = v_(r, t, u, n, i), t = u;
  }
  return i;
}
function V8(r, t, e, n, i) {
  const s = ca;
  for (let o = 0, a = e.length; o < a; ++o) {
    const u = e[o];
    i = m_(r, t, u, n, i), t = u[u[s(258)] - 1];
  }
  return i;
}
function __(r, t, e, n, i, s, o, a, u, x, c) {
  const f = ca;
  if (t == e) return x;
  let l, h;
  if (i === 0) {
    if (h = $o(o, a, r[t], r[t + 1]), h < x) {
      for (l = 0; l < n; ++l)
        u[l] = r[t + l];
      return u[f(258)] = n, h;
    }
    return x;
  }
  c = c || [NaN, NaN];
  let p = t + n;
  for (; p < e; )
    if (Sb(r, p - n, p, n, o, a, c), h = $o(o, a, c[0], c[1]), h < x) {
      for (x = h, l = 0; l < n; ++l)
        u[l] = c[l];
      u[f(258)] = n, p += n;
    } else p += n * Math[f(251)]((Math[f(250)](h) - Math[f(250)](x)) / i | 0, 1);
  if (s && (Sb(r, e - n, t, n, o, a, c), h = $o(o, a, c[0], c[1]), h < x)) {
    for (x = h, l = 0; l < n; ++l)
      u[l] = c[l];
    u[f(258)] = n;
  }
  return x;
}
function b_(r, t, e, n, i, s, o, a, u, x, c) {
  const f = ca;
  c = c || [NaN, NaN];
  for (let l = 0, h = e[f(258)]; l < h; ++l) {
    const p = e[l];
    x = __(r, t, p, n, i, s, o, a, u, x, c), t = p;
  }
  return x;
}
function W8(r, t, e, n, i, s, o, a, u, x, c) {
  const f = ca;
  c = c || [NaN, NaN];
  for (let l = 0, h = e[f(258)]; l < h; ++l) {
    const p = e[l];
    x = b_(r, t, p, n, i, s, o, a, u, x, c), t = p[p[f(258)] - 1];
  }
  return x;
}
function U1() {
  const r = ["12gSODou", "sqrt", "max", "1420kyKpot", "36718dyYNDj", "12vdvujU", "1506vShBqQ", "20yERtYu", "11926530ijhiZk", "length", "88628yikQtG", "51309hxVICL", "1086759yxVVxm", "29705gGmQDL", "728coWPrS", "17188158tBZYwH"];
  return U1 = function() {
    return r;
  }, U1();
}
(function(r, t) {
  const e = Wa, n = r();
  for (; ; )
    try {
      if (-parseInt(e(293)) / 1 * (-parseInt(e(280)) / 2) + parseInt(e(295)) / 3 + parseInt(e(285)) / 4 * (-parseInt(e(294)) / 5) + parseInt(e(284)) / 6 * (parseInt(e(282)) / 7) + -parseInt(e(292)) / 8 * (-parseInt(e(287)) / 9) + -parseInt(e(281)) / 10 * (parseInt(e(286)) / 11) + -parseInt(e(288)) / 12 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(V1, 399352);
function gy(r, t, e, n, i, s, o) {
  const a = Wa, u = (e - t) / n;
  if (u < 3) {
    for (; t < e; t += n)
      s[o++] = r[t], s[o++] = r[t + 1];
    return o;
  }
  const x = new Array(u);
  x[0] = 1, x[u - 1] = 1;
  const c = [t, e - n];
  let f = 0;
  for (; c[a(283)] > 0; ) {
    const l = c[a(291)](), h = c.pop();
    let p = 0;
    const y = r[h], v = r[h + 1], m = r[l], d = r[l + 1];
    for (let g = h + n; g < l; g += n) {
      const _ = r[g], b = r[g + 1], w = I8(_, b, y, v, m, d);
      w > p && (f = g, p = w);
    }
    p > i && (x[(f - t) / n] = 1, h + n < f && c.push(h, f), f + n < l && c[a(289)](f, l));
  }
  for (let l = 0; l < u; ++l)
    x[l] && (s[o++] = r[t + l * n], s[o++] = r[t + l * n + 1]);
  return o;
}
function b4(r, t, e, n, i, s, o, a) {
  const u = Wa;
  for (let x = 0, c = e[u(283)]; x < c; ++x) {
    const f = e[x];
    o = gy(r, t, f, n, i, s, o), a[u(289)](o), t = f;
  }
  return o;
}
function V1() {
  const r = ["2691096dVOtJa", "103476jLsSuE", "288245fJbpXc", "2106300blKVTn", "6zeBZVR", "294530zwAYvi", "122857FWAyat", "length", "180CvVTBm", "28eAHKVm", "88sDvtHp", "18EmcVYp", "14079756cqwfWf", "push", "round", "pop"];
  return V1 = function() {
    return r;
  }, V1();
}
function I0(r, t) {
  return t * Math[Wa(290)](r / t);
}
function Wa(r, t) {
  const e = V1();
  return Wa = function(n, i) {
    return n = n - 280, e[n];
  }, Wa(r, t);
}
function H8(r, t, e, n, i, s, o) {
  if (t == e) return o;
  let a = I0(r[t], i), u = I0(r[t + 1], i);
  t += n, s[o++] = a, s[o++] = u;
  let x, c;
  do
    if (x = I0(r[t], i), c = I0(r[t + 1], i), t += n, t == e) return s[o++] = x, s[o++] = c, o;
  while (x == a && c == u);
  for (; t < e; ) {
    const f = I0(r[t], i), l = I0(r[t + 1], i);
    if (t += n, f == x && l == c) continue;
    const h = x - a, p = c - u, y = f - a, v = l - u;
    if (h * v == p * y && (h < 0 && y < h || h == y || h > 0 && y > h) && (p < 0 && v < p || p == v || p > 0 && v > p)) {
      x = f, c = l;
      continue;
    }
    s[o++] = x, s[o++] = c, a = x, u = c, x = f, c = l;
  }
  return s[o++] = x, s[o++] = c, o;
}
function I_(r, t, e, n, i, s, o, a) {
  const u = Wa;
  for (let x = 0, c = e[u(283)]; x < c; ++x) {
    const f = e[x];
    o = H8(r, t, f, n, i, s, o), a[u(289)](o), t = f;
  }
  return o;
}
function J8(r, t, e, n, i, s, o, a) {
  const u = Wa;
  for (let x = 0, c = e[u(283)]; x < c; ++x) {
    const f = e[x], l = [];
    o = I_(r, t, f, n, i, s, o, l), a[u(289)](l), t = f[f[u(283)] - 1];
  }
  return o;
}
(function(r, t) {
  const e = fx, n = r();
  for (; ; )
    try {
      if (parseInt(e(112)) / 1 * (-parseInt(e(120)) / 2) + -parseInt(e(114)) / 3 + -parseInt(e(110)) / 4 + -parseInt(e(118)) / 5 * (-parseInt(e(119)) / 6) + -parseInt(e(111)) / 7 + -parseInt(e(113)) / 8 + -parseInt(e(115)) / 9 * (-parseInt(e(117)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(W1, 561778);
function fx(r, t) {
  const e = W1();
  return fx = function(n, i) {
    return n = n - 110, e[n];
  }, fx(r, t);
}
function Da(r, t, e, n, i) {
  const s = fx;
  i = i !== void 0 ? i : [];
  let o = 0;
  for (let a = t; a < e; a += n)
    i[o++] = r[s(121)](a, a + n);
  return i[s(116)] = o, i;
}
function cf(r, t, e, n, i) {
  const s = fx;
  i = i !== void 0 ? i : [];
  let o = 0;
  for (let a = 0, u = e[s(116)]; a < u; ++a) {
    const x = e[a];
    i[o++] = Da(r, t, x, n, i[o]), t = x;
  }
  return i.length = o, i;
}
function gm(r, t, e, n, i) {
  const s = fx;
  i = i !== void 0 ? i : [];
  let o = 0;
  for (let a = 0, u = e[s(116)]; a < u; ++a) {
    const x = e[a];
    i[o++] = x.length === 1 && x[0] === t ? [] : cf(r, t, x, n, i[o]), t = x[x[s(116)] - 1];
  }
  return i[s(116)] = o, i;
}
function W1() {
  const r = ["36650034CmmBPk", "length", "10mIGdrw", "403770MeiNYW", "18vBHybL", "7142MzVUJE", "slice", "3030288vqxskh", "3514700zoBJhT", "305GtzwFN", "3168288Dopofo", "3023541AVNjCn"];
  return W1 = function() {
    return r;
  }, W1();
}
(function(r, t) {
  const e = ff, n = r();
  for (; ; )
    try {
      if (parseInt(e(309)) / 1 + -parseInt(e(312)) / 2 + parseInt(e(317)) / 3 * (-parseInt(e(308)) / 4) + parseInt(e(314)) / 5 * (parseInt(e(316)) / 6) + -parseInt(e(310)) / 7 * (parseInt(e(307)) / 8) + parseInt(e(313)) / 9 + parseInt(e(311)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(H1, 410255);
function I4(r, t, e, n) {
  let i = 0;
  const s = r[e - n], o = r[e - n + 1];
  let a = 0, u = 0;
  for (; t < e; t += n) {
    const x = r[t] - s, c = r[t + 1] - o;
    i += u * x - a * c, a = x, u = c;
  }
  return i / 2;
}
function w4(r, t, e, n) {
  const i = ff;
  let s = 0;
  for (let o = 0, a = e[i(315)]; o < a; ++o) {
    const u = e[o];
    s += I4(r, t, u, n), t = u;
  }
  return s;
}
function H1() {
  const r = ["125ZUFumx", "length", "173388DReztc", "44937KnknXO", "266360ZIfRaO", "52vjimka", "120639YUhHrb", "154wCuCjK", "395180EmXUdH", "207274paIHEj", "5026518TQwxoU"];
  return H1 = function() {
    return r;
  }, H1();
}
function ff(r, t) {
  const e = H1();
  return ff = function(n, i) {
    return n = n - 307, e[n];
  }, ff(r, t);
}
function Z8(r, t, e, n) {
  const i = ff;
  let s = 0;
  for (let o = 0, a = e[i(315)]; o < a; ++o) {
    const u = e[o];
    s += w4(r, t, u, n), t = u[u.length - 1];
  }
  return s;
}
const ao = lx;
(function(r, t) {
  const e = lx, n = r();
  for (; ; )
    try {
      if (parseInt(e(218)) / 1 + parseInt(e(239)) / 2 * (-parseInt(e(236)) / 3) + parseInt(e(240)) / 4 * (parseInt(e(216)) / 5) + parseInt(e(238)) / 6 + -parseInt(e(226)) / 7 * (-parseInt(e(225)) / 8) + parseInt(e(224)) / 9 + -parseInt(e(228)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(J1, 814933);
function lx(r, t) {
  const e = J1();
  return lx = function(n, i) {
    return n = n - 215, e[n];
  }, lx(r, t);
}
let Cb = class ym extends u0 {
  constructor(t, e) {
    const n = lx;
    super(), this[n(219)] = -1, this[n(235)] = -1, e !== void 0 && !Array[n(227)](t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e);
  }
  clone() {
    const t = lx;
    return new ym(this[t(233)].slice(), this[t(234)]);
  }
  [ao(217)](t, e, n, i) {
    const s = ao;
    return i < xu(this[s(229)](), t, e) ? i : (this[s(235)] != this[s(230)]() && (this[s(219)] = Math[s(220)](v_(this.flatCoordinates, 0, this[s(233)][s(215)], this[s(232)], 0)), this.maxDeltaRevision_ = this[s(230)]()), __(this[s(233)], 0, this[s(233)][s(215)], this[s(232)], this.maxDelta_, !0, t, e, n, i));
  }
  getArea() {
    const t = ao;
    return I4(this[t(233)], 0, this[t(233)].length, this.stride);
  }
  [ao(223)]() {
    const t = ao;
    return Da(this.flatCoordinates, 0, this[t(233)][t(215)], this[t(232)]);
  }
  getSimplifiedGeometryInternal(t) {
    const e = ao, n = [];
    return n.length = gy(this[e(233)], 0, this.flatCoordinates[e(215)], this[e(232)], t, n, 0), new ym(n, "XY");
  }
  getType() {
    return ao(222);
  }
  [ao(237)](t) {
    return !1;
  }
  [ao(221)](t, e) {
    const n = ao;
    this[n(231)](e, t, 1), !this[n(233)] && (this[n(233)] = []), this[n(233)][n(215)] = dy(this.flatCoordinates, 0, t, this[n(232)]), this.changed();
  }
};
function J1() {
  const r = ["23280090cAmkeV", "getExtent", "getRevision", "setLayout", "stride", "flatCoordinates", "layout", "maxDeltaRevision_", "24FjfJmp", "intersectsExtent", "7685046yatFqH", "241216ihAZiV", "172lQGGxQ", "length", "65215xQRpok", "closestPointXY", "549881IuYeRo", "maxDelta_", "sqrt", "setCoordinates", "LinearRing", "getCoordinates", "14172561CBrGOw", "1132048joPNCU", "7SobLDT", "isArray"];
  return J1 = function() {
    return r;
  }, J1();
}
(function(r, t) {
  const e = Z1, n = r();
  for (; ; )
    try {
      if (-parseInt(e(488)) / 1 * (parseInt(e(498)) / 2) + -parseInt(e(494)) / 3 * (parseInt(e(497)) / 4) + parseInt(e(490)) / 5 + -parseInt(e(492)) / 6 + parseInt(e(489)) / 7 * (parseInt(e(487)) / 8) + -parseInt(e(491)) / 9 * (parseInt(e(493)) / 10) + -parseInt(e(495)) / 11 * (-parseInt(e(499)) / 12) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(K1, 960652);
function Z1(r, t) {
  const e = K1();
  return Z1 = function(n, i) {
    return n = n - 487, e[n];
  }, Z1(r, t);
}
function E4(r, t, e, n, i) {
  const s = Z1;
  let o;
  for (t += n; t < e; t += n)
    if (o = i(r[s(496)](t - n, t), r.slice(t, t + n)), o) return o;
  return !1;
}
function K1() {
  const r = ["568UFIikm", "687YHxKtz", "174713kMfokH", "7314670KFxmXa", "169425xFxfxE", "3806496TneMqt", "730hQhVIG", "9GvUkkR", "3548479UbQqNH", "slice", "2064932QREAEX", "3778oOxVBD", "96nVyxBl"];
  return K1 = function() {
    return r;
  }, K1();
}
(function(r, t) {
  const e = hx, n = r();
  for (; ; )
    try {
      if (parseInt(e(206)) / 1 * (-parseInt(e(219)) / 2) + parseInt(e(214)) / 3 * (-parseInt(e(216)) / 4) + -parseInt(e(215)) / 5 * (-parseInt(e(212)) / 6) + -parseInt(e(218)) / 7 + -parseInt(e(209)) / 8 + -parseInt(e(220)) / 9 * (-parseInt(e(208)) / 10) + parseInt(e(211)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(j1, 711940);
function j1() {
  const r = ["10660490zPYOCT", "3503496NLUetB", "sqrt", "12919225bHfFon", "4140WlfyWL", "slice", "2709UuxyDl", "6920ocHjMe", "3412IkPFnd", "push", "7604093weNWeS", "378098tejzln", "9JhKWWY", "1czygKy", "length"];
  return j1 = function() {
    return r;
  }, j1();
}
function Q1(r, t, e, n, i, s, o) {
  const a = hx;
  let u, x;
  const c = (e - t) / n;
  if (c === 1) u = t;
  else if (c === 2) u = t, x = i;
  else if (c !== 0) {
    let f = r[t], l = r[t + 1], h = 0;
    const p = [0];
    for (let m = t + n; m < e; m += n) {
      const d = r[m], g = r[m + 1];
      h += Math[a(210)]((d - f) * (d - f) + (g - l) * (g - l)), p.push(h), f = d, l = g;
    }
    const y = i * h, v = Y6(p, y);
    v < 0 ? (x = (y - p[-v - 2]) / (p[-v - 1] - p[-v - 2]), u = t + (-v - 2) * n) : u = t + v * n;
  }
  o = o > 1 ? o : 2, s = s || new Array(o);
  for (let f = 0; f < o; ++f)
    s[f] = u === void 0 ? NaN : x === void 0 ? r[u + f] : Yi(r[u + f], r[u + n + f], x);
  return s;
}
function vm(r, t, e, n, i, s) {
  const o = hx;
  if (e == t) return null;
  let a;
  if (i < r[t + n - 1])
    return s ? (a = r.slice(t, t + n), a[n - 1] = i, a) : null;
  if (r[e - 1] < i)
    return s ? (a = r[o(213)](e - n, e), a[n - 1] = i, a) : null;
  if (i == r[t + n - 1]) return r[o(213)](t, t + n);
  let u = t / n, x = e / n;
  for (; u < x; ) {
    const h = u + x >> 1;
    i < r[(h + 1) * n - 1] ? x = h : u = h + 1;
  }
  const c = r[u * n - 1];
  if (i == c) return r[o(213)]((u - 1) * n, (u - 1) * n + n);
  const f = r[(u + 1) * n - 1], l = (i - c) / (f - c);
  a = [];
  for (let h = 0; h < n - 1; ++h)
    a[o(217)](Yi(r[(u - 1) * n + h], r[u * n + h], l));
  return a[o(217)](i), a;
}
function hx(r, t) {
  const e = j1();
  return hx = function(n, i) {
    return n = n - 206, e[n];
  }, hx(r, t);
}
function K8(r, t, e, n, i, s, o) {
  const a = hx;
  if (o) return vm(r, t, e[e.length - 1], n, i, s);
  let u;
  if (i < r[n - 1])
    return s ? (u = r[a(213)](0, n), u[n - 1] = i, u) : null;
  if (r[r[a(207)] - 1] < i)
    return s ? (u = r.slice(r[a(207)] - n), u[n - 1] = i, u) : null;
  for (let x = 0, c = e[a(207)]; x < c; ++x) {
    const f = e[x];
    if (t != f) {
      if (i < r[t + n - 1]) return null;
      if (i <= r[f - 1]) return vm(r, t, f, n, i, !1);
      t = f;
    }
  }
  return null;
}
function lf(r, t) {
  const e = $1();
  return lf = function(n, i) {
    return n = n - 150, e[n];
  }, lf(r, t);
}
(function(r, t) {
  const e = lf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(158)) / 1 * (parseInt(e(152)) / 2) + -parseInt(e(153)) / 3 + parseInt(e(159)) / 4 * (parseInt(e(155)) / 5) + -parseInt(e(161)) / 6 * (-parseInt(e(160)) / 7) + -parseInt(e(150)) / 8 * (-parseInt(e(156)) / 9) + parseInt(e(154)) / 10 + -parseInt(e(151)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})($1, 620730);
function $1() {
  const r = ["5ILhgOV", "18LwvqLC", "length", "6114AbkSbS", "3467700VtTDCq", "7chNaiM", "3665478MCclZX", "3174792qNfsDJ", "18966035YaHINO", "30ZzYZiA", "1936635SPBZKI", "8106340ScJmoF"];
  return $1 = function() {
    return r;
  }, $1();
}
function j8(r, t, e, n, i) {
  return !i4(i, function(o) {
    return !E0(r, t, e, n, o[0], o[1]);
  });
}
function E0(r, t, e, n, i, s) {
  let o = 0, a = r[e - n], u = r[e - n + 1];
  for (; t < e; t += n) {
    const x = r[t], c = r[t + 1];
    u <= s ? c > s && (x - a) * (s - u) - (i - a) * (c - u) > 0 && o++ : c <= s && (x - a) * (s - u) - (i - a) * (c - u) < 0 && o--, a = x, u = c;
  }
  return o !== 0;
}
function w_(r, t, e, n, i, s) {
  const o = lf;
  if (e[o(157)] === 0 || !E0(r, t, e[0], n, i, s)) return !1;
  for (let a = 1, u = e[o(157)]; a < u; ++a)
    if (E0(r, e[a - 1], e[a], n, i, s)) return !1;
  return !0;
}
function Q8(r, t, e, n, i, s) {
  const o = lf;
  if (e[o(157)] === 0) return !1;
  for (let a = 0, u = e[o(157)]; a < u; ++a) {
    const x = e[a];
    if (w_(r, t, x, n, i, s)) return !0;
    t = x[x[o(157)] - 1];
  }
  return !1;
}
(function(r, t) {
  const e = hf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(267)) / 1 + parseInt(e(266)) / 2 + -parseInt(e(268)) / 3 * (parseInt(e(270)) / 4) + parseInt(e(265)) / 5 * (parseInt(e(272)) / 6) + -parseInt(e(269)) / 7 + parseInt(e(264)) / 8 + parseInt(e(273)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(tp, 890736);
function hf(r, t) {
  const e = tp();
  return hf = function(n, i) {
    return n = n - 264, e[n];
  }, hf(r, t);
}
function yy(r, t, e, n, i) {
  const s = r4(Hs(), r, t, e, n);
  return hs(i, s) ? Fu(i, s) || s[0] >= i[0] && s[2] <= i[2] || s[1] >= i[1] && s[3] <= i[3] ? !0 : E4(r, t, e, n, function(o, a) {
    return o8(i, o, a);
  }) : !1;
}
function $8(r, t, e, n, i) {
  for (let s = 0, o = e.length; s < o; ++s) {
    if (yy(r, t, e[s], n, i)) return !0;
    t = e[s];
  }
  return !1;
}
function t9(r, t, e, n, i) {
  return !!(yy(r, t, e, n, i) || E0(r, t, e, n, i[0], i[1]) || E0(r, t, e, n, i[0], i[3]) || E0(r, t, e, n, i[2], i[1]) || E0(r, t, e, n, i[2], i[3]));
}
function S4(r, t, e, n, i) {
  const s = hf;
  if (!t9(r, t, e[0], n, i)) return !1;
  if (e[s(271)] === 1) return !0;
  for (let o = 1, a = e.length; o < a; ++o)
    if (j8(r, e[o - 1], e[o], n, i) && !yy(r, e[o - 1], e[o], n, i))
      return !1;
  return !0;
}
function e9(r, t, e, n, i) {
  const s = hf;
  for (let o = 0, a = e[s(271)]; o < a; ++o) {
    const u = e[o];
    if (S4(r, t, u, n, i)) return !0;
    t = u[u[s(271)] - 1];
  }
  return !1;
}
function tp() {
  const r = ["1928145cXqlYA", "145354xNKVTO", "383040kMDlOw", "6753udMsRc", "2864134xgKGCv", "2348ILbgGW", "length", "6YSPUZx", "19603971HzNQAk", "2942000FdDjqk"];
  return tp = function() {
    return r;
  }, tp();
}
(function(r, t) {
  const e = np, n = r();
  for (; ; )
    try {
      if (parseInt(e(141)) / 1 * (-parseInt(e(139)) / 2) + parseInt(e(143)) / 3 + parseInt(e(138)) / 4 + -parseInt(e(146)) / 5 * (parseInt(e(140)) / 6) + parseInt(e(136)) / 7 * (-parseInt(e(144)) / 8) + -parseInt(e(142)) / 9 + parseInt(e(137)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ep, 547727);
function ep() {
  const r = ["9367443cPQuyO", "415719irgglq", "672584XMXDAf", "sqrt", "86940plALac", "7iPzzCC", "22139450mOZLQQ", "1656308JwhUcq", "24CzGsmE", "6HLgDbk", "89715xMGtsT"];
  return ep = function() {
    return r;
  }, ep();
}
function np(r, t) {
  const e = ep();
  return np = function(n, i) {
    return n = n - 136, e[n];
  }, np(r, t);
}
function C4(r, t, e, n) {
  const i = np;
  let s = r[t], o = r[t + 1], a = 0;
  for (let u = t + n; u < e; u += n) {
    const x = r[u], c = r[u + 1];
    a += Math[i(145)]((x - s) * (x - s) + (c - o) * (c - o)), s = x, o = c;
  }
  return a;
}
const Ln = px;
function rp() {
  const r = ["100299jLXttv", "applyProperties", "getSimplifiedGeometryInternal", "maxDelta_", "getLength", "XYM", "5014488xvzrxi", "getCoordinates", "intersectsExtent", "XYZM", "getExtent", "getRevision", "35tsxpSy", "getFlatMidpoint", "getType", "flatMidpointRevision_", "getCoordinateAtM", "812643KaMklu", "38xutTVA", "1945788nbqksK", "layout", "5494923WfnndF", "getCoordinateAt", "flatMidpoint_", "setCoordinates", "stride", "LineString", "658914KxbGpX", "flatCoordinates", "changed", "length", "slice", "10461708jgaqfl", "clone", "maxDeltaRevision_"];
  return rp = function() {
    return r;
  }, rp();
}
(function(r, t) {
  const e = px, n = r();
  for (; ; )
    try {
      if (parseInt(e(143)) / 1 + parseInt(e(144)) / 2 * (-parseInt(e(161)) / 3) + parseInt(e(145)) / 4 + parseInt(e(138)) / 5 * (parseInt(e(153)) / 6) + parseInt(e(147)) / 7 + -parseInt(e(132)) / 8 + -parseInt(e(158)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(rp, 428362);
function px(r, t) {
  const e = rp();
  return px = function(n, i) {
    return n = n - 131, e[n];
  }, px(r, t);
}
let Ku = class mm extends u0 {
  constructor(t, e) {
    const n = px;
    super(), this[n(149)] = null, this.flatMidpointRevision_ = -1, this[n(164)] = -1, this[n(160)] = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this[n(150)](t, e);
  }
  appendCoordinate(t) {
    const e = px;
    ds(this[e(154)], t), this[e(155)]();
  }
  [Ln(159)]() {
    const t = Ln, e = new mm(this[t(154)][t(157)](), this[t(146)]);
    return e[t(162)](this), e;
  }
  closestPointXY(t, e, n, i) {
    const s = Ln;
    return i < xu(this[s(136)](), t, e) ? i : (this[s(160)] != this[s(137)]() && (this[s(164)] = Math.sqrt(v_(this[s(154)], 0, this[s(154)][s(156)], this[s(151)], 0)), this[s(160)] = this[s(137)]()), __(this[s(154)], 0, this[s(154)][s(156)], this[s(151)], this[s(164)], !1, t, e, n, i));
  }
  forEachSegment(t) {
    const e = Ln;
    return E4(this[e(154)], 0, this.flatCoordinates[e(156)], this[e(151)], t);
  }
  [Ln(142)](t, e) {
    const n = Ln;
    return this[n(146)] != n(131) && this[n(146)] != n(135) ? null : (e = e !== void 0 ? e : !1, vm(this.flatCoordinates, 0, this[n(154)][n(156)], this[n(151)], t, e));
  }
  [Ln(133)]() {
    const t = Ln;
    return Da(this[t(154)], 0, this.flatCoordinates[t(156)], this[t(151)]);
  }
  [Ln(148)](t, e) {
    const n = Ln;
    return Q1(this[n(154)], 0, this[n(154)].length, this[n(151)], t, e, this.stride);
  }
  [Ln(165)]() {
    const t = Ln;
    return C4(this[t(154)], 0, this[t(154)][t(156)], this[t(151)]);
  }
  [Ln(139)]() {
    const t = Ln;
    return this[t(141)] != this[t(137)]() && (this[t(149)] = this[t(148)](0.5, this.flatMidpoint_ ?? void 0), this[t(141)] = this[t(137)]()), this[t(149)];
  }
  [Ln(163)](t) {
    const e = Ln, n = [];
    return n[e(156)] = gy(this[e(154)], 0, this[e(154)][e(156)], this[e(151)], t, n, 0), new mm(n, "XY");
  }
  [Ln(140)]() {
    return Ln(152);
  }
  [Ln(134)](t) {
    const e = Ln;
    return yy(this[e(154)], 0, this.flatCoordinates[e(156)], this[e(151)], t);
  }
  [Ln(150)](t, e) {
    const n = Ln;
    this.setLayout(e, t, 1), !this[n(154)] && (this[n(154)] = []), this[n(154)][n(156)] = dy(this.flatCoordinates, 0, t, this[n(151)]), this[n(155)]();
  }
};
const un = pf;
(function(r, t) {
  const e = pf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(386)) / 1 * (-parseInt(e(375)) / 2) + parseInt(e(358)) / 3 + -parseInt(e(380)) / 4 + -parseInt(e(360)) / 5 * (-parseInt(e(351)) / 6) + parseInt(e(374)) / 7 + -parseInt(e(378)) / 8 * (-parseInt(e(384)) / 9) + parseInt(e(394)) / 10 * (-parseInt(e(391)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ip, 342678);
let M4 = class _m extends u0 {
  constructor(t, e, n) {
    const i = pf;
    if (super(), this.ends_ = [], this[i(359)] = -1, this[i(371)] = -1, Array[i(372)](t[0])) this.setCoordinates(t, e);
    else if (e !== void 0 && n) this.setFlatCoordinates(e, t), this[i(369)] = n;
    else {
      const s = t, o = [], a = [];
      for (let x = 0, c = s[i(388)]; x < c; ++x) {
        const f = s[x];
        ds(o, f[i(354)]()), a[i(366)](o.length);
      }
      const u = s[i(388)] === 0 ? this[i(362)]() : s[0][i(362)]();
      this[i(376)](u, o), this.ends_ = a;
    }
  }
  [un(382)](t) {
    const e = un;
    ds(this[e(390)], t.getFlatCoordinates()[e(363)]()), this.ends_[e(366)](this[e(390)][e(388)]), this[e(367)]();
  }
  [un(381)]() {
    const t = un, e = new _m(this[t(390)][t(363)](), this[t(370)], this[t(369)].slice());
    return e[t(361)](this), e;
  }
  [un(364)](t, e, n, i) {
    const s = un;
    return i < xu(this[s(387)](), t, e) ? i : (this[s(371)] != this[s(353)]() && (this.maxDelta_ = Math[s(392)](m_(this.flatCoordinates, 0, this[s(369)], this.stride, 0)), this[s(371)] = this[s(353)]()), b_(this[s(390)], 0, this[s(369)], this[s(393)], this[s(359)], !1, t, e, n, i));
  }
  getCoordinateAtM(t, e, n) {
    const i = un;
    return this[i(370)] != "XYM" && this[i(370)] != i(357) || this[i(390)].length === 0 ? null : (e = e !== void 0 ? e : !1, n = n !== void 0 ? n : !1, K8(this[i(390)], 0, this[i(369)], this[i(393)], t, e, n));
  }
  [un(373)]() {
    const t = un;
    return cf(this[t(390)], 0, this[t(369)], this[t(393)]);
  }
  [un(356)]() {
    return this.ends_;
  }
  [un(385)](t) {
    const e = un;
    return t < 0 || this[e(369)][e(388)] <= t ? null : new Ku(this[e(390)][e(363)](t === 0 ? 0 : this[e(369)][t - 1], this[e(369)][t]), this[e(370)]);
  }
  [un(352)]() {
    const t = un, e = this[t(390)], n = this[t(369)], i = this.layout, s = [];
    let o = 0;
    for (let a = 0, u = n[t(388)]; a < u; ++a) {
      const x = n[a], c = new Ku(e[t(363)](o, x), i);
      s.push(c), o = x;
    }
    return s;
  }
  [un(355)]() {
    const t = un, e = [], n = this[t(390)];
    let i = 0;
    const s = this[t(369)], o = this[t(393)];
    for (let a = 0, u = s[t(388)]; a < u; ++a) {
      const x = s[a], c = Q1(n, i, x, o, 0.5);
      ds(e, c), i = x;
    }
    return e;
  }
  [un(377)](t) {
    const e = un, n = [], i = [];
    return n[e(388)] = b4(this.flatCoordinates, 0, this.ends_, this[e(393)], t, n, 0, i), new _m(n, "XY", i);
  }
  [un(389)]() {
    return un(368);
  }
  [un(365)](t) {
    const e = un;
    return $8(this[e(390)], 0, this[e(369)], this[e(393)], t);
  }
  [un(379)](t, e) {
    const n = un;
    this[n(383)](e, t, 2), !this[n(390)] && (this.flatCoordinates = []);
    const i = y_(this.flatCoordinates, 0, t, this[n(393)], this[n(369)]);
    this[n(390)][n(388)] = i[n(388)] === 0 ? 0 : i[i[n(388)] - 1], this[n(367)]();
  }
};
function pf(r, t) {
  const e = ip();
  return pf = function(n, i) {
    return n = n - 351, e[n];
  }, pf(r, t);
}
function ip() {
  const r = ["196488dbuExS", "getLineString", "4visgzf", "getExtent", "length", "getType", "flatCoordinates", "18436YVIAzP", "sqrt", "stride", "6140gzBfBt", "3540FQYhLL", "getLineStrings", "getRevision", "getFlatCoordinates", "getFlatMidpoints", "getEnds", "XYZM", "1799064zeSLXu", "maxDelta_", "95FYnIoO", "applyProperties", "getLayout", "slice", "closestPointXY", "intersectsExtent", "push", "changed", "MultiLineString", "ends_", "layout", "maxDeltaRevision_", "isArray", "getCoordinates", "1387239cVZqSC", "298318cTYCTE", "setFlatCoordinates", "getSimplifiedGeometryInternal", "216ykmecV", "setCoordinates", "2493732vbMTnr", "clone", "appendLineString", "setLayout"];
  return ip = function() {
    return r;
  }, ip();
}
const ss = df;
function sp() {
  const r = ["length", "changed", "intersectsExtent", "slice", "closestPointXY", "5BMlQLd", "layout", "634416jxXjPZ", "applyProperties", "1319115okVzCM", "14303280jmnqOE", "computeExtent", "getType", "clone", "18CHCuJd", "56077NZIwHk", "Point", "setCoordinates", "461096pOTgPt", "233814ZFGfmz", "1845441AHkWDn", "setLayout", "12IwPJFV", "stride", "flatCoordinates"];
  return sp = function() {
    return r;
  }, sp();
}
(function(r, t) {
  const e = df, n = r();
  for (; ; )
    try {
      if (parseInt(e(273)) / 1 * (-parseInt(e(272)) / 2) + -parseInt(e(267)) / 3 + -parseInt(e(276)) / 4 * (parseInt(e(288)) / 5) + -parseInt(e(280)) / 6 * (-parseInt(e(277)) / 7) + parseInt(e(290)) / 8 + -parseInt(e(278)) / 9 + parseInt(e(268)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(sp, 311713);
function df(r, t) {
  const e = sp();
  return df = function(n, i) {
    return n = n - 266, e[n];
  }, df(r, t);
}
let tr = class P4 extends u0 {
  constructor(t, e) {
    const n = df;
    super(), this[n(275)](t, e);
  }
  [ss(271)]() {
    const t = ss, e = new P4(this[t(282)][t(286)](), this[t(289)]);
    return e[t(266)](this), e;
  }
  [ss(287)](t, e, n, i) {
    const s = ss, o = this[s(282)], a = $o(t, e, o[0], o[1]);
    if (a < i) {
      const u = this[s(281)];
      for (let x = 0; x < u; ++x)
        n[x] = o[x];
      return n[s(283)] = u, a;
    }
    return i;
  }
  getCoordinates() {
    return this[ss(282)].slice();
  }
  [ss(269)](t) {
    return zc(this.flatCoordinates, t);
  }
  [ss(270)]() {
    return ss(274);
  }
  [ss(285)](t) {
    const e = ss;
    return f_(t, this[e(282)][0], this[e(282)][1]);
  }
  [ss(275)](t, e) {
    const n = ss;
    this[n(279)](e, t, 0), !this.flatCoordinates && (this[n(282)] = []), this[n(282)].length = v4(this[n(282)], 0, t, this.stride), this[n(284)]();
  }
};
function op() {
  const r = ["setCoordinates", "layout", "345002ICyoeG", "setFlatCoordinates", "2818837VfXNwS", "1331800PShNRA", "1752834UeqAVZ", "applyProperties", "appendPoint", "getFlatCoordinates", "123aZwidX", "MultiPoint", "slice", "length", "getCoordinates", "381291MKBWzj", "stride", "closestPointXY", "getPoint", "push", "intersectsExtent", "getExtent", "37588pOwtSk", "clone", "flatCoordinates", "setLayout", "633570BBbtWs", "changed", "getType"];
  return op = function() {
    return r;
  }, op();
}
const Pr = gf;
(function(r, t) {
  const e = gf, n = r();
  for (; ; )
    try {
      if (parseInt(e(476)) / 1 + -parseInt(e(492)) / 2 + parseInt(e(500)) / 3 * (-parseInt(e(483)) / 4) + -parseInt(e(487)) / 5 + parseInt(e(496)) / 6 + parseInt(e(494)) / 7 + -parseInt(e(495)) / 8 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(op, 225154);
function gf(r, t) {
  const e = op();
  return gf = function(n, i) {
    return n = n - 475, e[n];
  }, gf(r, t);
}
let L4 = class N4 extends u0 {
  constructor(t, e) {
    const n = gf;
    super(), e && !Array.isArray(t[0]) ? this[n(493)](e, t) : this[n(490)](t, e);
  }
  [Pr(498)](t) {
    const e = Pr;
    ds(this.flatCoordinates, t[e(499)]()), this[e(488)]();
  }
  [Pr(484)]() {
    const t = Pr, e = new N4(this[t(485)][t(502)](), this[t(491)]);
    return e[t(497)](this), e;
  }
  [Pr(478)](t, e, n, i) {
    const s = Pr;
    if (i < xu(this[s(482)](), t, e)) return i;
    const o = this[s(485)], a = this[s(477)];
    for (let u = 0, x = o[s(503)]; u < x; u += a) {
      const c = $o(t, e, o[u], o[u + 1]);
      if (c < i) {
        i = c;
        for (let f = 0; f < a; ++f)
          n[f] = o[u + f];
        n[s(503)] = a;
      }
    }
    return i;
  }
  [Pr(475)]() {
    const t = Pr;
    return Da(this[t(485)], 0, this[t(485)][t(503)], this[t(477)]);
  }
  [Pr(479)](t) {
    const e = Pr, n = this[e(485)][e(503)] / this[e(477)];
    return t < 0 || n <= t ? null : new tr(this[e(485)][e(502)](t * this.stride, (t + 1) * this.stride), this[e(491)]);
  }
  getPoints() {
    const t = Pr, e = this.flatCoordinates, n = this[t(491)], i = this[t(477)], s = [];
    for (let o = 0, a = e.length; o < a; o += i) {
      const u = new tr(e[t(502)](o, o + i), n);
      s[t(480)](u);
    }
    return s;
  }
  [Pr(489)]() {
    return Pr(501);
  }
  [Pr(481)](t) {
    const e = Pr, n = this[e(485)], i = this[e(477)];
    for (let s = 0, o = n[e(503)]; s < o; s += i) {
      const a = n[s], u = n[s + 1];
      if (f_(t, a, u)) return !0;
    }
    return !1;
  }
  [Pr(490)](t, e) {
    const n = Pr;
    this[n(486)](e, t, 1), !this.flatCoordinates && (this[n(485)] = []), this.flatCoordinates[n(503)] = dy(this[n(485)], 0, t, this[n(477)]), this[n(488)]();
  }
};
(function(r, t) {
  const e = ap, n = r();
  for (; ; )
    try {
      if (-parseInt(e(290)) / 1 + -parseInt(e(299)) / 2 + -parseInt(e(294)) / 3 * (-parseInt(e(291)) / 4) + parseInt(e(298)) / 5 + parseInt(e(297)) / 6 * (-parseInt(e(300)) / 7) + parseInt(e(296)) / 8 * (-parseInt(e(295)) / 9) + parseInt(e(301)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(up, 263486);
function ap(r, t) {
  const e = up();
  return ap = function(n, i) {
    return n = n - 290, e[n];
  }, ap(r, t);
}
function up() {
  const r = ["7899360hsMePH", "push", "235049VqwDQQ", "357476sYcOFb", "length", "sort", "9ZHrsiI", "63MGPiap", "354056KllbDt", "29478sazKor", "714845FmRAaB", "579010DGMgGJ", "147LaYiSp"];
  return up = function() {
    return r;
  }, up();
}
function E_(r, t, e, n, i, s, o) {
  const a = ap;
  let u, x, c, f, l, h, p;
  const y = i[s + 1], v = [];
  for (let g = 0, _ = e[a(292)]; g < _; ++g) {
    const b = e[g];
    for (f = r[b - n], h = r[b - n + 1], u = t; u < b; u += n)
      l = r[u], p = r[u + 1], (y <= h && p <= y || h <= y && y <= p) && (c = (y - h) / (p - h) * (l - f) + f, v[a(302)](c)), f = l, h = p;
  }
  let m = NaN, d = -1 / 0;
  for (v[a(293)](P0), f = v[0], u = 1, x = v[a(292)]; u < x; ++u) {
    l = v[u];
    const g = Math.abs(l - f);
    g > d && (c = (f + l) / 2, w_(r, t, e, n, c, y) && (m = c, d = g)), f = l;
  }
  return isNaN(m) && (m = i[s]), o ? (o[a(302)](m, y, d), o) : [m, y, d];
}
function O4(r, t, e, n, i) {
  let s = [];
  for (let o = 0, a = e.length; o < a; ++o) {
    const u = e[o];
    s = E_(r, t, u, n, i, 2 * o, s), t = u[u.length - 1];
  }
  return s;
}
function n9(r, t, e, n) {
  for (; t < e - n; ) {
    for (let i = 0; i < n; ++i) {
      const s = r[t + i];
      r[t + i] = r[e - n + i], r[e - n + i] = s;
    }
    t += n, e -= n;
  }
}
(function(r, t) {
  const e = D0, n = r();
  for (; ; )
    try {
      if (-parseInt(e(389)) / 1 * (-parseInt(e(384)) / 2) + parseInt(e(385)) / 3 * (parseInt(e(382)) / 4) + parseInt(e(391)) / 5 + parseInt(e(383)) / 6 + -parseInt(e(390)) / 7 + parseInt(e(388)) / 8 + -parseInt(e(387)) / 9 * (parseInt(e(381)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(xp, 436496);
function D0(r, t) {
  const e = xp();
  return D0 = function(n, i) {
    return n = n - 380, e[n];
  }, D0(r, t);
}
function S_(r, t, e, n) {
  let i = 0, s = r[e - n], o = r[e - n + 1];
  for (; t < e; t += n) {
    const a = r[t], u = r[t + 1];
    i += (a - s) * (u + o), s = a, o = u;
  }
  return i === 0 ? void 0 : i > 0;
}
function R4(r, t, e, n, i) {
  const s = D0;
  i = i !== void 0 ? i : !1;
  for (let o = 0, a = e[s(380)]; o < a; ++o) {
    const u = e[o], x = S_(r, t, u, n);
    if (o === 0) {
      if (i && x || !i && !x) return !1;
    } else if (i && !x || !i && x) return !1;
    t = u;
  }
  return !0;
}
function r9(r, t, e, n, i) {
  const s = D0;
  for (let o = 0, a = e[s(380)]; o < a; ++o) {
    const u = e[o];
    if (!R4(r, t, u, n, i)) return !1;
    u[s(380)] && (t = u[u[s(380)] - 1]);
  }
  return !0;
}
function bm(r, t, e, n, i) {
  const s = D0;
  i = i !== void 0 ? i : !1;
  for (let o = 0, a = e[s(380)]; o < a; ++o) {
    const u = e[o], x = S_(r, t, u, n);
    (o === 0 ? i && x || !i && !x : i && !x || !i && x) && n9(r, t, u, n), t = u;
  }
  return t;
}
function Mb(r, t, e, n, i) {
  for (let s = 0, o = e.length; s < o; ++s)
    t = bm(r, t, e[s], n, i);
  return t;
}
function i9(r, t) {
  const e = D0, n = [];
  let i = 0, s = 0, o;
  for (let a = 0, u = t.length; a < u; ++a) {
    const x = t[a], c = S_(r, i, x, 2);
    if (o === void 0 && (o = c), c === o) n[e(386)](t.slice(s, a + 1));
    else {
      if (n[e(380)] === 0) continue;
      n[n[e(380)] - 1][e(386)](t[s]);
    }
    s = a + 1, i = x;
  }
  return n;
}
function xp() {
  const r = ["2337350vUFBjK", "length", "7044880FGxyhV", "4EvnKWd", "1854420SSmBgf", "10492XOyCoq", "69159SZpzbe", "push", "9GVNjXm", "3734168SkgLqf", "69aEesgI", "3411478fjJrcQ"];
  return xp = function() {
    return r;
  }, xp();
}
function yf(r, t) {
  const e = cp();
  return yf = function(n, i) {
    return n = n - 343, e[n];
  }, yf(r, t);
}
const Ne = yf;
(function(r, t) {
  const e = yf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(346)) / 1 * (parseInt(e(349)) / 2) + -parseInt(e(366)) / 3 * (parseInt(e(358)) / 4) + parseInt(e(383)) / 5 + parseInt(e(371)) / 6 + -parseInt(e(386)) / 7 + -parseInt(e(355)) / 8 * (-parseInt(e(359)) / 9) + parseInt(e(354)) / 10 * (-parseInt(e(381)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(cp, 960616);
function cp() {
  const r = ["length", "stride", "51tLUDDZ", "containsXY", "setCoordinates", "flatInteriorPointRevision_", "closestPointXY", "9095400yUbgPb", "getCoordinates", "applyProperties", "layout", "getLinearRingCount", "getFlatInteriorPoint", "getRevision", "changed", "cos", "push", "9972061cyzMnA", "orientedRevision_", "9483410dUVtwu", "getArea", "ends_", "1080289RacetV", "setLayout", "getCenter", "Polygon", "flatCoordinates", "slice", "getLinearRings", "getRadius", "getSimplifiedGeometryInternal", "maxDeltaRevision_", "flatInteriorPoint_", "setFlatCoordinates", "1atDDiz", "Cannot create polygon from empty extent", "clone", "2223190Hsvafp", "orientedFlatCoordinates_", "getExtent", "getLayout", "maxDelta_", "30YgBmwV", "61312aYddWx", "sqrt", "getOrientedFlatCoordinates", "14236BKWAFW", "1872UbHmgk", "appendLinearRing", "XYM", "getFlatCoordinates", "getInteriorPoint"];
  return cp = function() {
    return r;
  }, cp();
}
let F0 = class Im extends u0 {
  constructor(t, e, n) {
    const i = yf;
    super(), this[i(385)] = [], this[i(369)] = -1, this[i(344)] = null, this[i(353)] = -1, this[i(343)] = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, e !== void 0 && n ? (this[i(345)](e, t), this.ends_ = n) : this[i(368)](t, e);
  }
  [Ne(360)](t) {
    const e = Ne;
    this[e(390)] ? ds(this[e(390)], t[e(362)]()) : this.flatCoordinates = t.getFlatCoordinates()[e(391)](), this[e(385)][e(380)](this[e(390)][e(364)]), this[e(378)]();
  }
  [Ne(348)]() {
    const t = Ne, e = new Im(this[t(390)][t(391)](), this[t(374)], this[t(385)].slice());
    return e[t(373)](this), e;
  }
  [Ne(370)](t, e, n, i) {
    const s = Ne;
    return i < xu(this[s(351)](), t, e) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this[s(353)] = Math[s(356)](m_(this[s(390)], 0, this[s(385)], this[s(365)], 0)), this[s(343)] = this[s(377)]()), b_(this[s(390)], 0, this[s(385)], this.stride, this.maxDelta_, !0, t, e, n, i));
  }
  [Ne(367)](t, e) {
    const n = Ne;
    return w_(this[n(357)](), 0, this[n(385)], this[n(365)], t, e);
  }
  [Ne(384)]() {
    const t = Ne;
    return w4(this[t(357)](), 0, this[t(385)], this[t(365)]);
  }
  [Ne(372)](t) {
    const e = Ne;
    let n;
    return t !== void 0 ? (n = this.getOrientedFlatCoordinates()[e(391)](), bm(n, 0, this[e(385)], this[e(365)], t)) : n = this.flatCoordinates, cf(n, 0, this[e(385)], this.stride);
  }
  getEnds() {
    return this[Ne(385)];
  }
  getFlatInteriorPoint() {
    const t = Ne;
    if (this[t(369)] != this[t(377)]()) {
      const e = ua(this[t(351)]());
      this.flatInteriorPoint_ = E_(this[t(357)](), 0, this.ends_, this[t(365)], e, 0), this[t(369)] = this[t(377)]();
    }
    return this[t(344)];
  }
  [Ne(363)]() {
    const t = Ne;
    return new tr(this[t(376)](), t(361));
  }
  [Ne(375)]() {
    return this.ends_.length;
  }
  getLinearRing(t) {
    const e = Ne;
    return t < 0 || this[e(385)][e(364)] <= t ? null : new Cb(this[e(390)][e(391)](t === 0 ? 0 : this[e(385)][t - 1], this[e(385)][t]), this[e(374)]);
  }
  [Ne(392)]() {
    const t = Ne, e = this[t(374)], n = this[t(390)], i = this[t(385)], s = [];
    let o = 0;
    for (let a = 0, u = i[t(364)]; a < u; ++a) {
      const x = i[a], c = new Cb(n[t(391)](o, x), e);
      s[t(380)](c), o = x;
    }
    return s;
  }
  [Ne(357)]() {
    const t = Ne;
    if (this.orientedRevision_ != this[t(377)]()) {
      const e = this.flatCoordinates;
      R4(e, 0, this[t(385)], this.stride) ? this[t(350)] = e : (this.orientedFlatCoordinates_ = e.slice(), this[t(350)][t(364)] = bm(this.orientedFlatCoordinates_, 0, this[t(385)], this[t(365)])), this[t(382)] = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  [Ne(394)](t) {
    const e = Ne, n = [], i = [];
    return n[e(364)] = I_(this[e(390)], 0, this[e(385)], this[e(365)], Math[e(356)](t), n, 0, i), new Im(n, "XY", i);
  }
  getType() {
    return Ne(389);
  }
  intersectsExtent(t) {
    const e = Ne;
    return S4(this[e(357)](), 0, this[e(385)], this[e(365)], t);
  }
  [Ne(368)](t, e) {
    const n = Ne;
    this[n(387)](e, t, 2), !this.flatCoordinates && (this[n(390)] = []);
    const i = y_(this[n(390)], 0, t, this[n(365)], this.ends_);
    this.flatCoordinates.length = i[n(364)] === 0 ? 0 : i[i[n(364)] - 1], this[n(378)]();
  }
};
function Gu(r) {
  const t = Ne;
  if (x4(r)) throw new Error(t(347));
  const e = r[0], n = r[1], i = r[2], s = r[3], o = [e, n, e, s, i, s, i, n, e, n];
  return new F0(o, "XY", [o[t(364)]]);
}
function s9(r, t, e) {
  const n = Ne;
  t = t || 32;
  const i = r.getStride(), s = r[n(352)](), o = r[n(388)](), a = i * (t + 1), u = new Array(a);
  for (let f = 0; f < a; f += i) {
    u[f] = 0, u[f + 1] = 0;
    for (let l = 2; l < i; l++)
      u[f + l] = o[l];
  }
  const x = [u[n(364)]], c = new F0(u, s, x);
  return o9(c, o, r[n(393)]()), c;
}
function o9(r, t, e, n) {
  const i = Ne, s = r[i(362)](), o = r.getStride(), a = s[i(364)] / o - 1, u = 0;
  for (let x = 0; x <= a; ++x) {
    const c = x * o, f = u + hm(x, a) * 2 * Math.PI / a;
    s[c] = t[0] + e * Math[i(379)](f), s[c + 1] = t[1] + e * Math.sin(f);
  }
  r[i(378)]();
}
function fp(r, t) {
  const e = lp();
  return fp = function(n, i) {
    return n = n - 285, e[n];
  }, fp(r, t);
}
(function(r, t) {
  const e = fp, n = r();
  for (; ; )
    try {
      if (-parseInt(e(286)) / 1 * (parseInt(e(294)) / 2) + -parseInt(e(288)) / 3 * (-parseInt(e(291)) / 4) + parseInt(e(298)) / 5 * (-parseInt(e(287)) / 6) + -parseInt(e(289)) / 7 * (-parseInt(e(285)) / 8) + -parseInt(e(296)) / 9 * (-parseInt(e(295)) / 10) + -parseInt(e(299)) / 11 * (-parseInt(e(297)) / 12) + -parseInt(e(293)) / 13 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(lp, 695213);
function A4(r, t, e, n) {
  const i = fp, s = [];
  let o = Hs();
  for (let a = 0, u = e[i(292)]; a < u; ++a) {
    const x = e[a];
    o = h_(r, t, x[0], n), s[i(290)]((o[0] + o[2]) / 2, (o[1] + o[3]) / 2), t = x[x[i(292)] - 1];
  }
  return s;
}
function lp() {
  const r = ["261565FfMQxq", "451sptyoF", "7280528IlkaJM", "1315231WDpYMo", "12TllhYA", "1077507YGhvuc", "7JzIdjC", "push", "12rCOPfW", "length", "31294757gMjpsp", "2KldhFV", "105170LExVGg", "1143LwGJep", "350964zOyKwL"];
  return lp = function() {
    return r;
  }, lp();
}
const Ue = vf;
(function(r, t) {
  const e = vf, n = r();
  for (; ; )
    try {
      if (parseInt(e(239)) / 1 * (-parseInt(e(238)) / 2) + parseInt(e(228)) / 3 * (parseInt(e(232)) / 4) + parseInt(e(245)) / 5 * (parseInt(e(252)) / 6) + -parseInt(e(241)) / 7 * (parseInt(e(253)) / 8) + parseInt(e(260)) / 9 + -parseInt(e(235)) / 10 + -parseInt(e(227)) / 11 * (parseInt(e(240)) / 12) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(hp, 686554);
function hp() {
  const r = ["2605fSiwap", "getArea", "maxDeltaRevision_", "flatCoordinates", "flatInteriorPointsRevision_", "maxDelta_", "getEndss", "9498cxKcph", "64RYzscy", "MultiPolygon", "XYM", "stride", "getOrientedFlatCoordinates", "getType", "appendPolygon", "11718990CwtzvI", "length", "sqrt", "endss_", "getFlatInteriorPoints", "getRevision", "orientedRevision_", "layout", "changed", "applyProperties", "setCoordinates", "containsXY", "closestPointXY", "getExtent", "1100RszEvW", "17193OLVuzU", "getEnds", "slice", "intersectsExtent", "28zCIRMl", "push", "setLayout", "3494030kjxsZm", "getFlatCoordinates", "orientedFlatCoordinates_", "26iKnHBN", "60757LfpHiT", "22764GDnoqt", "132538dRqxOC", "getLayout", "flatInteriorPoints_", "getSimplifiedGeometryInternal"];
  return hp = function() {
    return r;
  }, hp();
}
function vf(r, t) {
  const e = hp();
  return vf = function(n, i) {
    return n = n - 214, e[n];
  }, vf(r, t);
}
let T4 = class wm extends u0 {
  constructor(t, e, n) {
    const i = vf;
    if (super(), this[i(216)] = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this[i(250)] = -1, this[i(247)] = -1, this[i(219)] = -1, this[i(237)] = null, !n && !Array.isArray(t[0])) {
      const s = t, o = [], a = [];
      for (let u = 0, x = s[i(214)]; u < x; ++u) {
        const c = s[u], f = o.length, l = c[i(229)]();
        for (let h = 0, p = l[i(214)]; h < p; ++h)
          l[h] += f;
        ds(o, c[i(236)]()), a[i(233)](l);
      }
      e = s.length === 0 ? this.getLayout() : s[0][i(242)](), t = o, n = a;
    }
    e !== void 0 && n ? (this.setFlatCoordinates(e, t), this[i(216)] = n) : this[i(223)](t, e);
  }
  [Ue(259)](t) {
    const e = Ue;
    let n;
    if (!this[e(248)]) this[e(248)] = t[e(236)]()[e(230)](), n = t.getEnds()[e(230)](), this[e(216)][e(233)]();
    else {
      const i = this[e(248)][e(214)];
      ds(this.flatCoordinates, t[e(236)]()), n = t[e(229)]()[e(230)]();
      for (let s = 0, o = n.length; s < o; ++s)
        n[s] += i;
    }
    this[e(216)].push(n), this[e(221)]();
  }
  clone() {
    const t = Ue, e = this[t(216)][t(214)], n = new Array(e);
    for (let s = 0; s < e; ++s)
      n[s] = this[t(216)][s][t(230)]();
    const i = new wm(this[t(248)].slice(), this.layout, n);
    return i[t(222)](this), i;
  }
  [Ue(225)](t, e, n, i) {
    const s = Ue;
    return i < xu(this[s(226)](), t, e) ? i : (this[s(247)] != this[s(218)]() && (this[s(250)] = Math[s(215)](V8(this[s(248)], 0, this[s(216)], this[s(256)], 0)), this.maxDeltaRevision_ = this[s(218)]()), W8(this[s(257)](), 0, this[s(216)], this.stride, this[s(250)], !0, t, e, n, i));
  }
  [Ue(224)](t, e) {
    const n = Ue;
    return Q8(this[n(257)](), 0, this[n(216)], this[n(256)], t, e);
  }
  [Ue(246)]() {
    const t = Ue;
    return Z8(this[t(257)](), 0, this.endss_, this[t(256)]);
  }
  getCoordinates(t) {
    const e = Ue;
    let n;
    return t !== void 0 ? (n = this[e(257)]()[e(230)](), Mb(n, 0, this[e(216)], this.stride, t)) : n = this[e(248)], gm(n, 0, this[e(216)], this[e(256)]);
  }
  [Ue(251)]() {
    return this[Ue(216)];
  }
  [Ue(217)]() {
    const t = Ue;
    if (this[t(249)] != this[t(218)]()) {
      const e = A4(this.flatCoordinates, 0, this[t(216)], this[t(256)]);
      this[t(243)] = O4(this[t(257)](), 0, this[t(216)], this[t(256)], e), this[t(249)] = this[t(218)]();
    }
    return this[t(243)];
  }
  getInteriorPoints() {
    const t = Ue;
    return new L4(this[t(217)]()[t(230)](), t(255));
  }
  [Ue(257)]() {
    const t = Ue;
    if (this[t(219)] != this[t(218)]()) {
      const e = this[t(248)];
      r9(e, 0, this[t(216)], this[t(256)]) ? this[t(237)] = e : (this.orientedFlatCoordinates_ = e[t(230)](), this[t(237)].length = Mb(this[t(237)], 0, this[t(216)], this.stride)), this[t(219)] = this.getRevision();
    }
    return this[t(237)];
  }
  [Ue(244)](t) {
    const e = Ue, n = [], i = [];
    return n[e(214)] = J8(this[e(248)], 0, this[e(216)], this[e(256)], Math[e(215)](t), n, 0, i), new wm(n, "XY", i);
  }
  getPolygon(t) {
    const e = Ue;
    if (t < 0 || this[e(216)].length <= t) return null;
    let n;
    if (t === 0) n = 0;
    else {
      const o = this.endss_[t - 1];
      n = o[o.length - 1];
    }
    const i = this[e(216)][t].slice(), s = i[i[e(214)] - 1];
    if (n !== 0) for (let o = 0, a = i[e(214)]; o < a; ++o)
      i[o] -= n;
    return new F0(this[e(248)][e(230)](n, s), this[e(220)], i);
  }
  getPolygons() {
    const t = Ue, e = this[t(220)], n = this[t(248)], i = this.endss_, s = [];
    let o = 0;
    for (let a = 0, u = i[t(214)]; a < u; ++a) {
      const x = i[a].slice(), c = x[x[t(214)] - 1];
      if (o !== 0) for (let l = 0, h = x[t(214)]; l < h; ++l)
        x[l] -= o;
      const f = new F0(n[t(230)](o, c), e, x);
      s[t(233)](f), o = c;
    }
    return s;
  }
  [Ue(258)]() {
    return Ue(254);
  }
  [Ue(231)](t) {
    return e9(this[Ue(257)](), 0, this.endss_, this.stride, t);
  }
  [Ue(223)](t, e) {
    const n = Ue;
    this[n(234)](e, t, 3), !this.flatCoordinates && (this[n(248)] = []);
    const i = z8(this[n(248)], 0, t, this[n(256)], this.endss_);
    if (i[n(214)] === 0) this[n(248)][n(214)] = 0;
    else {
      const s = i[i[n(214)] - 1];
      this[n(248)][n(214)] = s[n(214)] === 0 ? 0 : s[s[n(214)] - 1];
    }
    this[n(221)]();
  }
};
const Ye = dx;
(function(r, t) {
  const e = dx, n = r();
  for (; ; )
    try {
      if (-parseInt(e(382)) / 1 + -parseInt(e(345)) / 2 + -parseInt(e(348)) / 3 * (parseInt(e(356)) / 4) + parseInt(e(368)) / 5 * (parseInt(e(371)) / 6) + parseInt(e(363)) / 7 + -parseInt(e(362)) / 8 + parseInt(e(361)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(pp, 744592);
function dx(r, t) {
  const e = pp();
  return dx = function(n, i) {
    return n = n - 340, e[n];
  }, dx(r, t);
}
function pp() {
  const r = ["setGeometry", "setGeometryName", "getStyleFunction", "MultiPoint", "Polygon", "2470616CZvPVC", "getSimplifiedGeometry", "get", "1652289SPiVJu", "id_", "getEnds", "ends_", "getWorldExtent", "setId", "getFlatMidpoint", "getType", "4FIEbVl", "getPropertiesInternal", "setProperties", "getProperties", "getId", "26874153tooBde", "7522088XOwboD", "6419637UpgyeX", "squaredTolerance_", "transform", "length", "flatCoordinates_", "1494695RKJJTL", "getOrientedFlatCoordinates", "clone", "6RADgCO", "extent_", "getFlatCoordinates", "flatInteriorPoints_", "Point", "MultiLineString", "simplifyTransformed", "stride_", "slice", "type_", "applyTransform", "731123UYVIdo", "styleFunction", "simplifiedGeometry_", "assign", "properties_", "flatMidpoints_", "LineString", "getExtent"];
  return pp = function() {
    return r;
  }, pp();
}
const Pb = Qo();
class Xs {
  constructor(t, e, n, i, s, o) {
    const a = dx;
    this[a(383)], this[a(372)], this[a(349)] = o, this[a(380)] = t, this[a(367)] = e, this[a(374)] = null, this.flatMidpoints_ = null, this[a(351)] = n || null, this.properties_ = s, this[a(364)], this[a(378)] = i, this[a(384)];
  }
  [Ye(347)](t) {
    return this[Ye(386)][t];
  }
  [Ye(389)]() {
    const t = Ye;
    return !this[t(372)] && (this.extent_ = this.type_ === t(375) ? zc(this[t(367)]) : h_(this[t(367)], 0, this[t(367)].length, 2)), this.extent_;
  }
  getFlatInteriorPoint() {
    const t = Ye;
    if (!this[t(374)]) {
      const e = ua(this[t(389)]());
      this[t(374)] = E_(this.flatCoordinates_, 0, this[t(351)], 2, e, 0);
    }
    return this[t(374)];
  }
  getFlatInteriorPoints() {
    const t = Ye;
    if (!this[t(374)]) {
      const e = i9(this[t(367)], this[t(351)]), n = A4(this[t(367)], 0, e, 2);
      this[t(374)] = O4(this.flatCoordinates_, 0, e, 2, n);
    }
    return this.flatInteriorPoints_;
  }
  [Ye(354)]() {
    const t = Ye;
    return !this[t(387)] && (this.flatMidpoints_ = Q1(this.flatCoordinates_, 0, this[t(367)][t(366)], 2, 0.5)), this[t(387)];
  }
  getFlatMidpoints() {
    const t = Ye;
    if (!this[t(387)]) {
      this[t(387)] = [];
      const e = this[t(367)];
      let n = 0;
      const i = this[t(351)];
      for (let s = 0, o = i[t(366)]; s < o; ++s) {
        const a = i[s], u = Q1(e, n, a, 2, 0.5);
        ds(this[t(387)], u), n = a;
      }
    }
    return this[t(387)];
  }
  getId() {
    return this[Ye(349)];
  }
  [Ye(369)]() {
    return this[Ye(367)];
  }
  getGeometry() {
    return this;
  }
  [Ye(346)](t) {
    return this;
  }
  [Ye(377)](t, e) {
    return this;
  }
  getProperties() {
    return this[Ye(386)];
  }
  [Ye(357)]() {
    return this.properties_;
  }
  getStride() {
    return this.stride_;
  }
  [Ye(342)]() {
    return this.styleFunction;
  }
  [Ye(355)]() {
    return this[Ye(380)];
  }
  [Ye(365)](t) {
    const e = Ye;
    t = R0(t);
    const n = t[e(389)](), i = t[e(352)]();
    if (n && i) {
      const s = xa(i) / xa(n);
      O0(Pb, i[0], i[3], s, -s, 0, 0, 0), Ga(this[e(367)], 0, this.flatCoordinates_[e(366)], 2, Pb, this.flatCoordinates_);
    }
  }
  applyTransform(t) {
    const e = Ye;
    t(this[e(367)], this[e(367)], this[e(378)]);
  }
  [Ye(370)]() {
    var e;
    const t = Ye;
    return new Xs(this[t(380)], this[t(367)][t(379)](), (e = this[t(351)]) == null ? void 0 : e[t(379)](), this[t(378)], Object[t(385)]({}, this[t(386)]), this[t(349)]);
  }
  [Ye(350)]() {
    return this[Ye(351)];
  }
  enableSimplifyTransformed() {
    return this.simplifyTransformed = Q3((t, e) => {
      const n = dx;
      if (t === this.squaredTolerance_) return this[n(384)];
      this[n(384)] = this.clone(), e && this[n(384)][n(381)](e);
      const i = this[n(384)].getFlatCoordinates();
      let s;
      switch (this.type_) {
        case n(388):
          i.length = gy(i, 0, this.simplifiedGeometry_.flatCoordinates_[n(366)], this.simplifiedGeometry_.stride_, t, i, 0), s = [i.length];
          break;
        case n(376):
          s = [], i.length = b4(i, 0, this.simplifiedGeometry_.ends_, this[n(384)][n(378)], t, i, 0, s);
          break;
        case n(344):
          s = [], i[n(366)] = I_(i, 0, this[n(384)].ends_, this.simplifiedGeometry_[n(378)], Math.sqrt(t), i, 0, s);
          break;
      }
      return s && (this[n(384)] = new Xs(this[n(380)], i, s, 2, this.properties_, this[n(349)])), this[n(364)] = t, this[n(384)];
    }), this;
  }
}
Xs.prototype[Ye(373)] = Xs.prototype[Ye(369)];
const Lr = mf;
function dp() {
  const r = ["viewPromise_", "ready", "state", "refresh", "getState", "158475OnhLCt", "attributionsCollapsible_", "5438792YTIUKk", "717704qvFTru", "isArray", "state_", "viewResolver", "17536145aVbSMY", "9CjHDWR", "10IAVZWS", "getAttributionsCollapsible", "attributions_", "changed", "275174avXImb", "getInterpolate", "5615484ieFSDL", "36LWTLDa", "getView", "attributionsCollapsible", "7JJZCwy", "loading", "wrapX_", "getAttributions", "753933EXPFHB", "projection", "wrapX", "interpolate_"];
  return dp = function() {
    return r;
  }, dp();
}
function mf(r, t) {
  const e = dp();
  return mf = function(n, i) {
    return n = n - 367, e[n];
  }, mf(r, t);
}
(function(r, t) {
  const e = mf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(395)) / 1 * (parseInt(e(389)) / 2) + -parseInt(e(367)) / 3 + parseInt(e(379)) / 4 + parseInt(e(376)) / 5 * (parseInt(e(392)) / 6) + -parseInt(e(391)) / 7 + -parseInt(e(378)) / 8 * (-parseInt(e(384)) / 9) + -parseInt(e(385)) / 10 * (-parseInt(e(383)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(dp, 627008);
class a9 extends a0 {
  constructor(t) {
    const e = mf;
    super(), this[e(368)] = R0(t[e(368)]), this[e(387)] = Lb(t.attributions), this[e(377)] = t[e(394)] ?? !0, this[e(396)] = !1, this.state_ = t[e(373)] !== void 0 ? t.state : e(372), this[e(397)] = t.wrapX !== void 0 ? t[e(369)] : !1, this[e(370)] = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
    const n = this;
    this[e(371)] = new Promise(function(i, s) {
      const o = e;
      n[o(382)] = i, n.viewRejector = s;
    });
  }
  [Lr(398)]() {
    return this[Lr(387)];
  }
  [Lr(386)]() {
    return this[Lr(377)];
  }
  getProjection() {
    return this[Lr(368)];
  }
  getResolutions(t) {
    return null;
  }
  [Lr(393)]() {
    return this[Lr(371)];
  }
  [Lr(375)]() {
    return this[Lr(381)];
  }
  getWrapX() {
    return this[Lr(397)];
  }
  [Lr(390)]() {
    return this[Lr(370)];
  }
  [Lr(374)]() {
    this[Lr(388)]();
  }
  setAttributions(t) {
    const e = Lr;
    this[e(387)] = Lb(t), this[e(388)]();
  }
  setState(t) {
    const e = Lr;
    this[e(381)] = t, this[e(388)]();
  }
}
function Lb(r) {
  const t = Lr;
  return r ? typeof r == "function" ? r : (!Array[t(380)](r) && (r = [r]), (e) => r) : null;
}
function gp() {
  var r = ["6039AtKOXX", "188755shBDfM", "502503fIVpgA", "3502632xGgpTL", "5056mRbYoI", "10NeWLPC", "removefeature", "7131200lAClwf", "13976ogDzup", "addfeature", "featuresloadend", "6KNxYwn", "clear", "changefeature", "974040tfylLY"];
  return gp = function() {
    return r;
  }, gp();
}
function yp(r, t) {
  var e = gp();
  return yp = function(n, i) {
    n = n - 102;
    var s = e[n];
    return s;
  }, yp(r, t);
}
var gc = yp;
(function(r, t) {
  for (var e = yp, n = r(); ; )
    try {
      var i = parseInt(e(103)) / 1 + parseInt(e(116)) / 2 + -parseInt(e(104)) / 3 + parseInt(e(110)) / 4 * (-parseInt(e(107)) / 5) + -parseInt(e(113)) / 6 * (parseInt(e(105)) / 7) + parseInt(e(106)) / 8 * (-parseInt(e(102)) / 9) + parseInt(e(109)) / 10;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(gp, 289958);
const Xr = { ADDFEATURE: gc(111), CHANGEFEATURE: gc(115), CLEAR: gc(114), REMOVEFEATURE: gc(108), FEATURESLOADSTART: "featuresloadstart", FEATURESLOADEND: gc(112), FEATURESLOADERROR: "featuresloaderror" };
(function(r, t) {
  const e = Em, n = r();
  for (; ; )
    try {
      if (-parseInt(e(482)) / 1 * (-parseInt(e(481)) / 2) + -parseInt(e(489)) / 3 * (parseInt(e(483)) / 4) + parseInt(e(475)) / 5 + parseInt(e(474)) / 6 + -parseInt(e(478)) / 7 + -parseInt(e(486)) / 8 * (parseInt(e(485)) / 9) + -parseInt(e(490)) / 10 * (-parseInt(e(480)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(vp, 704950);
function Em(r, t) {
  const e = vp();
  return Em = function(n, i) {
    return n = n - 474, e[n];
  }, Em(r, t);
}
function u9(r, t) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
function vp() {
  const r = ["41036pOMTOC", "11wlkpWI", "20JHSZRk", "getTileCoordExtent", "5238HyAOuN", "3968bLvEDg", "getTileRangeForExtentAndZ", "getZForResolution", "463503yZxzUQ", "218180FiYNGe", "maxY", "7218816ZbSlYE", "5700450inYmAd", "minX", "maxX", "7299565xIYbgF", "minY", "121ZAFpKo"];
  return vp = function() {
    return r;
  }, vp();
}
function mp() {
  const r = ["15547689PMQvqO", "12hrhUxi", "6ZdcvRg", "responseText", "send", "20254280hCvLwe", "readProjection", "2fXZVKA", "onerror", "1003335IEGYTb", "status", "2600800CPpAFZ", "arraybuffer", "getType", "text", "8773170nTClCb", "1335060WueHmj", "response", "1537781ZYYRXh", "xml", "responseType", "open"];
  return mp = function() {
    return r;
  }, mp();
}
function _p(r, t) {
  const e = mp();
  return _p = function(n, i) {
    return n = n - 356, e[n];
  }, _p(r, t);
}
(function(r, t) {
  const e = _p, n = r();
  for (; ; )
    try {
      if (-parseInt(e(364)) / 1 * (parseInt(e(375)) / 2) + -parseInt(e(370)) / 3 * (-parseInt(e(362)) / 4) + parseInt(e(377)) / 5 * (-parseInt(e(369)) / 6) + -parseInt(e(361)) / 7 + -parseInt(e(357)) / 8 + parseInt(e(368)) / 9 + parseInt(e(373)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(mp, 902954);
let x9 = !1;
function c9(r, t, e, n, i, s, o) {
  const a = _p, u = new XMLHttpRequest();
  u[a(367)]("GET", typeof r == "function" ? r(e, n, i) : r, !0), t[a(359)]() == "arraybuffer" && (u[a(366)] = a(358)), u.withCredentials = x9, u.onload = function(x) {
    const c = a;
    if (!u.status || u[c(356)] >= 200 && u[c(356)] < 300) {
      const f = t[c(359)]();
      try {
        let l;
        f == c(360) || f == "json" ? l = u[c(371)] : f == c(365) ? l = u.responseXML || u[c(371)] : f == c(358) && (l = u[c(363)]), l ? s(t.readFeatures(l, { extent: e, featureProjection: i }), t[c(374)](l)) : o();
      } catch {
        o();
      }
    } else o();
  }, u[a(376)] = o, u[a(372)]();
}
function Nb(r, t) {
  return function(e, n, i, s, o) {
    const a = this;
    c9(r, t, e, n, i, function(u, x) {
      a.addFeatures(u), s !== void 0 && s(u);
    }, o || Zc);
  };
}
const ft = Ya;
(function(r, t) {
  const e = Ya, n = r();
  for (; ; )
    try {
      if (parseInt(e(360)) / 1 * (-parseInt(e(337)) / 2) + -parseInt(e(362)) / 3 + parseInt(e(328)) / 4 + -parseInt(e(321)) / 5 * (-parseInt(e(303)) / 6) + parseInt(e(346)) / 7 + -parseInt(e(305)) / 8 * (-parseInt(e(371)) / 9) + parseInt(e(324)) / 10 * (-parseInt(e(307)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(bp, 167793);
function Ya(r, t) {
  const e = bp();
  return Ya = function(n, i) {
    return n = n - 286, e[n];
  }, Ya(r, t);
}
class Sa extends Oo {
  constructor(t, e, n) {
    const i = Ya;
    super(t), this[i(358)] = e, this[i(317)] = n;
  }
}
class vy extends a9 {
  constructor(t) {
    const e = Ya;
    t = t || {}, super({ attributions: t[e(365)], interpolate: !0, projection: void 0, state: e(308), wrapX: t.wrapX !== void 0 ? t[e(334)] : !0 }), this.on, this[e(370)], this.un, this[e(306)] = Zc, this.format_ = t[e(363)] || null, this.overlaps_ = t[e(289)] === void 0 ? !0 : t[e(289)], this[e(344)] = t[e(368)], t.loader !== void 0 ? this.loader_ = t.loader : this[e(344)] !== void 0 && (dr(this[e(333)], e(316)), this[e(306)] = Nb(this[e(344)], this[e(333)])), this[e(294)] = t[e(310)] !== void 0 ? t[e(310)] : u9;
    const n = t[e(302)] !== void 0 ? t.useSpatialIndex : !0;
    this[e(322)] = n ? new y1() : null, this.loadedExtentsRtree_ = new y1(), this[e(375)] = 0, this[e(336)] = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this[e(335)] = null;
    let i, s;
    Array.isArray(t[e(317)]) ? s = t[e(317)] : t.features && (i = t[e(317)], s = i[e(315)]()), !n && i === void 0 && (i = new aa(s)), s !== void 0 && this[e(293)](s), i !== void 0 && this[e(327)](i);
  }
  addFeature(t) {
    const e = Ya;
    this[e(301)](t), this[e(389)]();
  }
  [ft(301)](t) {
    const e = ft, n = ve(t);
    if (!this[e(290)](n, t)) {
      this.featuresCollection_ && this[e(335)][e(287)](t);
      return;
    }
    this[e(385)](n, t);
    const i = t[e(348)]();
    if (i) {
      const s = i[e(349)]();
      this[e(322)] && this[e(322)][e(314)](s, t);
    } else this[e(336)][n] = t;
    this[e(378)](new Sa(Xr[e(345)], t));
  }
  [ft(385)](t, e) {
    const n = ft;
    e instanceof Xs || (this.featureChangeKeys_[t] = [ii(e, rr[n(380)], this[n(350)], this), ii(e, K3[n(341)], this[n(350)], this)]);
  }
  addToIndex_(t, e) {
    const n = ft;
    let i = !0;
    if (e[n(353)]() !== void 0) {
      const s = String(e[n(353)]());
      if (!(s in this.idIndex_)) this[n(330)][s] = e;
      else if (e instanceof Xs) {
        const o = this[n(330)][s];
        o instanceof Xs ? Array[n(355)](o) ? o[n(323)](e) : this[n(330)][s] = [o, e] : i = !1;
      } else i = !1;
    }
    return i && (dr(!(t in this[n(376)]), n(286)), this[n(376)][t] = e), i;
  }
  [ft(291)](t) {
    const e = ft;
    this[e(293)](t), this[e(389)]();
  }
  [ft(293)](t) {
    const e = ft, n = [], i = [], s = [];
    for (let o = 0, a = t[e(386)]; o < a; o++) {
      const u = t[o], x = ve(u);
      this[e(290)](x, u) && i[e(323)](u);
    }
    for (let o = 0, a = i[e(386)]; o < a; o++) {
      const u = i[o], x = ve(u);
      this[e(385)](x, u);
      const c = u[e(348)]();
      if (c) {
        const f = c.getExtent();
        n[e(323)](f), s[e(323)](u);
      } else this[e(336)][x] = u;
    }
    if (this[e(322)] && this.featuresRtree_.load(n, s), this.hasListener(Xr.ADDFEATURE)) for (let o = 0, a = i[e(386)]; o < a; o++)
      this[e(378)](new Sa(Xr[e(345)], i[o]));
  }
  bindFeaturesCollection_(t) {
    const e = ft;
    let n = !1;
    this[e(320)](Xr[e(345)], function(i) {
      const s = e;
      !n && (n = !0, t[s(323)](i[s(358)]), n = !1);
    }), this[e(320)](Xr[e(297)], function(i) {
      const s = e;
      !n && (n = !0, t[s(287)](i[s(358)]), n = !1);
    }), t[e(320)](_i[e(309)], (i) => {
      const s = e;
      !n && (n = !0, this[s(347)](i[s(381)]), n = !1);
    }), t[e(320)](_i[e(339)], (i) => {
      const s = e;
      !n && (n = !0, this[s(356)](i.element), n = !1);
    }), this[e(335)] = t;
  }
  [ft(384)](t) {
    const e = ft;
    if (t) {
      for (const i in this[e(351)])
        this[e(351)][i][e(359)](gs);
      !this[e(335)] && (this[e(351)] = {}, this.idIndex_ = {}, this[e(376)] = {});
    } else if (this.featuresRtree_) {
      const i = (s) => {
        this[e(382)](s);
      };
      this[e(322)].forEach(i);
      for (const s in this[e(336)])
        this[e(382)](this[e(336)][s]);
    }
    this[e(335)] && this.featuresCollection_[e(384)](), this[e(322)] && this[e(322)].clear(), this.nullGeometryFeatures_ = {};
    const n = new Sa(Xr[e(364)]);
    this[e(378)](n), this[e(389)]();
  }
  [ft(319)](t) {
    const e = ft;
    if (this.featuresRtree_) return this[e(322)][e(359)](t);
    this[e(335)] && this[e(335)][e(359)](t);
  }
  [ft(295)](t, e) {
    const n = ft, i = [t[0], t[1], t[0], t[1]];
    return this[n(338)](i, function(s) {
      const o = n, a = s[o(348)]();
      if (a instanceof Xs || a.intersectsCoordinate(t)) return e(s);
    });
  }
  [ft(338)](t, e) {
    const n = ft;
    if (this[n(322)]) return this[n(322)][n(383)](t, e);
    this[n(335)] && this[n(335)][n(359)](e);
  }
  forEachFeatureIntersectingExtent(t, e) {
    return this.forEachFeatureInExtent(t, function(n) {
      const i = Ya, s = n.getGeometry();
      if (s instanceof Xs || s[i(369)](t)) {
        const o = e(n);
        if (o) return o;
      }
    });
  }
  [ft(311)]() {
    return this.featuresCollection_;
  }
  [ft(332)]() {
    const t = ft;
    let e;
    return this.featuresCollection_ ? e = this[t(335)][t(315)]()[t(352)](0) : this.featuresRtree_ && (e = this[t(322)][t(342)](), !sx(this[t(336)]) && ds(e, Object[t(367)](this.nullGeometryFeatures_))), e;
  }
  [ft(354)](t) {
    const e = ft, n = [];
    return this[e(295)](t, function(i) {
      n.push(i);
    }), n;
  }
  [ft(343)](t, e) {
    const n = ft;
    if (this[n(322)]) {
      if (!(e && e[n(372)]() && this[n(387)]())) return this[n(322)][n(373)](t);
      const s = a8(t, e);
      return [].concat(...s[n(340)]((o) => this[n(322)][n(373)](o)));
    }
    return this.featuresCollection_ ? this[n(335)].getArray()[n(352)](0) : [];
  }
  getClosestFeatureToCoordinate(t, e) {
    const n = ft, i = t[0], s = t[1];
    let o = null;
    const a = [NaN, NaN];
    let u = 1 / 0;
    const x = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return e = e || ix, this[n(322)].forEachInExtent(x, function(c) {
      const f = n;
      if (e(c)) {
        const l = c[f(348)](), h = u;
        if (u = l instanceof Xs ? 0 : l.closestPointXY(i, s, a, u), u < h) {
          o = c;
          const p = Math[f(304)](u);
          x[0] = i - p, x[1] = s - p, x[2] = i + p, x[3] = s + p;
        }
      }
    }), o;
  }
  [ft(349)](t) {
    return this[ft(322)].getExtent(t);
  }
  [ft(377)](t) {
    const e = ft, n = this[e(330)][t.toString()];
    return n !== void 0 ? n : null;
  }
  getFeatureByUid(t) {
    const e = ft, n = this[e(376)][t];
    return n !== void 0 ? n : null;
  }
  [ft(296)]() {
    return this.format_;
  }
  [ft(361)]() {
    return this[ft(326)];
  }
  [ft(292)]() {
    return this[ft(344)];
  }
  [ft(350)](t) {
    const e = ft, n = t.target, i = ve(n), s = n[e(348)]();
    if (!s) !(i in this[e(336)]) && (this[e(322)] && this[e(322)].remove(n), this[e(336)][i] = n);
    else {
      const a = s.getExtent();
      i in this[e(336)] ? (delete this[e(336)][i], this[e(322)] && this[e(322)][e(314)](a, n)) : this.featuresRtree_ && this[e(322)].update(a, n);
    }
    const o = n[e(353)]();
    if (o !== void 0) {
      const a = o.toString();
      this[e(330)][a] !== n && (this[e(331)](n), this[e(330)][a] = n);
    } else this[e(331)](n), this[e(376)][i] = n;
    this.changed(), this[e(378)](new Sa(Xr.CHANGEFEATURE, n));
  }
  [ft(288)](t) {
    const e = ft, n = t[e(353)]();
    return n !== void 0 ? n in this[e(330)] : ve(t) in this[e(376)];
  }
  [ft(388)]() {
    const t = ft;
    return this[t(322)] ? this.featuresRtree_[t(388)]() && sx(this[t(336)]) : this[t(335)] ? this[t(335)][t(357)]() === 0 : !0;
  }
  loadFeatures(t, e, n) {
    const i = ft, s = this[i(374)], o = this[i(294)](t, e, n);
    for (let a = 0, u = o[i(386)]; a < u; ++a) {
      const x = o[a];
      !s.forEachInExtent(x, function(f) {
        return Fu(f[i(325)], x);
      }) && (++this[i(375)], this[i(378)](new Sa(Xr[i(313)])), this[i(306)][i(379)](this, x, e, n, (f) => {
        const l = i;
        --this[l(375)], this[l(378)](new Sa(Xr[l(298)], void 0, f));
      }, () => {
        const f = i;
        --this[f(375)], this[f(378)](new Sa(Xr[f(366)]));
      }), s.insert(x, { extent: x[i(352)]() }));
    }
    this.loading = this[i(306)][i(386)] < 4 ? !1 : this[i(375)] > 0;
  }
  [ft(318)]() {
    const t = ft;
    this[t(384)](!0), this.loadedExtentsRtree_[t(384)](), super[t(318)]();
  }
  removeLoadedExtent(t) {
    const e = ft, n = this.loadedExtentsRtree_;
    let i;
    n[e(383)](t, function(s) {
      if (e4(s.extent, t)) return i = s, !0;
    }), i && n[e(287)](i);
  }
  [ft(312)](t) {
    const e = ft;
    let n = !1;
    for (let i = 0, s = t[e(386)]; i < s; ++i)
      n = this[e(382)](t[i]) || n;
    n && this[e(389)]();
  }
  [ft(356)](t) {
    const e = ft;
    if (!t) return;
    this[e(382)](t) && this[e(389)]();
  }
  [ft(382)](t) {
    const e = ft, n = ve(t);
    if (!(n in this[e(376)])) return !1;
    n in this[e(336)] ? delete this[e(336)][n] : this[e(322)] && this[e(322)][e(287)](t);
    const i = this.featureChangeKeys_[n];
    i == null || i[e(359)](gs), delete this[e(351)][n];
    const s = t[e(353)]();
    if (s !== void 0) {
      const o = s[e(300)](), a = this[e(330)][o];
      a === t ? delete this[e(330)][o] : Array.isArray(a) && (a[e(299)](a.indexOf(t), 1), a[e(386)] === 1 && (this[e(330)][o] = a[0]));
    }
    return delete this[e(376)][n], this.hasListener(Xr[e(297)]) && this.dispatchEvent(new Sa(Xr[e(297)], t)), !0;
  }
  removeFromIdIndex_(t) {
    const e = ft;
    for (const n in this.idIndex_)
      if (this[e(330)][n] === t) {
        delete this[e(330)][n];
        break;
      }
  }
  setLoader(t) {
    const e = ft;
    this[e(306)] = t;
  }
  setUrl(t) {
    const e = ft;
    dr(this.format_, e(316)), this[e(344)] = t, this[e(329)](Nb(t, this[e(333)]));
  }
}
function bp() {
  const r = ["format", "CLEAR", "attributions", "FEATURESLOADERROR", "values", "url", "intersectsExtent", "once", "3231APLQXC", "canWrapX", "getInExtent", "loadedExtentsRtree_", "loadingExtentsCount_", "uidIndex_", "getFeatureById", "dispatchEvent", "call", "CHANGE", "element", "removeFeatureInternal", "forEachInExtent", "clear", "setupChangeEvents_", "length", "getWrapX", "isEmpty", "changed", "The passed `feature` was already added to the source", "remove", "hasFeature", "overlaps", "addToIndex_", "addFeatures", "getUrl", "addFeaturesInternal", "strategy_", "forEachFeatureAtCoordinateDirect", "getFormat", "REMOVEFEATURE", "FEATURESLOADEND", "splice", "toString", "addFeatureInternal", "useSpatialIndex", "48tWRytS", "sqrt", "5704bycPQq", "loader_", "22ZqMheu", "ready", "ADD", "strategy", "getFeaturesCollection", "removeFeatures", "FEATURESLOADSTART", "insert", "getArray", "`format` must be set when `url` is set", "features", "refresh", "forEachFeature", "addEventListener", "199535wkaPwJ", "featuresRtree_", "push", "3138430oMyUAS", "extent", "overlaps_", "bindFeaturesCollection_", "1179944KOMklL", "setLoader", "idIndex_", "removeFromIdIndex_", "getFeatures", "format_", "wrapX", "featuresCollection_", "nullGeometryFeatures_", "142hMBZND", "forEachFeatureInExtent", "REMOVE", "map", "PROPERTYCHANGE", "getAll", "getFeaturesInExtent", "url_", "ADDFEATURE", "1315916uckzUz", "addFeature", "getGeometry", "getExtent", "handleFeatureChange_", "featureChangeKeys_", "slice", "getId", "getFeaturesAtCoordinate", "isArray", "removeFeature", "getLength", "feature", "forEach", "581RKCmWB", "getOverlaps", "664401zHRCSU"];
  return bp = function() {
    return r;
  }, bp();
}
var et = _f;
function _f(r, t) {
  var e = Ip();
  return _f = function(n, i) {
    n = n - 309;
    var s = e[n];
    return s;
  }, _f(r, t);
}
(function(r, t) {
  for (var e = _f, n = r(); ; )
    try {
      var i = -parseInt(e(376)) / 1 + parseInt(e(358)) / 2 * (-parseInt(e(333)) / 3) + -parseInt(e(337)) / 4 * (parseInt(e(393)) / 5) + parseInt(e(394)) / 6 * (-parseInt(e(371)) / 7) + -parseInt(e(360)) / 8 + -parseInt(e(351)) / 9 + parseInt(e(415)) / 10 * (parseInt(e(421)) / 11);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Ip, 417837);
function Ip() {
  var r = ["layerName", "_undoStack", "beforesplit", "hasRedo", "source", "getProperties", "_reduce", "changeattribute", "setMaxSize", "dispatchEvent", "_sourceListener", "bind", '" is not defined.', "target", "_onInteraction", "call", "_doShift", "_addStartFeature", "split", "name", "aftersplit", "removefeature", "push", "size", "blockEnd", "blockStart", "getStack", "define", "forEach", "_watchSources", "264gCkZZf", "prototype", "clone", "type", "47744jBfMzV", "maxSize", "features", "length", "translatestart", "setattribute", "removeAt", "clear", "deletestart", "blockend", "_record", "assign", "_doClear", "add", "7202385SgRJSY", "removeFeature", "level", "_redoStack", "getLayers", "clearend", "undo", "17762JTXWjK", "stack:add", "5883696RFYmhH", '[UndoRedoInteraction]: "', "scalestart", "redo", "undoblockend", "undoblockstart", "SOURCE", "oldGeom", "addfeature", "indexOf", "delete", "189UqZKmZ", "clearstart", "deleteend", "getView", "_mapListener", "336580vqiWKn", "pop", "_watchInteractions", "shift", "remove", "stack:clear", "undore", "getGeometry", "feature", "setattributestart", "_undo", "unset", "blockstart", "_interactionListener", "warn", "_defs", "_level", "290wSjhYI", "48942Mdrjtj", "modifystart", "setGeometry", "getMap", "maxLength", "addFeature", "setActive", "setMaxLength", "getLength", "prop", "custom", "_onAddRemove", "replace", "item", "_handleDo", "element", "properties", "_block", "_redo", "getZoom", "get", "10FFOWUq", "getCenter", "setMap", "getInteractions", "newProperties", "getSource", "43826189aaNCJI", "log", "_layers", "layers", "oldProperties"];
  return Ip = function() {
    return r;
  }, Ip();
}
var Gs = class extends hy {
  constructor(t) {
    var e = _f;
    t = t || {}, super({ handleEvent: function() {
      return !0;
    } }), this[e(423)] = t[e(424)], this._undoStack = new aa(), this._redoStack = new aa(), this[e(386)] = [], this._redo = [], this[e(427)].on(e(350), (function(n) {
      var i = e;
      n.element[i(353)] === void 0 ? (n[i(409)].level = this[i(392)], !n[i(409)][i(353)] && (n[i(409)].view = { center: this[i(397)]()[i(374)]()[i(416)](), zoom: this.getMap().getView()[i(413)]() }, this._undo.push(n[i(409)]))) : n[i(409)].level || this[i(386)].push(this[i(412)].shift()), !n[i(409)].level && this.dispatchEvent({ type: i(359), action: n.element }), this._reduce();
    })[e(314)](this)), this._undoStack.on("remove", (function(n) {
      var i = e;
      n[i(409)][i(353)] || (this[i(319)] ? this[i(386)].shift() : this[i(386)][i(340)] && this[i(412)][i(325)](this[i(386)][i(377)]()), !this[i(349)] && this[i(312)]({ type: "stack:remove", action: n.element, shift: this[i(319)] }));
    })[e(314)](this)), this._block = 0, this._level = 0, this[e(319)] = !1, this[e(347)] = !0, this._defs = {};
  }
  [et(330)](t, e, n) {
    var i = et;
    this[i(391)][t] = { undo: e, redo: n };
  }
  [et(340)](t) {
    var e = et;
    return t === e(363) ? this[e(412)][e(340)] : this[e(386)].length;
  }
  [et(401)](t) {
    var e = et;
    t = parseInt(t), t && t < 0 && (t = 0), this.set(e(398), t), this._reduce();
  }
  size(t) {
    var e = et;
    return t === "redo" ? this[e(354)][e(402)]() : this[e(427)][e(402)]();
  }
  [et(311)](t) {
    var e = et;
    t = parseInt(t), t && t < 0 && (t = 0), this.set(e(338), t), this[e(309)]();
  }
  [et(309)]() {
    var t = et;
    if (this.get(t(398))) for (; this[t(340)]() > this[t(414)]("maxLength"); )
      this[t(379)]();
    if (this[t(414)](t(338))) for (; this[t(340)]() > 1 && this[t(326)]() > this[t(414)](t(338)); )
      this[t(379)]();
  }
  [et(329)](t) {
    var e = et;
    return t === e(363) ? this._redo : this[e(386)];
  }
  push(t, e, n) {
    var i = et;
    return this[i(391)][t] ? (this[i(427)].push({ type: t, name: n, custom: !0, prop: e }), !0) : (console[i(390)]('[UndoRedoInteraction]: "' + t + i(315)), !1);
  }
  [et(379)]() {
    var t = et;
    this[t(319)] = !0;
    var e = this[t(427)][t(343)](0);
    if (this._doShift = !1, e.type === "blockstart")
      for (e = this[t(427)][t(407)](0); this[t(427)][t(402)]() && e.level > 0; )
        this[t(427)][t(343)](0), e = this[t(427)][t(407)](0);
  }
  [et(400)](t) {
    var e = et;
    super[e(400)](t), this._record = t;
  }
  [et(417)](t) {
    var e = et;
    this[e(375)] && this._mapListener[e(331)](function(n) {
      qc(n);
    }), this[e(375)] = [], super[e(417)](t), t && (this[e(375)][e(325)](t.on(e(365), this[e(328)][e(314)](this))), this[e(375)][e(325)](t.on(e(364), this.blockEnd.bind(this)))), this[e(332)](), this[e(378)]();
  }
  _watchSources() {
    var t = et, e = this[t(397)]();
    this[t(313)] && this[t(313)][t(331)](function(o) {
      qc(o);
    }), this._sourceListener = [];
    var n = this;
    function i(o, a) {
      var u = t;
      return a || (a = []), o.getArray(), o[u(331)](function(x) {
        var c = u;
        !n[c(423)] || n._layers[c(369)](x) >= 0 ? x[c(431)]()[c(426)] == n[c(423)][0][c(431)]()[c(426)] && (a.push(x), n[c(320)]()) : x.getLayers && i(x[c(355)](), a);
      }), a;
    }
    if (e) {
      var s = i(e.getLayers());
      s[t(331)]((function(o) {
        var a = t, u = o[a(420)]();
        console[a(422)](a(366), u), this[a(313)][a(325)](u.on([a(368), a(324)], this._onAddRemove.bind(this))), this._sourceListener[a(325)](u.on(a(372), (function() {
          var x = a;
          this[x(328)](x(344));
        }).bind(this))), this[a(313)].push(u.on(a(356), this[a(327)][a(314)](this)));
      })[t(314)](this)), this._sourceListener[t(325)](e.getLayers().on([t(350), t(380)], this[t(332)][t(314)](this)));
    }
  }
  _addStartFeature() {
    var t = et;
    let e = this;
    this._layers[0][t(420)]().getFeatures().forEach(function(n) {
      var i = t;
      e._undoStack[i(325)]({ type: "addfeature", feature: n, source: e[i(423)][0][i(420)](), view: { center: e[i(397)]().getView().getCenter(), zoom: e.getMap()[i(374)]()[i(413)]() } });
    });
  }
  _watchInteractions() {
    var t = et, e = this[t(397)]();
    this[t(389)] && this[t(389)][t(331)](function(n) {
      qc(n);
    }), this._interactionListener = [], e && (e[t(418)]().forEach((function(n) {
      var i = t;
      this._interactionListener[i(325)](n.on([i(385), i(395), "rotatestart", "translatestart", i(362), "deletestart", i(373), i(428), "aftersplit"], this._onInteraction[i(314)](this)));
    })[t(314)](this)), this._interactionListener[t(325)](e[t(418)]().on(["add", t(380)], this._watchInteractions[t(314)](this))));
  }
  [et(405)](t) {
    var e = et;
    console.log(e(382)), this[e(347)] && (this[e(354)][e(344)](), this[e(412)][e(340)] = 0, this._undoStack[e(325)]({ type: t.type, source: t[e(316)], feature: t[e(384)] }));
  }
  [et(317)](t) {
    var e = et, n = this[e(317)][t.type];
    n && n[e(318)](this, t);
  }
  blockStart(t) {
    var e = et;
    this._redoStack[e(344)](), this[e(412)][e(340)] = 0, this[e(427)][e(325)]({ type: "blockstart", name: t }), this[e(392)]++;
  }
  [et(327)]() {
    var t = et;
    this[t(427)].push({ type: "blockend" }), this[t(392)]--;
  }
  _handleDo(t, e) {
    var n = et;
    if (this.getActive()) {
      if (this[n(347)] = !1, t[n(404)])
        this[n(391)][t[n(336)]] ? e ? this[n(391)][t[n(336)]][n(357)](t[n(403)]) : this._defs[t[n(336)]][n(363)](t[n(403)]) : console[n(390)](n(361) + t[n(336)] + n(315));
      else switch (t[n(336)]) {
        case n(368): {
          e ? t[n(430)][n(352)](t[n(384)]) : t[n(430)][n(399)](t[n(384)]);
          break;
        }
        case "removefeature": {
          e ? t[n(430)][n(399)](t[n(384)]) : t[n(430)][n(352)](t[n(384)]);
          break;
        }
        case "changegeometry": {
          var i = t.feature.getGeometry();
          t[n(384)][n(396)](t[n(367)]), t[n(367)] = i;
          break;
        }
        case n(310): {
          var s = t[n(419)], o = t[n(425)];
          for (var a in o)
            o === void 0 ? t[n(384)][n(387)](a) : t[n(384)].set(a, o[a]);
          t[n(425)] = s, t.newProperties = o;
          break;
        }
        case n(388): {
          this[n(411)] += e ? -1 : 1;
          break;
        }
        case n(346): {
          this[n(411)] += e ? 1 : -1;
          break;
        }
        default:
          console[n(390)](n(361) + t[n(336)] + n(315));
      }
      this[n(411)] < 0 && (this._block = 0), this[n(411)] && (e ? this[n(357)]() : this[n(363)]()), this._record = !0, this[n(312)]({ type: n(e ? 357 : 363), action: t });
    }
  }
  [et(357)]() {
    var t = et, e = this[t(427)].item(this[t(427)][t(402)]() - 1);
    e && (this[t(354)][t(325)](e), this[t(427)][t(377)](), this[t(408)](e, !0));
  }
  redo() {
    var t = et, e = this[t(354)][t(407)](this[t(354)][t(402)]() - 1);
    e && (this[t(427)][t(325)](e), this._redoStack[t(377)](), this[t(408)](e, !1));
  }
  clear() {
    var t = et;
    this._doClear = !0, this[t(386)][t(340)] = this[t(412)][t(340)] = 0, this[t(427)][t(344)](), this[t(354)][t(344)](), this[t(349)] = !1, this.dispatchEvent({ type: t(381) });
  }
  hasUndo() {
    var t = et;
    return this[t(427)][t(402)]();
  }
  [et(429)]() {
    var t = et;
    return this[t(354)].getLength();
  }
};
Gs[et(334)][et(317)][et(385)] = function(r) {
  var t = et;
  this[t(328)](r[t(316)][t(414)](t(322)) || t(342));
  var e = Object[t(348)]({}, r[t(410)]);
  r[t(339)][t(331)]((function(n) {
    var i = t, s = {};
    for (var o in e)
      s[o] = n[i(414)](o);
    this[i(427)][i(325)]({ type: i(310), feature: n, newProperties: e, oldProperties: s });
  })[t(314)](this)), this[t(327)]();
}, Gs[et(334)][et(317)].rotatestart = Gs[et(334)][et(317)][et(341)] = Gs.prototype[et(317)][et(362)] = Gs.prototype[et(317)][et(395)] = function(r) {
  var t = et;
  this[t(328)](r[t(336)][t(406)](/start$/, "")), r[t(339)][t(331)]((function(e) {
    var n = t;
    this[n(427)].push({ type: "changegeometry", feature: e, oldGeom: e[n(383)]()[n(335)]() });
  })[t(314)](this)), this.blockEnd();
}, Gs[et(334)]._onInteraction[et(428)] = function() {
  var r = et, t = this[r(427)][r(402)]();
  t > 2 && this[r(427)][r(407)](t - 1)[r(336)] === r(346) && this[r(427)][r(407)](t - 2)[r(336)] === "changegeometry" ? this[r(427)][r(377)]() : this[r(328)](r(321));
}, Gs[et(334)][et(317)][et(345)] = function() {
  var r = et;
  this.blockStart(r(370));
}, Gs[et(334)][et(317)][et(323)] = Gs[et(334)][et(317)][et(373)] = Gs[et(334)].blockEnd;
var f9 = class extends Gs {
  constructor(t, e) {
    t.layers = [t.layer], super(t), this.set("interactionType", t.interactionType), this.setActive(!0);
  }
};
function wp() {
  const r = ["452VLUvvC", "getMap", "2675808WkkCGx", "onKeyPress", "forEach", "32401WguumV", "activeElement", "disposeInternal", "bind", "isCurrentMap", "49480mihkGg", "10swDzGs", "getCurrentMap", "keypress", "949662vQvYaX", "30283FAwovI", "prototype", "onKeyDown", "tagName", "onKeyUp", "push", "_currentMap", "1542MDzgXI", "266XxnmrD", "setCurrentMap", "_olinteractionCurrentMap_cleanup", "dispatchEvent", "focus", "removeEventListener", "10frOHhT", "1608xRzlev", "keydown", "939855QfvwMN", "type", "test", "keyup", "addEventListener"];
  return wp = function() {
    return r;
  }, wp();
}
function gx(r, t) {
  const e = wp();
  return gx = function(n, i) {
    return n = n - 400, e[n];
  }, gx(r, t);
}
const Vo = gx;
(function(r, t) {
  const e = gx, n = r();
  for (; ; )
    try {
      if (parseInt(e(404)) / 1 * (parseInt(e(410)) / 2) + parseInt(e(421)) / 3 * (-parseInt(e(436)) / 4) + parseInt(e(431)) / 5 + parseInt(e(401)) / 6 + -parseInt(e(422)) / 7 * (parseInt(e(409)) / 8) + parseInt(e(413)) / 9 * (parseInt(e(428)) / 10) + -parseInt(e(414)) / 11 * (parseInt(e(429)) / 12) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(wp, 239448);
var Uc = class extends hy {
  constructor(t) {
    const e = gx;
    t = t || {};
    var n = t.condition || function() {
      return !0;
    };
    if (super({ handleEvent: function(i) {
      const s = gx;
      return n(i) && !this[s(408)]() && (this[s(423)](this[s(400)]()), this.dispatchEvent({ type: s(426), map: this.getMap() }), this[s(400)]()[s(425)]({ type: s(426), map: this[s(400)]() })), !0;
    } }), this[e(424)] = [], t[e(416)]) {
      const i = (function(s) {
        const o = e;
        this.isCurrentMap() && !/INPUT|TEXTAREA|SELECT/[o(433)](document[o(405)][o(417)]) && t.onKeyDown({ type: s.type, map: this.getMap(), originalEvent: s });
      })[e(407)](this);
      document[e(435)](e(430), i), this[e(424)].push(() => document[e(427)]("keydown", i));
    }
    if (t[e(402)]) {
      const i = (function(s) {
        const o = e;
        this.isCurrentMap() && !/INPUT|TEXTAREA|SELECT/.test(document[o(405)][o(417)]) && t[o(402)]({ type: s[o(432)], map: this[o(400)](), originalEvent: s });
      })[e(407)](this);
      document[e(435)]("keypress", i), this[e(424)][e(419)](() => document[e(427)](e(412), i));
    }
    if (t.onKeyUp) {
      const i = (function(s) {
        const o = e;
        this[o(408)]() && !/INPUT|TEXTAREA|SELECT/[o(433)](document[o(405)].tagName) && t[o(418)]({ type: s[o(432)], map: this.getMap(), originalEvent: s });
      }).bind(this);
      document[e(435)](e(434), i), this[e(424)].push(() => document[e(427)]("keyup", i));
    }
  }
  [Vo(408)]() {
    const t = Vo;
    return this[t(400)]() === Uc[t(415)]._currentMap;
  }
  [Vo(411)]() {
    const t = Vo;
    return Uc.prototype[t(420)];
  }
  [Vo(423)](t) {
    const e = Vo;
    Uc[e(415)]._currentMap = t;
  }
  disposeInternal() {
    const t = Vo;
    super[t(406)](), this[t(424)][t(403)]((e) => e());
  }
};
Uc[Vo(415)][Vo(420)] = void 0;
function yx(r, t) {
  var e = Ep();
  return yx = function(n, i) {
    n = n - 235;
    var s = e[n];
    return s;
  }, yx(r, t);
}
var Fi = yx;
(function(r, t) {
  for (var e = yx, n = r(); ; )
    try {
      var i = -parseInt(e(254)) / 1 + -parseInt(e(242)) / 2 + parseInt(e(267)) / 3 + parseInt(e(236)) / 4 * (-parseInt(e(271)) / 5) + -parseInt(e(240)) / 6 * (-parseInt(e(244)) / 7) + -parseInt(e(241)) / 8 + parseInt(e(249)) / 9 * (parseInt(e(263)) / 10);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Ep, 402004);
function Ep() {
  var r = ["originalEvent", "setSources", "key", "condition", "10ZzEjrt", "_source", "getFeatures", "sources", "1257126oxPMrt", "getTime", "bind", "_destination", "56805KkGSBL", "dispatchEvent", "forEach", "_featuresSource", "silent", "features", "28LOSmUg", "addFeatures", "test", "removeFeature", "42qUASbp", "2424200cWcHFr", "573798rSQClp", "function", "699349LifpZI", "setDestination", "getDestination", "ctrlKey", "_cloneFeature", "5995935TGjoee", "cut", "getSources", "push", "destination", "713151NvjfTt", "paste", "setMap", "getArray", "copy"];
  return Ep = function() {
    return r;
  }, Ep();
}
var l9 = class extends Uc {
  constructor(t) {
    var e = yx;
    t = t || {};
    var n = t[e(262)];
    typeof n !== e(243) && (n = function(s) {
      var o = e;
      if (s[o(259)][o(247)]) {
        if (/^c$/i[o(238)](s[o(259)][o(261)])) return o(258);
        if (/^x$/i[o(238)](s[o(259)][o(261)])) return o(250);
        if (/^v$/i.test(s.originalEvent[o(261)])) return "paste";
      }
      return !1;
    }), super({ condition: t.mapCondition, onKeyDown: function(s) {
      var o = e;
      switch (n(s)) {
        case o(258): {
          i[o(258)]({ silent: !1 });
          break;
        }
        case o(250): {
          i[o(258)]({ cut: !0, silent: !1 });
          break;
        }
        case "paste": {
          i[o(255)]({ silent: !1 });
          break;
        }
      }
    } });
    var i = this;
    this.features = [], this[e(248)] = !0, this[e(274)] = t[e(235)] || new aa(), this[e(260)](t[e(266)]), this[e(245)](t[e(253)]);
  }
  [Fi(256)](t) {
    var e = Fi;
    super[e(256)](t), this[e(235)] = [];
  }
  [Fi(260)](t) {
    var e = Fi;
    t ? (this[e(264)] = [], this[e(264)] = t instanceof Array ? t : [t]) : this[e(264)] = null;
  }
  [Fi(251)]() {
    var t = Fi;
    return this[t(264)];
  }
  setDestination(t) {
    var e = Fi;
    this[e(270)] = t;
  }
  [Fi(246)]() {
    var t = Fi;
    return this[t(270)];
  }
  [Fi(265)]() {
    return this.features;
  }
  copy(t) {
    var e = Fi;
    t = t || {};
    var n = t[e(235)] || this[e(274)][e(257)]();
    if (t[e(250)]) {
      var i = this[e(264)] || [this[e(270)]];
      n[e(273)](function(s) {
        i.forEach(function(o) {
          var a = yx;
          try {
            o[a(239)](s);
          } catch {
          }
        });
      });
    }
    this._cloneFeature ? (this[e(235)] = [], n[e(273)]((function(s) {
      var o = e;
      this.features[o(252)](s.clone());
    })[e(269)](this))) : this[e(235)] = n, t[e(275)] === !1 && this[e(272)]({ type: t.cut ? e(250) : e(258), time: (/* @__PURE__ */ new Date())[e(268)]() });
  }
  [Fi(255)](t) {
    var e = Fi;
    t = t || {};
    var n = t[e(235)] || this[e(235)];
    if (n) {
      var i = t[e(253)] || this[e(270)];
      i && (i[e(237)](this[e(235)]), this[e(248)] && this[e(258)]({ features: this[e(235)] }));
    }
    t[e(275)] === !1 && this.dispatchEvent({ type: e(255), features: n, time: (/* @__PURE__ */ new Date())[e(268)]() });
  }
}, h9 = class extends l9 {
  constructor(t, e) {
    super(t), this.set("interactionType", t.interactionType);
    debugger;
    this.on("cut", function(n) {
      e.select();
    }), this.on("paste", function(n) {
      e.select(), n.features.forEach(function(i) {
        e.select(i, !0);
      });
    });
  }
};
function Sm(r, t) {
  var e = Sp();
  return Sm = function(n, i) {
    n = n - 216;
    var s = e[n];
    return s;
  }, Sm(r, t);
}
(function(r, t) {
  for (var e = Sm, n = r(); ; )
    try {
      var i = parseInt(e(217)) / 1 * (parseInt(e(222)) / 2) + -parseInt(e(226)) / 3 * (-parseInt(e(220)) / 4) + -parseInt(e(218)) / 5 + -parseInt(e(219)) / 6 + -parseInt(e(216)) / 7 * (-parseInt(e(224)) / 8) + parseInt(e(221)) / 9 * (-parseInt(e(223)) / 10) + parseInt(e(225)) / 11;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Sp, 367097);
function Sp() {
  var r = ["4320hlvJzo", "87648HvKebz", "16072265smPHLN", "93999mEbAtf", "14GHYCFx", "195937yQdcEP", "2560500jISZEO", "1805070puvstx", "4TTNTjJ", "15129xpDWmK", "4qxhTvJ"];
  return Sp = function() {
    return r;
  }, Sp();
}
const Et = { IDLE: 0, LOADING: 1, LOADED: 2, ERROR: 3, EMPTY: 4 };
function Cp() {
  var r = ["901747AMdQVG", "2114696ctErCL", "21540yUKkbz", "148923emwjdE", "156LqHtYA", "28DbfHit", "isArray", "481986gpyTun", "149899limZgA", "632424nHZzxC"];
  return Cp = function() {
    return r;
  }, Cp();
}
(function(r, t) {
  for (var e = Mp, n = r(); ; )
    try {
      var i = parseInt(e(346)) / 1 + parseInt(e(337)) / 2 + -parseInt(e(341)) / 3 * (parseInt(e(343)) / 4) + parseInt(e(340)) / 5 * (-parseInt(e(342)) / 6) + -parseInt(e(338)) / 7 + parseInt(e(339)) / 8 + parseInt(e(345)) / 9;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Cp, 195686);
function Mp(r, t) {
  var e = Cp();
  return Mp = function(n, i) {
    n = n - 337;
    var s = e[n];
    return s;
  }, Mp(r, t);
}
function vx(r, t) {
  var e = Mp;
  return Array[e(344)](r) ? r : (t === void 0 ? t = [r, r] : (t[0] = r, t[1] = r), t);
}
const Me = bf;
(function(r, t) {
  const e = bf, n = r();
  for (; ; )
    try {
      if (parseInt(e(481)) / 1 * (-parseInt(e(478)) / 2) + -parseInt(e(455)) / 3 + -parseInt(e(486)) / 4 * (-parseInt(e(459)) / 5) + parseInt(e(460)) / 6 * (parseInt(e(458)) / 7) + -parseInt(e(450)) / 8 + parseInt(e(477)) / 9 + parseInt(e(462)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Pp, 472843);
function Pp() {
  const r = ["6rGrMRS", "getDeclutterMode", "8235600TNVwno", "slice", "getPixelRatio", "getDisplacement", "clone", "opacity", "setRotateWithView", "listenImageChange", "ready", "setRotation", "rotateWithView", "getImage", "setOpacity", "getAnchor", "rotation", "3690666EoIVPx", "166gVoVuN", "load", "getHitDetectionImage", "1001WXMHJu", "getSize", "getOpacity", "displacement", "declutterMode_", "36760FVgSqI", "getRotateWithView", "resolve", "unlistenImageChange", "displacement_", "scale_", "getScaleArray", "getRotation", "opacity_", "rotation_", "scaleArray_", "4257136KArfWn", "setScale", "declutterMode", "rotateWithView_", "scale", "1910952UPkOcB", "getOrigin", "getScale", "2217656PrMtiT", "95OPwHyZ"];
  return Pp = function() {
    return r;
  }, Pp();
}
class nc {
  constructor(t) {
    const e = bf;
    this[e(494)] = t[e(467)], this[e(453)] = t[e(472)], this[e(448)] = t[e(476)], this[e(491)] = t[e(454)], this.scaleArray_ = vx(t[e(454)]), this[e(490)] = t[e(484)], this[e(485)] = t[e(452)];
  }
  [Me(466)]() {
    const t = Me, e = this[t(457)]();
    return new nc({ opacity: this[t(483)](), scale: Array.isArray(e) ? e.slice() : e, rotation: this[t(493)](), rotateWithView: this[t(487)](), displacement: this[t(465)]()[t(463)](), declutterMode: this[t(461)]() });
  }
  getOpacity() {
    return this[Me(494)];
  }
  [Me(487)]() {
    return this[Me(453)];
  }
  [Me(493)]() {
    return this[Me(448)];
  }
  [Me(457)]() {
    return this.scale_;
  }
  [Me(492)]() {
    return this[Me(449)];
  }
  [Me(465)]() {
    return this[Me(490)];
  }
  [Me(461)]() {
    return this.declutterMode_;
  }
  [Me(475)]() {
    return qe();
  }
  [Me(473)](t) {
    return qe();
  }
  [Me(480)]() {
    return qe();
  }
  [Me(464)](t) {
    return 1;
  }
  getImageState() {
    return qe();
  }
  getImageSize() {
    return qe();
  }
  [Me(456)]() {
    return qe();
  }
  [Me(482)]() {
    return qe();
  }
  setDisplacement(t) {
    this.displacement_ = t;
  }
  [Me(474)](t) {
    const e = Me;
    this[e(494)] = t;
  }
  [Me(468)](t) {
    const e = Me;
    this[e(453)] = t;
  }
  [Me(471)](t) {
    this.rotation_ = t;
  }
  [Me(451)](t) {
    const e = Me;
    this.scale_ = t, this[e(449)] = vx(t);
  }
  [Me(469)](t) {
    qe();
  }
  [Me(479)]() {
    qe();
  }
  [Me(489)](t) {
    qe();
  }
  [Me(470)]() {
    return Promise[Me(488)]();
  }
}
function bf(r, t) {
  const e = Pp();
  return bf = function(n, i) {
    return n = n - 448, e[n];
  }, bf(r, t);
}
const If = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
};
var Dr = {
  name: "xyz",
  min: [0, 0, 0],
  channel: ["X", "Y", "Z"],
  alias: ["XYZ", "ciexyz", "cie1931"]
};
Dr.whitepoint = {
  //1931 2°
  2: {
    //incadescent
    A: [109.85, 100, 35.585],
    // B:[],
    C: [98.074, 100, 118.232],
    D50: [96.422, 100, 82.521],
    D55: [95.682, 100, 92.149],
    //daylight
    D65: [95.045592705167, 100, 108.9057750759878],
    D75: [94.972, 100, 122.638],
    //flourescent
    // F1: [],
    F2: [99.187, 100, 67.395],
    // F3: [],
    // F4: [],
    // F5: [],
    // F6:[],
    F7: [95.044, 100, 108.755],
    // F8: [],
    // F9: [],
    // F10: [],
    F11: [100.966, 100, 64.37],
    // F12: [],
    E: [100, 100, 100]
  },
  //1964  10°
  10: {
    //incadescent
    A: [111.144, 100, 35.2],
    C: [97.285, 100, 116.145],
    D50: [96.72, 100, 81.427],
    D55: [95.799, 100, 90.926],
    //daylight
    D65: [94.811, 100, 107.304],
    D75: [94.416, 100, 120.641],
    //flourescent
    F2: [103.28, 100, 69.026],
    F7: [95.792, 100, 107.687],
    F11: [103.866, 100, 65.627],
    E: [100, 100, 100]
  }
};
Dr.max = Dr.whitepoint[2].D65;
Dr.rgb = function(r, t) {
  t = t || Dr.whitepoint[2].E;
  var e = r[0] / t[0], n = r[1] / t[1], i = r[2] / t[2], s, o, a;
  return s = e * 3.240969941904521 + n * -1.537383177570093 + i * -0.498610760293, o = e * -0.96924363628087 + n * 1.87596750150772 + i * 0.041555057407175, a = e * 0.055630079696993 + n * -0.20397695888897 + i * 1.056971514242878, s = s > 31308e-7 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s = s * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a = a * 12.92, s = Math.min(Math.max(0, s), 1), o = Math.min(Math.max(0, o), 1), a = Math.min(Math.max(0, a), 1), [s * 255, o * 255, a * 255];
};
If.xyz = function(r, t) {
  var e = r[0] / 255, n = r[1] / 255, i = r[2] / 255;
  e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92;
  var s = e * 0.41239079926595 + n * 0.35758433938387 + i * 0.18048078840183, o = e * 0.21263900587151 + n * 0.71516867876775 + i * 0.072192315360733, a = e * 0.019330818715591 + n * 0.11919477979462 + i * 0.95053215224966;
  return t = t || Dr.whitepoint[2].E, [s * t[0], o * t[1], a * t[2]];
};
const C_ = {
  name: "luv",
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ["lightness", "u", "v"],
  alias: ["LUV", "cieluv", "cie1976"],
  xyz: function(r, t, e) {
    var n, i, s, o, a, u, x, c, f, l, h, p, y;
    if (s = r[0], o = r[1], a = r[2], s === 0) return [0, 0, 0];
    var v = 0.0011070564598794539;
    return t = t || "D65", e = e || 2, f = Dr.whitepoint[e][t][0], l = Dr.whitepoint[e][t][1], h = Dr.whitepoint[e][t][2], p = 4 * f / (f + 15 * l + 3 * h), y = 9 * l / (f + 15 * l + 3 * h), n = o / (13 * s) + p || 0, i = a / (13 * s) + y || 0, x = s > 8 ? l * Math.pow((s + 16) / 116, 3) : l * s * v, u = x * 9 * n / (4 * i) || 0, c = x * (12 - 3 * n - 20 * i) / (4 * i) || 0, [u, x, c];
  }
};
Dr.luv = function(r, t, e) {
  var n, i, s, o, a, u, x, c, f, l, h, p, y, v = 0.008856451679035631, m = 903.2962962962961;
  t = t || "D65", e = e || 2, f = Dr.whitepoint[e][t][0], l = Dr.whitepoint[e][t][1], h = Dr.whitepoint[e][t][2], p = 4 * f / (f + 15 * l + 3 * h), y = 9 * l / (f + 15 * l + 3 * h), u = r[0], x = r[1], c = r[2], n = 4 * u / (u + 15 * x + 3 * c) || 0, i = 9 * x / (u + 15 * x + 3 * c) || 0;
  var d = x / l;
  return s = d <= v ? m * d : 116 * Math.pow(d, 1 / 3) - 16, o = 13 * s * (n - p), a = 13 * s * (i - y), [s, o, a];
};
var D4 = {
  name: "lchuv",
  channel: ["lightness", "chroma", "hue"],
  alias: ["LCHuv", "cielchuv"],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function(r) {
    var t = r[0], e = r[1], n = r[2], i, s, o;
    return o = n / 360 * 2 * Math.PI, i = e * Math.cos(o), s = e * Math.sin(o), [t, i, s];
  },
  xyz: function(r) {
    return C_.xyz(D4.luv(r));
  }
};
C_.lchuv = function(r) {
  var t = r[0], e = r[1], n = r[2], i = Math.sqrt(e * e + n * n), s = Math.atan2(n, e), o = s * 360 / 2 / Math.PI;
  return o < 0 && (o += 360), [t, i, o];
};
Dr.lchuv = function(r) {
  return C_.lchuv(Dr.luv(r));
};
const Ob = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var Rb = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function p9(r) {
  var c, f;
  var t, e = [], n = 1, i;
  if (typeof r == "number")
    return { space: "rgb", values: [r >>> 16, (r & 65280) >>> 8, r & 255], alpha: 1 };
  if (typeof r == "number") return { space: "rgb", values: [r >>> 16, (r & 65280) >>> 8, r & 255], alpha: 1 };
  if (r = String(r).toLowerCase(), Ob[r])
    e = Ob[r].slice(), i = "rgb";
  else if (r === "transparent")
    n = 0, i = "rgb", e = [0, 0, 0];
  else if (r[0] === "#") {
    var s = r.slice(1), o = s.length, a = o <= 4;
    n = 1, a ? (e = [
      parseInt(s[0] + s[0], 16),
      parseInt(s[1] + s[1], 16),
      parseInt(s[2] + s[2], 16)
    ], o === 4 && (n = parseInt(s[3] + s[3], 16) / 255)) : (e = [
      parseInt(s[0] + s[1], 16),
      parseInt(s[2] + s[3], 16),
      parseInt(s[4] + s[5], 16)
    ], o === 8 && (n = parseInt(s[6] + s[7], 16) / 255)), e[0] || (e[0] = 0), e[1] || (e[1] = 0), e[2] || (e[2] = 0), i = "rgb";
  } else if (t = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(r)) {
    var u = t[1];
    i = u.replace(/a$/, "");
    var x = i === "cmyk" ? 4 : i === "gray" ? 1 : 3;
    e = t[2].trim().split(/\s*[,\/]\s*|\s+/), i === "color" && (i = e.shift()), e = e.map(function(l, h) {
      if (l[l.length - 1] === "%")
        return l = parseFloat(l) / 100, h === 3 ? l : i === "rgb" ? l * 255 : i[0] === "h" || i[0] === "l" && !h ? l * 100 : i === "lab" ? l * 125 : i === "lch" ? h < 2 ? l * 150 : l * 360 : i[0] === "o" && !h ? l : i === "oklab" ? l * 0.4 : i === "oklch" ? h < 2 ? l * 0.4 : l * 360 : l;
      if (i[h] === "h" || h === 2 && i[i.length - 1] === "h") {
        if (Rb[l] !== void 0) return Rb[l];
        if (l.endsWith("deg")) return parseFloat(l);
        if (l.endsWith("turn")) return parseFloat(l) * 360;
        if (l.endsWith("grad")) return parseFloat(l) * 360 / 400;
        if (l.endsWith("rad")) return parseFloat(l) * 180 / Math.PI;
      }
      return l === "none" ? 0 : parseFloat(l);
    }), n = e.length > x ? e.pop() : 1;
  } else /[0-9](?:\s|\/|,)/.test(r) && (e = r.match(/([0-9]+)/g).map(function(l) {
    return parseFloat(l);
  }), i = ((f = (c = r.match(/([a-z])/ig)) == null ? void 0 : c.join("")) == null ? void 0 : f.toLowerCase()) || "rgb");
  return {
    space: i,
    values: e,
    alpha: n
  };
}
const hv = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(r) {
    var t = r[0] / 360, e = r[1] / 100, n = r[2] / 100, i, s, o, a, u, x = 0;
    if (e === 0) return u = n * 255, [u, u, u];
    for (s = n < 0.5 ? n * (1 + e) : n + e - n * e, i = 2 * n - s, a = [0, 0, 0]; x < 3; )
      o = t + 1 / 3 * -(x - 1), o < 0 ? o++ : o > 1 && o--, u = 6 * o < 1 ? i + (s - i) * 6 * o : 2 * o < 1 ? s : 3 * o < 2 ? i + (s - i) * (2 / 3 - o) * 6 : i, a[x++] = u * 255;
    return a;
  }
};
If.hsl = function(r) {
  var t = r[0] / 255, e = r[1] / 255, n = r[2] / 255, i = Math.min(t, e, n), s = Math.max(t, e, n), o = s - i, a, u, x;
  return s === i ? a = 0 : t === s ? a = (e - n) / o : e === s ? a = 2 + (n - t) / o : n === s && (a = 4 + (t - e) / o), a = Math.min(a * 60, 360), a < 0 && (a += 360), x = (i + s) / 2, s === i ? u = 0 : x <= 0.5 ? u = o / (s + i) : u = o / (2 - s - i), [a, u * 100, x * 100];
};
function d9(r) {
  Array.isArray(r) && r.raw && (r = String.raw(...arguments)), r instanceof Number && (r = +r);
  var t, e = p9(r);
  if (!e.space) return [];
  const n = e.space[0] === "h" ? hv.min : If.min, i = e.space[0] === "h" ? hv.max : If.max;
  return t = Array(3), t[0] = Math.min(Math.max(e.values[0], n[0]), i[0]), t[1] = Math.min(Math.max(e.values[1], n[1]), i[1]), t[2] = Math.min(Math.max(e.values[2], n[2]), i[2]), e.space[0] === "h" && (t = hv.rgb(t)), t.push(Math.min(Math.max(e.alpha, 0), 1)), t;
}
(function(r, t) {
  const e = wo, n = r();
  for (; ; )
    try {
      if (parseInt(e(224)) / 1 + -parseInt(e(223)) / 2 + -parseInt(e(215)) / 3 + -parseInt(e(218)) / 4 + parseInt(e(225)) / 5 + -parseInt(e(219)) / 6 + -parseInt(e(216)) / 7 * (-parseInt(e(228)) / 8) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Lp, 958194);
function wo(r, t) {
  const e = Lp();
  return wo = function(n, i) {
    return n = n - 211, e[n];
  }, wo(r, t);
}
function Lp() {
  const r = ['" as color', "slice", "176MApFtg", "hasOwnProperty", "lchuv", "rgba(", "string", "2205366WtNmJm", "238252DyDdSm", 'failed to parse "', "6777772qAVcMH", "1059252xDosXj", "round", "isArray", "xyz", "480424SqULaW", "1380117rGBaFh", "8378020dmLYsa"];
  return Lp = function() {
    return r;
  }, Lp();
}
const M_ = [NaN, NaN, NaN, 0];
function Jo(r) {
  return typeof r === wo(214) ? r : L_(r);
}
const g9 = 1024, yc = {};
let pv = 0;
function y9(r) {
  const t = wo;
  if (r.length === 4) return r;
  const e = r[t(227)]();
  return e[3] = 1, e;
}
function Ab(r) {
  const t = wo, e = Dr[t(212)](If.xyz(r));
  return e[3] = r[3], e;
}
function v9(r) {
  const t = wo, e = Dr.rgb(D4[t(222)](r));
  return e[3] = r[3], e;
}
function P_(r) {
  const t = wo;
  if (r === "none") return M_;
  if (yc[t(211)](r)) return yc[r];
  if (pv >= g9) {
    let n = 0;
    for (const i in yc)
      !(n++ & 3) && (delete yc[i], --pv);
  }
  const e = d9(r);
  if (e.length !== 4) throw new Error(t(217) + r + t(226));
  for (const n of e)
    if (isNaN(n)) throw new Error(t(217) + r + t(226));
  return F4(e), yc[r] = e, ++pv, e;
}
function wf(r) {
  return Array[wo(221)](r) ? r : P_(r);
}
function F4(r) {
  return r[0] = Tr(r[0] + 0.5 | 0, 0, 255), r[1] = Tr(r[1] + 0.5 | 0, 0, 255), r[2] = Tr(r[2] + 0.5 | 0, 0, 255), r[3] = Tr(r[3], 0, 1), r;
}
function L_(r) {
  const t = wo;
  let e = r[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  let n = r[1];
  n != (n | 0) && (n = n + 0.5 | 0);
  let i = r[2];
  i != (i | 0) && (i = i + 0.5 | 0);
  const s = r[3] === void 0 ? 1 : Math[t(220)](r[3] * 1e3) / 1e3;
  return t(213) + e + "," + n + "," + i + "," + s + ")";
}
const ir = Op;
(function(r, t) {
  const e = Op, n = r();
  for (; ; )
    try {
      if (-parseInt(e(243)) / 1 * (parseInt(e(239)) / 2) + -parseInt(e(233)) / 3 + -parseInt(e(242)) / 4 + -parseInt(e(251)) / 5 + parseInt(e(238)) / 6 + -parseInt(e(241)) / 7 * (-parseInt(e(236)) / 8) + parseInt(e(237)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Np, 490975);
const Ha = typeof navigator < "u" && typeof navigator[ir(229)] < "u" ? navigator[ir(229)].toLowerCase() : "";
Ha[ir(248)](ir(230));
function Np() {
  const r = ["userAgent", "firefox", "decode", "webkit", "1112856oJQNEy", "addEventListener", "version/15.4", "352agmviZ", "7935696ArIHhx", "3548748uCNjGa", "1580316MDXVaW", "removeEventListener", "134911eTPFAQ", "2172656GLdCid", "1HFrqFZ", "test", "safari", "passive", "chrom", "includes", "prototype", "undefined", "629825tmptHB"];
  return Np = function() {
    return r;
  }, Np();
}
const m9 = Ha[ir(248)](ir(245)) && !Ha.includes(ir(247));
function Op(r, t) {
  const e = Np();
  return Op = function(n, i) {
    return n = n - 229, e[n];
  }, Op(r, t);
}
m9 && (Ha[ir(248)](ir(235)) || /cpu (os|iphone os) 15_4 like mac os x/[ir(244)](Ha));
Ha[ir(248)](ir(232)) && Ha.includes("edge");
Ha[ir(248)]("macintosh");
const Tb = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, k4 = typeof WorkerGlobalScope !== ir(250) && typeof OffscreenCanvas !== ir(250) && self instanceof WorkerGlobalScope, _9 = typeof Image !== ir(250) && Image[ir(249)][ir(231)];
(function() {
  const r = ir;
  let t = !1;
  try {
    const e = Object.defineProperty({}, r(246), { get: function() {
      t = !0;
    } });
    window[r(234)]("_", null, e), window[r(240)]("_", null, e);
  } catch {
  }
  return t;
})();
(function(r, t) {
  const e = Ef, n = r();
  for (; ; )
    try {
      if (parseInt(e(508)) / 1 + parseInt(e(499)) / 2 * (-parseInt(e(490)) / 3) + -parseInt(e(495)) / 4 * (-parseInt(e(494)) / 5) + -parseInt(e(511)) / 6 * (-parseInt(e(498)) / 7) + parseInt(e(506)) / 8 + parseInt(e(509)) / 9 * (-parseInt(e(501)) / 10) + parseInt(e(512)) / 11 * (-parseInt(e(513)) / 12) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Ap, 369985);
function Ui(r, t, e, n) {
  const i = Ef;
  let s;
  return e && e[i(493)] ? s = e.shift() : k4 ? s = new OffscreenCanvas(r || 300, t || 300) : s = document[i(504)]("canvas"), r && (s.width = r), t && (s.height = t), s[i(497)]("2d", n);
}
let dv;
function Rp() {
  return !dv && (dv = Ui(1, 1)), dv;
}
function b9(r) {
  const t = Ef, e = r[t(515)];
  e[t(488)] = 1, e[t(491)] = 1, r[t(502)](0, 0, 1, 1);
}
function Ef(r, t) {
  const e = Ap();
  return Ef = function(n, i) {
    return n = n - 487, e[n];
  }, Ef(r, t);
}
function Ap() {
  const r = ["childNodes", "canvas", "appendChild", "width", "marginRight", "348knoptX", "height", "offsetWidth", "length", "572205ZakKll", "12DgsHUl", "marginBottom", "getContext", "7AwBIRn", "1526yKxURh", "lastChild", "877670ZtwTzq", "clearRect", "marginTop", "createElement", "marginLeft", "2454368cLpNVO", "parentNode", "583180kqKtPx", "9HmSZmx", "removeChild", "1329738NERkBr", "9995282uFfvPf", "12aVXNkp"];
  return Ap = function() {
    return r;
  }, Ap();
}
const Bi = k0;
(function(r, t) {
  const e = k0, n = r();
  for (; ; )
    try {
      if (-parseInt(e(190)) / 1 * (-parseInt(e(200)) / 2) + parseInt(e(203)) / 3 * (-parseInt(e(176)) / 4) + parseInt(e(199)) / 5 * (parseInt(e(188)) / 6) + -parseInt(e(175)) / 7 * (-parseInt(e(169)) / 8) + -parseInt(e(168)) / 9 + -parseInt(e(164)) / 10 + parseInt(e(166)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Tp, 234293);
function Tp() {
  const r = ["catch", "extent", "IDLE", "decode", "getPixelRatio", "1267GAyfDZ", "1254664LAxOOX", "image", "width", "getState", "getExtent", "removeEventListener", "then", "src", "loader", "getResolution", "LOADED", "pixelRatio", "66PYmdTM", "pixelRatio_", "2eTjtqI", "image_", "changed", "LOAD", "dispatchEvent", "error", "push", "CHANGE", "function", "76505ZcvKzu", "340394rXsrUM", "finally", "state", "3nXwYnx", "resolution", "ERROR", "2570490XYYwcZ", "load", "2183775aMsIOs", "setImage", "766917lVYidl", "8088IuhDTZ"];
  return Tp = function() {
    return r;
  }, Tp();
}
class Zk extends c_ {
  constructor(t, e, n, i) {
    const s = k0;
    super(), this[s(171)] = t, this.pixelRatio_ = n, this.resolution = e, this[s(202)] = typeof i == "function" ? Et[s(172)] : i, this.image_ = null, this.loader = typeof i === s(198) ? i : null;
  }
  [Bi(192)]() {
    const t = Bi;
    this[t(194)](rr[t(197)]);
  }
  [Bi(180)]() {
    return this[Bi(171)];
  }
  getImage() {
    return this.image_;
  }
  getPixelRatio() {
    return this.pixelRatio_;
  }
  getResolution() {
    return this[Bi(204)];
  }
  [Bi(179)]() {
    return this[Bi(202)];
  }
  [Bi(165)]() {
    const t = Bi;
    if (this[t(202)] == Et.IDLE && this.loader) {
      this[t(202)] = Et.LOADING, this[t(192)]();
      const e = this[t(185)](), n = Array.isArray(e) ? e[0] : e;
      q6(() => this[t(184)](this.getExtent(), n, this[t(174)]()))[t(182)]((i) => {
        const s = t;
        s(177) in i && (this[s(191)] = i[s(177)]), s(171) in i && (this.extent = i[s(171)]), s(204) in i && (this.resolution = i[s(204)]), s(187) in i && (this[s(189)] = i[s(187)]), (i instanceof HTMLImageElement || i instanceof ImageBitmap || i instanceof HTMLCanvasElement || i instanceof HTMLVideoElement) && (this[s(191)] = i), this[s(202)] = Et[s(186)];
      }).catch((i) => {
        const s = t;
        this[s(202)] = Et[s(205)], console.error(i);
      })[t(201)](() => this[t(192)]());
    }
  }
  [Bi(167)](t) {
    const e = Bi;
    this[e(191)] = t;
  }
  setResolution(t) {
    const e = Bi;
    this[e(204)] = t;
  }
}
function I9(r, t) {
  return new Promise((e, n) => {
    const i = k0;
    function s() {
      a(), e(r);
    }
    function o() {
      a(), n(new Error("Image load error"));
    }
    function a() {
      const u = k0;
      r[u(181)](u(165), s), r[u(181)](u(195), o);
    }
    r.addEventListener(i(165), s), r.addEventListener("error", o);
  });
}
function k0(r, t) {
  const e = Tp();
  return k0 = function(n, i) {
    return n = n - 164, e[n];
  }, k0(r, t);
}
function w9(r, t) {
  const e = Bi;
  return t && (r[e(183)] = t), r[e(183)] && _9 ? new Promise((n, i) => r[e(173)]().then(() => n(r)).catch((s) => r.complete && r[e(178)] ? n(r) : i(s))) : I9(r);
}
const Ds = Sf;
(function(r, t) {
  const e = Sf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(147)) / 1 * (parseInt(e(152)) / 2) + -parseInt(e(169)) / 3 + parseInt(e(168)) / 4 + parseInt(e(153)) / 5 * (parseInt(e(155)) / 6) + parseInt(e(164)) / 7 + -parseInt(e(149)) / 8 * (-parseInt(e(163)) / 9) + -parseInt(e(170)) / 10 * (parseInt(e(154)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Dp, 124578);
function Dp() {
  const r = ["694945DjMDPK", "66GqXnsf", "6sjeYCM", "ready", "repeat", "expire", "cache_", "IDLE", "canExpireCache", "patternCache_", "72bisLoZ", "785673YVRecb", "setSize", "createPattern", "cacheSize_", "845632kyQirp", "339975ktlYKe", "486620RHwNNk", "getImage", "then", "maxCacheSize_", "1sioRUW", "hasListener", "71032iigyMG", "clear", "load", "7586RDhVbN"];
  return Dp = function() {
    return r;
  }, Dp();
}
function Sf(r, t) {
  const e = Dp();
  return Sf = function(n, i) {
    return n = n - 144, e[n];
  }, Sf(r, t);
}
class E9 {
  constructor() {
    const t = Sf;
    this[t(159)] = {}, this[t(162)] = {}, this[t(167)] = 0, this[t(146)] = 32;
  }
  [Ds(150)]() {
    const t = Ds;
    this[t(159)] = {}, this[t(162)] = {}, this.cacheSize_ = 0;
  }
  [Ds(161)]() {
    const t = Ds;
    return this[t(167)] > this[t(146)];
  }
  [Ds(158)]() {
    const t = Ds;
    if (this[t(161)]()) {
      let e = 0;
      for (const n in this[t(159)]) {
        const i = this[t(159)][n];
        !(e++ & 3) && !i[t(148)]() && (delete this[t(159)][n], delete this[t(162)][n], --this[t(167)]);
      }
    }
  }
  get(t, e, n) {
    const i = Ds, s = gv(t, e, n);
    return s in this[i(159)] ? this.cache_[s] : null;
  }
  getPattern(t, e, n) {
    const i = Ds, s = gv(t, e, n);
    return s in this[i(162)] ? this[i(162)][s] : null;
  }
  set(t, e, n, i, s) {
    const o = Ds, a = gv(t, e, n), u = a in this[o(159)];
    this.cache_[a] = i, s && (i.getImageState() === Et[o(160)] && i[o(151)](), i.getImageState() === Et.LOADING ? i[o(156)]()[o(145)](() => {
      const x = o;
      this[x(162)][a] = Rp()[x(166)](i[x(144)](1), x(157));
    }) : this[o(162)][a] = Rp().createPattern(i[o(144)](1), o(157))), !u && ++this[o(167)];
  }
  [Ds(165)](t) {
    const e = Ds;
    this[e(146)] = t, this[e(158)]();
  }
}
function gv(r, t, e) {
  const n = e ? wf(e) : "null";
  return t + ":" + r + ":" + n;
}
const Fa = new E9(), xn = mx;
(function(r, t) {
  const e = mx, n = r();
  for (; ; )
    try {
      if (parseInt(e(149)) / 1 + -parseInt(e(136)) / 2 + parseInt(e(154)) / 3 + parseInt(e(134)) / 4 + parseInt(e(163)) / 5 + -parseInt(e(155)) / 6 * (-parseInt(e(151)) / 7) + -parseInt(e(185)) / 8 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Fp, 503322);
function Fp() {
  const r = ["canvas", "handleImageLoad_", "height", "replaceColor_", "src_", "IDLE", "getContext", "color_", "ready_", "drawImage", "ERROR", "906685qylqfC", "canvas_", "14eGVEOZ", "getImageState", "ceil", "1467675trHANv", "1903698oLCaIE", "fillRect", "LOADING", "CHANGE", "addEventListener", "get", "imageState_", "dispatchEvent", "1347690ISHsnn", "getPattern", "then", "isTainted_", "getImageData", "hitDetectionImage_", "initializeImage_", "crossOrigin_", "dispatchChangeEvent_", "scale", "image_", "set", "load", "handleImageError_", "width", "getSize", "src", "getHitDetectionImage", "size_", "tainted_", "ready", "bind", "14172624wbKzjx", "getSrc", "LOADED", "globalCompositeOperation", "destination-in", "2895644FQtXRp", "fillStyle", "1498050WhCOUj", "getPixelRatio"];
  return Fp = function() {
    return r;
  }, Fp();
}
function mx(r, t) {
  const e = Fp();
  return mx = function(n, i) {
    return n = n - 130, e[n];
  }, mx(r, t);
}
let vc = null;
class N_ extends c_ {
  constructor(t, e, n, i, s) {
    const o = mx;
    super(), this[o(168)] = null, this[o(173)] = t, this.crossOrigin_ = n, this[o(150)] = {}, this.color_ = s, this.imageState_ = i === void 0 ? Et[o(143)] : i, this.size_ = t && t.width && t[o(140)] ? [t[o(177)], t.height] : null, this[o(142)] = e, this[o(182)], this[o(146)] = null;
  }
  initializeImage_() {
    const t = mx;
    this[t(173)] = new Image(), this[t(170)] !== null && (this.image_.crossOrigin = this[t(170)]);
  }
  [xn(166)]() {
    const t = xn;
    if (this[t(182)] === void 0 && this.imageState_ === Et[t(131)]) {
      !vc && (vc = Ui(1, 1, void 0, { willReadFrequently: !0 })), vc[t(147)](this[t(173)], 0, 0);
      try {
        vc[t(167)](0, 0, 1, 1), this[t(182)] = !1;
      } catch {
        vc = null, this[t(182)] = !0;
      }
    }
    return this[t(182)] === !0;
  }
  [xn(171)]() {
    this[xn(162)](rr.CHANGE);
  }
  [xn(176)]() {
    const t = xn;
    this.imageState_ = Et.ERROR, this[t(171)]();
  }
  handleImageLoad_() {
    const t = xn;
    this.imageState_ = Et[t(131)], this[t(181)] = [this[t(173)][t(177)], this[t(173)][t(140)]], this[t(171)]();
  }
  getImage(t) {
    const e = xn;
    return !this[e(173)] && this[e(169)](), this[e(141)](t), this.canvas_[t] ? this.canvas_[t] : this[e(173)];
  }
  [xn(137)](t) {
    const e = xn;
    return this[e(141)](t), this[e(150)][t] ? t : 1;
  }
  [xn(152)]() {
    return this[xn(161)];
  }
  [xn(180)]() {
    const t = xn;
    if (!this[t(173)] && this[t(169)](), !this.hitDetectionImage_)
      if (this[t(166)]()) {
        const e = this.size_[0], n = this.size_[1], i = Ui(e, n);
        i[t(156)](0, 0, e, n), this[t(168)] = i[t(138)];
      } else this[t(168)] = this[t(173)];
    return this[t(168)];
  }
  [xn(178)]() {
    return this[xn(181)];
  }
  [xn(130)]() {
    return this.src_;
  }
  [xn(175)]() {
    const t = xn;
    if (this[t(161)] === Et[t(143)]) {
      !this[t(173)] && this[t(169)](), this[t(161)] = Et[t(157)];
      try {
        this[t(142)] !== void 0 && (this.image_.src = this[t(142)]);
      } catch {
        this[t(176)]();
      }
      this[t(173)] instanceof HTMLImageElement && w9(this[t(173)], this.src_)[t(165)]((e) => {
        const n = t;
        this[n(173)] = e, this[n(139)]();
      }).catch(this.handleImageError_[t(184)](this));
    }
  }
  [xn(141)](t) {
    const e = xn;
    if (!this.color_ || this.canvas_[t] || this[e(161)] !== Et[e(131)]) return;
    const n = this.image_, i = document.createElement(e(138));
    i[e(177)] = Math.ceil(n[e(177)] * t), i[e(140)] = Math[e(153)](n[e(140)] * t);
    const s = i[e(144)]("2d");
    s[e(172)](t, t), s[e(147)](n, 0, 0), s[e(132)] = "multiply", s[e(135)] = Jo(this[e(145)]), s[e(156)](0, 0, i.width / t, i[e(140)] / t), s.globalCompositeOperation = e(133), s[e(147)](n, 0, 0), this[e(150)][t] = i;
  }
  [xn(183)]() {
    const t = xn;
    return !this.ready_ && (this[t(146)] = new Promise((e) => {
      const n = t;
      if (this.imageState_ === Et[n(131)] || this[n(161)] === Et[n(148)]) e();
      else {
        const i = () => {
          const s = n;
          (this[s(161)] === Et.LOADED || this[s(161)] === Et.ERROR) && (this.removeEventListener(rr.CHANGE, i), e());
        };
        this[n(159)](rr[n(158)], i);
      }
    })), this[t(146)];
  }
}
function O_(r, t, e, n, i, s) {
  const o = xn;
  let a = t === void 0 ? void 0 : Fa[o(160)](t, e, i);
  return !a && (a = new N_(r, r && o(179) in r ? r[o(179)] || void 0 : t, e, n, i), Fa[o(174)](t, e, i, a, s)), s && a && !Fa[o(164)](t, e, i) && Fa.set(t, e, i, a, s), a;
}
function Cf(r, t) {
  const e = kp();
  return Cf = function(n, i) {
    return n = n - 404, e[n];
  }, Cf(r, t);
}
(function(r, t) {
  const e = Cf, n = r();
  for (; ; )
    try {
      if (parseInt(e(405)) / 1 + parseInt(e(420)) / 2 + parseInt(e(408)) / 3 * (-parseInt(e(404)) / 4) + -parseInt(e(419)) / 5 + parseInt(e(406)) / 6 * (-parseInt(e(421)) / 7) + parseInt(e(407)) / 8 + parseInt(e(412)) / 9 * (parseInt(e(422)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(kp, 959184);
function kp() {
  const r = ["18UmxSlC", "3486488VHHydb", "6MdqVmO", "color", "isArray", "offset", "1397313FJkXNg", "anonymous", "getImage", "LOADED", "size", "src", "getPattern", "4509390ZdIPpu", "1627116JQwEjD", "3028207QxPxxi", "110nxvpHs", "getImageState", "drawImage", "1245268vfZsCu", "824303nzOjau"];
  return kp = function() {
    return r;
  }, kp();
}
function yo(r) {
  const t = Cf;
  return r ? Array[t(410)](r) ? L_(r) : typeof r == "object" && t(417) in r ? S9(r) : r : null;
}
function S9(r) {
  const t = Cf;
  if (!r[t(411)] || !r.size) return Fa[t(418)](r[t(417)], "anonymous", r[t(409)]);
  const e = r[t(417)] + ":" + r[t(411)], n = Fa[t(418)](e, void 0, r.color);
  if (n) return n;
  const i = Fa.get(r.src, t(413), null);
  if (i[t(423)]() !== Et[t(415)]) return null;
  const s = Ui(r[t(416)][0], r[t(416)][1]);
  return s[t(424)](i[t(414)](1), r[t(411)][0], r[t(411)][1], r[t(416)][0], r[t(416)][1], 0, 0, r[t(416)][0], r[t(416)][1]), O_(s.canvas, e, void 0, Et[t(415)], r.color, !0), Fa[t(418)](e, void 0, r[t(409)]);
}
const Vr = Gp;
(function(r, t) {
  const e = Gp, n = r();
  for (; ; )
    try {
      if (parseInt(e(343)) / 1 * (parseInt(e(344)) / 2) + parseInt(e(346)) / 3 * (parseInt(e(351)) / 4) + -parseInt(e(358)) / 5 + -parseInt(e(362)) / 6 + -parseInt(e(350)) / 7 + -parseInt(e(338)) / 8 + parseInt(e(349)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Bp, 908674);
function Bp() {
  const r = ["(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))", "lineHeight", "ol-selectable", "ol-hidden", "variant", "family", "5676725IQthGO", "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)", "match", "ol-unsupported", "1194078NzFTAP", "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))", "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?", "4626464oKCUpl", "ol-collapsed", "size", "ol-control", "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)", "591JdQGPX", "3578pMHcki", "ol-unselectable", "1788xrgsEI", "normal", "weight", "10209501FtxZha", "398580TUmbgG", "4608dmatFR"];
  return Bp = function() {
    return r;
  }, Bp();
}
Vr(355);
Vr(354);
Vr(345);
Vr(361);
Vr(341);
Vr(339);
function Gp(r, t) {
  const e = Bp();
  return Gp = function(n, i) {
    return n = n - 336, e[n];
  }, Gp(r, t);
}
const C9 = new RegExp([Vr(359), Vr(342), "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)", Vr(337), Vr(352), Vr(336), `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`].join(""), "i"), Db = ["style", Vr(356), Vr(348), Vr(340), Vr(353), "family"], B4 = function(r) {
  const t = Vr, e = r[t(360)](C9);
  if (!e) return null;
  const n = { lineHeight: t(347), size: "1.2em", style: t(347), weight: t(347), variant: t(347) };
  for (let i = 0, s = Db.length; i < s; ++i) {
    const o = e[i + 1];
    o !== void 0 && (n[Db[i]] = o);
  }
  return n.families = n[t(357)].split(/,\s?/), n;
}, Ro = Mf;
(function(r, t) {
  const e = Mf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(327)) / 1 * (-parseInt(e(325)) / 2) + -parseInt(e(313)) / 3 * (-parseInt(e(294)) / 4) + -parseInt(e(290)) / 5 * (parseInt(e(304)) / 6) + -parseInt(e(285)) / 7 * (parseInt(e(283)) / 8) + parseInt(e(288)) / 9 + -parseInt(e(292)) / 10 + parseInt(e(331)) / 11 * (parseInt(e(317)) / 12) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Xp, 793669);
const G4 = Ro(335), gi = "#000", _x = Ro(321), ea = [];
function Mf(r, t) {
  const e = Xp();
  return Mf = function(n, i) {
    return n = n - 281, e[n];
  }, Mf(r, t);
}
const na = 0, bx = Ro(321), Pf = 10, Lf = "#000", Nf = Ro(298), Yp = "middle", S0 = [0, 0, 0, 0];
function Xp() {
  const r = ["save", "length", "globalAlpha", "521400MTSfFP", "removeChild", "padding", "get", "round", "display", "families", "none", "490494SZBWrC", "div", "1owlfUI", "wmytzilWMYTZIL@#/&?$%10", "scale", "style", "99GeKHom", "push", "translate", "drawImage", "10px sans-serif", "max", "position", "auto", "left", "weight", "7197472cySHpl", "restore", "7WRWige", "actualBoundingBoxDescent", "font", "12342177DCJitG", "body", "8330IGIVwP", "transform", "5505420txsBNg", "reduce", "36xmGspN", "height", "appendChild", "monospace", "center", "serif", "isArray", "lineHeight", "border", "innerHTML", "840HDCaMN", "-99999px", "apply", "set", "split", "measureText", "block", "32px ", "minHeight", "156495xTFnbX"];
  return Xp = function() {
    return r;
  }, Xp();
}
const Of = 1, Ca = new a0();
let Ou = null, Cm;
const Mm = {}, M9 = function() {
  const r = Ro, t = 100, e = r(311), n = [r(297), r(299)], i = n[r(315)], s = r(328);
  let o, a;
  function u(c, f, l) {
    let h = !0;
    for (let p = 0; p < i; ++p) {
      const y = n[p];
      if (a = qp(c + " " + f + " " + e + y, s), l != y) {
        const v = qp(c + " " + f + " " + e + l + "," + y, s);
        h = h && v != a;
      }
    }
    return !!h;
  }
  function x() {
    const c = r;
    let f = !0;
    const l = Ca.getKeys();
    for (let h = 0, p = l.length; h < p; ++h) {
      const y = l[h];
      if (Ca[c(320)](y) < t) {
        const [v, m, d] = y.split(`
`);
        u(v, m, d) ? (ly(Mm), Ou = null, Cm = void 0, Ca[c(307)](y, t)) : (Ca[c(307)](y, Ca.get(y) + 1, !0), f = !1);
      }
    }
    f && (clearInterval(o), o = void 0);
  }
  return function(c) {
    const f = r, l = B4(c);
    if (!l) return;
    const h = l[f(323)];
    for (let p = 0, y = h.length; p < y; ++p) {
      const v = h[p], m = l.style + `
` + l[f(282)] + `
` + v;
      Ca.get(m) === void 0 && (Ca[f(307)](m, t, !0), !u(l[f(330)], l[f(282)], v) && (Ca[f(307)](m, 0, !0), o === void 0 && (o = setInterval(x, 32))));
    }
  };
}(), P9 = /* @__PURE__ */ function() {
  let r;
  return function(t) {
    const e = Mf;
    let n = Mm[t];
    if (n == null) {
      if (k4) {
        const i = B4(t), s = Y4(t, "Žg");
        n = (isNaN(Number(i[e(301)])) ? 1.2 : Number(i[e(301)])) * (s.actualBoundingBoxAscent + s[e(286)]);
      } else !r && (r = document.createElement(e(326)), r[e(303)] = "M", r.style[e(312)] = "0", r[e(330)].maxHeight = "none", r[e(330)][e(295)] = e(338), r[e(330)][e(319)] = "0", r[e(330)][e(302)] = e(324), r.style[e(337)] = "absolute", r[e(330)][e(322)] = e(310), r[e(330)][e(281)] = e(305)), r.style[e(287)] = t, document[e(289)][e(296)](r), n = r.offsetHeight, document[e(289)][e(318)](r);
      Mm[t] = n;
    }
    return n;
  };
}();
function Y4(r, t) {
  const e = Ro;
  return !Ou && (Ou = Ui(1, 1)), r != Cm && (Ou.font = r, Cm = Ou[e(287)]), Ou[e(309)](t);
}
function qp(r, t) {
  return Y4(r, t).width;
}
function Fb(r, t, e) {
  const n = Ro;
  if (t in e) return e[t];
  const i = t[n(308)](`
`)[n(293)]((s, o) => Math[n(336)](s, qp(r, o)), 0);
  return e[t] = i, i;
}
function L9(r, t) {
  const e = Ro, n = [], i = [], s = [];
  let o = 0, a = 0, u = 0, x = 0;
  for (let c = 0, f = t[e(315)]; c <= f; c += 2) {
    const l = t[c];
    if (l === `
` || c === f) {
      o = Math.max(o, a), s[e(332)](a), a = 0, u += x, x = 0;
      continue;
    }
    const h = t[c + 1] || r[e(287)], p = qp(h, l);
    n[e(332)](p), a += p;
    const y = P9(h);
    i[e(332)](y), x = Math[e(336)](x, y);
  }
  return { width: o, height: u, widths: n, heights: i, lineWidths: s };
}
function N9(r, t, e, n, i, s, o, a, u, x, c) {
  const f = Ro;
  r[f(314)](), e !== 1 && (r.globalAlpha === void 0 ? r[f(316)] = (l) => l.globalAlpha *= e : r[f(316)] *= e), t && r[f(291)][f(306)](r, t), n.contextInstructions ? (r[f(333)](u, x), r[f(329)](c[0], c[1]), O9(n, r)) : c[0] < 0 || c[1] < 0 ? (r.translate(u, x), r[f(329)](c[0], c[1]), r[f(334)](n, i, s, o, a, 0, 0, o, a)) : r.drawImage(n, i, s, o, a, u, x, o * c[0], a * c[1]), r[f(284)]();
}
function O9(r, t) {
  const e = Ro, n = r.contextInstructions;
  for (let i = 0, s = n[e(315)]; i < s; i += 2)
    Array[e(300)](n[i + 1]) ? t[n[i]][e(306)](t, n[i + 1]) : t[n[i]] = n[i + 1];
}
const bt = Rf;
(function(r, t) {
  const e = Rf, n = r();
  for (; ; )
    try {
      if (parseInt(e(251)) / 1 * (-parseInt(e(243)) / 2) + parseInt(e(296)) / 3 * (parseInt(e(264)) / 4) + -parseInt(e(297)) / 5 + parseInt(e(329)) / 6 + -parseInt(e(265)) / 7 + -parseInt(e(259)) / 8 * (parseInt(e(303)) / 9) + parseInt(e(285)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(zp, 340540);
function Rf(r, t) {
  const e = zp();
  return Rf = function(n, i) {
    return n = n - 243, e[n];
  }, Rf(r, t);
}
class _o extends nc {
  constructor(t) {
    const e = Rf;
    super({ opacity: 1, rotateWithView: t.rotateWithView !== void 0 ? t[e(327)] : !1, rotation: t[e(280)] !== void 0 ? t[e(280)] : 0, scale: t[e(319)] !== void 0 ? t[e(319)] : 1, displacement: t[e(267)] !== void 0 ? t[e(267)] : [0, 0], declutterMode: t[e(318)] }), this[e(305)], this.hitDetectionCanvas_ = null, this[e(253)] = t[e(315)] !== void 0 ? t[e(315)] : null, this[e(302)] = [0, 0], this.points_ = t.points, this[e(258)] = t[e(258)], this[e(277)] = t[e(256)], this[e(311)] = t.angle !== void 0 ? t[e(247)] : 0, this.stroke_ = t.stroke !== void 0 ? t[e(317)] : null, this[e(306)], this[e(263)], this.imageState_ = this[e(253)] && this.fill_[e(270)]() ? Et[e(272)] : Et[e(254)], this[e(268)] === Et[e(272)] && this[e(276)]().then(() => this[e(268)] = Et[e(254)]), this[e(332)]();
  }
  [bt(298)]() {
    const t = bt, e = this[t(334)](), n = new _o({ fill: this[t(245)]() ? this[t(245)]()[t(298)]() : void 0, points: this.getPoints(), radius: this.getRadius(), radius2: this[t(283)](), angle: this[t(290)](), stroke: this[t(252)]() ? this.getStroke()[t(298)]() : void 0, rotation: this.getRotation(), rotateWithView: this[t(291)](), scale: Array[t(322)](e) ? e[t(261)]() : e, displacement: this[t(294)]()[t(261)](), declutterMode: this[t(281)]() });
    return n.setOpacity(this[t(308)]()), n;
  }
  [bt(325)]() {
    const t = bt, e = this[t(306)], n = this[t(294)](), i = this[t(333)]();
    return [e[0] / 2 - n[0] / i[0], e[1] / 2 + n[1] / i[1]];
  }
  [bt(290)]() {
    return this[bt(311)];
  }
  [bt(245)]() {
    return this[bt(253)];
  }
  [bt(300)](t) {
    const e = bt;
    this.fill_ = t, this[e(332)]();
  }
  [bt(269)]() {
    const t = bt;
    return !this[t(284)] && (this[t(284)] = this[t(260)](this[t(263)])), this.hitDetectionCanvas_;
  }
  [bt(288)](t) {
    const e = bt;
    let n = this[e(305)][t];
    if (!n) {
      const i = this[e(263)], s = Ui(i[e(250)] * t, i[e(250)] * t);
      this.draw_(i, s, t), n = s[e(328)], this[e(305)][t] = n;
    }
    return n;
  }
  getPixelRatio(t) {
    return t;
  }
  [bt(274)]() {
    return this[bt(306)];
  }
  [bt(307)]() {
    return this.imageState_;
  }
  [bt(279)]() {
    return this[bt(302)];
  }
  [bt(335)]() {
    return this.points_;
  }
  [bt(331)]() {
    return this[bt(258)];
  }
  [bt(283)]() {
    return this[bt(277)];
  }
  [bt(304)]() {
    return this[bt(306)];
  }
  [bt(252)]() {
    return this.stroke_;
  }
  [bt(337)](t) {
    const e = bt;
    this[e(309)] = t, this.render();
  }
  [bt(326)](t) {
  }
  [bt(248)]() {
  }
  unlistenImageChange(t) {
  }
  [bt(293)](t, e, n) {
    const i = bt;
    if (e === 0 || this[i(310)] === 1 / 0 || t !== i(249) && t !== "miter") return e;
    let s = this.radius, o = this[i(277)] === void 0 ? s : this[i(277)];
    if (s < o) {
      const E = s;
      s = o, o = E;
    }
    const a = this[i(277)] === void 0 ? this.points_ : this[i(310)] * 2, u = 2 * Math.PI / a, x = o * Math[i(244)](u), c = Math[i(286)](o * o - x * x), f = s - c, l = Math[i(286)](x * x + f * f), h = l / x;
    if (t === i(316) && h <= n) return h * e;
    const p = e / 2 / h, y = e / 2 * (f / l), v = Math.sqrt((s + p) * (s + p) + y * y), m = v - s;
    if (this[i(277)] === void 0 || t === "bevel") return m * 2;
    const d = s * Math[i(244)](u), g = Math[i(286)](s * s - d * d), _ = o - g, b = Math[i(286)](d * d + _ * _), w = b / d;
    if (w <= n) {
      const E = w * e / 2 - o - s;
      return 2 * Math.max(m, E);
    }
    return m * 2;
  }
  [bt(320)]() {
    const t = bt;
    let e = _x, n = bx, i = 0, s = null, o = 0, a, u = 0;
    this[t(309)] && (a = yo(this[t(309)][t(301)]() ?? Lf), u = this[t(309)].getWidth() ?? Of, s = this[t(309)].getLineDash(), o = this[t(309)][t(271)]() ?? 0, n = this[t(309)][t(278)]() ?? bx, e = this[t(309)][t(321)]() ?? _x, i = this[t(309)].getMiterLimit() ?? Pf);
    const x = this[t(293)](n, u, i), c = Math.max(this.radius, this[t(277)] || 0), f = Math.ceil(2 * c + x);
    return { strokeStyle: a, strokeWidth: u, size: f, lineCap: e, lineDash: s, lineDashOffset: o, lineJoin: n, miterLimit: i };
  }
  [bt(332)]() {
    const t = bt;
    this.renderOptions_ = this.createRenderOptions();
    const e = this[t(263)].size;
    this[t(305)] = {}, this[t(284)] = null, this[t(306)] = [e, e];
  }
  [bt(313)](t, e, n) {
    const i = bt;
    if (e[i(319)](n, n), e[i(336)](t[i(250)] / 2, t[i(250)] / 2), this[i(338)](e), this.fill_) {
      let s = this[i(253)][i(301)]();
      s === null && (s = gi), e[i(324)] = yo(s), e.fill();
    }
    t[i(255)] && (e.strokeStyle = t.strokeStyle, e[i(266)] = t[i(289)], t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t[i(323)]), e.lineCap = t[i(282)], e[i(295)] = t[i(295)], e[i(287)] = t.miterLimit, e[i(317)]());
  }
  [bt(260)](t) {
    const e = bt;
    let n;
    if (this.fill_) {
      let i = this[e(253)][e(301)](), s = 0;
      typeof i === e(246) && (i = wf(i)), i === null ? s = 1 : Array[e(322)](i) && (s = i[e(299)] === 4 ? i[3] : 1), s === 0 && (n = Ui(t[e(250)], t.size), this.drawHitDetectionCanvas_(t, n));
    }
    return n ? n.canvas : this[e(288)](1);
  }
  [bt(338)](t) {
    const e = bt;
    let n = this[e(310)];
    const i = this.radius;
    if (n === 1 / 0) t[e(275)](0, 0, i, 0, 2 * Math.PI);
    else {
      const s = this.radius2_ === void 0 ? i : this[e(277)];
      this[e(277)] !== void 0 && (n *= 2);
      const o = this[e(311)] - Math.PI / 2, a = 2 * Math.PI / n;
      for (let u = 0; u < n; u++) {
        const x = o + u * a, c = u % 2 === 0 ? i : s;
        t[e(273)](c * Math[e(292)](x), c * Math[e(244)](x));
      }
      t[e(262)]();
    }
  }
  [bt(314)](t, e) {
    const n = bt;
    e[n(336)](t[n(250)] / 2, t[n(250)] / 2), this[n(338)](e), e.fillStyle = gi, e[n(315)](), t[n(255)] && (e.strokeStyle = t[n(255)], e[n(266)] = t.strokeWidth, t.lineDash && (e[n(330)](t[n(312)]), e[n(323)] = t.lineDashOffset), e.lineJoin = t[n(295)], e[n(287)] = t.miterLimit, e.stroke());
  }
  [bt(276)]() {
    const t = bt;
    return this[t(253)] ? this[t(253)].ready() : Promise[t(257)]();
  }
}
function zp() {
  const r = ["getPoints", "translate", "setStroke", "createPath_", "8lXhMBb", "sin", "getFill", "string", "angle", "load", "bevel", "size", "162628mOmXlJ", "getStroke", "fill_", "LOADED", "strokeStyle", "radius2", "resolve", "radius", "2933464mTDTuJ", "createHitDetectionCanvas_", "slice", "closePath", "renderOptions_", "578516xUEVmz", "1411291PWlJHk", "lineWidth", "displacement", "imageState_", "getHitDetectionImage", "loading", "getLineDashOffset", "LOADING", "lineTo", "getImageSize", "arc", "ready", "radius2_", "getLineJoin", "getOrigin", "rotation", "getDeclutterMode", "lineCap", "getRadius2", "hitDetectionCanvas_", "11841970qSGCnQ", "sqrt", "miterLimit", "getImage", "strokeWidth", "getAngle", "getRotateWithView", "cos", "calculateLineJoinSize_", "getDisplacement", "lineJoin", "3YJUzjf", "525660feWaEc", "clone", "length", "setFill", "getColor", "origin_", "9IRFJYK", "getSize", "canvases_", "size_", "getImageState", "getOpacity", "stroke_", "points_", "angle_", "lineDash", "draw_", "drawHitDetectionCanvas_", "fill", "miter", "stroke", "declutterMode", "scale", "createRenderOptions", "getLineCap", "isArray", "lineDashOffset", "fillStyle", "getAnchor", "listenImageChange", "rotateWithView", "canvas", "2013924OBTbpS", "setLineDash", "getRadius", "render", "getScaleArray", "getScale"];
  return zp = function() {
    return r;
  }, zp();
}
function Up() {
  const r = ["132442CoBmho", "346479WFvnzX", "isArray", "scale", "getRotation", "2HYIMiO", "setRadius", "getRadius", "getDeclutterMode", "getStroke", "slice", "3678885UtpNsU", "fill", "rotation", "32oasIrL", "285LtFAUI", "stroke", "radius", "getOpacity", "getFill", "getDisplacement", "914012PYPngY", "rotateWithView", "setOpacity", "977935fmMyCW", "clone", "373608wtOtTt"];
  return Up = function() {
    return r;
  }, Up();
}
function Af(r, t) {
  const e = Up();
  return Af = function(n, i) {
    return n = n - 335, e[n];
  }, Af(r, t);
}
const ch = Af;
(function(r, t) {
  const e = Af, n = r();
  for (; ; )
    try {
      if (parseInt(e(355)) / 1 * (-parseInt(e(350)) / 2) + parseInt(e(338)) / 3 + parseInt(e(344)) / 4 + parseInt(e(347)) / 5 + parseInt(e(349)) / 6 + parseInt(e(351)) / 7 * (parseInt(e(337)) / 8) + -parseInt(e(361)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Up, 143234);
class x0 extends _o {
  constructor(t) {
    const e = Af;
    t = t || { radius: 5 }, super({ points: 1 / 0, fill: t[e(335)], radius: t[e(340)], stroke: t[e(339)], scale: t[e(353)] !== void 0 ? t[e(353)] : 1, rotation: t[e(336)] !== void 0 ? t[e(336)] : 0, rotateWithView: t[e(345)] !== void 0 ? t[e(345)] : !1, displacement: t.displacement !== void 0 ? t.displacement : [0, 0], declutterMode: t.declutterMode });
  }
  [ch(348)]() {
    const t = ch, e = this.getScale(), n = new x0({ fill: this.getFill() ? this[t(342)]()[t(348)]() : void 0, stroke: this[t(359)]() ? this[t(359)]()[t(348)]() : void 0, radius: this[t(357)](), scale: Array[t(352)](e) ? e[t(360)]() : e, rotation: this[t(354)](), rotateWithView: this.getRotateWithView(), displacement: this[t(343)]()[t(360)](), declutterMode: this[t(358)]() });
    return n[t(346)](this[t(341)]()), n;
  }
  [ch(356)](t) {
    const e = ch;
    this[e(340)] = t, this.render();
  }
}
const v0 = Ix;
function Ix(r, t) {
  const e = Vp();
  return Ix = function(n, i) {
    return n = n - 332, e[n];
  }, Ix(r, t);
}
(function(r, t) {
  const e = Ix, n = r();
  for (; ; )
    try {
      if (parseInt(e(340)) / 1 + -parseInt(e(342)) / 2 + parseInt(e(351)) / 3 + parseInt(e(336)) / 4 + parseInt(e(339)) / 5 + -parseInt(e(338)) / 6 * (parseInt(e(357)) / 7) + parseInt(e(334)) / 8 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Vp, 245946);
class Hr {
  constructor(t) {
    const e = Ix;
    t = t || {}, this[e(333)] = null, this[e(332)] = null, t.color !== void 0 && this[e(344)](t[e(355)]);
  }
  clone() {
    const t = Ix, e = this[t(346)]();
    return new Hr({ color: Array[t(343)](e) ? e[t(352)]() : e || void 0 });
  }
  [v0(346)]() {
    return this[v0(332)];
  }
  setColor(t) {
    const e = v0;
    if (t !== null && typeof t == "object" && "src" in t) {
      const n = O_(null, t[e(335)], e(356), void 0, t.offset ? null : t.color ? t[e(355)] : null, !(t[e(345)] && t[e(348)]));
      n[e(347)]()[e(350)](() => {
        const i = e;
        this[i(333)] = null;
      }), n[e(337)]() === Et[e(354)] && n[e(358)](), n.getImageState() === Et[e(341)] && (this[e(333)] = n);
    }
    this[e(332)] = t;
  }
  [v0(353)]() {
    return !!this[v0(333)];
  }
  [v0(347)]() {
    const t = v0;
    return this.patternImage_ ? this[t(333)][t(347)]() : Promise[t(349)]();
  }
}
function Vp() {
  const r = ["slice", "loading", "IDLE", "color", "anonymous", "88991xPvhiL", "load", "color_", "patternImage_", "1035144qADZIH", "src", "866020JZVVyr", "getImageState", "18kclgjN", "1406310ixXOZt", "48262pnjUTL", "LOADING", "944008iStkxq", "isArray", "setColor", "offset", "getColor", "ready", "size", "resolve", "then", "242001caMiyj"];
  return Vp = function() {
    return r;
  }, Vp();
}
function Wp() {
  const r = ["11826fhjeJh", "lineCap_", "42tmYFkK", "getColor", "1531744hPjYTL", "setLineDashOffset", "294831KLAunn", "lineDash", "getWidth", "slice", "color", "miterLimit", "lineDashOffset_", "width", "setLineJoin", "2487TzXyuP", "setLineDash", "434piWwwg", "lineDashOffset", "getLineJoin", "50qjgmxI", "setMiterLimit", "isArray", "41062zdUXTz", "width_", "lineCap", "getLineCap", "1613415BlWALI", "color_", "setWidth", "18124IOgNoA", "getLineDashOffset", "miterLimit_", "lineDash_", "getLineDash", "lineJoin_"];
  return Wp = function() {
    return r;
  }, Wp();
}
const Qn = wx;
(function(r, t) {
  const e = wx, n = r();
  for (; ; )
    try {
      if (parseInt(e(337)) / 1 + -parseInt(e(318)) / 2 * (parseInt(e(316)) / 3) + -parseInt(e(331)) / 4 + parseInt(e(328)) / 5 + parseInt(e(339)) / 6 * (parseInt(e(324)) / 7) + parseInt(e(305)) / 8 + parseInt(e(307)) / 9 * (-parseInt(e(321)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Wp, 218820);
function wx(r, t) {
  const e = Wp();
  return wx = function(n, i) {
    return n = n - 305, e[n];
  }, wx(r, t);
}
class ys {
  constructor(t) {
    const e = wx;
    t = t || {}, this[e(329)] = t[e(311)] !== void 0 ? t[e(311)] : null, this.lineCap_ = t[e(326)], this.lineDash_ = t.lineDash !== void 0 ? t[e(308)] : null, this[e(313)] = t[e(319)], this[e(336)] = t.lineJoin, this[e(333)] = t[e(312)], this[e(325)] = t[e(314)];
  }
  clone() {
    const t = wx, e = this.getColor();
    return new ys({ color: Array[t(323)](e) ? e[t(310)]() : e || void 0, lineCap: this[t(327)](), lineDash: this[t(335)]() ? this[t(335)]()[t(310)]() : void 0, lineDashOffset: this.getLineDashOffset(), lineJoin: this[t(320)](), miterLimit: this.getMiterLimit(), width: this[t(309)]() });
  }
  [Qn(340)]() {
    return this.color_;
  }
  [Qn(327)]() {
    return this[Qn(338)];
  }
  getLineDash() {
    return this[Qn(334)];
  }
  [Qn(332)]() {
    return this[Qn(313)];
  }
  getLineJoin() {
    return this[Qn(336)];
  }
  getMiterLimit() {
    return this[Qn(333)];
  }
  getWidth() {
    return this[Qn(325)];
  }
  setColor(t) {
    const e = Qn;
    this[e(329)] = t;
  }
  setLineCap(t) {
    const e = Qn;
    this[e(338)] = t;
  }
  [Qn(317)](t) {
    const e = Qn;
    this[e(334)] = t;
  }
  [Qn(306)](t) {
    this.lineDashOffset_ = t;
  }
  [Qn(315)](t) {
    this.lineJoin_ = t;
  }
  [Qn(322)](t) {
    const e = Qn;
    this[e(333)] = t;
  }
  [Qn(330)](t) {
    const e = Qn;
    this[e(325)] = t;
  }
}
function Hp() {
  const r = ["geometryFunction_", "hitDetectionRenderer", "getStroke", "fill", "1563440JFKbrW", "stroke_", "Circle", "getHitDetectionRenderer", "setText", "setFill", "641112rinvnd", "155997ODAFvu", "2944942BwBkOB", "setImage", "3380768VkMgrd", "rgba(255,255,255,0.4)", "3nrippQ", "renderer", "clone", "getGeometryFunction", "setGeometry", "setHitDetectionRenderer", "function", "setRenderer", "getImage", "fill_", "GeometryCollection", "text", "image", "getFill", "Point", "Expected an `Style` or an array of `Style`", "zIndex_", "renderer_", "6VPFLTJ", "MultiPoint", "geometry_", "object", "image_", "Polygon", "10AaHfVY", "getRenderer", "geometry", "setZIndex", "MultiLineString", "hitDetectionRenderer_", "#3399CC", "text_", "getGeometry", "590352qPbOwf", "getZIndex", "444922vxqqfY", "LineString", "getText", "get", "stroke", "concat"];
  return Hp = function() {
    return r;
  }, Hp();
}
const Oe = Tf;
(function(r, t) {
  const e = Tf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(439)) / 1 * (-parseInt(e(417)) / 2) + parseInt(e(415)) / 3 + -parseInt(e(433)) / 4 + -parseInt(e(427)) / 5 + -parseInt(e(457)) / 6 * (parseInt(e(435)) / 7) + parseInt(e(437)) / 8 + -parseInt(e(434)) / 9 * (parseInt(e(406)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Hp, 375758);
class En {
  constructor(t) {
    const e = Tf;
    t = t || {}, this[e(402)] = null, this[e(423)] = kb, t[e(408)] !== void 0 && this.setGeometry(t.geometry), this.fill_ = t[e(426)] !== void 0 ? t[e(426)] : null, this[e(404)] = t[e(451)] !== void 0 ? t.image : null, this[e(456)] = t.renderer !== void 0 ? t[e(440)] : null, this[e(411)] = t[e(424)] !== void 0 ? t[e(424)] : null, this.stroke_ = t[e(421)] !== void 0 ? t[e(421)] : null, this[e(413)] = t[e(450)] !== void 0 ? t[e(450)] : null, this[e(455)] = t.zIndex;
  }
  [Oe(441)]() {
    const t = Oe;
    let e = this.getGeometry();
    return e && typeof e === t(403) && (e = e.clone()), new En({ geometry: e ?? void 0, fill: this[t(452)]() ? this[t(452)]()[t(441)]() : void 0, image: this.getImage() ? this[t(447)]()[t(441)]() : void 0, renderer: this[t(407)]() ?? void 0, stroke: this[t(425)]() ? this[t(425)]()[t(441)]() : void 0, text: this.getText() ? this.getText().clone() : void 0, zIndex: this.getZIndex() });
  }
  [Oe(407)]() {
    return this[Oe(456)];
  }
  [Oe(446)](t) {
    this.renderer_ = t;
  }
  [Oe(444)](t) {
    this.hitDetectionRenderer_ = t;
  }
  [Oe(430)]() {
    return this.hitDetectionRenderer_;
  }
  [Oe(414)]() {
    return this.geometry_;
  }
  [Oe(442)]() {
    return this[Oe(423)];
  }
  [Oe(452)]() {
    return this[Oe(448)];
  }
  [Oe(432)](t) {
    const e = Oe;
    this[e(448)] = t;
  }
  [Oe(447)]() {
    return this.image_;
  }
  [Oe(436)](t) {
    const e = Oe;
    this[e(404)] = t;
  }
  [Oe(425)]() {
    return this[Oe(428)];
  }
  setStroke(t) {
    const e = Oe;
    this[e(428)] = t;
  }
  [Oe(419)]() {
    return this.text_;
  }
  [Oe(431)](t) {
    this.text_ = t;
  }
  getZIndex() {
    return this[Oe(455)];
  }
  [Oe(443)](t) {
    const e = Oe;
    typeof t === e(445) ? this[e(423)] = t : typeof t == "string" ? this[e(423)] = function(n) {
      return n[e(420)](t);
    } : t ? t !== void 0 && (this[e(423)] = function() {
      return t;
    }) : this.geometryFunction_ = kb, this[e(402)] = t;
  }
  [Oe(409)](t) {
    const e = Oe;
    this[e(455)] = t;
  }
}
function R9(r) {
  const t = Oe;
  let e;
  if (typeof r === t(445)) e = r;
  else {
    let n;
    Array.isArray(r) ? n = r : (dr(typeof r[t(416)] === t(445), t(454)), n = [r]), e = function() {
      return n;
    };
  }
  return e;
}
let yv = null;
function X4(r, t) {
  const e = Oe;
  if (!yv) {
    const n = new Hr({ color: e(438) }), i = new ys({ color: e(412), width: 1.25 });
    yv = [new En({ image: new x0({ fill: n, stroke: i, radius: 5 }), fill: n, stroke: i })];
  }
  return yv;
}
function R_() {
  const r = Oe, t = {}, e = [255, 255, 255, 1], n = [0, 153, 255, 1], i = 3;
  return t[r(405)] = [new En({ fill: new Hr({ color: [255, 255, 255, 0.5] }) })], t.MultiPolygon = t[r(405)], t.LineString = [new En({ stroke: new ys({ color: e, width: i + 2 }) }), new En({ stroke: new ys({ color: n, width: i }) })], t[r(410)] = t[r(418)], t[r(429)] = t[r(405)][r(422)](t[r(418)]), t[r(453)] = [new En({ image: new x0({ radius: i * 2, fill: new Hr({ color: n }), stroke: new ys({ color: e, width: i / 2 }) }), zIndex: 1 / 0 })], t[r(401)] = t[r(453)], t[r(449)] = t[r(405)][r(422)](t[r(418)], t[r(453)]), t;
}
function kb(r) {
  return r[Oe(414)]();
}
function Tf(r, t) {
  const e = Hp();
  return Tf = function(n, i) {
    return n = n - 401, e[n];
  }, Tf(r, t);
}
var m0 = Jp;
(function(r, t) {
  for (var e = Jp, n = r(); ; )
    try {
      var i = parseInt(e(384)) / 1 + -parseInt(e(383)) / 2 + parseInt(e(390)) / 3 + parseInt(e(382)) / 4 + -parseInt(e(392)) / 5 + -parseInt(e(385)) / 6 + -parseInt(e(388)) / 7 * (parseInt(e(395)) / 8);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Zp, 201072);
function Jp(r, t) {
  var e = Zp();
  return Jp = function(n, i) {
    n = n - 381;
    var s = e[n];
    return s;
  }, Jp(r, t);
}
const De = { OPACITY: m0(393), VISIBLE: m0(387), EXTENT: m0(391), Z_INDEX: m0(389), MAX_RESOLUTION: m0(381), MIN_RESOLUTION: "minResolution", MAX_ZOOM: m0(386), MIN_ZOOM: "minZoom", SOURCE: m0(394), MAP: "map" };
function Zp() {
  var r = ["maxResolution", "1410036QkRsHU", "657544vWLpJj", "188311ywzwzw", "1014036ymBRrT", "maxZoom", "visible", "1034684PEfGwY", "zIndex", "934560OOWfRe", "extent", "28390ozULdH", "opacity", "source", "8EJdfIr"];
  return Zp = function() {
    return r;
  }, Zp();
}
const se = Df;
(function(r, t) {
  const e = Df, n = r();
  for (; ; )
    try {
      if (parseInt(e(524)) / 1 + -parseInt(e(531)) / 2 * (-parseInt(e(540)) / 3) + -parseInt(e(521)) / 4 * (-parseInt(e(478)) / 5) + parseInt(e(528)) / 6 * (parseInt(e(539)) / 7) + -parseInt(e(516)) / 8 * (parseInt(e(533)) / 9) + parseInt(e(523)) / 10 * (-parseInt(e(536)) / 11) + -parseInt(e(493)) / 12 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Kp, 469850);
function Kp() {
  const r = ["4eiiDJq", "visible", "179420sfwCru", "314007FbhqXK", "properties", "className_", "assign", "180KYkBbq", "VISIBLE", "background_", "23686nzaFEp", "MIN_ZOOM", "6302493EtHjIW", "max", "OPACITY", "242Auxclg", "zIndex", "setBackground", "209573WcyQRk", "111HYnFZj", "EXTENT", "2811470vSzJAk", "getMaxZoom", "MAX_RESOLUTION", "setMinResolution", "setExtent", "getMaxResolution", "minZoom", "number", "state_", "getLayerStatesArray", "getLayersArray", "get", "MIN_RESOLUTION", "setMinZoom", "getClassName", "7773732yoJZgq", "setZIndex", "getExtent", "Layer opacity must be a number", "set", "layer", "MAX_ZOOM", "opacity", "getZIndex", "maxResolution", "maxZoom", "getVisible", "getLayerState", "getMinResolution", "disposeInternal", "changed", "getOpacity", "getMinZoom", "setProperties", "ol-layer", "minResolution", "getBackground", "setOpacity", "8OawSnY", "round", "background", "className", "Z_INDEX"];
  return Kp = function() {
    return r;
  }, Kp();
}
function Df(r, t) {
  const e = Kp();
  return Df = function(n, i) {
    return n = n - 477, e[n];
  }, Df(r, t);
}
class A9 extends a0 {
  constructor(t) {
    const e = Df;
    super(), this.on, this.once, this.un, this[e(530)] = t[e(518)];
    const n = Object[e(527)]({}, t);
    typeof t[e(525)] == "object" && (delete n[e(525)], Object[e(527)](n, t[e(525)])), n[De[e(535)]] = t[e(500)] !== void 0 ? t[e(500)] : 1, dr(typeof n[De[e(535)]] === e(485), "Layer opacity must be a number"), n[De[e(529)]] = t[e(522)] !== void 0 ? t[e(522)] : !0, n[De.Z_INDEX] = t[e(537)], n[De.MAX_RESOLUTION] = t[e(502)] !== void 0 ? t[e(502)] : 1 / 0, n[De[e(490)]] = t[e(513)] !== void 0 ? t[e(513)] : 0, n[De[e(532)]] = t.minZoom !== void 0 ? t[e(484)] : -1 / 0, n[De.MAX_ZOOM] = t[e(503)] !== void 0 ? t.maxZoom : 1 / 0, this[e(526)] = n[e(519)] !== void 0 ? n[e(519)] : e(512), delete n.className, this[e(511)](n), this[e(486)] = null;
  }
  [se(514)]() {
    return this[se(530)];
  }
  [se(492)]() {
    return this[se(526)];
  }
  [se(505)](t) {
    const e = se, n = this[e(486)] || { layer: this, managed: t === void 0 ? !0 : t }, i = this[e(501)]();
    return n[e(500)] = Tr(Math[e(517)](this[e(509)]() * 100) / 100, 0, 1), n[e(522)] = this[e(504)](), n.extent = this[e(495)](), n[e(537)] = i === void 0 && !n.managed ? 1 / 0 : i, n[e(502)] = this.getMaxResolution(), n[e(513)] = Math[e(534)](this.getMinResolution(), 0), n.minZoom = this[e(510)](), n[e(503)] = this.getMaxZoom(), this[e(486)] = n, n;
  }
  [se(488)](t) {
    return qe();
  }
  [se(487)](t) {
    return qe();
  }
  getExtent() {
    const t = se;
    return this.get(De[t(477)]);
  }
  [se(483)]() {
    const t = se;
    return this.get(De[t(480)]);
  }
  [se(506)]() {
    const t = se;
    return this.get(De[t(490)]);
  }
  [se(510)]() {
    return this[se(489)](De.MIN_ZOOM);
  }
  [se(479)]() {
    return this.get(De.MAX_ZOOM);
  }
  getOpacity() {
    const t = se;
    return this.get(De[t(535)]);
  }
  getSourceState() {
    return qe();
  }
  getVisible() {
    const t = se;
    return this.get(De[t(529)]);
  }
  [se(501)]() {
    const t = se;
    return this.get(De[t(520)]);
  }
  [se(538)](t) {
    const e = se;
    this[e(530)] = t, this[e(508)]();
  }
  [se(482)](t) {
    const e = se;
    this[e(497)](De[e(477)], t);
  }
  setMaxResolution(t) {
    const e = se;
    this[e(497)](De[e(480)], t);
  }
  [se(481)](t) {
    const e = se;
    this.set(De[e(490)], t);
  }
  setMaxZoom(t) {
    const e = se;
    this[e(497)](De[e(499)], t);
  }
  [se(491)](t) {
    const e = se;
    this.set(De[e(532)], t);
  }
  [se(515)](t) {
    const e = se;
    dr(typeof t == "number", e(496)), this.set(De[e(535)], t);
  }
  setVisible(t) {
    const e = se;
    this[e(497)](De[e(529)], t);
  }
  [se(494)](t) {
    this[se(497)](De.Z_INDEX, t);
  }
  [se(507)]() {
    const t = se;
    this[t(486)] && (this.state_[t(498)] = null, this[t(486)] = null), super.disposeInternal();
  }
}
var vv = Qp;
function jp() {
  var r = ["491676WStAup", "5665710MfGGUP", "1368941kiYBcD", "6uWlMBA", "750204OHzlbX", "3766815NVhsQg", "prerender", "1220100UTnxeu", "3135395cVMOCF", "postrender", "24BOmqAt", "rendercomplete", "54VoLGsY"];
  return jp = function() {
    return r;
  }, jp();
}
(function(r, t) {
  for (var e = Qp, n = r(); ; )
    try {
      var i = -parseInt(e(159)) / 1 + -parseInt(e(169)) / 2 + -parseInt(e(170)) / 3 + parseInt(e(165)) / 4 + parseInt(e(160)) / 5 * (-parseInt(e(168)) / 6) + parseInt(e(167)) / 7 * (parseInt(e(162)) / 8) + -parseInt(e(164)) / 9 * (-parseInt(e(166)) / 10);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(jp, 631148);
function Qp(r, t) {
  var e = jp();
  return Qp = function(n, i) {
    n = n - 158;
    var s = e[n];
    return s;
  }, Qp(r, t);
}
const C0 = { PRERENDER: vv(158), POSTRENDER: vv(161), PRECOMPOSE: "precompose", POSTCOMPOSE: "postcompose", RENDERCOMPLETE: vv(163) };
function Pm(r, t) {
  var e = $p();
  return Pm = function(n, i) {
    n = n - 289;
    var s = e[n];
    return s;
  }, Pm(r, t);
}
function $p() {
  var r = ["1702760fxzzmt", "3395PBeVjS", "2528UveMDI", "10364250PlCjgr", "6953812hvUPva", "9ZGQACp", "1gdxvhE", "1707118ySlUYQ", "4399611rJnKdI", "6153855VoABWs"];
  return $p = function() {
    return r;
  }, $p();
}
(function(r, t) {
  for (var e = Pm, n = r(); ; )
    try {
      var i = -parseInt(e(298)) / 1 * (-parseInt(e(289)) / 2) + -parseInt(e(290)) / 3 + -parseInt(e(296)) / 4 + parseInt(e(291)) / 5 + parseInt(e(295)) / 6 + parseInt(e(293)) / 7 * (parseInt(e(294)) / 8) + parseInt(e(297)) / 9 * (parseInt(e(292)) / 10);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})($p, 930251);
const us = { ANIMATING: 0, INTERACTING: 1 };
var Bb = ed;
(function(r, t) {
  for (var e = ed, n = r(); ; )
    try {
      var i = -parseInt(e(347)) / 1 + parseInt(e(341)) / 2 + parseInt(e(345)) / 3 + -parseInt(e(338)) / 4 + -parseInt(e(342)) / 5 + -parseInt(e(339)) / 6 + -parseInt(e(340)) / 7 * (-parseInt(e(343)) / 8);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(td, 285424);
function td() {
  var r = ["592kQUKTH", "rotation", "1151691ZySoEo", "resolution", "355247URtmwm", "1313372cJzUIv", "1179012KGnyqV", "64694lCYOpM", "709020ZNTKRM", "1283995GInVxB"];
  return td = function() {
    return r;
  }, td();
}
function ed(r, t) {
  var e = td();
  return ed = function(n, i) {
    n = n - 338;
    var s = e[n];
    return s;
  }, ed(r, t);
}
const Fs = { CENTER: "center", RESOLUTION: Bb(346), ROTATION: Bb(344) }, T9 = 256;
function nd(r, t) {
  const e = rd();
  return nd = function(n, i) {
    return n = n - 471, e[n];
  }, nd(r, t);
}
(function(r, t) {
  const e = nd, n = r();
  for (; ; )
    try {
      if (-parseInt(e(473)) / 1 * (parseInt(e(485)) / 2) + parseInt(e(479)) / 3 * (parseInt(e(472)) / 4) + -parseInt(e(480)) / 5 * (parseInt(e(475)) / 6) + parseInt(e(476)) / 7 * (parseInt(e(483)) / 8) + -parseInt(e(474)) / 9 + -parseInt(e(482)) / 10 * (parseInt(e(481)) / 11) + parseInt(e(484)) / 12 * (parseInt(e(478)) / 13) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(rd, 893515);
function Gb(r, t, e) {
  return function(n, i, s, o, a) {
    const u = nd;
    if (!n) return;
    if (!i && !t) return n;
    const x = t ? 0 : s[0] * i, c = t ? 0 : s[1] * i, f = a ? a[0] : 0, l = a ? a[1] : 0;
    let h = r[0] + x / 2 + f, p = r[2] - x / 2 + f, y = r[1] + c / 2 + l, v = r[3] - c / 2 + l;
    h > p && (h = (p + h) / 2, p = h), y > v && (y = (v + y) / 2, v = y);
    let m = Tr(n[0], h, p), d = Tr(n[1], y, v);
    if (o && e && i) {
      const g = 30 * i;
      m += -g * Math[u(471)](1 + Math[u(477)](0, h - n[0]) / g) + g * Math[u(471)](1 + Math[u(477)](0, n[0] - p) / g), d += -g * Math.log(1 + Math[u(477)](0, y - n[1]) / g) + g * Math[u(471)](1 + Math.max(0, n[1] - v) / g);
    }
    return [m, d];
  };
}
function D9(r) {
  return r;
}
function rd() {
  const r = ["log", "7144AXycJF", "5541tJJQCM", "14768415xkCvme", "2835618Iyhmsr", "6748huNskz", "max", "13fKgUyI", "2631jWJfKN", "15jeZicC", "299332TfRkpJ", "40TgeqEa", "2312NmuHMr", "29386932pSZMWZ", "84DWGODb"];
  return rd = function() {
    return r;
  }, rd();
}
function B0(r, t) {
  const e = id();
  return B0 = function(n, i) {
    return n = n - 162, e[n];
  }, B0(r, t);
}
(function(r, t) {
  const e = B0, n = r();
  for (; ; )
    try {
      if (parseInt(e(163)) / 1 * (-parseInt(e(167)) / 2) + parseInt(e(162)) / 3 * (-parseInt(e(177)) / 4) + -parseInt(e(171)) / 5 + parseInt(e(168)) / 6 + parseInt(e(164)) / 7 + parseInt(e(165)) / 8 + parseInt(e(166)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(id, 859925);
function id() {
  const r = ["127628OAfWws", "141wNHTLV", "393oKbyOU", "8566537hCaqUc", "5246656LdrLXN", "562041GfzsCO", "2720JcURxm", "7088586HWxydM", "log", "pow", "1147345xDVKzt", "length", "min", "max", "ceil", "floor"];
  return id = function() {
    return r;
  }, id();
}
function A_(r, t, e, n) {
  const i = B0, s = vi(t) / e[0], o = xa(t) / e[1];
  return n ? Math[i(173)](r, Math[i(174)](s, o)) : Math.min(r, Math[i(173)](s, o));
}
function T_(r, t, e) {
  const n = B0;
  let i = Math[n(173)](r, t);
  const s = 50;
  return i *= Math.log(1 + s * Math[n(174)](0, r / t - 1)) / s + 1, e && (i = Math.max(i, e), i /= Math[n(169)](1 + s * Math[n(174)](0, e / r - 1)) / s + 1), Tr(i, e / 2, t * 2);
}
function F9(r, t, e, n) {
  return t = t !== void 0 ? t : !0, function(i, s, o, a) {
    const u = B0;
    if (i !== void 0) {
      const x = r[0], c = r[r[u(172)] - 1], f = e ? A_(x, e, o, n) : x;
      if (a)
        return t ? T_(i, f, c) : Tr(i, c, f);
      const l = Math.min(f, i), h = Math[u(176)](j3(r, l, s));
      return r[h] > f && h < r[u(172)] - 1 ? r[h + 1] : r[h];
    }
  };
}
function k9(r, t, e, n, i, s) {
  return n = n !== void 0 ? n : !0, e = e !== void 0 ? e : 0, function(o, a, u, x) {
    const c = B0;
    if (o !== void 0) {
      const f = i ? A_(t, i, u, s) : t;
      if (x)
        return n ? T_(o, f, e) : Tr(o, e, f);
      const l = 1e-9, h = Math[c(175)](Math[c(169)](t / f) / Math[c(169)](r) - l), p = -a * (0.5 - l) + 0.5, y = Math[c(173)](f, o), v = Math[c(176)](Math.log(t / y) / Math.log(r) + p), m = Math[c(174)](h, v), d = t / Math[c(170)](r, m);
      return Tr(d, e, f);
    }
  };
}
function Yb(r, t, e, n, i) {
  return e = e !== void 0 ? e : !0, function(s, o, a, u) {
    if (s !== void 0) {
      const x = n ? A_(r, n, a, i) : r;
      return !e || !u ? Tr(s, t, x) : T_(s, x, t);
    }
  };
}
(function(r, t) {
  const e = od, n = r();
  for (; ; )
    try {
      if (-parseInt(e(446)) / 1 * (parseInt(e(441)) / 2) + -parseInt(e(439)) / 3 * (parseInt(e(444)) / 4) + -parseInt(e(442)) / 5 + parseInt(e(437)) / 6 + parseInt(e(436)) / 7 * (parseInt(e(443)) / 8) + parseInt(e(440)) / 9 * (parseInt(e(435)) / 10) + parseInt(e(438)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(sd, 428029);
function B9(r) {
  if (r !== void 0) return 0;
}
function Xb(r) {
  if (r !== void 0) return r;
}
function sd() {
  const r = ["10042835GimzcO", "45EJJKjp", "44838ZpTwKA", "16iqfHfI", "1592700FYESyO", "8hHBgxo", "150952SJqiAK", "abs", "49976ZgQEVt", "1270AcNuAv", "198863QGmTMS", "830034Qrunaq"];
  return sd = function() {
    return r;
  }, sd();
}
function od(r, t) {
  const e = sd();
  return od = function(n, i) {
    return n = n - 435, e[n];
  }, od(r, t);
}
function G9(r) {
  const t = 2 * Math.PI / r;
  return function(e, n) {
    if (n) return e;
    if (e !== void 0) return e = Math.floor(e / t + 0.5) * t, e;
  };
}
function Y9(r) {
  const t = w8(5);
  return function(e, n) {
    const i = od;
    return n || e === void 0 ? e : Math[i(445)](e) <= t ? 0 : e;
  };
}
const G = Ff;
(function(r, t) {
  const e = Ff, n = r();
  for (; ; )
    try {
      if (-parseInt(e(376)) / 1 * (parseInt(e(373)) / 2) + parseInt(e(362)) / 3 + -parseInt(e(323)) / 4 + -parseInt(e(383)) / 5 * (parseInt(e(333)) / 6) + parseInt(e(310)) / 7 * (parseInt(e(409)) / 8) + parseInt(e(385)) / 9 + -parseInt(e(365)) / 10 * (-parseInt(e(443)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ad, 307038);
const mv = 0;
class qb extends a0 {
  constructor(t) {
    const e = Ff;
    super(), this.on, this.once, this.un, t = Object[e(348)]({}, t), this.hints_ = [0, 0], this[e(340)] = [], this[e(375)], this[e(299)] = d_(t[e(415)], e(395)), this[e(416)] = [100, 100], this.targetCenter_ = null, this[e(404)], this[e(351)], this[e(374)] = null, this[e(350)], this.nextRotation_, this[e(366)] = void 0, t[e(415)] && R8(), t[e(414)] && (t[e(414)] = cn(t[e(414)], this[e(299)])), t.extent && (t[e(326)] = Bu(t[e(326)], this.projection_)), this.applyOptions_(t);
  }
  [G(397)](t) {
    const e = G, n = Object[e(348)]({}, t);
    for (const u in Fs)
      delete n[u];
    this[e(388)](n, !0);
    const i = q9(t);
    this[e(368)] = i[e(407)], this[e(319)] = i[e(296)], this[e(446)] = i.zoomFactor, this[e(422)] = t[e(372)], this[e(447)] = t.padding, this[e(413)] = i[e(410)];
    const s = X9(t), o = i[e(427)], a = z9(t);
    this.constraints_ = { center: s, resolution: o, rotation: a }, this[e(402)](t.rotation !== void 0 ? t[e(297)] : 0), this[e(331)](t[e(414)] !== void 0 ? t[e(414)] : null), t[e(334)] !== void 0 ? this[e(426)](t[e(334)]) : t[e(306)] !== void 0 && this.setZoom(t[e(306)]);
  }
  get padding() {
    return this[G(447)];
  }
  set padding(t) {
    const e = G;
    let n = this[e(447)];
    this[e(447)] = t;
    const i = this[e(398)]();
    if (i) {
      const s = t || [0, 0, 0, 0];
      n = n || [0, 0, 0, 0];
      const o = this[e(332)](), a = o / 2 * (s[3] - n[3] + n[1] - s[1]), u = o / 2 * (s[0] - n[0] + n[2] - s[2]);
      this[e(331)]([i[0] + a, i[1] - u]);
    }
  }
  getUpdatedOptions_(t) {
    const e = G, n = this.getProperties();
    return n[e(334)] !== void 0 ? n[e(334)] = this[e(332)]() : n[e(306)] = this[e(406)](), n[e(414)] = this[e(398)](), n[e(297)] = this[e(434)](), Object[e(348)]({}, n, t);
  }
  [G(382)](t) {
    const e = G;
    this[e(298)]() && !this[e(330)]() && this[e(322)](0);
    const n = new Array(arguments.length);
    for (let i = 0; i < n[e(451)]; ++i) {
      let s = arguments[i];
      s[e(414)] && (s = Object[e(348)]({}, s), s.center = cn(s[e(414)], this[e(442)]())), s[e(384)] && (s = Object[e(348)]({}, s), s[e(384)] = cn(s[e(384)], this[e(442)]())), n[i] = s;
    }
    this[e(320)][e(408)](this, n);
  }
  [G(320)](t) {
    const e = G;
    let n = arguments[e(451)], i;
    n > 1 && typeof arguments[n - 1] === e(318) && (i = arguments[n - 1], --n);
    let s = 0;
    for (; s < n && !this[e(298)](); ++s) {
      const f = arguments[s];
      f[e(414)] && this.setCenterInternal(f.center), f[e(306)] !== void 0 ? this[e(338)](f[e(306)]) : f[e(334)] && this.setResolution(f[e(334)]), f[e(297)] !== void 0 && this[e(402)](f.rotation);
    }
    if (s === n) {
      i && fh(i, !0);
      return;
    }
    let o = Date[e(390)](), a = this[e(386)][e(361)](), u = this[e(404)], x = this.targetRotation_;
    const c = [];
    for (; s < n; ++s) {
      const f = arguments[s], l = { start: o, complete: !1, anchor: f[e(384)], duration: f.duration !== void 0 ? f[e(377)] : 1e3, easing: f.easing || J6, callback: i };
      if (f.center && (l[e(387)] = a, l[e(425)] = f[e(414)][e(361)](), a = l.targetCenter), f[e(306)] !== void 0 ? (l[e(421)] = u, l[e(423)] = this[e(327)](f[e(306)]), u = l[e(423)]) : f[e(334)] && (l[e(421)] = u, l[e(423)] = f[e(334)], u = l[e(423)]), f[e(297)] !== void 0) {
        l[e(336)] = x;
        const h = hm(f[e(297)] - x + Math.PI, 2 * Math.PI) - Math.PI;
        l[e(440)] = x + h, x = l[e(440)];
      }
      U9(l) ? l[e(309)] = !0 : o += l.duration, c.push(l);
    }
    this[e(340)][e(431)](c), this[e(342)](us[e(391)], 1), this[e(305)]();
  }
  [G(330)]() {
    return this[G(419)][us.ANIMATING] > 0;
  }
  [G(455)]() {
    const t = G;
    return this[t(419)][us[t(429)]] > 0;
  }
  [G(399)]() {
    const t = G;
    this[t(342)](us[t(391)], -this.hints_[us[t(391)]]);
    let e;
    for (let n = 0, i = this[t(340)][t(451)]; n < i; ++n) {
      const s = this[t(340)][n];
      if (s[0][t(347)] && fh(s[0][t(347)], !1), !e) for (let o = 0, a = s[t(451)]; o < a; ++o) {
        const u = s[o];
        if (!u.complete) {
          e = u[t(384)];
          break;
        }
      }
    }
    this[t(340)][t(451)] = 0, this[t(366)] = e, this[t(374)] = null, this[t(350)] = NaN, this[t(300)] = NaN;
  }
  [G(305)]() {
    const t = G;
    if (this[t(375)] !== void 0 && (cancelAnimationFrame(this[t(375)]), this[t(375)] = void 0), !this[t(330)]()) return;
    const e = Date[t(390)]();
    let n = !1;
    for (let i = this[t(340)][t(451)] - 1; i >= 0; --i) {
      const s = this[t(340)][i];
      let o = !0;
      for (let a = 0, u = s[t(451)]; a < u; ++a) {
        const x = s[a];
        if (x[t(309)]) continue;
        const c = e - x.start;
        let f = x.duration > 0 ? c / x[t(377)] : 1;
        f >= 1 ? (x.complete = !0, f = 1) : o = !1;
        const l = x.easing(f);
        if (x.sourceCenter) {
          const h = x.sourceCenter[0], p = x[t(387)][1], y = x[t(425)][0], v = x.targetCenter[1];
          this[t(374)] = x.targetCenter;
          const m = h + l * (y - h), d = p + l * (v - p);
          this[t(386)] = [m, d];
        }
        if (x[t(421)] && x.targetResolution) {
          const h = l === 1 ? x[t(423)] : x.sourceResolution + l * (x[t(423)] - x[t(421)]);
          if (x[t(384)]) {
            const p = this[t(454)](this[t(434)]()), y = this[t(314)].resolution(h, 0, p, !0);
            this[t(386)] = this.calculateCenterZoom(y, x[t(384)]);
          }
          this[t(350)] = x[t(423)], this.targetResolution_ = h, this[t(370)](!0);
        }
        if (x[t(336)] !== void 0 && x[t(440)] !== void 0) {
          const h = l === 1 ? hm(x[t(440)] + Math.PI, 2 * Math.PI) - Math.PI : x[t(336)] + l * (x[t(440)] - x[t(336)]);
          if (x.anchor) {
            const p = this.constraints_.rotation(h, !0);
            this[t(386)] = this[t(403)](p, x[t(384)]);
          }
          this[t(300)] = x[t(440)], this.targetRotation_ = h;
        }
        if (this[t(370)](!0), n = !0, !x[t(309)]) break;
      }
      if (o) {
        this.animations_[i] = null, this[t(342)](us.ANIMATING, -1), this.nextCenter_ = null, this[t(350)] = NaN, this[t(300)] = NaN;
        const a = s[0][t(347)];
        a && fh(a, !0);
      }
    }
    this[t(340)] = this[t(340)][t(444)](Boolean), n && this[t(375)] === void 0 && (this[t(375)] = requestAnimationFrame(this[t(305)].bind(this)));
  }
  [G(403)](t, e) {
    const n = G;
    let i;
    const s = this[n(398)]();
    return s !== void 0 && (i = [s[0] - e[0], s[1] - e[1]], C8(i, t - this[n(434)]()), E8(i, e)), i;
  }
  [G(359)](t, e) {
    const n = G;
    let i;
    const s = this[n(398)](), o = this.getResolution();
    if (s !== void 0 && o !== void 0) {
      const a = e[0] - t * (e[0] - s[0]) / o, u = e[1] - t * (e[1] - s[1]) / o;
      i = [a, u];
    }
    return i;
  }
  [G(454)](t) {
    const e = G, n = this[e(416)];
    if (t) {
      const i = n[0], s = n[1];
      return [Math.abs(i * Math[e(369)](t)) + Math[e(312)](s * Math[e(450)](t)), Math[e(312)](i * Math[e(450)](t)) + Math[e(312)](s * Math.cos(t))];
    }
    return n;
  }
  [G(315)](t) {
    const e = G;
    this[e(416)] = Array[e(364)](t) ? t[e(361)]() : [100, 100], !this[e(330)]() && this[e(322)](0);
  }
  [G(441)]() {
    const t = G, e = this[t(398)]();
    return e && cx(e, this[t(442)]());
  }
  [G(398)]() {
    const t = G;
    return this[t(420)](Fs[t(316)]);
  }
  [G(392)]() {
    return this.constraints_;
  }
  [G(346)]() {
    const t = G;
    return this[t(420)](t(411));
  }
  [G(449)](t) {
    const e = G;
    return t !== void 0 ? (t[0] = this[e(419)][0], t[1] = this[e(419)][1], t) : this.hints_.slice();
  }
  [G(412)](t) {
    const e = G, n = this[e(396)](t);
    return py(n, this[e(442)]());
  }
  [G(396)](t) {
    const e = G;
    t = t || this.getViewportSizeMinusPadding_();
    const n = this[e(398)]();
    dr(n, "The view center is not defined");
    const i = this[e(332)]();
    dr(i !== void 0, "The view resolution is not defined");
    const s = this[e(434)]();
    return dr(s !== void 0, e(378)), r8(n, i, s, t);
  }
  [G(352)]() {
    return this[G(368)];
  }
  getMinResolution() {
    return this[G(319)];
  }
  getMaxZoom() {
    const t = G;
    return this[t(304)](this[t(319)]);
  }
  [G(335)](t) {
    const e = G;
    this[e(397)](this[e(371)]({ maxZoom: t }));
  }
  [G(381)]() {
    return this.getZoomForResolution(this.maxResolution_);
  }
  [G(439)](t) {
    this[G(397)](this.getUpdatedOptions_({ minZoom: t }));
  }
  setConstrainResolution(t) {
    const e = G;
    this.applyOptions_(this[e(371)]({ constrainResolution: t }));
  }
  getProjection() {
    return this[G(299)];
  }
  [G(332)]() {
    return this[G(420)](Fs.RESOLUTION);
  }
  [G(436)]() {
    return this[G(422)];
  }
  [G(456)](t, e) {
    const n = G;
    return this.getResolutionForExtentInternal(Bu(t, this[n(442)]()), e);
  }
  [G(367)](t, e) {
    const n = G;
    e = e || this[n(307)]();
    const i = vi(t) / e[0], s = xa(t) / e[1];
    return Math[n(448)](i, s);
  }
  [G(379)](t) {
    const e = G;
    t = t || 2;
    const n = this[e(428)](this[e(368)]), i = this[e(319)], s = Math.log(n / i) / Math[e(424)](t);
    return function(o) {
      return n / Math.pow(t, o * s);
    };
  }
  getRotation() {
    const t = G;
    return this[t(420)](Fs[t(328)]);
  }
  [G(345)](t) {
    const e = G, n = Math[e(424)](t || 2), i = this.getConstrainedResolution(this[e(368)]), s = this[e(319)], o = Math.log(i / s) / n;
    return function(a) {
      return Math[e(424)](i / a) / n / o;
    };
  }
  [G(307)](t) {
    const e = G;
    let n = this[e(454)](t);
    const i = this[e(447)];
    return i && (n = [n[0] - i[1] - i[3], n[1] - i[0] - i[2]]), n;
  }
  [G(437)]() {
    const t = G, e = this.getProjection(), n = this.getResolution(), i = this[t(434)]();
    let s = this[t(398)]();
    const o = this[t(447)];
    if (o) {
      const a = this[t(307)]();
      s = _v(s, this[t(454)](), [a[0] / 2 + o[3], a[1] / 2 + o[0]], n, i);
    }
    return { center: s[t(361)](0), projection: e !== void 0 ? e : null, resolution: n, nextCenter: this[t(374)], nextResolution: this[t(350)], nextRotation: this[t(300)], rotation: i, zoom: this[t(406)]() };
  }
  getViewStateAndExtent() {
    const t = G;
    return { viewState: this.getState(), extent: this[t(412)]() };
  }
  [G(406)]() {
    let t;
    const e = this.getResolution();
    return e !== void 0 && (t = this.getZoomForResolution(e)), t;
  }
  [G(304)](t) {
    const e = G;
    let n = this[e(413)] || 0, i, s;
    if (this.resolutions_) {
      const o = j3(this[e(422)], t, 1);
      n = o, i = this[e(422)][o], o == this.resolutions_.length - 1 ? s = 2 : s = i / this[e(422)][o + 1];
    } else i = this.maxResolution_, s = this[e(446)];
    return n + Math[e(424)](i / t) / Math[e(424)](s);
  }
  [G(327)](t) {
    const e = G;
    if (this.resolutions_) {
      if (this.resolutions_[e(451)] <= 1) return 0;
      const n = Tr(Math.floor(t), 0, this[e(422)][e(451)] - 2), i = this[e(422)][n] / this[e(422)][n + 1];
      return this[e(422)][n] / Math[e(459)](i, Tr(t - n, 0, 1));
    }
    return this.maxResolution_ / Math[e(459)](this[e(446)], t - this.minZoom_);
  }
  fit(t, e) {
    const n = G;
    let i;
    if (dr(Array.isArray(t) || typeof t[n(400)] === n(318), n(389)), Array.isArray(t)) {
      dr(!x4(t), n(349));
      const s = Bu(t, this.getProjection());
      i = Gu(s);
    } else if (t.getType() === n(302)) {
      const s = Bu(t.getExtent(), this[n(442)]());
      i = Gu(s), i[n(393)](this[n(434)](), ua(s));
    } else
      i = t;
    this[n(453)](i, e);
  }
  [G(433)](t) {
    const e = G, n = this.getRotation(), i = Math.cos(n), s = Math.sin(-n), o = t[e(324)](), a = t[e(329)]();
    let u = 1 / 0, x = 1 / 0, c = -1 / 0, f = -1 / 0;
    for (let l = 0, h = o[e(451)]; l < h; l += a) {
      const p = o[l] * i - o[l + 1] * s, y = o[l] * s + o[l + 1] * i;
      u = Math[e(418)](u, p), x = Math.min(x, y), c = Math[e(448)](c, p), f = Math.max(f, y);
    }
    return [u, x, c, f];
  }
  fitInternal(t, e) {
    const n = G;
    e = e || {};
    let i = e[n(343)];
    !i && (i = this[n(307)]());
    const s = e[n(401)] !== void 0 ? e[n(401)] : [0, 0, 0, 0], o = e[n(339)] !== void 0 ? e[n(339)] : !1;
    let a;
    e.minResolution !== void 0 ? a = e[n(296)] : e[n(321)] !== void 0 ? a = this.getResolutionForZoom(e[n(321)]) : a = 0;
    const u = this.rotatedExtentForGeometry(t);
    let x = this[n(367)](u, [i[0] - s[1] - s[3], i[1] - s[0] - s[2]]);
    x = isNaN(x) ? a : Math[n(448)](x, a), x = this.getConstrainedResolution(x, o ? 0 : 1);
    const c = this[n(434)](), f = Math[n(450)](c), l = Math.cos(c), h = ua(u);
    h[0] += (s[1] - s[3]) / 2 * x, h[1] += (s[0] - s[2]) / 2 * x;
    const p = h[0] * l - h[1] * f, y = h[1] * l + h[0] * f, v = this[n(405)]([p, y], x), m = e[n(347)] ? e[n(347)] : Zc;
    e[n(377)] !== void 0 ? this[n(320)]({ resolution: x, center: v, duration: e.duration, easing: e.easing }, m) : (this[n(404)] = x, this[n(386)] = v, this[n(370)](!1, !0), fh(m, !0));
  }
  [G(295)](t, e, n) {
    const i = G;
    this[i(301)](cn(t, this[i(442)]()), e, n);
  }
  [G(301)](t, e, n) {
    const i = G;
    this.setCenterInternal(_v(t, e, n, this.getResolution(), this[i(434)]()));
  }
  [G(445)](t, e, n, i) {
    const s = G;
    let o;
    const a = this.padding_;
    if (a && t) {
      const u = this[s(307)](-n), x = _v(t, i, [u[0] / 2 + a[3], u[1] / 2 + a[0]], e, n);
      o = [t[0] - x[0], t[1] - x[1]];
    }
    return o;
  }
  isDef() {
    const t = G;
    return !!this[t(398)]() && this[t(332)]() !== void 0;
  }
  [G(341)](t) {
    const e = G, n = cx(this.targetCenter_, this[e(442)]());
    this[e(358)]([n[0] + t[0], n[1] + t[1]]);
  }
  adjustCenterInternal(t) {
    const e = G, n = this[e(386)];
    this.setCenterInternal([n[0] + t[0], n[1] + t[1]]);
  }
  [G(357)](t, e) {
    const n = G;
    e = e && cn(e, this[n(442)]()), this[n(452)](t, e);
  }
  [G(452)](t, e) {
    const n = G, i = this[n(330)]() || this[n(455)](), s = this[n(454)](this[n(434)]()), o = this[n(314)][n(334)](this[n(404)] * t, 0, s, i);
    e && (this[n(386)] = this[n(359)](o, e)), this.targetResolution_ *= t, this[n(370)]();
  }
  [G(438)](t, e) {
    const n = G;
    this[n(357)](Math[n(459)](this.zoomFactor_, -t), e);
  }
  [G(356)](t, e) {
    const n = G;
    e && (e = cn(e, this[n(442)]())), this[n(355)](t, e);
  }
  [G(355)](t, e) {
    const n = G, i = this.getAnimating() || this[n(455)](), s = this.constraints_[n(297)](this[n(351)] + t, i);
    e && (this[n(386)] = this.calculateCenterRotate(s, e)), this[n(351)] += t, this.applyTargetState_();
  }
  [G(358)](t) {
    const e = G;
    this[e(331)](t && cn(t, this[e(442)]()));
  }
  [G(331)](t) {
    const e = G;
    this[e(386)] = t, this[e(370)]();
  }
  [G(342)](t, e) {
    const n = G;
    return this.hints_[t] += e, this[n(432)](), this.hints_[t];
  }
  [G(426)](t) {
    const e = G;
    this.targetResolution_ = t, this[e(370)]();
  }
  [G(402)](t) {
    const e = G;
    this[e(351)] = t, this[e(370)]();
  }
  setZoom(t) {
    const e = G;
    this.setResolution(this[e(327)](t));
  }
  [G(370)](t, e) {
    const n = G, i = this.getAnimating() || this[n(455)]() || e, s = this[n(314)].rotation(this[n(351)], i), o = this[n(454)](s), a = this.constraints_[n(334)](this[n(404)], 0, o, i), u = this[n(314)][n(414)](this[n(386)], a, o, i, this[n(445)](this.targetCenter_, a, s, o));
    this.get(Fs.ROTATION) !== s && this[n(354)](Fs[n(328)], s), this.get(Fs[n(353)]) !== a && (this[n(354)](Fs[n(353)], a), this.set(n(306), this[n(406)](), !0)), (!u || !this[n(420)](Fs[n(316)]) || !Ys(this[n(420)](Fs[n(316)]), u)) && this[n(354)](Fs.CENTER, u), this[n(330)]() && !t && this[n(399)](), this[n(366)] = void 0;
  }
  resolveConstraints(t, e, n) {
    const i = G;
    t = t !== void 0 ? t : 200;
    const s = e || 0, o = this[i(314)][i(297)](this.targetRotation_), a = this[i(454)](o), u = this.constraints_.resolution(this.targetResolution_, s, a), x = this[i(314)][i(414)](this[i(386)], u, a, !1, this[i(445)](this[i(386)], u, o, a));
    if (t === 0 && !this[i(366)]) {
      this.targetResolution_ = u, this[i(351)] = o, this[i(386)] = x, this[i(370)]();
      return;
    }
    n = n || (t === 0 ? this[i(366)] : void 0), this[i(366)] = void 0, (this[i(332)]() !== u || this[i(434)]() !== o || !this[i(398)]() || !Ys(this[i(398)](), x)) && (this.getAnimating() && this[i(399)](), this[i(320)]({ rotation: o, center: x, resolution: u, duration: t, easing: H6, anchor: n }));
  }
  [G(303)]() {
    const t = G;
    this.resolveConstraints(0), this.setHint(us[t(429)], 1);
  }
  [G(325)](t, e, n) {
    n = n && cn(n, this[G(442)]()), this.endInteractionInternal(t, e, n);
  }
  [G(417)](t, e, n) {
    const i = G;
    this[i(455)]() && (this.setHint(us[i(429)], -1), this[i(322)](t, e, n));
  }
  [G(405)](t, e) {
    const n = G, i = this.getViewportSize_(this.getRotation());
    return this.constraints_[n(414)](t, e || this[n(332)](), i);
  }
  [G(344)](t, e) {
    const n = G, i = this[n(327)](t);
    return this.getZoomForResolution(this[n(428)](i, e));
  }
  [G(428)](t, e) {
    const n = G;
    e = e || 0;
    const i = this[n(454)](this[n(434)]());
    return this[n(314)][n(334)](t, e, i);
  }
}
function ad() {
  const r = ["getStride", "getAnimating", "setCenterInternal", "getResolution", "18uZZvhI", "resolution", "setMaxZoom", "sourceRotation", "getExtent", "setZoom", "nearest", "animations_", "adjustCenter", "setHint", "size", "getConstrainedZoom", "getValueForResolutionFunction", "getConstrainResolution", "callback", "assign", "Cannot fit empty extent provided as `geometry`", "nextResolution_", "targetRotation_", "getMaxResolution", "RESOLUTION", "set", "adjustRotationInternal", "adjustRotation", "adjustResolution", "setCenter", "calculateCenterZoom", "isGlobal", "slice", "374583LymTXH", "zoomFactor", "isArray", "16770YpLvFm", "cancelAnchor_", "getResolutionForExtentInternal", "maxResolution_", "cos", "applyTargetState_", "getUpdatedOptions_", "resolutions", "149198USlmGl", "nextCenter_", "updateAnimationKey_", "1HGmaLk", "duration", "The view rotation is not defined", "getResolutionForValueFunction", "constrainRotation", "getMinZoom", "animate", "676115vNIhUY", "anchor", "3425301LZuEUl", "targetCenter_", "sourceCenter", "setProperties", "Invalid extent or geometry provided as `geometry`", "now", "ANIMATING", "getConstraints", "rotate", "clone", "EPSG:3857", "calculateExtentInternal", "applyOptions_", "getCenterInternal", "cancelAnimations", "getSimplifiedGeometry", "padding", "setRotation", "calculateCenterRotate", "targetResolution_", "getConstrainedCenter", "getZoom", "maxResolution", "apply", "8IWAtkx", "minZoom", "constrainResolution", "calculateExtent", "minZoom_", "center", "projection", "viewportSize_", "endInteractionInternal", "min", "hints_", "get", "sourceResolution", "resolutions_", "targetResolution", "log", "targetCenter", "setResolution", "constraint", "getConstrainedResolution", "INTERACTING", "showFullExtent", "push", "changed", "rotatedExtentForGeometry", "getRotation", "smoothExtentConstraint", "getResolutions", "getState", "adjustZoom", "setMinZoom", "targetRotation", "getCenter", "getProjection", "2211VYgBun", "filter", "calculateCenterShift", "zoomFactor_", "padding_", "max", "getHints", "sin", "length", "adjustResolutionInternal", "fitInternal", "getViewportSize_", "getInteracting", "getResolutionForExtent", "smoothResolutionConstraint", "transform", "pow", "centerOn", "minResolution", "rotation", "isDef", "projection_", "nextRotation_", "centerOnInternal", "Circle", "beginInteraction", "getZoomForResolution", "updateAnimations_", "zoom", "getViewportSizeMinusPadding_", "multiWorld", "complete", "3192693dZRXpR", "degrees", "abs", "constrainOnlyCenter", "constraints_", "setViewportSize", "CENTER", "enableRotation", "function", "minResolution_", "animateInternal", "maxZoom", "resolveConstraints", "2045280ssdBqX", "getFlatCoordinates", "endInteraction", "extent", "getResolutionForZoom", "ROTATION"];
  return ad = function() {
    return r;
  }, ad();
}
function fh(r, t) {
  setTimeout(function() {
    r(t);
  }, 0);
}
function X9(r) {
  const t = G;
  if (r[t(326)] !== void 0) {
    const n = r.smoothExtentConstraint !== void 0 ? r[t(435)] : !0;
    return Gb(r[t(326)], r[t(313)], n);
  }
  const e = d_(r.projection, t(395));
  if (r[t(308)] !== !0 && e[t(360)]()) {
    const n = e[t(337)]().slice();
    return n[0] = -1 / 0, n[2] = 1 / 0, Gb(n, !1, !1);
  }
  return D9;
}
function q9(r) {
  const t = G;
  let e, n, i;
  const s = 28, o = 2;
  let a = r[t(410)] !== void 0 ? r[t(410)] : mv, u = r.maxZoom !== void 0 ? r[t(321)] : s;
  const x = r[t(363)] !== void 0 ? r[t(363)] : o, c = r[t(308)] !== void 0 ? r[t(308)] : !1, f = r.smoothResolutionConstraint !== void 0 ? r[t(457)] : !0, l = r[t(430)] !== void 0 ? r[t(430)] : !1, h = d_(r[t(415)], "EPSG:3857"), p = h[t(337)]();
  let y = r[t(313)], v = r.extent;
  if (!c && !v && h.isGlobal() && (y = !1, v = p), r[t(372)] !== void 0) {
    const m = r.resolutions;
    n = m[a], i = m[u] !== void 0 ? m[u] : m[m[t(451)] - 1], r[t(411)] ? e = F9(m, f, !y && v, l) : e = Yb(n, i, f, !y && v, l);
  } else {
    const m = p ? Math[t(448)](vi(p), xa(p)) : 360 * f4[t(311)] / h.getMetersPerUnit(), d = m / T9 / Math[t(459)](o, mv), g = d / Math[t(459)](o, s - mv);
    n = r[t(407)], n !== void 0 ? a = 0 : n = d / Math[t(459)](x, a), i = r[t(296)], i === void 0 && (r[t(321)] !== void 0 ? r[t(407)] !== void 0 ? i = n / Math.pow(x, u) : i = d / Math[t(459)](x, u) : i = g), u = a + Math.floor(Math[t(424)](n / i) / Math[t(424)](x)), i = n / Math[t(459)](x, u - a), r[t(411)] ? e = k9(x, n, i, f, !y && v, l) : e = Yb(n, i, f, !y && v, l);
  }
  return { constraint: e, maxResolution: n, minResolution: i, minZoom: a, zoomFactor: x };
}
function z9(r) {
  const t = G;
  if (r[t(317)] !== void 0 ? r[t(317)] : !0) {
    const n = r[t(380)];
    return n === void 0 || n === !0 ? Y9() : n === !1 ? Xb : typeof n == "number" ? G9(n) : Xb;
  }
  return B9;
}
function Ff(r, t) {
  const e = ad();
  return Ff = function(n, i) {
    return n = n - 295, e[n];
  }, Ff(r, t);
}
function U9(r) {
  const t = G;
  return !(r[t(387)] && r[t(425)] && !Ys(r[t(387)], r[t(425)]) || r[t(421)] !== r[t(423)] || r[t(336)] !== r[t(440)]);
}
function _v(r, t, e, n, i) {
  const s = G, o = Math.cos(-i);
  let a = Math[s(450)](-i), u = r[0] * o - r[1] * a, x = r[1] * o + r[0] * a;
  u += (t[0] / 2 - e[0]) * n, x += (e[1] - t[1] / 2) * n, a = -a;
  const c = u * o - x * a, f = x * o + u * a;
  return [c, f];
}
const Mt = kf;
(function(r, t) {
  const e = kf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(378)) / 1 + -parseInt(e(408)) / 2 + -parseInt(e(416)) / 3 * (parseInt(e(386)) / 4) + -parseInt(e(406)) / 5 * (parseInt(e(377)) / 6) + -parseInt(e(424)) / 7 + parseInt(e(391)) / 8 + parseInt(e(417)) / 9 * (parseInt(e(393)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ud, 430718);
function kf(r, t) {
  const e = ud();
  return kf = function(n, i) {
    return n = n - 369, e[n];
  }, kf(r, t);
}
function ud() {
  const r = ["layer", "setMap", "undefined", "4504vMvapd", "mapPrecomposeKey_", "source", "sourceready", "handleSourceChange_", "76440gnsLry", "getViewStateAndExtent", "6693930ZdYBbm", "getRenderer", "getMapInternal", "unrender", "maxZoom", "isArray", "setMapInternal", "frameState", "hasRenderer", "render", "getLayersArray", "getData2", "prepareFrame", "115995YRrqIS", "handleSourcePropertyChange_", "567650mqVRjn", "renderDeclutter", "mapRenderKey_", "SOURCE", "getLayerState", "resolution", "getAttributions", "getLayerGroup", "1992GKwIYO", "36igjwmk", "changed", "get", "maxResolution", "getSourceState", "extent", "renderer_", "3878035HtzlPa", "disposeInternal", "ready", "setSource", "calculateExtent", "getData", "map", "renderDeferred", "push", "dispose", "once", "rendered", "visible", "sourceChangeKey_", "dispatchEvent", "getRenderSource", "getState", "getSource", "CHANGE", "viewState", "getFeatures", "set", "MAP", "getLayerStatesArray", "layerStatesArray", "minResolution", "PRECOMPOSE", "sourceReady_", "getDeclutter", "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.", "getExtent", "138ADOZTH", "137338LEHZDZ", "getView", "minZoom", "isVisible", "createRenderer"];
  return ud = function() {
    return r;
  }, ud();
}
class V9 extends A9 {
  constructor(t) {
    const e = kf, n = Object.assign({}, t);
    delete n[e(388)], super(n), this.on, this[e(434)], this.un, this[e(387)] = null, this[e(410)] = null, this[e(437)] = null, this.renderer_ = null, this[e(373)] = !1, this[e(435)] = !1, t[e(402)] && (this[e(402)] = t[e(402)]), t.map && this.setMap(t[e(430)]), this.addChangeListener(De[e(411)], this[e(407)]);
    const i = t[e(388)] ? t.source : null;
    this.setSource(i);
  }
  [Mt(403)](t) {
    const e = Mt;
    return t = t || [], t[e(432)](this), t;
  }
  [Mt(369)](t) {
    const e = Mt;
    return t = t || [], t[e(432)](this[e(412)]()), t;
  }
  [Mt(441)]() {
    const t = Mt;
    return this.get(De[t(411)]) || null;
  }
  [Mt(439)]() {
    return this.getSource();
  }
  [Mt(421)]() {
    const t = Mt, e = this.getSource();
    return e ? e.getState() : t(385);
  }
  [Mt(390)]() {
    const t = Mt;
    this.changed(), !(this[t(373)] || this[t(441)]()[t(440)]() !== t(426)) && (this[t(373)] = !0, this[t(438)](t(389)));
  }
  [Mt(407)]() {
    const t = Mt;
    this[t(437)] && (gs(this[t(437)]), this[t(437)] = null), this.sourceReady_ = !1;
    const e = this[t(441)]();
    e && (this[t(437)] = ii(e, rr.CHANGE, this[t(390)], this), e[t(440)]() === t(426) && (this.sourceReady_ = !0, setTimeout(() => {
      const n = t;
      this[n(438)](n(389));
    }, 0))), this[t(418)]();
  }
  [Mt(444)](t) {
    const e = Mt;
    return this[e(423)] ? this[e(423)][e(444)](t) : Promise.resolve([]);
  }
  [Mt(429)](t) {
    const e = Mt;
    return !this.renderer_ || !this[e(435)] ? null : this[e(423)][e(429)](t);
  }
  [Mt(404)](t, e) {
    const n = Mt;
    return !this.renderer_ || !this[n(435)] ? null : this[n(423)][n(404)](t, e);
  }
  [Mt(381)](t) {
    const e = Mt;
    let n;
    const i = this[e(395)]();
    !t && i && (t = i[e(379)]()), t instanceof qb ? n = { viewState: t[e(440)](), extent: t[e(428)]() } : n = t, !n[e(370)] && i && (n[e(370)] = i[e(415)]().getLayerStatesArray());
    let s;
    n[e(370)] ? s = n[e(370)].find((a) => a.layer === this) : s = this[e(412)]();
    const o = this[e(376)]();
    return W9(s, n[e(443)]) && (!o || hs(o, n[e(422)]));
  }
  [Mt(414)](t) {
    var o;
    const e = Mt;
    if (!this[e(381)](t)) return [];
    const n = (o = this[e(441)]()) == null ? void 0 : o.getAttributions();
    if (!n) return [];
    const i = t instanceof qb ? t[e(392)]() : t;
    let s = n(i);
    return !Array[e(398)](s) && (s = [s]), s;
  }
  [Mt(402)](t, e) {
    const n = Mt, i = this.getRenderer();
    return i[n(405)](t) ? (this[n(435)] = !0, i.renderFrame(t, e)) : null;
  }
  [Mt(396)]() {
    const t = Mt;
    this[t(435)] = !1;
  }
  [Mt(374)]() {
  }
  [Mt(409)](t, e) {
  }
  renderDeferred(t) {
    const e = Mt, n = this[e(394)]();
    n && n[e(431)](t);
  }
  [Mt(399)](t) {
    const e = Mt;
    !t && this[e(396)](), this[e(445)](De[e(446)], t);
  }
  [Mt(395)]() {
    const t = Mt;
    return this[t(419)](De[t(446)]);
  }
  [Mt(384)](t) {
    const e = Mt;
    this.mapPrecomposeKey_ && (gs(this.mapPrecomposeKey_), this[e(387)] = null), !t && this.changed(), this[e(410)] && (gs(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this[e(387)] = ii(t, C0[e(372)], (n) => {
      const i = e, s = n, o = s[i(400)][i(370)], a = this[i(412)](!1);
      dr(!o.some(function(u) {
        const x = i;
        return u[x(383)] === a[x(383)];
      }), i(375)), o[i(432)](a);
    }), this.mapRenderKey_ = ii(this, rr[e(442)], t[e(402)], t), this.changed());
  }
  setSource(t) {
    const e = Mt;
    this.set(De[e(411)], t);
  }
  getRenderer() {
    const t = Mt;
    return !this[t(423)] && (this[t(423)] = this[t(382)]()), this[t(423)];
  }
  [Mt(401)]() {
    return !!this[Mt(423)];
  }
  createRenderer() {
    return null;
  }
  [Mt(425)]() {
    const t = Mt;
    this[t(423)] && (this[t(423)][t(433)](), delete this[t(423)]), this[t(427)](null), super[t(425)]();
  }
}
function W9(r, t) {
  const e = Mt;
  if (!r[e(436)]) return !1;
  const n = t[e(413)];
  if (n < r[e(371)] || n >= r[e(420)]) return !1;
  const i = t.zoom;
  return i > r[e(380)] && i <= r[e(397)];
}
const Te = Ex;
(function(r, t) {
  const e = Ex, n = r();
  for (; ; )
    try {
      if (-parseInt(e(305)) / 1 + -parseInt(e(332)) / 2 + -parseInt(e(278)) / 3 + parseInt(e(355)) / 4 * (-parseInt(e(292)) / 5) + parseInt(e(301)) / 6 * (parseInt(e(329)) / 7) + parseInt(e(328)) / 8 + parseInt(e(295)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(xd, 363928);
function xd() {
  const r = ["63gjKVfy", "offsetOrigin_", "displacement", "26192GdyxXt", "origin_", "getImageState", "top-left", "getSrc", "slice", "scale", "`image` and `src` cannot be provided at the same time", "getDisplacement", "setAnchor", "top-right", "fraction", "anchor_", "getPixelRatio", "getScale", "getAnchor", "anchorXUnits_", "ready", "setScale", "width", "height", "getImage", "bottom-left", "164xReibK", "declutterMode", "1920336WsYOUy", "iconImage_", "LOADING", "anchorOrigin_", "A defined and non-empty `src` or `image` must be provided", "IDLE", "crossOrigin_", "isArray", "LOADED", "src", "opacity", "addEventListener", "color_", "img", "11515EjdkhW", "`width` or `height` cannot be provided together with `scale`", "getRotateWithView", "9947763XcSntI", "bottom-right", "normalizedAnchor_", "initialOptions_", "getWidth", "anchorYUnits_", "118182MOqjkk", "getOpacity", "load", "getSize", "362638ksHEXU", "length", "removeEventListener", "anchorOrigin", "size_", "size", "getDeclutterMode", "crossOrigin", "listenImageChange", "getScaleArray", "color", "offset_", "rotation", "offsetOrigin", "getHitDetectionImage", "anchorYUnits", "getRotation", "CHANGE", "complete", "getOrigin", "anchorXUnits", "offset", "unlistenImageChange", "1532936izEJWu"];
  return xd = function() {
    return r;
  }, xd();
}
function Ex(r, t) {
  const e = xd();
  return Ex = function(n, i) {
    return n = n - 278, e[n];
  }, Ex(r, t);
}
function zb(r, t, e, n) {
  return e !== void 0 && n !== void 0 ? [e / r, n / t] : e !== void 0 ? e / r : n !== void 0 ? n / t : 1;
}
class rc extends nc {
  constructor(t) {
    const e = Ex;
    t = t || {};
    const n = t[e(288)] !== void 0 ? t[e(288)] : 1, i = t[e(317)] !== void 0 ? t.rotation : 0, s = t.scale !== void 0 ? t[e(338)] : 1, o = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
    super({ opacity: n, rotation: i, scale: s, displacement: t.displacement !== void 0 ? t[e(331)] : [0, 0], rotateWithView: o, declutterMode: t[e(356)] }), this[e(344)] = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this[e(297)] = null, this[e(281)] = t[e(308)] !== void 0 ? t[e(308)] : e(335), this[e(348)] = t[e(325)] !== void 0 ? t[e(325)] : "fraction", this[e(300)] = t.anchorYUnits !== void 0 ? t[e(320)] : e(343), this[e(284)] = t[e(312)] !== void 0 ? t[e(312)] : null;
    const a = t[e(291)] !== void 0 ? t[e(291)] : null;
    let u = t[e(287)];
    dr(!(u !== void 0 && a), e(339)), (u === void 0 || u[e(306)] === 0) && a && (u = a[e(287)] || ve(a)), dr(u !== void 0 && u[e(306)] > 0, e(282)), dr(!((t[e(351)] !== void 0 || t.height !== void 0) && t[e(338)] !== void 0), e(293));
    let x;
    if (t[e(287)] !== void 0 ? x = Et[e(283)] : a !== void 0 && (e(323) in a ? a.complete ? x = a[e(287)] ? Et.LOADED : Et[e(283)] : x = Et[e(280)] : x = Et.LOADED), this[e(290)] = t[e(315)] !== void 0 ? wf(t[e(315)]) : null, this[e(279)] = O_(a, u, this[e(284)], x, this[e(290)]), this[e(316)] = t[e(326)] !== void 0 ? t.offset : [0, 0], this[e(330)] = t[e(318)] !== void 0 ? t[e(318)] : e(335), this[e(333)] = null, this[e(309)] = t.size !== void 0 ? t.size : null, this[e(298)], t[e(351)] !== void 0 || t.height !== void 0) {
      let c, f;
      if (t[e(310)]) [c, f] = t[e(310)];
      else {
        const l = this[e(353)](1);
        if (l[e(351)] && l[e(352)]) c = l[e(351)], f = l[e(352)];
        else if (l instanceof HTMLImageElement) {
          this[e(298)] = t;
          const h = () => {
            const p = e;
            if (this[p(327)](h), !this[p(298)]) return;
            const y = this.iconImage_[p(304)]();
            this[p(350)](zb(y[0], y[1], t[p(351)], t[p(352)]));
          };
          this[e(313)](h);
          return;
        }
      }
      c !== void 0 && this[e(350)](zb(c, f, t[e(351)], t[e(352)]));
    }
  }
  clone() {
    const t = Ex;
    let e, n, i;
    return this[t(298)] ? (n = this[t(298)].width, i = this[t(298)].height) : (e = this[t(346)](), e = Array[t(285)](e) ? e[t(337)]() : e), new rc({ anchor: this.anchor_[t(337)](), anchorOrigin: this[t(281)], anchorXUnits: this[t(348)], anchorYUnits: this[t(300)], color: this[t(290)] && this.color_[t(337)] ? this[t(290)][t(337)]() : this[t(290)] || void 0, crossOrigin: this[t(284)], offset: this[t(316)][t(337)](), offsetOrigin: this.offsetOrigin_, opacity: this[t(302)](), rotateWithView: this[t(294)](), rotation: this[t(321)](), scale: e, width: n, height: i, size: this.size_ !== null ? this[t(309)][t(337)]() : void 0, src: this[t(336)](), displacement: this.getDisplacement()[t(337)](), declutterMode: this[t(311)]() });
  }
  [Te(347)]() {
    const t = Te;
    let e = this[t(297)];
    if (!e) {
      e = this.anchor_;
      const s = this[t(304)]();
      if (this.anchorXUnits_ == t(343) || this[t(300)] == t(343)) {
        if (!s) return null;
        e = this[t(344)].slice(), this.anchorXUnits_ == t(343) && (e[0] *= s[0]), this[t(300)] == "fraction" && (e[1] *= s[1]);
      }
      if (this[t(281)] != t(335)) {
        if (!s) return null;
        e === this.anchor_ && (e = this[t(344)][t(337)]()), (this.anchorOrigin_ == "top-right" || this[t(281)] == t(296)) && (e[0] = -e[0] + s[0]), (this[t(281)] == t(354) || this[t(281)] == t(296)) && (e[1] = -e[1] + s[1]);
      }
      this[t(297)] = e;
    }
    const n = this[t(340)](), i = this[t(314)]();
    return [e[0] - n[0] / i[0], e[1] + n[1] / i[1]];
  }
  [Te(341)](t) {
    const e = Te;
    this.anchor_ = t, this[e(297)] = null;
  }
  getColor() {
    return this[Te(290)];
  }
  [Te(353)](t) {
    const e = Te;
    return this[e(279)][e(353)](t);
  }
  [Te(345)](t) {
    const e = Te;
    return this[e(279)][e(345)](t);
  }
  getImageSize() {
    const t = Te;
    return this.iconImage_[t(304)]();
  }
  getImageState() {
    const t = Te;
    return this[t(279)][t(334)]();
  }
  getHitDetectionImage() {
    const t = Te;
    return this.iconImage_[t(319)]();
  }
  [Te(324)]() {
    const t = Te;
    if (this[t(333)]) return this[t(333)];
    let e = this[t(316)];
    if (this[t(330)] != t(335)) {
      const n = this[t(304)](), i = this[t(279)][t(304)]();
      if (!n || !i) return null;
      e = e[t(337)](), (this[t(330)] == t(342) || this.offsetOrigin_ == t(296)) && (e[0] = i[0] - n[0] - e[0]), (this[t(330)] == "bottom-left" || this[t(330)] == "bottom-right") && (e[1] = i[1] - n[1] - e[1]);
    }
    return this.origin_ = e, this[t(333)];
  }
  [Te(336)]() {
    return this.iconImage_.getSrc();
  }
  [Te(304)]() {
    const t = Te;
    return this[t(309)] ? this[t(309)] : this[t(279)].getSize();
  }
  [Te(299)]() {
    const t = Te, e = this.getScaleArray();
    if (this.size_) return this[t(309)][0] * e[0];
    if (this[t(279)][t(334)]() == Et[t(286)]) return this.iconImage_.getSize()[0] * e[0];
  }
  getHeight() {
    const t = Te, e = this.getScaleArray();
    if (this[t(309)]) return this.size_[1] * e[1];
    if (this.iconImage_[t(334)]() == Et[t(286)]) return this[t(279)][t(304)]()[1] * e[1];
  }
  [Te(350)](t) {
    const e = Te;
    delete this[e(298)], super[e(350)](t);
  }
  [Te(313)](t) {
    const e = Te;
    this[e(279)][e(289)](rr.CHANGE, t);
  }
  load() {
    const t = Te;
    this.iconImage_[t(303)]();
  }
  [Te(327)](t) {
    const e = Te;
    this[e(279)][e(307)](rr[e(322)], t);
  }
  [Te(349)]() {
    const t = Te;
    return this.iconImage_[t(349)]();
  }
}
const it = Bf;
(function(r, t) {
  const e = Bf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(149)) / 1 * (parseInt(e(175)) / 2) + -parseInt(e(182)) / 3 + -parseInt(e(130)) / 4 * (parseInt(e(138)) / 5) + parseInt(e(160)) / 6 + -parseInt(e(123)) / 7 + -parseInt(e(171)) / 8 + parseInt(e(176)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(cd, 223389);
function cd() {
  const r = ["setTextAlign", "padding", "getFont", "getBackgroundStroke", "setBackgroundFill", "text_", "getStroke", "clone", "getPlacement", "placement_", "textAlign", "setOffsetY", "setPadding", "textAlign_", "backgroundStroke", "fill", "slice", "offsetY_", "getPadding", "827568AtXNvs", "scale_", "textBaseline", "setScale", "isArray", "font_", "getDeclutterMode", "63092FyAyQR", "getRepeat", "backgroundStroke_", "stroke_", "font", "getOverflow", "padding_", "scaleArray_", "135RJUITf", "justify_", "getText", "overflow", "getBackgroundFill", "repeat", "maxAngle_", "getTextAlign", "declutterMode_", "getFill", "offsetX", "1rmUdje", "getTextBaseline", "setRepeat", "point", "offsetY", "getOffsetX", "rotateWithView_", "setRotation", "backgroundFill_", "getJustify", "fill_", "818652ZpusrA", "getRotation", "repeat_", "justify", "getMaxAngle", "declutterMode", "setPlacement", "overflow_", "setText", "getOffsetY", "setTextBaseline", "1261592KzaaUs", "setMaxAngle", "placement", "stroke", "65428DnoBhf", "8862201jOZwpE", "offsetX_", "getRotateWithView", "setStroke", "backgroundFill", "textBaseline_", "489702KtqVZk", "scale", "maxAngle", "setOffsetX", "rotation_", "setFont", "setOverflow"];
  return cd = function() {
    return r;
  }, cd();
}
function Bf(r, t) {
  const e = cd();
  return Bf = function(n, i) {
    return n = n - 119, e[n];
  }, Bf(r, t);
}
const H9 = "#333";
class Dl {
  constructor(t) {
    const e = Bf;
    t = t || {}, this[e(128)] = t[e(134)], this.rotation_ = t.rotation, this[e(155)] = t.rotateWithView, this[e(124)] = t[e(183)], this.scaleArray_ = vx(t[e(183)] !== void 0 ? t[e(183)] : 1), this[e(194)] = t.text, this.textAlign_ = t[e(199)], this[e(139)] = t[e(163)], this[e(162)] = t[e(143)], this[e(181)] = t[e(125)], this.fill_ = t.fill !== void 0 ? t[e(119)] : new Hr({ color: H9 }), this[e(144)] = t[e(184)] !== void 0 ? t[e(184)] : Math.PI / 4, this[e(198)] = t[e(173)] !== void 0 ? t[e(173)] : e(152), this[e(167)] = !!t[e(141)], this[e(133)] = t[e(174)] !== void 0 ? t[e(174)] : null, this[e(177)] = t.offsetX !== void 0 ? t[e(148)] : 0, this[e(121)] = t[e(153)] !== void 0 ? t[e(153)] : 0, this[e(157)] = t[e(180)] ? t[e(180)] : null, this.backgroundStroke_ = t[e(203)] ? t[e(203)] : null, this.padding_ = t.padding === void 0 ? null : t[e(190)], this[e(146)] = t[e(165)];
  }
  [it(196)]() {
    const t = it, e = this.getScale();
    return new Dl({ font: this.getFont(), placement: this[t(197)](), repeat: this[t(131)](), maxAngle: this.getMaxAngle(), overflow: this[t(135)](), rotation: this[t(161)](), rotateWithView: this[t(178)](), scale: Array[t(127)](e) ? e[t(120)]() : e, text: this.getText(), textAlign: this[t(145)](), justify: this[t(158)](), textBaseline: this[t(150)](), fill: this.getFill() ? this[t(147)]()[t(196)]() : void 0, stroke: this[t(195)]() ? this.getStroke()[t(196)]() : void 0, offsetX: this[t(154)](), offsetY: this[t(169)](), backgroundFill: this[t(142)]() ? this[t(142)]().clone() : void 0, backgroundStroke: this[t(192)]() ? this[t(192)]()[t(196)]() : void 0, padding: this.getPadding() || void 0, declutterMode: this[t(129)]() });
  }
  [it(135)]() {
    return this[it(167)];
  }
  [it(191)]() {
    return this[it(128)];
  }
  [it(164)]() {
    return this[it(144)];
  }
  [it(197)]() {
    return this[it(198)];
  }
  [it(131)]() {
    return this.repeat_;
  }
  [it(154)]() {
    return this[it(177)];
  }
  [it(169)]() {
    return this[it(121)];
  }
  getFill() {
    return this[it(159)];
  }
  [it(178)]() {
    return this[it(155)];
  }
  [it(161)]() {
    return this.rotation_;
  }
  getScale() {
    return this[it(124)];
  }
  getScaleArray() {
    return this[it(137)];
  }
  getStroke() {
    return this.stroke_;
  }
  [it(140)]() {
    return this.text_;
  }
  [it(145)]() {
    return this[it(202)];
  }
  [it(158)]() {
    return this[it(139)];
  }
  getTextBaseline() {
    return this.textBaseline_;
  }
  [it(142)]() {
    return this[it(157)];
  }
  [it(192)]() {
    return this[it(132)];
  }
  [it(122)]() {
    return this[it(136)];
  }
  [it(129)]() {
    return this[it(146)];
  }
  [it(188)](t) {
    this.overflow_ = t;
  }
  [it(187)](t) {
    this.font_ = t;
  }
  [it(172)](t) {
    const e = it;
    this[e(144)] = t;
  }
  [it(185)](t) {
    const e = it;
    this[e(177)] = t;
  }
  [it(200)](t) {
    const e = it;
    this[e(121)] = t;
  }
  [it(166)](t) {
    const e = it;
    this[e(198)] = t;
  }
  [it(151)](t) {
    const e = it;
    this[e(162)] = t;
  }
  setRotateWithView(t) {
    const e = it;
    this[e(155)] = t;
  }
  setFill(t) {
    const e = it;
    this[e(159)] = t;
  }
  [it(156)](t) {
    const e = it;
    this[e(186)] = t;
  }
  [it(126)](t) {
    const e = it;
    this[e(124)] = t, this[e(137)] = vx(t !== void 0 ? t : 1);
  }
  [it(179)](t) {
    this.stroke_ = t;
  }
  [it(168)](t) {
    const e = it;
    this[e(194)] = t;
  }
  [it(189)](t) {
    const e = it;
    this[e(202)] = t;
  }
  setJustify(t) {
    const e = it;
    this[e(139)] = t;
  }
  [it(170)](t) {
    this.textBaseline_ = t;
  }
  [it(193)](t) {
    const e = it;
    this[e(157)] = t;
  }
  setBackgroundStroke(t) {
    const e = it;
    this[e(132)] = t;
  }
  [it(201)](t) {
    const e = it;
    this[e(136)] = t;
  }
}
const J = Y0;
(function(r, t) {
  const e = Y0, n = r();
  for (; ; )
    try {
      if (parseInt(e(282)) / 1 + parseInt(e(277)) / 2 + parseInt(e(302)) / 3 * (parseInt(e(339)) / 4) + parseInt(e(321)) / 5 * (parseInt(e(299)) / 6) + parseInt(e(209)) / 7 * (-parseInt(e(325)) / 8) + parseInt(e(236)) / 9 + -parseInt(e(338)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(fd, 423419);
let cu = 0;
const ni = 1 << cu++, de = 1 << cu++, yi = 1 << cu++, zs = 1 << cu++, G0 = 1 << cu++;
function fd() {
  const r = ["geometryType", "properties", "expected an odd number of arguments for ", "line-metric", "Point", "Subtract", "the second argument of palette must be an array", "band", "12140150lnQOQD", "874204TeGwdn", "expected no arguments for ", "MultiPoint", "string", "sin", "join", "stringify", "boolean", "to-string", "failed to parse color at index ", 'failed to parse "in" expression: the literal operator must be followed by an array', "434dGUojR", "var", "Circle", "Sqrt", "expected ", "Pow", "expected an array of numbers", "expected an array of two values for a size, got ", "failed to parse argument ", " arguments for ", "sort", "featureId", "expected an array of 3 or 4 values for a color, got ", "empty expression", "got an array of numbers, but expected ", "toString", "true", " for interpolate expression: ", "Not", "all", "Multiply", "case", "MultiPolygon", ", or ", "length", "expected a string argument for var operation", ", got ", "4856895dwoEDw", "got a boolean, but expected ", "untyped", "Time", "abs", "Get", "invalid interpolation type: ", "Round", "expected last argument validator to return the parsed args", "size", "false", "map", 'for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions', " of match expression: ", "failed to parse argument 1 in interpolate expression: ", "Ceil", "resolution", "MultiLineString", "isArray", " for ", "Palette", "cos", "Sin", "Divide", "Polygon", "zoom", "failed to parse haystack item ", "operator", "variables", "unknown operator: ", "palette", "geometry-type", "push", "keys", "match", "ceil", " must be a literal value", "Var", "Zoom", "sqrt", " in palette expression: ", "81344kxFzvy", "Number", "message", "Band", "value", "177372hKGXNn", "number", "clamp", " instead", "interpolate", "All", "Atan", "Concat", "get", 'the second argument for the "in" operator must be an array', "Case", "atan", "Any", "Equal", "expected a string key or numeric array index for a get operation, got ", "has", "getType", "426WmgFxY", "LineString", "got a string, but expected ", "3qNjeyu", " operation", "array", "Match", "literal", "args", "round", "color", "linear", "GreaterThanOrEqualTo", "concat", "LessThan", "failed to parse first argument in palette expression: ", "Add", " argument", "Abs", "pow", "LessThanOrEqualTo", "type", "51710OxwPKO", "any", "time", " of case expression: ", "9432EWSVfN", "Has", "number[]", "slice", "GreaterThan"];
  return fd = function() {
    return r;
  }, fd();
}
const Mc = 1 << cu++, lh = Math[J(318)](2, cu) - 1, D_ = { [ni]: "boolean", [de]: J(283), [yi]: J(342), [zs]: J(309), [G0]: J(327), [Mc]: J(245) }, J9 = Object[J(269)](D_)[J(247)](Number)[J(219)](P0);
function Z9(r) {
  return r in D_;
}
function Pc(r) {
  const t = J, e = [];
  for (const n of J9)
    Lc(r, n) && e[t(268)](D_[n]);
  return e[t(233)] === 0 ? t(238) : e[t(233)] < 3 ? e[t(344)](" or ") : e[t(328)](0, -1)[t(344)](", ") + t(232) + e[e[t(233)] - 1];
}
function Lc(r, t) {
  return (r & t) === t;
}
function Ma(r, t) {
  return r === t;
}
class $n {
  constructor(t, e) {
    const n = J;
    if (!Z9(t)) throw new Error("literal expressions must have a specific type, got " + Pc(t));
    this[n(320)] = t, this[n(281)] = e;
  }
}
class K9 {
  constructor(t, e, ...n) {
    const i = J;
    this[i(320)] = t, this[i(263)] = e, this[i(307)] = n;
  }
}
function Y0(r, t) {
  const e = fd();
  return Y0 = function(n, i) {
    return n = n - 205, e[n];
  }, Y0(r, t);
}
function q4() {
  return { variables: /* @__PURE__ */ new Set(), properties: /* @__PURE__ */ new Set(), featureId: !1, geometryType: !1 };
}
function Fr(r, t, e) {
  const n = J;
  switch (typeof r) {
    case n(205): {
      if (Ma(t, yi)) return new $n(yi, n(r ? 225 : 246));
      if (!Lc(t, ni)) throw new Error(n(237) + Pc(t));
      return new $n(ni, r);
    }
    case "number": {
      if (Ma(t, Mc)) return new $n(Mc, vx(r));
      if (Ma(t, ni)) return new $n(ni, !!r);
      if (Ma(t, yi)) return new $n(yi, r[n(224)]());
      if (!Lc(t, de)) throw new Error("got a number, but expected " + Pc(t));
      return new $n(de, r);
    }
    case n(342): {
      if (Ma(t, zs)) return new $n(zs, P_(r));
      if (Ma(t, ni)) return new $n(ni, !!r);
      if (!Lc(t, yi)) throw new Error(n(301) + Pc(t));
      return new $n(yi, r);
    }
  }
  if (!Array[n(254)](r)) throw new Error("expression must be an array or a primitive value");
  if (r[n(233)] === 0) throw new Error(n(222));
  if (typeof r[0] === n(342)) return a7(r, t, e);
  for (const i of r)
    if (typeof i !== n(283)) throw new Error(n(215));
  if (Ma(t, Mc)) {
    if (r[n(233)] !== 2) throw new Error(n(216) + r.length);
    return new $n(Mc, r);
  }
  if (Ma(t, zs)) {
    if (r[n(233)] === 3) return new $n(zs, [...r, 1]);
    if (r.length === 4) return new $n(zs, r);
    throw new Error(n(221) + r[n(233)]);
  }
  if (!Lc(t, G0)) throw new Error(n(223) + Pc(t));
  return new $n(G0, r);
}
const Y = { Get: J(290), Var: J(210), Concat: J(312), GeometryType: J(267), LineMetric: J(333), Any: J(322), All: J(228), Not: "!", Resolution: J(252), Zoom: J(261), Time: J(323), Equal: "==", NotEqual: "!=", GreaterThan: ">", GreaterThanOrEqualTo: ">=", LessThan: "<", LessThanOrEqualTo: "<=", Multiply: "*", Divide: "/", Add: "+", Subtract: "-", Clamp: J(284), Mod: "%", Pow: "^", Abs: J(240), Floor: "floor", Ceil: J(271), Round: J(308), Sin: J(343), Cos: J(257), Atan: J(293), Sqrt: J(275), Match: J(270), Between: "between", Interpolate: J(286), Coalesce: "coalesce", Case: J(230), In: "in", Number: J(283), String: J(342), Array: J(304), Color: J(309), Id: "id", Band: J(337), Palette: J(266), ToString: J(206), Has: J(297) }, j9 = { [Y[J(241)]]: It(Lt(1, 1 / 0), Ub), [Y[J(273)]]: It(Lt(1, 1), Q9), [Y[J(326)]]: It(Lt(1, 1 / 0), Ub), [Y.Id]: It($9, mu), [Y[J(289)]]: It(Lt(2, 1 / 0), Pe(yi)), [Y.GeometryType]: It(t7, mu), [Y.LineMetric]: It(mu), [Y.Resolution]: It(mu), [Y[J(274)]]: It(mu), [Y[J(239)]]: It(mu), [Y[J(294)]]: It(Lt(2, 1 / 0), Pe(ni)), [Y[J(287)]]: It(Lt(2, 1 / 0), Pe(ni)), [Y[J(227)]]: It(Lt(1, 1), Pe(ni)), [Y[J(295)]]: It(Lt(2, 2), Pe(lh)), [Y.NotEqual]: It(Lt(2, 2), Pe(lh)), [Y[J(329)]]: It(Lt(2, 2), Pe(de)), [Y[J(311)]]: It(Lt(2, 2), Pe(de)), [Y[J(313)]]: It(Lt(2, 2), Pe(de)), [Y[J(319)]]: It(Lt(2, 2), Pe(de)), [Y[J(229)]]: It(Lt(2, 1 / 0), Vb), [Y.Coalesce]: It(Lt(2, 1 / 0), Vb), [Y[J(259)]]: It(Lt(2, 2), Pe(de)), [Y[J(315)]]: It(Lt(2, 1 / 0), Pe(de)), [Y[J(335)]]: It(Lt(2, 2), Pe(de)), [Y.Clamp]: It(Lt(3, 3), Pe(de)), [Y.Mod]: It(Lt(2, 2), Pe(de)), [Y[J(214)]]: It(Lt(2, 2), Pe(de)), [Y[J(317)]]: It(Lt(1, 1), Pe(de)), [Y.Floor]: It(Lt(1, 1), Pe(de)), [Y[J(251)]]: It(Lt(1, 1), Pe(de)), [Y[J(243)]]: It(Lt(1, 1), Pe(de)), [Y[J(258)]]: It(Lt(1, 1), Pe(de)), [Y.Cos]: It(Lt(1, 1), Pe(de)), [Y[J(288)]]: It(Lt(1, 2), Pe(de)), [Y[J(212)]]: It(Lt(1, 1), Pe(de)), [Y[J(305)]]: It(Lt(4, 1 / 0), Wb, n7), [Y.Between]: It(Lt(3, 3), Pe(de)), [Y.Interpolate]: It(Lt(6, 1 / 0), Wb, r7), [Y[J(292)]]: It(Lt(3, 1 / 0), e7, i7), [Y.In]: It(Lt(2, 2), s7), [Y[J(278)]]: It(Lt(1, 1 / 0), Pe(lh)), [Y.String]: It(Lt(1, 1 / 0), Pe(lh)), [Y.Array]: It(Lt(1, 1 / 0), Pe(de)), [Y.Color]: It(Lt(1, 4), Pe(de)), [Y[J(280)]]: It(Lt(1, 3), Pe(de)), [Y[J(256)]]: It(Lt(2, 2), o7), [Y.ToString]: It(Lt(1, 1), Pe(ni | de | yi | zs)) };
function Ub(r, t, e) {
  const n = J, i = r[n(233)] - 1, s = new Array(i);
  for (let o = 0; o < i; ++o) {
    const a = r[o + 1];
    switch (typeof a) {
      case "number": {
        s[o] = new $n(de, a);
        break;
      }
      case n(342): {
        s[o] = new $n(yi, a);
        break;
      }
      default:
        throw new Error(n(296) + a);
    }
    o === 0 && e[n(331)].add(String(a));
  }
  return s;
}
function Q9(r, t, e) {
  const n = J, i = r[1];
  if (typeof i != "string") throw new Error(n(234));
  return e[n(264)].add(i), [new $n(yi, i)];
}
function $9(r, t, e) {
  const n = J;
  e[n(220)] = !0;
}
function t7(r, t, e) {
  const n = J;
  e[n(330)] = !0;
}
function mu(r, t, e) {
  const n = J, i = r[0];
  if (r[n(233)] !== 1) throw new Error(n(340) + i + n(303));
  return [];
}
function Lt(r, t) {
  return function(e, n, i) {
    const s = Y0, o = e[0], a = e.length - 1;
    if (r === t) {
      if (a !== r) {
        const u = r === 1 ? "" : "s";
        throw new Error("expected " + r + s(316) + u + s(255) + o + s(235) + a);
      }
    } else if (a < r || a > t) {
      const u = t === 1 / 0 ? r + " or more" : r + " to " + t;
      throw new Error(s(213) + u + s(218) + o + s(235) + a);
    }
  };
}
function Vb(r, t, e) {
  const n = J, i = r[n(233)] - 1, s = new Array(i);
  for (let o = 0; o < i; ++o) {
    const a = Fr(r[o + 1], t, e);
    s[o] = a;
  }
  return s;
}
function Pe(r) {
  return function(t, e, n) {
    const i = Y0, s = t[i(233)] - 1, o = new Array(s);
    for (let a = 0; a < s; ++a) {
      const u = Fr(t[a + 1], r, n);
      o[a] = u;
    }
    return o;
  };
}
function e7(r, t, e) {
  const n = J, i = r[0], s = r[n(233)] - 1;
  if (s % 2 === 0) throw new Error(n(332) + i + n(235) + s + n(285));
}
function Wb(r, t, e) {
  const n = J, i = r[0], s = r.length - 1;
  if (s % 2 === 1) throw new Error("expected an even number of arguments for operation " + i + n(235) + s + n(285));
}
function n7(r, t, e) {
  const n = J, i = r[n(233)] - 1, s = yi | de | ni, o = Fr(r[1], s, e), a = Fr(r[r[n(233)] - 1], t, e), u = new Array(i - 2);
  for (let x = 0; x < i - 2; x += 2) {
    try {
      const c = Fr(r[x + 2], o[n(320)], e);
      u[x] = c;
    } catch (c) {
      throw new Error(n(217) + (x + 1) + n(249) + c.message);
    }
    try {
      const c = Fr(r[x + 3], a[n(320)], e);
      u[x + 1] = c;
    } catch (c) {
      throw new Error("failed to parse argument " + (x + 2) + n(249) + c[n(279)]);
    }
  }
  return [o, ...u, a];
}
function r7(r, t, e) {
  const n = J, i = r[1];
  let s;
  switch (i[0]) {
    case n(310):
      s = 1;
      break;
    case "exponential":
      const x = i[1];
      if (typeof x !== n(283) || x <= 0) throw new Error("expected a number base for exponential interpolation" + (", got " + JSON[n(345)](x) + n(285)));
      s = x;
      break;
    default:
      throw new Error(n(242) + JSON.stringify(i));
  }
  const o = new $n(de, s);
  let a;
  try {
    a = Fr(r[2], de, e);
  } catch (x) {
    throw new Error(n(250) + x.message);
  }
  const u = new Array(r[n(233)] - 3);
  for (let x = 0; x < u[n(233)]; x += 2) {
    try {
      const c = Fr(r[x + 3], de, e);
      u[x] = c;
    } catch (c) {
      throw new Error(n(217) + (x + 2) + n(226) + c[n(279)]);
    }
    try {
      const c = Fr(r[x + 4], t, e);
      u[x + 1] = c;
    } catch (c) {
      throw new Error(n(217) + (x + 3) + n(226) + c[n(279)]);
    }
  }
  return [o, a, ...u];
}
function i7(r, t, e) {
  const n = J, i = Fr(r[r.length - 1], t, e), s = new Array(r[n(233)] - 1);
  for (let o = 0; o < s.length - 1; o += 2) {
    try {
      const a = Fr(r[o + 1], ni, e);
      s[o] = a;
    } catch (a) {
      throw new Error(n(217) + o + n(324) + a[n(279)]);
    }
    try {
      const a = Fr(r[o + 2], i.type, e);
      s[o + 1] = a;
    } catch (a) {
      throw new Error("failed to parse argument " + (o + 1) + n(324) + a[n(279)]);
    }
  }
  return s[s.length - 1] = i, s;
}
function s7(r, t, e) {
  const n = J;
  let i = r[2];
  if (!Array.isArray(i)) throw new Error(n(291));
  let s;
  if (typeof i[0] === n(342)) {
    if (i[0] !== n(306)) throw new Error(n(248));
    if (!Array[n(254)](i[1])) throw new Error(n(208));
    i = i[1], s = yi;
  } else s = de;
  const o = new Array(i[n(233)]);
  for (let u = 0; u < o[n(233)]; u++)
    try {
      const x = Fr(i[u], s, e);
      o[u] = x;
    } catch (x) {
      throw new Error(n(262) + u + ' for "in" expression: ' + x[n(279)]);
    }
  return [Fr(r[1], s, e), ...o];
}
function o7(r, t, e) {
  const n = J;
  let i;
  try {
    i = Fr(r[1], de, e);
  } catch (a) {
    throw new Error(n(314) + a[n(279)]);
  }
  const s = r[2];
  if (!Array[n(254)](s)) throw new Error(n(336));
  const o = new Array(s[n(233)]);
  for (let a = 0; a < o.length; a++) {
    let u;
    try {
      u = Fr(s[a], zs, e);
    } catch (x) {
      throw new Error(n(207) + a + n(276) + x[n(279)]);
    }
    if (!(u instanceof $n)) throw new Error("the palette color at index " + a + n(272));
    o[a] = u;
  }
  return [i, ...o];
}
function It(...r) {
  return function(t, e, n) {
    const i = Y0, s = t[0];
    let o;
    for (let a = 0; a < r[i(233)]; a++) {
      const u = r[a](t, e, n);
      if (a == r[i(233)] - 1) {
        if (!u) throw new Error(i(244));
        o = u;
      }
    }
    return new K9(e, s, ...o);
  };
}
function a7(r, t, e) {
  const n = J, i = r[0], s = j9[i];
  if (!s) throw new Error(n(265) + i);
  return s(r, t, e);
}
function z4(r) {
  const t = J;
  if (!r) return "";
  const e = r[t(298)]();
  switch (e) {
    case t(334):
    case t(300):
    case "Polygon":
      return e;
    case t(341):
    case t(253):
    case t(231):
      return e.substring(5);
    case t(211):
      return t(260);
    case "GeometryCollection":
      return z4(r.getGeometries()[0]);
    default:
      return "";
  }
}
function Si(r, t) {
  const e = ld();
  return Si = function(n, i) {
    return n = n - 239, e[n];
  }, Si(r, t);
}
function ld() {
  const r = ["1242FxiMMF", "Expected one of the values to be a ", "map", "LessThanOrEqualTo", "Any", "Get", "Unsupported operator ", "isArray", "pow", "Divide", "Pow", "612tebMyn", "ToString", "undefined", "properties", "floor", "args", "featureId", "resolution", "2484728bQKVcQ", "atan2", "Equal", "Expected one of the values to be non-null", "Sqrt", "atan", "Floor", "Abs", "Cos", "GreaterThanOrEqualTo", "Unsupported comparison operator ", "type", "Has", "Round", "Not", "Match", "Clamp", "Var", "operator", "Unsupported logical operator ", "String", "string", "round", "concat", "NotEqual", "Unsupported convert operator ", "37TNMPpq", "Between", "5858391QpZZGF", "value", "GeometryType", "LessThan", "All", "sqrt", "140680uuHqZc", "Interpolate", "4584495BjjXOM", "Add", "toString", "Ceil", "Multiply", "Subtract", "6cqPmfP", "variables", "Unsupported assertion operator ", "Number", "length", "Concat", "7469225NmZely", "Sin", "GreaterThan", "cos", "6296844dEOQJX", "Coalesce"];
  return ld = function() {
    return r;
  }, ld();
}
(function(r, t) {
  const e = Si, n = r();
  for (; ; )
    try {
      if (parseInt(e(303)) / 1 * (-parseInt(e(258)) / 2) + parseInt(e(240)) / 3 + -parseInt(e(256)) / 4 + -parseInt(e(252)) / 5 * (-parseInt(e(246)) / 6) + parseInt(e(305)) / 7 + -parseInt(e(277)) / 8 + -parseInt(e(269)) / 9 * (parseInt(e(311)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ld, 994520);
function U4() {
  return { variables: {}, properties: {}, resolution: NaN, featureId: null, geometryType: "" };
}
function ba(r, t, e) {
  const n = Fr(r, t, e);
  return Zs(n);
}
function Zs(r, t) {
  const e = Si;
  if (r instanceof $n) {
    if (r[e(288)] === zs && typeof r[e(306)] === e(298)) {
      const i = P_(r.value);
      return function() {
        return i;
      };
    }
    return function() {
      return r[e(306)];
    };
  }
  const n = r.operator;
  switch (n) {
    case Y[e(249)]:
    case Y[e(297)]:
    case Y[e(257)]:
      return u7(r);
    case Y[e(263)]:
    case Y[e(294)]:
    case Y[e(289)]:
      return x7(r);
    case Y.Id:
      return (i) => i[e(275)];
    case Y[e(307)]:
      return (i) => i.geometryType;
    case Y[e(251)]: {
      const i = r[e(274)][e(260)]((s) => Zs(s));
      return (s) => ""[e(300)](...i.map((o) => o(s)[e(242)]()));
    }
    case Y.Resolution:
      return (i) => i[e(276)];
    case Y[e(262)]:
    case Y[e(309)]:
    case Y[e(304)]:
    case Y.In:
    case Y[e(291)]:
      return f7(r);
    case Y[e(279)]:
    case Y[e(301)]:
    case Y[e(308)]:
    case Y[e(261)]:
    case Y.GreaterThan:
    case Y[e(286)]:
      return c7(r);
    case Y[e(244)]:
    case Y[e(267)]:
    case Y[e(241)]:
    case Y[e(245)]:
    case Y[e(293)]:
    case Y.Mod:
    case Y[e(268)]:
    case Y[e(284)]:
    case Y[e(283)]:
    case Y[e(243)]:
    case Y[e(290)]:
    case Y[e(253)]:
    case Y[e(285)]:
    case Y.Atan:
    case Y[e(281)]:
      return l7(r);
    case Y.Case:
      return h7(r);
    case Y[e(292)]:
      return p7(r);
    case Y[e(239)]:
      return d7(r);
    case Y[e(270)]:
      return g7(r);
    default:
      throw new Error(e(264) + n);
  }
}
function u7(r, t) {
  const e = Si, n = r[e(295)], i = r.args[e(250)], s = new Array(i);
  for (let o = 0; o < i; ++o)
    s[o] = Zs(r[e(274)][o]);
  switch (n) {
    case Y[e(257)]:
      return (o) => {
        const a = e;
        for (let u = 0; u < i; ++u) {
          const x = s[u](o);
          if (typeof x !== a(271) && x !== null) return x;
        }
        throw new Error(a(280));
      };
    case Y[e(249)]:
    case Y[e(297)]:
      return (o) => {
        const a = e;
        for (let u = 0; u < i; ++u) {
          const x = s[u](o);
          if (typeof x === n) return x;
        }
        throw new Error(a(259) + n);
      };
    default:
      throw new Error(e(248) + n);
  }
}
function x7(r, t) {
  const e = Si, n = r[e(274)][0], i = n[e(306)];
  switch (r[e(295)]) {
    case Y[e(263)]:
      return (s) => {
        const o = e, a = r.args;
        let u = s[o(272)][i];
        for (let x = 1, c = a[o(250)]; x < c; ++x) {
          const f = a[x], l = f.value;
          u = u[l];
        }
        return u;
      };
    case Y[e(294)]:
      return (s) => s[e(247)][i];
    case Y[e(289)]:
      return (s) => {
        const o = e, a = r.args;
        if (!(i in s[o(272)])) return !1;
        let u = s[o(272)][i];
        for (let x = 1, c = a[o(250)]; x < c; ++x) {
          const f = a[x], l = f[o(306)];
          if (!u || !Object.hasOwn(u, l)) return !1;
          u = u[l];
        }
        return !0;
      };
    default:
      throw new Error("Unsupported accessor operator " + r[e(295)]);
  }
}
function c7(r, t) {
  const e = Si, n = r[e(295)], i = Zs(r[e(274)][0]), s = Zs(r.args[1]);
  switch (n) {
    case Y[e(279)]:
      return (o) => i(o) === s(o);
    case Y[e(301)]:
      return (o) => i(o) !== s(o);
    case Y[e(308)]:
      return (o) => i(o) < s(o);
    case Y.LessThanOrEqualTo:
      return (o) => i(o) <= s(o);
    case Y[e(254)]:
      return (o) => i(o) > s(o);
    case Y[e(286)]:
      return (o) => i(o) >= s(o);
    default:
      throw new Error(e(287) + n);
  }
}
function f7(r, t) {
  const e = Si, n = r[e(295)], i = r[e(274)][e(250)], s = new Array(i);
  for (let o = 0; o < i; ++o)
    s[o] = Zs(r[e(274)][o]);
  switch (n) {
    case Y[e(262)]:
      return (o) => {
        for (let a = 0; a < i; ++a)
          if (s[a](o)) return !0;
        return !1;
      };
    case Y[e(309)]:
      return (o) => {
        for (let a = 0; a < i; ++a)
          if (!s[a](o)) return !1;
        return !0;
      };
    case Y[e(304)]:
      return (o) => {
        const a = s[0](o), u = s[1](o), x = s[2](o);
        return a >= u && a <= x;
      };
    case Y.In:
      return (o) => {
        const a = s[0](o);
        for (let u = 1; u < i; ++u)
          if (a === s[u](o)) return !0;
        return !1;
      };
    case Y[e(291)]:
      return (o) => !s[0](o);
    default:
      throw new Error(e(296) + n);
  }
}
function l7(r, t) {
  const e = Si, n = r.operator, i = r[e(274)][e(250)], s = new Array(i);
  for (let o = 0; o < i; ++o)
    s[o] = Zs(r.args[o]);
  switch (n) {
    case Y[e(244)]:
      return (o) => {
        let a = 1;
        for (let u = 0; u < i; ++u)
          a *= s[u](o);
        return a;
      };
    case Y.Divide:
      return (o) => s[0](o) / s[1](o);
    case Y.Add:
      return (o) => {
        let a = 0;
        for (let u = 0; u < i; ++u)
          a += s[u](o);
        return a;
      };
    case Y[e(245)]:
      return (o) => s[0](o) - s[1](o);
    case Y.Clamp:
      return (o) => {
        const a = s[0](o), u = s[1](o);
        if (a < u) return u;
        const x = s[2](o);
        return a > x ? x : a;
      };
    case Y.Mod:
      return (o) => s[0](o) % s[1](o);
    case Y[e(268)]:
      return (o) => Math[e(266)](s[0](o), s[1](o));
    case Y[e(284)]:
      return (o) => Math.abs(s[0](o));
    case Y[e(283)]:
      return (o) => Math[e(273)](s[0](o));
    case Y[e(243)]:
      return (o) => Math.ceil(s[0](o));
    case Y[e(290)]:
      return (o) => Math[e(299)](s[0](o));
    case Y[e(253)]:
      return (o) => Math.sin(s[0](o));
    case Y[e(285)]:
      return (o) => Math[e(255)](s[0](o));
    case Y.Atan:
      return i === 2 ? (o) => Math[e(278)](s[0](o), s[1](o)) : (o) => Math[e(282)](s[0](o));
    case Y.Sqrt:
      return (o) => Math[e(310)](s[0](o));
    default:
      throw new Error("Unsupported numeric operator " + n);
  }
}
function h7(r, t) {
  const e = Si, n = r.args[e(250)], i = new Array(n);
  for (let s = 0; s < n; ++s)
    i[s] = Zs(r.args[s]);
  return (s) => {
    for (let o = 0; o < n - 1; o += 2)
      if (i[o](s)) return i[o + 1](s);
    return i[n - 1](s);
  };
}
function p7(r, t) {
  const e = Si, n = r[e(274)][e(250)], i = new Array(n);
  for (let s = 0; s < n; ++s)
    i[s] = Zs(r.args[s]);
  return (s) => {
    const o = i[0](s);
    for (let a = 1; a < n; a += 2)
      if (o === i[a](s)) return i[a + 1](s);
    return i[n - 1](s);
  };
}
function d7(r, t) {
  const e = Si, n = r[e(274)][e(250)], i = new Array(n);
  for (let s = 0; s < n; ++s)
    i[s] = Zs(r[e(274)][s]);
  return (s) => {
    const o = e, a = i[0](s), u = i[1](s);
    let x, c;
    for (let f = 2; f < n; f += 2) {
      const l = i[f](s);
      let h = i[f + 1](s);
      const p = Array[o(265)](h);
      if (p && (h = y9(h)), l >= u)
        return f === 2 ? h : p ? y7(a, u, x, c, l, h) : Nc(a, u, x, c, l, h);
      x = l, c = h;
    }
    return c;
  };
}
function g7(r, t) {
  const e = Si, n = r[e(295)], i = r[e(274)].length, s = new Array(i);
  for (let o = 0; o < i; ++o)
    s[o] = Zs(r[e(274)][o]);
  switch (n) {
    case Y[e(270)]:
      return (o) => {
        const a = e, u = s[0](o);
        return r[a(274)][0].type === zs ? L_(u) : u[a(242)]();
      };
    default:
      throw new Error(e(302) + n);
  }
}
function Nc(r, t, e, n, i, s) {
  const o = Si, a = i - e;
  if (a === 0) return n;
  const u = t - e, x = r === 1 ? u / a : (Math.pow(r, u) - 1) / (Math[o(266)](r, a) - 1);
  return n + x * (s - n);
}
function y7(r, t, e, n, i, s) {
  if (i - e === 0) return n;
  const a = Ab(n), u = Ab(s);
  let x = u[2] - a[2];
  x > 180 ? x -= 360 : x < -180 && (x += 360);
  const c = [Nc(r, t, e, a[0], i, u[0]), Nc(r, t, e, a[1], i, u[1]), a[2] + Nc(r, t, e, 0, i, x), Nc(r, t, e, n[3], i, s[3])];
  return F4(v9(c));
}
(function(r, t) {
  const e = We, n = r();
  for (; ; )
    try {
      if (-parseInt(e(491)) / 1 * (parseInt(e(510)) / 2) + -parseInt(e(509)) / 3 + -parseInt(e(525)) / 4 + parseInt(e(528)) / 5 + parseInt(e(479)) / 6 + -parseInt(e(530)) / 7 + parseInt(e(608)) / 8 * (parseInt(e(573)) / 9) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(dd, 769579);
function v7(r) {
  return !0;
}
function m7(r) {
  const t = q4(), e = _7(r, t), n = U4();
  return function(i, s) {
    const o = We;
    if (n[o(563)] = i[o(483)](), n[o(521)] = s, t[o(534)]) {
      const a = i[o(549)]();
      a !== void 0 ? n[o(534)] = a : n[o(534)] = null;
    }
    return t[o(607)] && (n[o(607)] = z4(i[o(511)]())), e(n);
  };
}
function Hb(r) {
  const t = We, e = q4(), n = r[t(536)], i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = Lm(r[a], e);
  const s = U4(), o = new Array(n);
  return function(a, u) {
    const x = t;
    if (s[x(563)] = a[x(483)](), s[x(521)] = u, e[x(534)]) {
      const f = a[x(549)]();
      f !== void 0 ? s[x(534)] = f : s[x(534)] = null;
    }
    let c = 0;
    for (let f = 0; f < n; ++f) {
      const l = i[f](s);
      l && (o[c] = l, c += 1);
    }
    return o[x(536)] = c, o;
  };
}
function _7(r, t) {
  const e = We, n = r[e(536)], i = new Array(n);
  for (let s = 0; s < n; ++s) {
    const o = r[s], a = e(545) in o ? ba(o.filter, ni, t) : v7;
    let u;
    if (Array[e(544)](o[e(604)])) {
      const x = o[e(604)][e(536)];
      u = new Array(x);
      for (let c = 0; c < x; ++c)
        u[c] = Lm(o[e(604)][c], t);
    } else u = [Lm(o[e(604)], t)];
    i[s] = { filter: a, styles: u };
  }
  return function(s) {
    const o = e, a = [];
    let u = !1;
    for (let x = 0; x < n; ++x) {
      const c = i[x][o(545)];
      if (c(s) && !(r[x][o(504)] && u)) {
        u = !0;
        for (const f of i[x][o(551)]) {
          const l = f(s);
          l && a[o(558)](l);
        }
      }
    }
    return a;
  };
}
function Lm(r, t) {
  const e = We, n = Gf(r, "", t), i = Yf(r, "", t), s = b7(r, t), o = I7(r, t), a = mi(r, e(565), t);
  if (!n && !i && !s && !o && !sx(r)) throw new Error(e(533) + JSON[e(512)](r));
  const u = new En();
  return function(x) {
    const c = e;
    let f = !0;
    if (n) {
      const l = n(x);
      l && (f = !1), u.setFill(l);
    }
    if (i) {
      const l = i(x);
      l && (f = !1), u[c(538)](l);
    }
    if (s) {
      const l = s(x);
      l && (f = !1), u.setText(l);
    }
    if (o) {
      const l = o(x);
      l && (f = !1), u[c(562)](l);
    }
    return a && u[c(507)](a(x)), f ? null : u;
  };
}
function Gf(r, t, e) {
  const n = We;
  let i;
  if (t + n(502) in r) i = C7(r, t + n(505), e);
  else {
    if (r[t + "fill-color"] === n(575)) return (o) => null;
    i = F_(r, t + n(591), e);
  }
  if (!i) return null;
  const s = new Hr();
  return function(o) {
    const a = n, u = i(o);
    return u === M_ ? null : (s[a(601)](u), s);
  };
}
function Yf(r, t, e) {
  const n = We, i = mi(r, t + "stroke-width", e), s = F_(r, t + n(595), e);
  if (!i && !s) return null;
  const o = Wo(r, t + "stroke-line-cap", e), a = Wo(r, t + n(576), e), u = V4(r, t + "stroke-line-dash", e), x = mi(r, t + n(554), e), c = mi(r, t + n(579), e), f = new ys();
  return function(l) {
    const h = n;
    if (s) {
      const p = s(l);
      if (p === M_) return null;
      f[h(601)](p);
    }
    if (i && f[h(531)](i(l)), o) {
      const p = o(l);
      if (p !== h(580) && p !== h(548) && p !== "square") throw new Error(h(577));
      f[h(582)](p);
    }
    if (a) {
      const p = a(l);
      if (p !== h(583) && p !== h(548) && p !== h(552)) throw new Error(h(482));
      f[h(600)](p);
    }
    return u && f[h(599)](u(l)), x && f[h(484)](x(l)), c && f[h(493)](c(l)), f;
  };
}
function b7(r, t) {
  const e = We, n = e(611), i = Wo(r, n + e(547), t);
  if (!i) return null;
  const s = Gf(r, n, t), o = Gf(r, n + e(572), t), a = Yf(r, n, t), u = Yf(r, n + "background-", t), x = Wo(r, n + "font", t), c = mi(r, n + "max-angle", t), f = mi(r, n + e(499), t), l = mi(r, n + e(500), t), h = Xf(r, n + e(540), t), p = Wo(r, n + "placement", t), y = mi(r, n + e(603), t), v = my(r, n + e(610), t), m = Xf(r, n + "rotate-with-view", t), d = mi(r, n + "rotation", t), g = Wo(r, n + e(589), t), _ = Wo(r, n + e(609), t), b = Wo(r, n + e(486), t), w = V4(r, n + e(498), t), E = _y(r, n + e(566)), S = new Dl({ declutterMode: E });
  return function(I) {
    const L = e;
    if (S[L(487)](i(I)), s && S[L(527)](s(I)), o && S[L(550)](o(I)), a && S[L(538)](a(I)), u && S[L(481)](u(I)), x && S[L(539)](x(I)), c && S[L(519)](c(I)), f && S[L(555)](f(I)), l && S[L(588)](l(I)), h && S[L(593)](h(I)), p) {
      const M = p(I);
      if (M !== L(537) && M !== "line") throw new Error(L(560));
      S[L(553)](M);
    }
    if (y && S[L(535)](y(I)), v && S[L(556)](v(I)), m && S[L(569)](m(I)), d && S[L(592)](d(I)), g) {
      const M = g(I);
      if (M !== "left" && M !== "center" && M !== "right" && M !== "end" && M !== L(517)) throw new Error("Expected left, right, center, start, or end for text-align");
      S[L(501)](M);
    }
    if (_) {
      const M = _(I);
      if (M !== L(495) && M !== L(514) && M !== "center") throw new Error("Expected left, right, or center for text-justify");
      S[L(586)](M);
    }
    if (b) {
      const M = b(I);
      if (M !== "bottom" && M !== L(594) && M !== L(567) && M !== L(522) && M !== L(518)) throw new Error(L(571));
      S[L(520)](M);
    }
    return w && S.setPadding(w(I)), S;
  };
}
function I7(r, t) {
  const e = We;
  return e(561) in r ? w7(r, t) : "shape-points" in r ? E7(r, t) : e(590) in r ? S7(r, t) : null;
}
function w7(r, t) {
  const e = We, n = "icon-", i = n + e(503), s = W4(r[i], i), o = hd(r, n + "anchor", t), a = my(r, n + "scale", t), u = mi(r, n + e(542), t), x = hd(r, n + e(587), t), c = mi(r, n + e(602), t), f = Xf(r, n + "rotate-with-view", t), l = Zb(r, n + e(532)), h = Kb(r, n + e(564)), p = Kb(r, n + e(529)), y = N7(r, n + e(489)), v = P7(r, n + e(606)), m = L7(r, n + e(497)), d = Zb(r, n + e(541)), g = pd(r, n + e(543)), _ = pd(r, n + "height"), b = M7(r, n + e(584)), w = _y(r, n + "declutter-mode"), E = new rc({ src: s, anchorOrigin: l, anchorXUnits: h, anchorYUnits: p, color: y, crossOrigin: v, offset: m, offsetOrigin: d, height: _, width: g, size: b, declutterMode: w });
  return function(S) {
    const I = e;
    return u && E[I(496)](u(S)), x && E.setDisplacement(x(S)), c && E.setRotation(c(S)), f && E[I(569)](f(S)), a && E[I(556)](a(S)), o && E.setAnchor(o(S)), E;
  };
}
function E7(r, t) {
  const e = We, n = e(605), i = n + e(508), s = n + "radius", o = Nm(r[i], i), a = Nm(r[s], s), u = Gf(r, n, t), x = Yf(r, n, t), c = my(r, n + e(610), t), f = hd(r, n + e(587), t), l = mi(r, n + e(602), t), h = Xf(r, n + "rotate-with-view", t), p = pd(r, n + "radius2"), y = pd(r, n + e(598)), v = _y(r, n + e(566)), m = new _o({ points: o, radius: a, radius2: p, angle: y, declutterMode: v });
  return function(d) {
    const g = e;
    return u && m[g(527)](u(d)), x && m[g(538)](x(d)), f && m.setDisplacement(f(d)), l && m[g(592)](l(d)), h && m.setRotateWithView(h(d)), c && m.setScale(c(d)), m;
  };
}
function S7(r, t) {
  const e = We, n = "circle-", i = Gf(r, n, t), s = Yf(r, n, t), o = mi(r, n + e(513), t), a = my(r, n + e(610), t), u = hd(r, n + e(587), t), x = mi(r, n + e(602), t), c = Xf(r, n + e(516), t), f = _y(r, n + e(566)), l = new x0({ radius: 5, declutterMode: f });
  return function(h) {
    const p = e;
    return o && l[p(480)](o(h)), i && l[p(527)](i(h)), s && l[p(538)](s(h)), u && l.setDisplacement(u(h)), x && l[p(592)](x(h)), c && l[p(569)](c(h)), a && l[p(556)](a(h)), l;
  };
}
function mi(r, t, e) {
  if (!(t in r)) return;
  const n = ba(r[t], de, e);
  return function(i) {
    return Nm(n(i), t);
  };
}
function Wo(r, t, e) {
  if (!(t in r)) return null;
  const n = ba(r[t], yi, e);
  return function(i) {
    return W4(n(i), t);
  };
}
function C7(r, t, e) {
  const n = We, i = Wo(r, t + n(526), e), s = Jb(r, t + n(578), e), o = Jb(r, t + n(557), e), a = F_(r, t + n(489), e);
  return function(u) {
    return { src: i(u), offset: s && s(u), size: o && o(u), color: a && a(u) };
  };
}
function Xf(r, t, e) {
  if (!(t in r)) return null;
  const n = ba(r[t], ni, e);
  return function(i) {
    const s = We, o = n(i);
    if (typeof o != "boolean") throw new Error(s(524) + t);
    return o;
  };
}
function F_(r, t, e) {
  if (!(t in r)) return null;
  const n = ba(r[t], zs, e);
  return function(i) {
    return H4(n(i), t);
  };
}
function V4(r, t, e) {
  if (!(t in r)) return null;
  const n = ba(r[t], G0, e);
  return function(i) {
    return Fl(n(i), t);
  };
}
function hd(r, t, e) {
  if (!(t in r)) return null;
  const n = ba(r[t], G0, e);
  return function(i) {
    const s = We, o = Fl(n(i), t);
    if (o[s(536)] !== 2) throw new Error(s(574) + t);
    return o;
  };
}
function Jb(r, t, e) {
  if (!(t in r)) return null;
  const n = ba(r[t], G0, e);
  return function(i) {
    return J4(n(i), t);
  };
}
function my(r, t, e) {
  if (!(t in r)) return null;
  const n = ba(r[t], G0 | de, e);
  return function(i) {
    return O7(n(i), t);
  };
}
function We(r, t) {
  const e = dd();
  return We = function(n, i) {
    return n = n - 479, e[n];
  }, We(r, t);
}
function pd(r, t) {
  const e = We, n = r[t];
  if (n !== void 0) {
    if (typeof n !== e(581)) throw new Error("Expected a number for " + t);
    return n;
  }
}
function M7(r, t) {
  const e = We, n = r[t];
  if (n !== void 0) {
    if (typeof n === e(581)) return vx(n);
    if (!Array[e(544)](n)) throw new Error("Expected a number or size array for " + t);
    if (n[e(536)] !== 2 || typeof n[0] !== e(581) || typeof n[1] !== e(581)) throw new Error(e(492) + t);
    return n;
  }
}
function P7(r, t) {
  const e = We, n = r[t];
  if (n !== void 0) {
    if (typeof n !== e(506)) throw new Error("Expected a string for " + t);
    return n;
  }
}
function Zb(r, t) {
  const e = We, n = r[t];
  if (n !== void 0) {
    if (n !== e(488) && n !== e(523) && n !== e(546) && n !== "top-right") throw new Error("Expected bottom-left, bottom-right, top-left, or top-right for " + t);
    return n;
  }
}
function Kb(r, t) {
  const e = We, n = r[t];
  if (n !== void 0) {
    if (n !== e(494) && n !== e(585)) throw new Error(e(596) + t);
    return n;
  }
}
function L7(r, t) {
  const e = r[t];
  if (e !== void 0)
    return Fl(e, t);
}
function dd() {
  const r = ["offset-origin", "opacity", "width", "isArray", "filter", "top-left", "value", "round", "getId", "setBackgroundFill", "styles", "miter", "setPlacement", "stroke-line-dash-offset", "setOffsetX", "setScale", "pattern-size", "push", "Expected a number for ", "Expected point or line for text-placement", "icon-src", "setImage", "properties", "anchor-x-units", "z-index", "declutter-mode", "middle", "Expected declutter, obstacle, or none for ", "setRotateWithView", "Expected an array for ", "Expected bottom, top, middle, alphabetic, or hanging for text-baseline", "background-", "5278968eQLDHD", "Expected two numbers for ", "none", "stroke-line-join", "Expected butt, round, or square line cap", "pattern-offset", "stroke-miter-limit", "butt", "number", "setLineCap", "bevel", "size", "fraction", "setJustify", "displacement", "setOffsetY", "align", "circle-radius", "fill-color", "setRotation", "setOverflow", "top", "stroke-color", "Expected pixels or fraction for ", "Expected a string for ", "angle", "setLineDash", "setLineJoin", "setColor", "rotation", "repeat", "style", "shape-", "cross-origin", "geometryType", "16GYIwHr", "justify", "scale", "text-", "declutter", "2380002wFRmaJ", "setRadius", "setBackgroundStroke", "Expected bevel, round, or miter line join", "getPropertiesInternal", "setLineDashOffset", "Expected an array of numbers for ", "baseline", "setText", "bottom-left", "color", "Expected an array of two numbers for ", "3WgChoG", "Expected a number or size array for ", "setMiterLimit", "pixels", "left", "setOpacity", "offset", "padding", "offset-x", "offset-y", "setTextAlign", "fill-pattern-src", "src", "else", "fill-", "string", "setZIndex", "points", "499176sDyzVB", "66680czRVKD", "getGeometry", "stringify", "radius", "right", "obstacle", "rotate-with-view", "start", "hanging", "setMaxAngle", "setTextBaseline", "resolution", "alphabetic", "bottom-right", "Expected a boolean for ", "1831320ciJfrq", "pattern-src", "setFill", "3461515PELyTN", "anchor-y-units", "5377771ycCKlo", "setWidth", "anchor-origin", "No fill, stroke, point, or text symbolizer properties in style: ", "featureId", "setRepeat", "length", "point", "setStroke", "setFont", "overflow"];
  return dd = function() {
    return r;
  }, dd();
}
function _y(r, t) {
  const e = We, n = r[t];
  if (n !== void 0) {
    if (typeof n != "string") throw new Error(e(597) + t);
    if (n !== e(612) && n !== e(515) && n !== "none") throw new Error(e(568) + t);
    return n;
  }
}
function N7(r, t) {
  const e = r[t];
  if (e !== void 0)
    return H4(e, t);
}
function Fl(r, t) {
  const e = We;
  if (!Array[e(544)](r)) throw new Error(e(570) + t);
  const n = r.length;
  for (let i = 0; i < n; ++i)
    if (typeof r[i] !== e(581)) throw new Error(e(485) + t);
  return r;
}
function W4(r, t) {
  if (typeof r != "string") throw new Error("Expected a string for " + t);
  return r;
}
function Nm(r, t) {
  const e = We;
  if (typeof r != "number") throw new Error(e(559) + t);
  return r;
}
function H4(r, t) {
  if (typeof r === We(506)) return r;
  const n = Fl(r, t), i = n.length;
  if (i < 3 || i > 4) throw new Error("Expected a color with 3 or 4 values for " + t);
  return n;
}
function J4(r, t) {
  const e = We, n = Fl(r, t);
  if (n[e(536)] !== 2) throw new Error(e(490) + t);
  return n;
}
function O7(r, t) {
  return typeof r == "number" ? r : J4(r, t);
}
const Yn = gd;
(function(r, t) {
  const e = gd, n = r();
  for (; ; )
    try {
      if (-parseInt(e(465)) / 1 + parseInt(e(497)) / 2 * (parseInt(e(493)) / 3) + parseInt(e(492)) / 4 + -parseInt(e(481)) / 5 + -parseInt(e(489)) / 6 * (-parseInt(e(498)) / 7) + parseInt(e(474)) / 8 * (parseInt(e(479)) / 9) + parseInt(e(486)) / 10 * (-parseInt(e(482)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(yd, 235109);
function gd(r, t) {
  const e = yd();
  return gd = function(n, i) {
    return n = n - 459, e[n];
  }, gd(r, t);
}
const jb = { RENDER_ORDER: Yn(463) };
class R7 extends V9 {
  constructor(t) {
    const e = Yn;
    t = t || {};
    const n = Object[e(475)]({}, t);
    delete n[e(483)], delete n[e(462)], delete n[e(476)], delete n[e(471)], super(n), this[e(478)] = t.declutter ? String(t[e(466)]) : void 0, this.renderBuffer_ = t[e(462)] !== void 0 ? t[e(462)] : 100, this[e(467)] = null, this[e(484)] = void 0, this.setStyle(t[e(483)]), this[e(487)] = t[e(476)] !== void 0 ? t[e(476)] : !1, this.updateWhileInteracting_ = t[e(471)] !== void 0 ? t.updateWhileInteracting : !1;
  }
  [Yn(485)]() {
    return this[Yn(478)];
  }
  [Yn(472)](t) {
    const e = Yn;
    return super[e(472)](t);
  }
  [Yn(490)]() {
    return this.renderBuffer_;
  }
  [Yn(488)]() {
    const t = Yn;
    return this[t(473)](jb[t(470)]);
  }
  [Yn(477)]() {
    return this[Yn(467)];
  }
  getStyleFunction() {
    return this.styleFunction_;
  }
  [Yn(494)]() {
    return this.updateWhileAnimating_;
  }
  [Yn(495)]() {
    return this[Yn(461)];
  }
  [Yn(496)](t, e) {
    const n = Yn, i = this[n(485)]();
    !(i in t[n(466)]) && (t[n(466)][i] = new t4(9)), this[n(491)]()[n(496)](t, e);
  }
  [Yn(460)](t) {
    const e = Yn;
    this[e(459)](jb[e(470)], t);
  }
  setStyle(t) {
    const e = Yn;
    this[e(467)] = t === void 0 ? X4 : t;
    const n = A7(t);
    this.styleFunction_ = t === null ? void 0 : R9(n), this.changed();
  }
}
function A7(r) {
  const t = Yn;
  if (r === void 0) return X4;
  if (!r) return null;
  if (typeof r == "function" || r instanceof En) return r;
  if (!Array[t(480)](r)) return Hb([r]);
  if (r[t(464)] === 0) return [];
  const e = r[t(464)], n = r[0];
  if (n instanceof En) {
    const s = new Array(e);
    for (let o = 0; o < e; ++o) {
      const a = r[o];
      if (!(a instanceof En)) throw new Error(t(469));
      s[o] = a;
    }
    return s;
  }
  if (t(483) in n) {
    const s = new Array(e);
    for (let o = 0; o < e; ++o) {
      const a = r[o];
      if (!(t(483) in a)) throw new Error(t(468));
      s[o] = a;
    }
    return m7(s);
  }
  return Hb(r);
}
function yd() {
  const r = ["RENDER_ORDER", "updateWhileInteracting", "getFeatures", "get", "1192LETIef", "assign", "updateWhileAnimating", "getStyle", "declutter_", "18369xdiesc", "isArray", "1272050uzEUAK", "409090epvLIW", "style", "styleFunction_", "getDeclutter", "50PAmpbs", "updateWhileAnimating_", "getRenderOrder", "37038OpUvtr", "getRenderBuffer", "getRenderer", "1647528rjUjNi", "11967PfUjaW", "getUpdateWhileAnimating", "getUpdateWhileInteracting", "renderDeclutter", "32ZINYUy", "14SGruDc", "set", "setRenderOrder", "updateWhileInteracting_", "renderBuffer", "renderOrder", "length", "116692lvFBcY", "declutter", "style_", "Expected a list of rules with a style property", "Expected a list of style instances"];
  return yd = function() {
    return r;
  }, yd();
}
function vd(r, t) {
  const e = md();
  return vd = function(n, i) {
    return n = n - 246, e[n];
  }, vd(r, t);
}
const by = vd;
(function(r, t) {
  const e = vd, n = r();
  for (; ; )
    try {
      if (parseInt(e(259)) / 1 * (-parseInt(e(257)) / 2) + parseInt(e(249)) / 3 * (-parseInt(e(251)) / 4) + parseInt(e(253)) / 5 + parseInt(e(246)) / 6 + parseInt(e(247)) / 7 * (-parseInt(e(256)) / 8) + -parseInt(e(258)) / 9 + parseInt(e(248)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(md, 907844);
const pt = { BEGIN_GEOMETRY: 0, BEGIN_PATH: 1, CIRCLE: 2, CLOSE_PATH: 3, CUSTOM: 4, DRAW_CHARS: 5, DRAW_IMAGE: 6, END_GEOMETRY: 7, FILL: 8, MOVE_TO_LINE_TO: 9, SET_FILL_STYLE: 10, SET_STROKE_STYLE: 11, STROKE: 12 }, hh = [pt[by(254)]], ka = [pt[by(252)]];
function md() {
  const r = ["STROKE", "2769435pTOvBu", "FILL", "BEGIN_PATH", "7064yDamFy", "6734yMashe", "6439320crrENk", "487EbRbUL", "5498988qwvavj", "7tooEcj", "32923640LPUapH", "4496439iUWSaP", "CLOSE_PATH", "4DlgFtN"];
  return md = function() {
    return r;
  }, md();
}
const M0 = [pt[by(255)]], Qb = [pt[by(250)]];
var ki = _d;
(function(r, t) {
  for (var e = _d, n = r(); ; )
    try {
      var i = -parseInt(e(189)) / 1 + -parseInt(e(175)) / 2 * (-parseInt(e(179)) / 3) + parseInt(e(184)) / 4 * (-parseInt(e(192)) / 5) + -parseInt(e(181)) / 6 + parseInt(e(176)) / 7 * (parseInt(e(193)) / 8) + -parseInt(e(188)) / 9 + parseInt(e(180)) / 10;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(bd, 480143);
function _d(r, t) {
  var e = bd();
  return _d = function(n, i) {
    n = n - 171;
    var s = e[n];
    return s;
  }, _d(r, t);
}
function bd() {
  var r = ["drawPolygon", "drawGeometryCollection", "1747584PQuoUc", "404503nfvtxZ", "drawCustom", "setTextStyle", "444475Siwgqr", "16RYqrdM", "drawMultiLineString", "setFillStrokeStyle", "drawGeometry", "setStyle", "62xyBkmZ", "108703IzhyCk", "drawLineString", "drawText", "8205iihzkK", "19758680DEVEhR", "1277004EBFYeU", "drawCircle", "drawMultiPolygon", "36OekQrW", "setImageStyle"];
  return bd = function() {
    return r;
  }, bd();
}
class Z4 {
  [ki(190)](t, e, n, i, s) {
  }
  [ki(173)](t) {
  }
  [ki(174)](t) {
  }
  [ki(182)](t, e, n) {
  }
  drawFeature(t, e, n) {
  }
  [ki(187)](t, e, n) {
  }
  [ki(177)](t, e, n) {
  }
  [ki(171)](t, e, n) {
  }
  drawMultiPoint(t, e, n) {
  }
  [ki(183)](t, e, n) {
  }
  drawPoint(t, e, n) {
  }
  [ki(186)](t, e, n) {
  }
  [ki(178)](t, e, n) {
  }
  [ki(172)](t, e) {
  }
  [ki(185)](t, e) {
  }
  [ki(191)](t, e) {
  }
}
function qf(r, t) {
  const e = Id();
  return qf = function(n, i) {
    return n = n - 173, e[n];
  }, qf(r, t);
}
const Ge = qf;
function Id() {
  const r = ["4QeiXPo", "lineWidth", "appendFlatPointCoordinates", "bufferedMaxExtent_", "endGeometry", "currentMiterLimit", "applyStroke", "currentLineWidth", "beginGeometryInstruction2_", "currentStrokeStyle", "INTERSECTING", "fillStyle", "getLineDash", "drawCustomCoordinates_", "setFillStrokeStyle", "MultiPoint", "appendFlatLineCoordinates", "length", "slice", "3694vkLecI", "3495360HzpDaa", "lineCap", "END_GEOMETRY", "getFlatCoordinates", "currentLineCap", "SET_STROKE_STYLE", "string", "coordinates", "tmpCoordinate_", "push", "state", "currentLineDash", "lineJoin", "Point", "currentLineDashOffset", "currentLineJoin", "CUSTOM", "getBufferedMaxExtent", "getMiterLimit", "Polygon", "miterLimit", "finish", "545LUaOwJ", "getEndss", "lineDashOffset", "reverseHitDetectionInstructions", "getWidth", "getLineJoin", "beginGeometryInstruction1_", "reverse", "hitDetectionInstructions", "SET_FILL_STYLE", "780228RAVbgn", "maxExtent", "call", "BEGIN_GEOMETRY", "377180SKPAZo", "maxLineWidth", "7313416QZHMvj", "LineString", "map", "getType", "resolution", "getStride", "strokeStyle", "instructions", "drawCustom", "updateFillStyle", "getOrientedFlatCoordinates", "pixelRatio", "MultiLineString", "lineDash", "Circle", "271872qoJJoj", "MultiPolygon", "getColor", "createStroke", "getLineCap", "tolerance", "src", "971642LBSTqI", "applyPixelRatio", "beginGeometry", "fillPatternScale"];
  return Id = function() {
    return r;
  }, Id();
}
(function(r, t) {
  const e = qf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(229)) / 1 * (parseInt(e(206)) / 2) + parseInt(e(207)) / 3 + -parseInt(e(187)) / 4 * (parseInt(e(243)) / 5) + -parseInt(e(239)) / 6 + -parseInt(e(183)) / 7 + parseInt(e(245)) / 8 + -parseInt(e(176)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Id, 698194);
class kl extends Z4 {
  constructor(t, e, n, i) {
    const s = qf;
    super(), this[s(181)] = t, this[s(240)] = e, this[s(256)] = i, this[s(244)] = 0, this.resolution = n, this[s(235)] = null, this[s(195)] = null, this[s(190)] = null, this[s(252)] = [], this[s(214)] = [], this[s(215)] = [], this[s(237)] = [], this[s(217)] = {};
  }
  [Ge(184)](t) {
    const e = Ge, n = this[e(256)];
    return n == 1 ? t : t[e(247)](function(i) {
      return i * n;
    });
  }
  [Ge(189)](t, e) {
    const n = Ge, i = this.getBufferedMaxExtent(), s = this[n(215)], o = this.coordinates;
    let a = o.length;
    for (let u = 0, x = t[n(204)]; u < x; u += e)
      s[0] = t[u], s[1] = t[u + 1], cm(i, s) && (o[a++] = s[0], o[a++] = s[1]);
    return a;
  }
  appendFlatLineCoordinates(t, e, n, i, s, o) {
    const a = Ge, u = this[a(214)];
    let x = u[a(204)];
    const c = this[a(224)]();
    o && (e += i);
    let f = t[e], l = t[e + 1];
    const h = this.tmpCoordinate_;
    let p = !0, y, v, m;
    for (y = e + i; y < n; y += i)
      h[0] = t[y], h[1] = t[y + 1], m = fm(c, h), m !== v ? (p && (u[x++] = f, u[x++] = l, p = !1), u[x++] = h[0], u[x++] = h[1]) : m === hr[a(197)] ? (u[x++] = h[0], u[x++] = h[1], p = !1) : p = !0, f = h[0], l = h[1], v = m;
    return (s && p || y === e + i) && (u[x++] = f, u[x++] = l), x;
  }
  [Ge(200)](t, e, n, i, s) {
    const o = Ge;
    for (let a = 0, u = n.length; a < u; ++a) {
      const x = n[a], c = this[o(203)](t, e, x, i, !1, !1);
      s.push(c), e = x;
    }
    return e;
  }
  [Ge(253)](t, e, n, i, s) {
    const o = Ge;
    this[o(185)](t, e, s);
    const a = t[o(248)](), u = t[o(250)](), x = this.coordinates[o(204)];
    let c, f, l, h, p;
    switch (a) {
      case o(177):
        c = t[o(255)](), h = [];
        const y = t[o(230)]();
        p = 0;
        for (let v = 0, m = y[o(204)]; v < m; ++v) {
          const d = [];
          p = this[o(200)](c, p, y[v], u, d), h[o(216)](d);
        }
        this[o(252)][o(216)]([pt[o(223)], x, h, t, n, gm, s]), this.hitDetectionInstructions[o(216)]([pt[o(223)], x, h, t, i || n, gm, s]);
        break;
      case o(226):
      case o(173):
        l = [], c = a == "Polygon" ? t[o(255)]() : t[o(210)](), p = this[o(200)](c, 0, t.getEnds(), u, l), this.instructions[o(216)]([pt[o(223)], x, l, t, n, cf, s]), this[o(237)].push([pt[o(223)], x, l, t, i || n, cf, s]);
        break;
      case o(246):
      case o(175):
        c = t.getFlatCoordinates(), f = this[o(203)](c, 0, c[o(204)], u, !1, !1), this[o(252)][o(216)]([pt[o(223)], x, f, t, n, Da, s]), this[o(237)].push([pt[o(223)], x, f, t, i || n, Da, s]);
        break;
      case o(202):
        c = t[o(210)](), f = this[o(189)](c, u), f > x && (this.instructions.push([pt[o(223)], x, f, t, n, Da, s]), this[o(237)].push([pt.CUSTOM, x, f, t, i || n, Da, s]));
        break;
      case o(220):
        c = t[o(210)](), this[o(214)][o(216)](c[0], c[1]), f = this[o(214)].length, this[o(252)][o(216)]([pt[o(223)], x, f, t, n, void 0, s]), this[o(237)][o(216)]([pt[o(223)], x, f, t, i || n, void 0, s]);
        break;
    }
    this[o(191)](e);
  }
  [Ge(185)](t, e, n) {
    const i = Ge;
    this[i(235)] = [pt[i(242)], e, 0, t, n], this[i(252)][i(216)](this[i(235)]), this[i(195)] = [pt.BEGIN_GEOMETRY, e, 0, t, n], this[i(237)][i(216)](this[i(195)]);
  }
  [Ge(228)]() {
    const t = Ge;
    return { instructions: this[t(252)], hitDetectionInstructions: this[t(237)], coordinates: this[t(214)] };
  }
  [Ge(232)]() {
    const t = Ge, e = this[t(237)];
    e[t(236)]();
    let n;
    const i = e.length;
    let s, o, a = -1;
    for (n = 0; n < i; ++n)
      s = e[n], o = s[0], o == pt[t(209)] ? a = n : o == pt[t(242)] && (s[2] = n, X6(this[t(237)], a, n), a = -1);
  }
  [Ge(201)](t, e) {
    const n = Ge, i = this[n(217)];
    if (t) {
      const s = t[n(178)]();
      i[n(186)] = s && typeof s == "object" && n(182) in s ? this[n(256)] : 1, i[n(198)] = yo(s || gi);
    } else i.fillStyle = void 0;
    if (e) {
      const s = e[n(178)]();
      i[n(251)] = yo(s || Lf);
      const o = e[n(180)]();
      i[n(208)] = o !== void 0 ? o : _x;
      const a = e[n(199)]();
      i.lineDash = a ? a[n(205)]() : ea;
      const u = e.getLineDashOffset();
      i[n(231)] = u || na;
      const x = e[n(234)]();
      i[n(219)] = x !== void 0 ? x : bx;
      const c = e[n(233)]();
      i[n(188)] = c !== void 0 ? c : Of;
      const f = e[n(225)]();
      i[n(227)] = f !== void 0 ? f : Pf, i[n(188)] > this[n(244)] && (this[n(244)] = i.lineWidth, this[n(190)] = null);
    } else i.strokeStyle = void 0, i[n(208)] = void 0, i[n(174)] = null, i[n(231)] = void 0, i[n(219)] = void 0, i[n(188)] = void 0, i[n(227)] = void 0;
  }
  createFill(t) {
    const e = Ge, n = t.fillStyle, i = [pt[e(238)], n];
    return typeof n !== e(213) && i.push(t[e(186)]), i;
  }
  [Ge(193)](t) {
    const e = Ge;
    this[e(252)][e(216)](this[e(179)](t));
  }
  [Ge(179)](t) {
    const e = Ge;
    return [pt[e(212)], t[e(251)], t[e(188)] * this[e(256)], t[e(208)], t[e(219)], t[e(227)], this.applyPixelRatio(t[e(174)]), t[e(231)] * this[e(256)]];
  }
  [Ge(254)](t, e) {
    const n = Ge, i = t[n(198)];
    (typeof i !== n(213) || t.currentFillStyle != i) && (i !== void 0 && this[n(252)].push(e[n(241)](this, t)), t.currentFillStyle = i);
  }
  updateStrokeStyle(t, e) {
    const n = Ge, i = t[n(251)], s = t[n(208)], o = t[n(174)], a = t[n(231)], u = t[n(219)], x = t[n(188)], c = t[n(227)];
    (t.currentStrokeStyle != i || t[n(211)] != s || o != t[n(218)] && !uu(t[n(218)], o) || t.currentLineDashOffset != a || t[n(222)] != u || t.currentLineWidth != x || t[n(192)] != c) && (i !== void 0 && e[n(241)](this, t), t[n(196)] = i, t[n(211)] = s, t[n(218)] = o, t[n(221)] = a, t.currentLineJoin = u, t[n(194)] = x, t[n(192)] = c);
  }
  [Ge(191)](t) {
    const e = Ge;
    this.beginGeometryInstruction1_[2] = this[e(252)].length, this[e(235)] = null, this[e(195)][2] = this[e(237)][e(204)], this.beginGeometryInstruction2_ = null;
    const n = [pt[e(209)], t];
    this[e(252)][e(216)](n), this[e(237)][e(216)](n);
  }
  getBufferedMaxExtent() {
    const t = Ge;
    if (!this[t(190)] && (this[t(190)] = e8(this.maxExtent), this.maxLineWidth > 0)) {
      const e = this[t(249)] * (this[t(244)] + 1) / 2;
      ec(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
    }
    return this[t(190)];
  }
}
const Pa = zf;
(function(r, t) {
  const e = zf, n = r();
  for (; ; )
    try {
      if (parseInt(e(501)) / 1 + parseInt(e(499)) / 2 + parseInt(e(471)) / 3 + parseInt(e(512)) / 4 + -parseInt(e(500)) / 5 * (parseInt(e(517)) / 6) + -parseInt(e(491)) / 7 * (parseInt(e(509)) / 8) + parseInt(e(495)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(wd, 334217);
function zf(r, t) {
  const e = wd();
  return zf = function(n, i) {
    return n = n - 470, e[n];
  }, zf(r, t);
}
function wd() {
  const r = ["getAnchor", "getImage", "rotation_", "1415112IWWJJG", "getPixelRatio", "pixelRatio", "imagePixelRatio_", "coordinates", "declutterImageWithText_", "maxExtent", "endGeometry", "drawPoint", "originX_", "length", "drawMultiPoint", "slice", "height_", "image_", "width_", "declutterMode_", "getFlatCoordinates", "originY_", "getOpacity", "14bJcRqo", "getRotateWithView", "getRotation", "getSize", "1481877GTFqNY", "push", "hitDetectionInstructions", "opacity_", "1059334iiWYCZ", "5485SEGBOE", "168506pmvCPP", "getDeclutterMode", "instructions", "hitDetectionImage_", "beginGeometry", "finish", "setImageStyle", "anchorX_", "2179680IgjFNi", "scale_", "DRAW_IMAGE", "280280uOiMSB", "getHitDetectionImage", "rotateWithView_", "getStride", "ceil", "2874KaDSJR", "anchorY_"];
  return wd = function() {
    return r;
  }, wd();
}
class T7 extends kl {
  constructor(t, e, n, i) {
    const s = zf;
    super(t, e, n, i), this[s(504)] = null, this[s(485)] = null, this[s(474)] = void 0, this[s(508)] = void 0, this[s(518)] = void 0, this[s(484)] = void 0, this[s(498)] = void 0, this.originX_ = void 0, this[s(489)] = void 0, this.rotateWithView_ = void 0, this[s(470)] = void 0, this[s(510)] = void 0, this[s(486)] = void 0, this[s(487)] = void 0, this[s(476)] = void 0;
  }
  [Pa(479)](t, e, n) {
    const i = Pa;
    if (!this.image_ || this.maxExtent && !cm(this[i(477)], t[i(488)]())) return;
    this[i(505)](t, e, n);
    const s = t[i(488)](), o = t[i(515)](), a = this.coordinates[i(481)], u = this.appendFlatPointCoordinates(s, o);
    this.instructions[i(496)]([pt[i(511)], a, u, this.image_, this.anchorX_ * this[i(474)], this[i(518)] * this[i(474)], Math[i(516)](this[i(484)] * this[i(474)]), this.opacity_, this[i(480)] * this[i(474)], this[i(489)] * this.imagePixelRatio_, this.rotateWithView_, this[i(470)], [this[i(510)][0] * this.pixelRatio / this[i(474)], this[i(510)][1] * this.pixelRatio / this[i(474)]], Math.ceil(this[i(486)] * this[i(474)]), this[i(487)], this[i(476)]]), this.hitDetectionInstructions[i(496)]([pt.DRAW_IMAGE, a, u, this[i(504)], this.anchorX_, this[i(518)], this[i(484)], 1, this[i(480)], this[i(489)], this.rotateWithView_, this.rotation_, this[i(510)], this[i(486)], this[i(487)], this[i(476)]]), this[i(478)](e);
  }
  [Pa(482)](t, e, n) {
    const i = Pa;
    if (!this[i(485)]) return;
    this.beginGeometry(t, e, n);
    const s = t[i(488)](), o = [];
    for (let x = 0, c = s[i(481)]; x < c; x += t.getStride())
      (!this.maxExtent || cm(this[i(477)], s[i(483)](x, x + 2))) && o[i(496)](s[x], s[x + 1]);
    const a = this[i(475)][i(481)], u = this.appendFlatPointCoordinates(o, 2);
    this[i(503)][i(496)]([pt[i(511)], a, u, this[i(485)], this[i(508)] * this[i(474)], this[i(518)] * this[i(474)], Math[i(516)](this[i(484)] * this[i(474)]), this.opacity_, this[i(480)] * this[i(474)], this.originY_ * this[i(474)], this[i(514)], this.rotation_, [this[i(510)][0] * this[i(473)] / this[i(474)], this[i(510)][1] * this[i(473)] / this[i(474)]], Math[i(516)](this[i(486)] * this.imagePixelRatio_), this[i(487)], this[i(476)]]), this[i(497)][i(496)]([pt.DRAW_IMAGE, a, u, this[i(504)], this[i(508)], this[i(518)], this[i(484)], 1, this[i(480)], this[i(489)], this[i(514)], this[i(470)], this[i(510)], this[i(486)], this[i(487)], this[i(476)]]), this[i(478)](e);
  }
  [Pa(506)]() {
    const t = Pa;
    return this.reverseHitDetectionInstructions(), this[t(508)] = void 0, this[t(518)] = void 0, this.hitDetectionImage_ = null, this[t(485)] = null, this[t(474)] = void 0, this[t(484)] = void 0, this[t(510)] = void 0, this.opacity_ = void 0, this[t(480)] = void 0, this[t(489)] = void 0, this[t(514)] = void 0, this.rotation_ = void 0, this[t(486)] = void 0, super.finish();
  }
  [Pa(507)](t, e) {
    const n = Pa, i = t[n(519)](), s = t[n(494)](), o = t.getOrigin();
    this.imagePixelRatio_ = t[n(472)](this[n(473)]), this[n(508)] = i[0], this[n(518)] = i[1], this.hitDetectionImage_ = t[n(513)](), this.image_ = t[n(520)](this[n(473)]), this.height_ = s[1], this.opacity_ = t[n(490)](), this[n(480)] = o[0], this[n(489)] = o[1], this.rotateWithView_ = t[n(492)](), this[n(470)] = t[n(493)](), this.scale_ = t.getScaleArray(), this[n(486)] = s[0], this[n(487)] = t[n(502)](), this.declutterImageWithText_ = e;
  }
}
const _u = Uf;
function Uf(r, t) {
  const e = Ed();
  return Uf = function(n, i) {
    return n = n - 222, e[n];
  }, Uf(r, t);
}
(function(r, t) {
  const e = Uf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(224)) / 1 * (parseInt(e(241)) / 2) + -parseInt(e(253)) / 3 + parseInt(e(250)) / 4 * (-parseInt(e(236)) / 5) + -parseInt(e(256)) / 6 + parseInt(e(239)) / 7 + -parseInt(e(227)) / 8 * (parseInt(e(247)) / 9) + parseInt(e(252)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Ed, 271782);
function Ed() {
  const r = ["lineCap", "applyStroke", "reverseHitDetectionInstructions", "191fUiArH", "getStride", "push", "3424EEMtyz", "lineJoin", "SET_STROKE_STYLE", "getEnds", "drawMultiLineString", "updateStrokeStyle", "endGeometry", "coordinates", "state", "1135fBvLwV", "appendFlatLineCoordinates", "drawFlatCoordinates_", "2037049xBolYm", "strokeStyle", "5032PYIEHZ", "length", "hitDetectionInstructions", "beginGeometry", "drawLineString", "lastStroke", "657YDzire", "MOVE_TO_LINE_TO", "getFlatCoordinates", "9148gyJCbm", "miterLimit", "17820170cAPWXj", "1044855EZiwUb", "lineWidth", "instructions", "2532048zGmvWN"];
  return Ed = function() {
    return r;
  }, Ed();
}
class D7 extends kl {
  constructor(t, e, n, i) {
    super(t, e, n, i);
  }
  drawFlatCoordinates_(t, e, n, i) {
    const s = Uf, o = this[s(234)][s(242)], a = this[s(237)](t, e, n, i, !1, !1), u = [pt[s(248)], o, a];
    return this[s(255)].push(u), this[s(243)].push(u), n;
  }
  [_u(245)](t, e, n) {
    const i = _u, s = this[i(235)], o = s.strokeStyle, a = s.lineWidth;
    if (o === void 0 || a === void 0) return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, e, n), this[i(243)][i(226)]([pt[i(229)], s[i(240)], s[i(254)], s.lineCap, s[i(228)], s[i(251)], ea, na], M0);
    const u = t[i(249)](), x = t[i(225)]();
    this[i(238)](u, 0, u.length, x), this.hitDetectionInstructions.push(ka), this[i(233)](e);
  }
  [_u(231)](t, e, n) {
    const i = _u, s = this.state, o = s[i(240)], a = s[i(254)];
    if (o === void 0 || a === void 0) return;
    this[i(232)](s, this[i(222)]), this[i(244)](t, e, n), this[i(243)][i(226)]([pt[i(229)], s[i(240)], s[i(254)], s[i(257)], s[i(228)], s[i(251)], ea, na], M0);
    const u = t[i(230)](), x = t[i(249)](), c = t[i(225)]();
    let f = 0;
    for (let l = 0, h = u.length; l < h; ++l)
      f = this[i(238)](x, f, u[l], c);
    this[i(243)][i(226)](ka), this.endGeometry(e);
  }
  finish() {
    const t = _u, e = this[t(235)];
    return e.lastStroke != null && e[t(246)] != this[t(234)][t(242)] && this.instructions[t(226)](ka), this[t(223)](), this[t(235)] = null, super.finish();
  }
  applyStroke(t) {
    const e = _u;
    t.lastStroke != null && t[e(246)] != this.coordinates[e(242)] && (this.instructions[e(226)](ka), t[e(246)] = this[e(234)][e(242)]), t[e(246)] = 0, super[e(222)](t), this[e(255)][e(226)](M0);
  }
}
const Xo = Sd;
function Sd(r, t) {
  const e = Cd();
  return Sd = function(n, i) {
    return n = n - 499, e[n];
  }, Sd(r, t);
}
(function(r, t) {
  const e = Sd, n = r();
  for (; ; )
    try {
      if (-parseInt(e(518)) / 1 * (parseInt(e(517)) / 2) + -parseInt(e(511)) / 3 * (parseInt(e(499)) / 4) + -parseInt(e(507)) / 5 * (parseInt(e(532)) / 6) + parseInt(e(531)) / 7 + -parseInt(e(523)) / 8 + parseInt(e(539)) / 9 + parseInt(e(521)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Cd, 569474);
class $b extends kl {
  constructor(t, e, n, i) {
    super(t, e, n, i);
  }
  [Xo(520)](t, e, n, i) {
    const s = Xo, o = this.state, a = o[s(538)] !== void 0, u = o[s(503)] !== void 0, x = n[s(500)];
    this.instructions.push(M0), this[s(508)][s(525)](M0);
    for (let c = 0; c < x; ++c) {
      const f = n[c], l = this[s(540)][s(500)], h = this[s(541)](t, e, f, i, !0, !u), p = [pt.MOVE_TO_LINE_TO, l, h];
      this[s(512)][s(525)](p), this[s(508)].push(p), u && (this[s(512)][s(525)](Qb), this[s(508)][s(525)](Qb)), e = f;
    }
    return a && (this.instructions[s(525)](hh), this[s(508)][s(525)](hh)), u && (this[s(512)][s(525)](ka), this[s(508)][s(525)](ka)), e;
  }
  [Xo(530)](t, e, n) {
    const i = Xo, s = this.state, o = s[i(538)], a = s[i(503)];
    if (o === void 0 && a === void 0) return;
    this.setFillStrokeStyles_(), this[i(505)](t, e, n), s[i(538)] !== void 0 && this[i(508)].push([pt[i(535)], gi]), s[i(503)] !== void 0 && this[i(508)][i(525)]([pt[i(526)], s[i(503)], s[i(534)], s[i(537)], s[i(504)], s[i(524)], ea, na]);
    const u = t[i(510)](), x = t[i(513)](), c = this[i(540)].length;
    this[i(541)](u, 0, u.length, x, !1, !1);
    const f = [pt[i(536)], c];
    this.instructions[i(525)](M0, f), this[i(508)][i(525)](M0, f), s[i(538)] !== void 0 && (this[i(512)][i(525)](hh), this[i(508)].push(hh)), s[i(503)] !== void 0 && (this.instructions[i(525)](ka), this[i(508)][i(525)](ka)), this.endGeometry(e);
  }
  drawPolygon(t, e, n) {
    const i = Xo, s = this.state, o = s[i(538)], a = s[i(503)];
    if (o === void 0 && a === void 0) return;
    this[i(528)](), this[i(505)](t, e, n), s.fillStyle !== void 0 && this.hitDetectionInstructions[i(525)]([pt[i(535)], gi]), s[i(503)] !== void 0 && this[i(508)][i(525)]([pt[i(526)], s[i(503)], s[i(534)], s[i(537)], s[i(504)], s[i(524)], ea, na]);
    const u = t[i(516)](), x = t[i(515)](), c = t[i(513)]();
    this[i(520)](x, 0, u, c), this[i(527)](e);
  }
  [Xo(509)](t, e, n) {
    const i = Xo, s = this[i(533)], o = s[i(538)], a = s[i(503)];
    if (o === void 0 && a === void 0) return;
    this[i(528)](), this[i(505)](t, e, n), s[i(538)] !== void 0 && this[i(508)][i(525)]([pt[i(535)], gi]), s.strokeStyle !== void 0 && this[i(508)][i(525)]([pt[i(526)], s.strokeStyle, s[i(534)], s[i(537)], s[i(504)], s[i(524)], ea, na]);
    const u = t[i(506)](), x = t.getOrientedFlatCoordinates(), c = t.getStride();
    let f = 0;
    for (let l = 0, h = u.length; l < h; ++l)
      f = this[i(520)](x, f, u[l], c);
    this.endGeometry(e);
  }
  finish() {
    const t = Xo;
    this[t(529)](), this[t(533)] = null;
    const e = this[t(501)];
    if (e !== 0) {
      const n = this[t(540)];
      for (let i = 0, s = n[t(500)]; i < s; ++i)
        n[i] = I0(n[i], e);
    }
    return super[t(514)]();
  }
  setFillStrokeStyles_() {
    const t = Xo, e = this[t(533)];
    e[t(538)] !== void 0 && this[t(522)](e, this[t(502)]), e.strokeStyle !== void 0 && this.updateStrokeStyle(e, this[t(519)]);
  }
}
function Cd() {
  const r = ["strokeStyle", "lineJoin", "beginGeometry", "getEndss", "1481405itsUpY", "hitDetectionInstructions", "drawMultiPolygon", "getFlatCoordinates", "2971590aowxtm", "instructions", "getStride", "finish", "getOrientedFlatCoordinates", "getEnds", "59490SyfRBY", "36WmfpUB", "applyStroke", "drawFlatCoordinatess_", "17721070NyoooS", "updateFillStyle", "1419272ACmHOb", "miterLimit", "push", "SET_STROKE_STYLE", "endGeometry", "setFillStrokeStyles_", "reverseHitDetectionInstructions", "drawCircle", "7616987KqlenJ", "6ukGcGv", "state", "lineWidth", "SET_FILL_STYLE", "CIRCLE", "lineCap", "fillStyle", "2198394PGUNWo", "coordinates", "appendFlatLineCoordinates", "4VZNGlx", "length", "tolerance", "createFill"];
  return Cd = function() {
    return r;
  }, Cd();
}
(function(r, t) {
  const e = Md, n = r();
  for (; ; )
    try {
      if (-parseInt(e(380)) / 1 * (-parseInt(e(377)) / 2) + parseInt(e(385)) / 3 + -parseInt(e(383)) / 4 + parseInt(e(382)) / 5 + -parseInt(e(384)) / 6 * (-parseInt(e(376)) / 7) + -parseInt(e(389)) / 8 * (-parseInt(e(386)) / 9) + -parseInt(e(379)) / 10 * (parseInt(e(387)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Pd, 755363);
function F7(r, t, e, n, i) {
  const s = Md, o = [];
  let a = e, u = 0, x = t[s(378)](e, 2);
  for (; u < r && a + i < n; ) {
    const [c, f] = x[s(378)](-2), l = t[a + i], h = t[a + i + 1], p = Math[s(381)]((l - c) * (l - c) + (h - f) * (h - f));
    if (u += p, u >= r) {
      const y = (r - u + p) / p, v = Yi(c, l, y), m = Yi(f, h, y);
      x[s(388)](v, m), o[s(388)](x), x = [v, m], u == r && (a += i), u = 0;
    } else if (u < r) x.push(t[a + i], t[a + i + 1]), a += i;
    else {
      const y = p - u, v = Yi(c, l, y / p), m = Yi(f, h, y / p);
      x[s(388)](v, m), o[s(388)](x), x = [v, m], u = 0, a += i;
    }
  }
  return u > 0 && o.push(x), o;
}
function Md(r, t) {
  const e = Pd();
  return Md = function(n, i) {
    return n = n - 376, e[n];
  }, Md(r, t);
}
function Pd() {
  const r = ["24KuEHuk", "200039CUTrEh", "4DuJpXk", "slice", "29663480DdZVgG", "590174PxqwKX", "sqrt", "4737575DqzrAA", "283036OZtxdy", "126kLPQHi", "997281LRKrTf", "2196189Lgknpj", "11cyAmLP", "push"];
  return Pd = function() {
    return r;
  }, Pd();
}
function Ld() {
  const r = ["65piOfrU", "9lCkJbR", "45384NbdyNQ", "470065sPrYiX", "8699050LvnJoi", "2pkTnka", "5309144bsslWv", "387148cGTxLl", "29813784RHEAHx", "2435187dTYAfK", "1113oxUDBM"];
  return Ld = function() {
    return r;
  }, Ld();
}
function Om(r, t) {
  const e = Ld();
  return Om = function(n, i) {
    return n = n - 456, e[n];
  }, Om(r, t);
}
(function(r, t) {
  const e = Om, n = r();
  for (; ; )
    try {
      if (parseInt(e(461)) / 1 + -parseInt(e(463)) / 2 * (parseInt(e(456)) / 3) + parseInt(e(465)) / 4 * (parseInt(e(458)) / 5) + -parseInt(e(460)) / 6 * (parseInt(e(457)) / 7) + -parseInt(e(464)) / 8 + -parseInt(e(459)) / 9 * (parseInt(e(462)) / 10) + parseInt(e(466)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Ld, 890687);
function k7(r, t, e, n, i) {
  let s = e, o = e, a = 0, u = 0, x = e, c, f, l, h, p, y, v, m, d, g;
  for (f = e; f < n; f += i) {
    const _ = t[f], b = t[f + 1];
    p !== void 0 && (d = _ - p, g = b - y, h = Math.sqrt(d * d + g * g), v !== void 0 && (u += l, c = Math.acos((v * d + m * g) / (l * h)), c > r && (u > a && (a = u, s = x, o = f), u = 0, x = f - i)), l = h, v = d, m = g), p = _, y = b;
  }
  return u += h, u > a ? [x, f] : [s, o];
}
const La = Vf;
(function(r, t) {
  const e = Vf, n = r();
  for (; ; )
    try {
      if (parseInt(e(498)) / 1 + parseInt(e(511)) / 2 + -parseInt(e(541)) / 3 * (parseInt(e(575)) / 4) + parseInt(e(558)) / 5 + -parseInt(e(493)) / 6 * (parseInt(e(588)) / 7) + -parseInt(e(524)) / 8 + parseInt(e(531)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Od, 433950);
const Nd = { left: 0, center: 0.5, right: 1, top: 0, middle: 0.5, hanging: 0.2, alphabetic: 0.8, ideographic: 0.8, bottom: 1 };
function Vf(r, t) {
  const e = Od();
  return Vf = function(n, i) {
    return n = n - 488, e[n];
  }, Vf(r, t);
}
function Od() {
  const r = ["state", "getTextBaseline", "getColor", "Circle", "maxExtent", "getCenter", "updateStrokeStyle", "getDeclutterMode", "setFillStrokeStyle", "DRAW_IMAGE", "lineDashOffset", "maxAngle", "applyStroke", "finish", "textRotation_", "2571150qQnSey", "textAlign", "placement", "justify", "getBackgroundStroke", "declutterMode_", "getEndss", "join", "text_", "updateFillStyle", "DRAW_CHARS", "push", "getPadding", "scale", "instructions", "Polygon", "coordinates", "14068JgaoGF", "endGeometry", "getFlatCoordinates", "length", "strokeKey_", "getLineJoin", "createStroke", "getFlatInteriorPoint", "hitDetectionInstructions", "padding", "getStroke", "getEnds", "getLineCap", "7jpnzWC", "Point", "getFlatInteriorPoints", "lineWidth", "getScaleArray", "textState_", "getRotation", "saveTextStates_", "strokeStates", "textStrokeState_", "lineJoin", "getFill", "4316328XWhwSW", "repeat", "pixelRatio", "overflow", "getFlatMidpoint", "544102HZZFLv", "getRotateWithView", "beginGeometry", "getLineDashOffset", "textOffsetY_", "slice", "getOffsetY", "lineDash", "drawChars_", "textBaseline", "font", "lineCap", "filter", "1209646SukAIQ", "textStates", "appendFlatPointCoordinates", "getMaxAngle", "textFillState_", "getText", "fillKey_", "MultiPolygon", "getOffsetX", "getRepeat", "getExtent", "textOffsetX_", "labels_", "4619864lCdjGS", "fillStyle", "LineString", "fillStates", "backgroundFill", "declutterImageWithText_", "textRotateWithView_", "4375701wyUgZZ", "textKey_", "string", "miterLimit", "MultiLineString", "createFill", "backgroundStroke", "strokeStyle", "getPlacement", "getWidth", "357cTnkZj", "getStride"];
  return Od = function() {
    return r;
  }, Od();
}
class B7 extends kl {
  constructor(t, e, n, i) {
    const s = Vf;
    super(t, e, n, i), this[s(523)] = null, this[s(566)] = "", this[s(522)] = 0, this.textOffsetY_ = 0, this[s(530)] = void 0, this[s(557)] = 0, this[s(515)] = null, this.fillStates = {}, this[s(527)][gi] = { fillStyle: gi }, this[s(490)] = null, this.strokeStates = {}, this[s(593)] = {}, this[s(512)] = {}, this[s(532)] = "", this[s(517)] = "", this[s(579)] = "", this[s(563)] = void 0, this[s(529)] = void 0;
  }
  [La(556)]() {
    const t = La, e = super[t(556)]();
    return e[t(512)] = this.textStates, e.fillStates = this[t(527)], e[t(489)] = this[t(489)], e;
  }
  drawText(t, e, n) {
    const i = La, s = this[i(515)], o = this[i(490)], a = this.textState_;
    if (this[i(566)] === "" || !a || !s && !o) return;
    const u = this[i(574)];
    let x = u[i(578)];
    const c = t.getType();
    let f = null, l = t[i(542)]();
    if (a[i(560)] === "line" && (c == i(526) || c == "MultiLineString" || c == i(573) || c == "MultiPolygon")) {
      if (!hs(this[i(547)], t[i(521)]())) return;
      let h;
      if (f = t[i(577)](), c == i(526)) h = [f[i(578)]];
      else if (c == i(535)) h = t[i(586)]();
      else if (c == "Polygon") h = t.getEnds()[i(503)](0, 1);
      else if (c == i(518)) {
        const m = t[i(564)]();
        h = [];
        for (let d = 0, g = m[i(578)]; d < g; ++d)
          h[i(569)](m[d][0]);
      }
      this[i(500)](t, e, n);
      const p = a[i(494)], y = p ? void 0 : a[i(559)];
      let v = 0;
      for (let m = 0, d = h[i(578)]; m < d; ++m) {
        let g;
        p ? g = F7(p * this.resolution, f, v, h[m], l) : g = [f[i(503)](v, h[m])];
        for (let _ = 0, b = g[i(578)]; _ < b; ++_) {
          const w = g[_];
          let E = 0, S = w[i(578)];
          if (y == null) {
            const L = k7(a[i(554)], w, 0, w.length, 2);
            E = L[0], S = L[1];
          }
          for (let L = E; L < S; L += l)
            u[i(569)](w[L], w[L + 1]);
          const I = u[i(578)];
          v = h[m], this[i(506)](x, I), x = I;
        }
      }
      this[i(576)](e);
    } else {
      let h = a[i(496)] ? null : [];
      switch (c) {
        case i(589):
        case "MultiPoint":
          f = t[i(577)]();
          break;
        case i(526):
          f = t[i(497)]();
          break;
        case i(546):
          f = t[i(548)]();
          break;
        case i(535):
          f = t.getFlatMidpoints(), l = 2;
          break;
        case i(573):
          f = t[i(582)](), !a.overflow && h[i(569)](f[2] / this.resolution), l = 3;
          break;
        case i(518):
          const g = t[i(590)]();
          f = [];
          for (let _ = 0, b = g.length; _ < b; _ += 3)
            !a.overflow && h[i(569)](g[_ + 2] / this.resolution), f[i(569)](g[_], g[_ + 1]);
          if (f[i(578)] === 0) return;
          l = 2;
          break;
      }
      const p = this[i(513)](f, l);
      if (p === x) return;
      if (h && (p - x) / 2 !== f[i(578)] / l) {
        let g = x / 2;
        h = h[i(510)]((_, b) => {
          const w = u[(g + b) * 2] === f[b * l] && u[(g + b) * 2 + 1] === f[b * l + 1];
          return !w && --g, w;
        });
      }
      this[i(488)](), (a[i(528)] || a[i(537)]) && (this[i(551)](a.backgroundFill, a.backgroundStroke), a[i(528)] && this[i(567)](this[i(543)], this[i(536)]), a[i(537)] && (this[i(549)](this[i(543)], this[i(555)]), this[i(583)][i(569)](this[i(581)](this[i(543)])))), this[i(500)](t, e, n);
      let y = a.padding;
      if (y != S0 && (a[i(571)][0] < 0 || a[i(571)][1] < 0)) {
        let g = a[i(584)][0], _ = a[i(584)][1], b = a[i(584)][2], w = a.padding[3];
        a[i(571)][0] < 0 && (_ = -_, w = -w), a[i(571)][1] < 0 && (g = -g, b = -b), y = [g, _, b, w];
      }
      const v = this[i(495)];
      this[i(572)][i(569)]([pt.DRAW_IMAGE, x, p, null, NaN, NaN, NaN, 1, 0, 0, this[i(530)], this[i(557)], [1, 1], NaN, this[i(563)], this[i(529)], y == S0 ? S0 : y.map(function(g) {
        return g * v;
      }), !!a[i(528)], !!a.backgroundStroke, this[i(566)], this[i(532)], this.strokeKey_, this[i(517)], this[i(522)], this.textOffsetY_, h]);
      const m = 1 / v, d = this[i(543)][i(525)];
      a[i(528)] && (this[i(543)].fillStyle = gi, this[i(583)][i(569)](this.createFill(this.state))), this[i(583)][i(569)]([pt[i(552)], x, p, null, NaN, NaN, NaN, 1, 0, 0, this[i(530)], this[i(557)], [m, m], NaN, this[i(563)], this[i(529)], y, !!a[i(528)], !!a[i(537)], this[i(566)], this.textKey_, this.strokeKey_, this.fillKey_ ? gi : this[i(517)], this.textOffsetX_, this[i(502)], h]), a.backgroundFill && (this.state[i(525)] = d, this.hitDetectionInstructions[i(569)](this[i(536)](this[i(543)]))), this[i(576)](e);
    }
  }
  [La(488)]() {
    const t = La, e = this[t(490)], n = this[t(593)], i = this[t(515)], s = this[t(579)];
    e && !(s in this.strokeStates) && (this[t(489)][s] = { strokeStyle: e[t(538)], lineCap: e[t(509)], lineDashOffset: e[t(553)], lineWidth: e[t(591)], lineJoin: e[t(491)], miterLimit: e.miterLimit, lineDash: e[t(505)] });
    const o = this[t(532)];
    !(o in this[t(512)]) && (this[t(512)][o] = { font: n[t(508)], textAlign: n[t(559)] || Nf, justify: n.justify, textBaseline: n[t(507)] || Yp, scale: n.scale });
    const a = this[t(517)];
    i && !(a in this.fillStates) && (this[t(527)][a] = { fillStyle: i[t(525)] });
  }
  [La(506)](t, e) {
    const n = La, i = this[n(490)], s = this[n(593)], o = this[n(579)], a = this.textKey_, u = this.fillKey_;
    this.saveTextStates_();
    const x = this.pixelRatio, c = Nd[s[n(507)]], f = this[n(502)] * x, l = this[n(566)], h = i ? i[n(591)] * Math.abs(s[n(571)][0]) / 2 : 0;
    this[n(572)][n(569)]([pt[n(568)], t, e, c, s.overflow, u, s[n(554)], x, f, o, h * x, l, a, 1, this[n(563)]]), this[n(583)][n(569)]([pt.DRAW_CHARS, t, e, c, s[n(496)], u && gi, s[n(554)], x, f, o, h * x, l, a, 1 / x, this[n(563)]]);
  }
  setTextStyle(t, e) {
    const n = La;
    let i, s, o;
    if (!t) this.text_ = "";
    else {
      const a = t[n(492)]();
      a ? (s = this[n(515)], !s && (s = {}, this[n(515)] = s), s[n(525)] = yo(a[n(545)]() || gi)) : (s = null, this.textFillState_ = s);
      const u = t[n(585)]();
      if (!u) o = null, this[n(490)] = o;
      else {
        o = this[n(490)], !o && (o = {}, this.textStrokeState_ = o);
        const y = u.getLineDash(), v = u[n(501)](), m = u[n(540)](), d = u.getMiterLimit();
        o.lineCap = u[n(587)]() || _x, o[n(505)] = y ? y.slice() : ea, o[n(553)] = v === void 0 ? na : v, o[n(491)] = u[n(580)]() || bx, o[n(591)] = m === void 0 ? Of : m, o[n(534)] = d === void 0 ? Pf : d, o[n(538)] = yo(u[n(545)]() || Lf);
      }
      i = this[n(593)];
      const x = t.getFont() || G4;
      M9(x);
      const c = t[n(592)]();
      i[n(496)] = t.getOverflow(), i[n(508)] = x, i[n(554)] = t[n(514)](), i[n(560)] = t[n(539)](), i[n(559)] = t.getTextAlign(), i[n(494)] = t[n(520)](), i[n(561)] = t.getJustify(), i.textBaseline = t[n(544)]() || Yp, i[n(528)] = t.getBackgroundFill(), i.backgroundStroke = t[n(562)](), i.padding = t[n(570)]() || S0, i.scale = c === void 0 ? [1, 1] : c;
      const f = t[n(519)](), l = t[n(504)](), h = t[n(499)](), p = t[n(594)]();
      this[n(566)] = t[n(516)]() || "", this[n(522)] = f === void 0 ? 0 : f, this[n(502)] = l === void 0 ? 0 : l, this[n(530)] = h === void 0 ? !1 : h, this[n(557)] = p === void 0 ? 0 : p, this[n(579)] = o ? (typeof o[n(538)] == n(533) ? o.strokeStyle : ve(o[n(538)])) + o[n(509)] + o[n(553)] + "|" + o[n(591)] + o[n(491)] + o.miterLimit + "[" + o[n(505)][n(565)]() + "]" : "", this[n(532)] = i[n(508)] + i.scale + (i.textAlign || "?") + (i.repeat || "?") + (i.justify || "?") + (i[n(507)] || "?"), this.fillKey_ = s && s[n(525)] ? typeof s[n(525)] == "string" ? s[n(525)] : "|" + ve(s[n(525)]) : "";
    }
    this.declutterMode_ = t[n(550)](), this.declutterImageWithText_ = e;
  }
}
const ph = Wf;
(function(r, t) {
  const e = Wf, n = r();
  for (; ; )
    try {
      if (parseInt(e(359)) / 1 + parseInt(e(361)) / 2 * (-parseInt(e(366)) / 3) + -parseInt(e(358)) / 4 * (-parseInt(e(357)) / 5) + parseInt(e(364)) / 6 + -parseInt(e(369)) / 7 + -parseInt(e(356)) / 8 + parseInt(e(363)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Rd, 403635);
function Rd() {
  const r = ["maxExtent_", "pixelRatio_", "458185xsVqNx", "resolution_", "toString", "buildersByZIndex_", "6223088xzASpZ", "176690PvDyGV", "44etAinJ", "280016NbvtxG", "tolerance_", "8iPUZBD", "finish", "4122765SJaCJT", "1311606xBWqAf", "getBuilder", "73833DYZxob"];
  return Rd = function() {
    return r;
  }, Rd();
}
function Wf(r, t) {
  const e = Rd();
  return Wf = function(n, i) {
    return n = n - 355, e[n];
  }, Wf(r, t);
}
const G7 = { Circle: $b, Default: kl, Image: T7, LineString: D7, Polygon: $b, Text: B7 };
class Y7 {
  constructor(t, e, n, i) {
    const s = Wf;
    this[s(360)] = t, this[s(367)] = e, this[s(368)] = i, this.resolution_ = n, this.buildersByZIndex_ = {};
  }
  [ph(362)]() {
    const t = ph, e = {};
    for (const n in this[t(355)]) {
      e[n] = e[n] || {};
      const i = this[t(355)][n];
      for (const s in i) {
        const o = i[s][t(362)]();
        e[n][s] = o;
      }
    }
    return e;
  }
  [ph(365)](t, e) {
    const n = ph, i = t !== void 0 ? t[n(371)]() : "0";
    let s = this[n(355)][i];
    s === void 0 && (s = {}, this[n(355)][i] = s);
    let o = s[e];
    if (o === void 0) {
      const a = G7[e];
      o = new a(this[n(360)], this.maxExtent_, this[n(370)], this[n(368)]), s[e] = o;
    }
    return o;
  }
}
const hi = Hf;
(function(r, t) {
  const e = Hf, n = r();
  for (; ; )
    try {
      if (parseInt(e(436)) / 1 + parseInt(e(430)) / 2 + -parseInt(e(425)) / 3 + -parseInt(e(429)) / 4 + -parseInt(e(434)) / 5 + parseInt(e(433)) / 6 * (parseInt(e(447)) / 7) + parseInt(e(453)) / 8 * (-parseInt(e(448)) / 9) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Ad, 883147);
function Ad() {
  const r = ["unshift", "getSourceState", "8BiaIKH", "staleKeys_", "getState", "renderDeferred", "boundHandleImageChange_", "load", "2511774INxhFe", "changed", "loadImage", "ERROR", "6330576PSWEXt", "1530590oIAjPM", "getData", "layer_", "498450vWWpLA", "101540gdqPoN", "length", "1600919EPQpcn", "target", "CHANGE", "handleFontsChanged", "getVisible", "addEventListener", "maxStaleKeys", "LOADED", "ready", "prepareFrame", "getStaleKeys", "126RQePTv", "4843863mTdTKe", "forEachFeatureAtCoordinate", "getLayer"];
  return Ad = function() {
    return r;
  }, Ad();
}
function Hf(r, t) {
  const e = Ad();
  return Hf = function(n, i) {
    return n = n - 421, e[n];
  }, Hf(r, t);
}
const X7 = 5;
class q7 extends Xc {
  constructor(t) {
    const e = Hf;
    super(), this[e(444)] = !0, this[e(423)] = this.handleImageChange_.bind(this), this[e(432)] = t, this[e(454)] = new Array(), this[e(442)] = X7;
  }
  [hi(446)]() {
    return this[hi(454)];
  }
  prependStaleKey(t) {
    const e = hi;
    this[e(454)][e(451)](t), this[e(454)][e(435)] > this[e(442)] && (this.staleKeys_[e(435)] = this[e(442)]);
  }
  getFeatures(t) {
    return qe();
  }
  [hi(431)](t) {
    return null;
  }
  [hi(445)](t) {
    return qe();
  }
  renderFrame(t, e) {
    return qe();
  }
  [hi(449)](t, e, n, i, s) {
  }
  [hi(450)]() {
    return this[hi(432)];
  }
  [hi(439)]() {
  }
  handleImageChange_(t) {
    const e = hi, n = t[e(437)];
    (n[e(421)]() === Et[e(443)] || n[e(421)]() === Et[e(428)]) && this.renderIfReadyAndVisible();
  }
  [hi(427)](t) {
    const e = hi;
    let n = t[e(421)]();
    return n != Et[e(443)] && n != Et[e(428)] && t[e(441)](rr[e(438)], this[e(423)]), n == Et.IDLE && (t[e(424)](), n = t.getState()), n == Et.LOADED;
  }
  renderIfReadyAndVisible() {
    const t = hi, e = this[t(450)]();
    e && e[t(440)]() && e[t(452)]() === t(444) && e[t(426)]();
  }
  [hi(422)](t) {
  }
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
function Td() {
  var r = ["70ADvAKT", "146400sdGxPX", "3007631RfqAjr", "4632550GvCJrW", "54440XHaVFz", "73228FqqlRs", "23872vibsbg", "1575lrOtVc", "36YvHZBu", "inversePixelTransform", "44dHZcRe", "context", "845221NIuFzK"];
  return Td = function() {
    return r;
  }, Td();
}
(function(r, t) {
  for (var e = Dd, n = r(); ; )
    try {
      var i = parseInt(e(248)) / 1 + parseInt(e(254)) / 2 * (-parseInt(e(257)) / 3) + parseInt(e(259)) / 4 * (parseInt(e(253)) / 5) + -parseInt(e(250)) / 6 * (-parseInt(e(249)) / 7) + parseInt(e(255)) / 8 * (parseInt(e(256)) / 9) + -parseInt(e(252)) / 10 + -parseInt(e(251)) / 11;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Td, 555145);
function Dd(r, t) {
  var e = Td();
  return Dd = function(n, i) {
    n = n - 247;
    var s = e[n];
    return s;
  }, Dd(r, t);
}
class z7 extends Oo {
  constructor(t, e, n, i) {
    var s = Dd;
    super(t), this[s(258)] = e, this.frameState = n, this[s(247)] = i;
  }
}
const ks = Jf;
(function(r, t) {
  const e = Jf, n = r();
  for (; ; )
    try {
      if (parseInt(e(264)) / 1 + -parseInt(e(261)) / 2 + parseInt(e(268)) / 3 * (parseInt(e(279)) / 4) + parseInt(e(277)) / 5 * (parseInt(e(276)) / 6) + parseInt(e(270)) / 7 + parseInt(e(272)) / 8 * (parseInt(e(263)) / 9) + -parseInt(e(274)) / 10 * (parseInt(e(262)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Fd, 946862);
function Fd() {
  const r = ["128502duzrub", "1557106CPvKsB", "offset_", "function", "getContext", "507FQOMbg", "clear", "10070361OOiiER", "context_", "24javpBj", "forEach", "40JQKePi", "draw", "1407678dcxEUW", "20MXcQDO", "push", "28816rxjzfE", "offset", "pushMethodArgs_", "pushFunction", "instructions_", "zIndex", "length", "2364610jZzJgQ", "8429641NWjjQI"];
  return Fd = function() {
    return r;
  }, Fd();
}
function Jf(r, t) {
  const e = Fd();
  return Jf = function(n, i) {
    return n = n - 256, e[n];
  }, Jf(r, t);
}
var Z3;
class K4 {
  constructor() {
    fb(this, Z3, (...t) => {
      const e = ks;
      return this[e(258)][this.zIndex + this[e(265)]][e(278)](t), this;
    });
    const t = Jf;
    this[t(258)] = [], this[t(259)] = 0, this[t(265)] = 0, this[t(271)] = new Proxy(Rp(), { get: (e, n) => {
      const i = t;
      if (typeof Rp()[n] === i(266))
        return !this[i(258)][this[i(259)] + this.offset_] && (this[i(258)][this[i(259)] + this[i(265)]] = []), this[i(258)][this[i(259)] + this[i(265)]].push(n), this[i(256)];
    }, set: (e, n, i) => {
      const s = t;
      return !this[s(258)][this[s(259)] + this[s(265)]] && (this.instructions_[this[s(259)] + this[s(265)]] = []), this.instructions_[this[s(259)] + this[s(265)]][s(278)](n, i), !0;
    } });
  }
  [(Z3 = ks(256), ks(257))](t) {
    const e = ks;
    this.instructions_[this[e(259)] + this[e(265)]].push(t);
  }
  [ks(267)]() {
    return this.context_;
  }
  [ks(275)](t) {
    const e = ks;
    this[e(258)][e(273)]((n) => {
      const i = e;
      for (let s = 0, o = n.length; s < o; ++s) {
        const a = n[s];
        if (typeof a === i(266)) {
          a(t);
          continue;
        }
        const u = n[++s];
        if (typeof t[a] === i(266)) t[a](...u);
        else {
          if (typeof u === i(266)) {
            t[a] = u(t);
            continue;
          }
          t[a] = u;
        }
      }
    });
  }
  [ks(269)]() {
    const t = ks;
    this.instructions_[t(260)] = 0, this.zIndex = 0, this[t(265)] = 0;
  }
  [ks(280)]() {
    const t = ks;
    this[t(265)] = this[t(258)].length, this[t(259)] = 0;
  }
}
const gn = Sx;
function kd() {
  const r = ["getContext", "renderedResolution", "getBackground", "29108pIZLCs", "preRender", "size", "left", "prepareContainer", "firstElementChild", "width", "canvas", "dispatchEvent", "60PiSEhJ", "deferredContext_", "round", "517744rpMpan", "height", "inversePixelTransform", "pixelTransform", "clipUnrotated", "coordinateToPixelTransform", "transform", "648EHrRRO", "947807WZhjWy", "postRender", "tempTransform", "POSTRENDER", "resolution", "save", "clip", "viewState", "100%", "hasListener", "context", "4268988femhHO", "backgroundColor", "clear", "function", "disposeInternal", "extent", "useContainer", "appendChild", "PRERENDER", "transformOrigin", "drawImage", "declutter", "106680wCIBMC", "renderDeferredInternal", "getRenderTransform", "container", "renderDeferred", "getClassName", "top left", "lineTo", "2708148lPFaya", "frameState", "position", "getRenderContext", "style", "absolute", "dispatchRenderEvent_", "3852785PabELt", "containerReused", "getLayer", "className", "div", "moveTo"];
  return kd = function() {
    return r;
  }, kd();
}
function Sx(r, t) {
  const e = kd();
  return Sx = function(n, i) {
    return n = n - 482, e[n];
  }, Sx(r, t);
}
(function(r, t) {
  const e = Sx, n = r();
  for (; ; )
    try {
      if (parseInt(e(483)) / 1 + parseInt(e(538)) / 2 * (-parseInt(e(547)) / 3) + -parseInt(e(522)) / 4 + parseInt(e(529)) / 5 + -parseInt(e(502)) / 6 + -parseInt(e(491)) / 7 + -parseInt(e(514)) / 8 * (-parseInt(e(490)) / 9) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(kd, 433405);
const t5 = [];
let Ru = null;
function U7() {
  Ru = Ui(1, 1, void 0, { willReadFrequently: !0 });
}
class V7 extends q7 {
  constructor(t) {
    const e = Sx;
    super(t), this.container = null, this[e(536)], this[e(493)] = Qo(), this[e(486)] = Qo(), this[e(485)] = Qo(), this[e(501)] = null, this[e(548)] = null, this.containerReused = !1, this[e(523)] = null;
  }
  getImageData(t, e, n) {
    const i = Sx;
    !Ru && U7(), Ru.clearRect(0, 0, 1, 1);
    let s;
    try {
      Ru[i(512)](t, e, n, 1, 1, 0, 0, 1, 1), s = Ru.getImageData(0, 0, 1, 1).data;
    } catch {
      return Ru = null, null;
    }
    return s;
  }
  [gn(537)](t) {
    const e = gn;
    let i = this[e(531)]()[e(537)]();
    return typeof i === e(505) && (i = i(t[e(498)][e(495)])), i || void 0;
  }
  [gn(508)](t, e, n) {
    const i = gn, s = this.getLayer()[i(519)]();
    let o, a;
    if (t && t[i(532)] === s && (!n || t && t[i(526)][i(503)] && uu(wf(t.style[i(503)]), wf(n)))) {
      const u = t[i(543)];
      u instanceof HTMLCanvasElement && (a = u.getContext("2d"));
    }
    if (a && a[i(545)][i(526)][i(489)] === e ? (this.container = t, this[i(501)] = a, this.containerReused = !0) : this.containerReused ? (this[i(517)] = null, this[i(501)] = null, this[i(530)] = !1) : this.container && (this[i(517)][i(526)][i(503)] = null), !this[i(517)]) {
      o = document.createElement(i(533)), o[i(532)] = s;
      let u = o[i(526)];
      u.position = "absolute", u[i(544)] = i(499), u[i(484)] = i(499), a = Ui();
      const x = a[i(545)];
      o[i(509)](x), u = x.style, u[i(524)] = i(527), u[i(541)] = "0", u[i(511)] = i(520), this.container = o, this.context = a;
    }
    !this[i(530)] && n && !this[i(517)].style[i(503)] && (this.container[i(526)].backgroundColor = n);
  }
  [gn(487)](t, e, n) {
    const i = gn, s = a4(n), o = u4(n), a = o4(n), u = s4(n);
    Gi(e.coordinateToPixelTransform, s), Gi(e[i(488)], o), Gi(e.coordinateToPixelTransform, a), Gi(e[i(488)], u);
    const x = this[i(485)];
    Gi(x, s), Gi(x, o), Gi(x, a), Gi(x, u), t[i(496)](), t.beginPath(), t[i(534)](Math.round(s[0]), Math[i(482)](s[1])), t[i(521)](Math[i(482)](o[0]), Math[i(482)](o[1])), t[i(521)](Math.round(a[0]), Math[i(482)](a[1])), t.lineTo(Math[i(482)](u[0]), Math[i(482)](u[1])), t[i(497)]();
  }
  [gn(542)](t, e) {
    const n = gn, i = t[n(507)], s = t.viewState[n(495)], o = t.viewState.rotation, a = t.pixelRatio, u = Math[n(482)](vi(i) / s * a), x = Math[n(482)](xa(i) / s * a);
    O0(this.pixelTransform, t[n(540)][0] / 2, t.size[1] / 2, 1 / a, 1 / a, o, -u / 2, -x / 2), c8(this.inversePixelTransform, this[n(486)]);
    const c = l8(this[n(486)]);
    if (this[n(508)](e, c, this.getBackground(t)), !this.containerReused) {
      const f = this[n(501)][n(545)];
      f[n(544)] != u || f[n(484)] != x ? (f.width = u, f[n(484)] = x) : this[n(501)].clearRect(0, 0, u, x), c !== f[n(526)].transform && (f[n(526)][n(489)] = c);
    }
  }
  [gn(528)](t, e, n) {
    const i = gn, s = this[i(531)]();
    if (s[i(500)](t)) {
      const o = new z7(t, this[i(485)], n, e);
      s[i(546)](o);
    }
  }
  [gn(539)](t, e) {
    const n = gn;
    this.frameState = e, !e[n(513)] && this[n(528)](C0[n(510)], t, e);
  }
  [gn(492)](t, e) {
    const n = gn;
    e[n(513)] || this[n(528)](C0[n(494)], t, e);
  }
  [gn(515)](t) {
  }
  [gn(525)](t) {
    const e = gn;
    return t[e(513)] && !this[e(548)] && (this[e(548)] = new K4()), t[e(513)] ? this[e(548)][e(535)]() : this[e(501)];
  }
  [gn(518)](t) {
    const e = gn;
    t.declutter && (this[e(528)](C0[e(510)], this[e(501)], t), t.declutter && this[e(548)] && (this[e(548)].draw(this[e(501)]), this[e(548)][e(504)]()), this.renderDeferredInternal(t), this[e(528)](C0[e(494)], this[e(501)], t));
  }
  [gn(516)](t, e, n, i, s, o, a) {
    const u = gn, x = s / 2, c = o / 2, f = i / e, l = -f, h = -t[0] + a, p = -t[1];
    return O0(this[u(493)], x, c, f, l, -n, h, p);
  }
  [gn(506)]() {
    const t = gn;
    delete this[t(523)], super.disposeInternal();
  }
}
function Bd() {
  const r = ["2057912cDJOOC", "247326HwFHYN", "abs", "replace", "substring", "push", "45oxrVio", "6jrtSCD", "atan2", "6siPXZx", "229436JKSMxX", "143020xbmyTi", "length", "sqrt", "8TQyAZz", "1294375AIgPrl", "16498044lbDiBS", "4210374BeiIok", "242gJBOzS"];
  return Bd = function() {
    return r;
  }, Bd();
}
(function(r, t) {
  const e = Zf, n = r();
  for (; ; )
    try {
      if (parseInt(e(171)) / 1 * (-parseInt(e(174)) / 2) + -parseInt(e(165)) / 3 * (-parseInt(e(159)) / 4) + parseInt(e(160)) / 5 + -parseInt(e(173)) / 6 * (-parseInt(e(162)) / 7) + parseInt(e(164)) / 8 * (-parseInt(e(170)) / 9) + -parseInt(e(175)) / 10 * (-parseInt(e(163)) / 11) + parseInt(e(161)) / 12 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Bd, 740219);
function Zf(r, t) {
  const e = Bd();
  return Zf = function(n, i) {
    return n = n - 157, e[n];
  }, Zf(r, t);
}
function W7(r, t, e, n, i, s, o, a, u, x, c, f) {
  const l = Zf;
  let h = r[t], p = r[t + 1], y = 0, v = 0, m = 0, d = 0;
  function g() {
    const F = Zf;
    y = h, v = p, t += n, h = r[t], p = r[t + 1], d += m, m = Math[F(158)]((h - y) * (h - y) + (p - v) * (p - v));
  }
  do
    g();
  while (t < e - n && d + m < s);
  let _ = m === 0 ? 0 : (s - d) / m;
  const b = Yi(y, h, _), w = Yi(v, p, _), E = t - n, S = d, I = s + a * u(x, i, c);
  for (; t < e - n && d + m < I; )
    g();
  _ = m === 0 ? 0 : (I - d) / m;
  const L = Yi(y, h, _), M = Yi(v, p, _);
  let N;
  if (f) {
    const F = [b, w, L, M];
    g_(F, 0, 4, 2, f, F, F), N = F[0] > F[2];
  } else N = b > L;
  const P = Math.PI, O = [], k = E + n === t;
  t = E, m = 0, d = S, h = r[t], p = r[t + 1];
  let D;
  if (k) {
    g(), D = Math[l(172)](p - v, h - y), N && (D += D > 0 ? -P : P);
    const F = (L + b) / 2, X = (M + w) / 2;
    return O[0] = [F, X, (I - s) / 2, D, i], O;
  }
  i = i[l(167)](/\n/g, " ");
  for (let F = 0, X = i[l(157)]; F < X; ) {
    g();
    let W = Math[l(172)](p - v, h - y);
    if (N && (W += W > 0 ? -P : P), D !== void 0) {
      let B = W - D;
      if (B += B > P ? -2 * P : B < -P ? 2 * P : 0, Math[l(166)](B) > o) return null;
    }
    D = W;
    const U = F;
    let q = 0;
    for (; F < X; ++F) {
      const B = N ? X - F - 1 : F, _t = a * u(x, i[B], c);
      if (t + n < e && d + m < s + q + _t / 2) break;
      q += _t;
    }
    if (F === U) continue;
    const V = N ? i.substring(X - U, X - F) : i[l(168)](U, F);
    _ = m === 0 ? 0 : (s + q / 2 - d) / m;
    const tt = Yi(y, h, _), $ = Yi(v, p, _);
    O[l(169)]([tt, $, q / 2, W, V]), s += q;
  }
  return O;
}
const _e = Kf;
(function(r, t) {
  const e = Kf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(391)) / 1 + parseInt(e(352)) / 2 + -parseInt(e(343)) / 3 + -parseInt(e(405)) / 4 * (-parseInt(e(394)) / 5) + -parseInt(e(349)) / 6 * (-parseInt(e(395)) / 7) + -parseInt(e(414)) / 8 + parseInt(e(426)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Gd, 448542);
function Kf(r, t) {
  const e = Gd();
  return Kf = function(n, i) {
    return n = n - 316, e[n];
  }, Kf(r, t);
}
const bu = Hs(), Na = [], qo = [], zo = [], Oa = [];
function Gd() {
  const r = ["geometry", "fillStates", "map", "FILL", "STROKE", "renderedTransform_", "arc", "textStates", "drawLabelWithPointPlacement_", "execute_", "MOVE_TO_LINE_TO", "test", "max", "declutter", "CUSTOM", "789378owYfdF", "width", "fill_", "241985rIrFdj", "763MBJtRg", "BEGIN_GEOMETRY", "floor", "prototype", "min", "round", "abs", "miterLimit", "resolution", "anchorY", "40wyETeT", "fillText", "CIRCLE", "load", "strokeStyle", "beginPath", "anchorX", "DRAW_CHARS", "zIndex", "4703880QxUhwT", "zIndexContext_", "minY", "getZIndexContext", "rotate", "textBaseline", "reduce", "lineDashOffset", "fillStyle", "alignAndScaleFill_", "canvas", "save", "3995046NyhiPA", "ceil", "getExtent", "coordinateCache_", "textAlign", "atan2", "execute", "maxX", "declutterBox", "executeHitDetection", "drawImageH", "fromCharCode", "canvasTransform", "pixelCoordinates_", "drawImageW", "height", "scale", "lineJoin", "strokeText", "none", "widths_", "stroke", "start", "replayTextBackground_", "length", "coordinates", "lineTo", "maxY", "639618bLMxjx", "pixelRatio", "instructions", "moveTo", "lineDash", "restore", "48984TIoVcV", "strokeStates", "END_GEOMETRY", "442742JTGPin", "createLabel", "originY", "collides", "justify", "labels_", "calculateImageOrLabelDimensions_", "setLineDash", "isArray", "right", "lineCap", "insert", "translate", "getGeometry", "viewRotation_", "lineWidth", "hitDetectionInstructions", "replayImageOrLabel_", "apply", "font", "left", "setStrokeStyle_", "fill", "push"];
  return Gd = function() {
    return r;
  }, Gd();
}
function e5(r) {
  const t = Kf;
  return r[3][t(323)];
}
const n5 = new RegExp("[֑-" + String[_e(326)](2303) + String[_e(326)](64285) + "-" + String[_e(326)](65023) + String[_e(326)](65136) + "-" + String[_e(326)](65276) + String[_e(326)](67584) + "-" + String[_e(326)](69631) + String[_e(326)](124928) + "-" + String[_e(326)](126975) + "]");
function bv(r, t) {
  const e = _e;
  return t === e(337) ? t = n5[e(387)](r) ? e(361) : e(372) : t === "end" && (t = n5[e(387)](r) ? e(372) : "right"), Nd[t];
}
function H7(r, t, e) {
  const n = _e;
  return e > 0 && r[n(375)](`
`, ""), r[n(375)](t, ""), r;
}
class J7 {
  constructor(t, e, n, i, s) {
    const o = _e;
    this.overlaps = n, this.pixelRatio = e, this[o(403)] = t, this[o(423)], this[o(345)] = i[o(345)], this[o(340)] = i[o(340)], this[o(318)] = {}, this.renderedTransform_ = Qo(), this.hitDetectionInstructions = i.hitDetectionInstructions, this[o(328)] = null, this[o(366)] = 0, this[o(377)] = i[o(377)] || {}, this.strokeStates = i[o(350)] || {}, this[o(383)] = i[o(383)] || {}, this[o(335)] = {}, this[o(357)] = {}, this[o(415)] = s ? new K4() : null;
  }
  [_e(417)]() {
    return this.zIndexContext_;
  }
  [_e(353)](t, e, n, i) {
    const s = _e, o = t + e + n + i;
    if (this[s(357)][o]) return this[s(357)][o];
    const a = i ? this[s(350)][i] : null, u = n ? this.fillStates[n] : null, x = this[s(383)][e], c = this[s(344)], f = [x[s(331)][0] * c, x[s(331)][1] * c], l = x[s(356)] ? Nd[x[s(356)]] : bv(Array[s(360)](t) ? t[0] : t, x[s(319)] || Nf), h = i && a[s(367)] ? a[s(367)] : 0, p = Array[s(360)](t) ? t : String(t).split(`
`)[s(420)](H7, []), { width: y, height: v, widths: m, heights: d, lineWidths: g } = L9(x, p), _ = y + h, b = [], w = (_ + 2) * f[0], E = (v + h) * f[1], S = { width: w < 0 ? Math[s(397)](w) : Math.ceil(w), height: E < 0 ? Math[s(397)](E) : Math[s(316)](E), contextInstructions: b };
    (f[0] != 1 || f[1] != 1) && b.push(s(331), f), i && (b.push(s(409), a.strokeStyle), b[s(375)](s(367), h), b[s(375)](s(362), a.lineCap), b[s(375)]("lineJoin", a[s(332)]), b[s(375)]("miterLimit", a[s(402)]), b[s(375)](s(359), [a[s(347)]]), b.push(s(421), a[s(421)])), n && b.push(s(422), u.fillStyle), b[s(375)](s(419), "middle"), b.push(s(319), "center");
    const I = 0.5 - l;
    let L = l * _ + I * h;
    const M = [], N = [];
    let P = 0, O = 0, k = 0, D = 0, F;
    for (let X = 0, W = p.length; X < W; X += 2) {
      const U = p[X];
      if (U === `
`) {
        O += P, P = 0, L = l * _ + I * h, ++D;
        continue;
      }
      const q = p[X + 1] || x.font;
      q !== F && (i && M[s(375)]("font", q), n && N.push(s(371), q), F = q), P = Math.max(P, d[k]);
      const V = [U, L + I * m[k] + l * (m[k] - g[D]), 0.5 * (h + P) + O];
      L += m[k], i && M[s(375)](s(333), V), n && N[s(375)](s(406), V), ++k;
    }
    return Array[s(398)].push.apply(b, M), Array[s(398)][s(375)][s(370)](b, N), this[s(357)][o] = S, S;
  }
  [_e(338)](t, e, n, i, s, o, a) {
    const u = _e;
    t[u(410)](), t.moveTo[u(370)](t, e), t.lineTo.apply(t, n), t[u(341)][u(370)](t, i), t[u(341)][u(370)](t, s), t[u(341)][u(370)](t, e), o && (this[u(423)] = o[2], this[u(393)](t)), a && (this[u(373)](t, a), t.stroke());
  }
  [_e(358)](t, e, n, i, s, o, a, u, x, c, f, l, h, p, y, v) {
    const m = _e;
    a *= l[0], u *= l[1];
    let d = n - a, g = i - u;
    const _ = s + x > t ? t - x : s, b = o + c > e ? e - c : o, w = p[3] + _ * l[0] + p[1], E = p[0] + b * l[1] + p[2], S = d - p[3], I = g - p[0];
    (y || f !== 0) && (Na[0] = S, Oa[0] = S, Na[1] = I, qo[1] = I, qo[0] = S + w, zo[0] = qo[0], zo[1] = I + E, Oa[1] = zo[1]);
    let L;
    return f !== 0 ? (L = O0(Qo(), n, i, 1, 1, f, -n, -i), Gi(L, Na), Gi(L, qo), Gi(L, zo), Gi(L, Oa), N0(Math.min(Na[0], qo[0], zo[0], Oa[0]), Math[m(399)](Na[1], qo[1], zo[1], Oa[1]), Math.max(Na[0], qo[0], zo[0], Oa[0]), Math.max(Na[1], qo[1], zo[1], Oa[1]), bu)) : N0(Math[m(399)](S, S + w), Math[m(399)](I, I + E), Math[m(388)](S, S + w), Math.max(I, I + E), bu), h && (d = Math[m(400)](d), g = Math.round(g)), { drawImageX: d, drawImageY: g, drawImageW: _, drawImageH: b, originX: x, originY: c, declutterBox: { minX: bu[0], minY: bu[1], maxX: bu[2], maxY: bu[3], value: v }, canvasTransform: L, scale: l };
  }
  [_e(369)](t, e, n, i, s, o, a) {
    const u = _e, x = !!(o || a), c = i.declutterBox, f = a ? a[2] * i.scale[0] / 2 : 0;
    return c.minX - f <= e[0] && c[u(322)] + f >= 0 && c[u(416)] - f <= e[1] && c[u(342)] + f >= 0 && (x && this[u(338)](t, Na, qo, zo, Oa, o, a), N9(t, i[u(327)], s, n, i.originX, i[u(354)], i[u(329)], i[u(325)], i.drawImageX, i.drawImageY, i.scale)), !0;
  }
  [_e(393)](t) {
    const e = _e, n = this[e(423)];
    if (n) {
      const i = Gi(this[e(381)], [0, 0]), s = 512 * this[e(344)];
      t[e(425)](), t[e(364)](i[0] % s, i[1] % s), n !== 1 && t[e(331)](n, n), t[e(418)](this[e(366)]);
    }
    t[e(374)](), n && t[e(348)]();
  }
  [_e(373)](t, e) {
    const n = _e;
    t[n(409)] = e[1], t[n(367)] = e[2], t[n(362)] = e[3], t[n(332)] = e[4], t[n(402)] = e[5], t[n(421)] = e[7], t[n(359)](e[6]);
  }
  [_e(384)](t, e, n, i) {
    const s = _e, o = this[s(383)][e], a = this[s(353)](t, e, i, n), u = this[s(350)][n], x = this[s(344)], c = bv(Array[s(360)](t) ? t[0] : t, o[s(319)] || Nf), f = Nd[o[s(419)] || Yp], l = u && u[s(367)] ? u[s(367)] : 0, h = a[s(392)] / x - 2 * o[s(331)][0], p = c * h + 2 * (0.5 - c) * l, y = f * a[s(330)] / x + 2 * (0.5 - f) * l;
    return { label: a, anchorX: p, anchorY: y };
  }
  [_e(385)](t, e, n, i, s, o, a, u) {
    const x = _e, c = this.zIndexContext_;
    let f;
    this[x(328)] && uu(n, this.renderedTransform_) ? f = this[x(328)] : (!this.pixelCoordinates_ && (this[x(328)] = []), f = Ga(this[x(340)], 0, this[x(340)][x(339)], 2, n, this.pixelCoordinates_), x8(this[x(381)], n));
    let l = 0;
    const h = i[x(339)];
    let p = 0, y, v, m, d, g, _, b, w, E, S, I, L, M, N = 0, P = 0, O = null, k = null;
    const D = this[x(318)], F = this[x(366)], X = Math[x(400)](Math[x(320)](-n[1], n[0]) * 1e12) / 1e12, W = { context: t, pixelRatio: this[x(344)], resolution: this[x(403)], rotation: F }, U = this[x(345)] != i || this.overlaps ? 0 : 200;
    let q, V, tt, $;
    for (; l < h; ) {
      const B = i[l];
      switch (B[0]) {
        case pt[x(396)]:
          q = B[1], $ = B[3], q[x(365)]() ? a !== void 0 && !hs(a, $[x(317)]()) ? l = B[2] + 1 : ++l : l = B[2], c && (c[x(413)] = B[4]);
          break;
        case pt.BEGIN_PATH:
          N > U && (this[x(393)](t), N = 0), P > U && (t.stroke(), P = 0), !N && !P && (t.beginPath(), g = NaN, _ = NaN), ++l;
          break;
        case pt[x(407)]:
          p = B[1];
          const pe = f[p], Bn = f[p + 1], on = f[p + 2], jn = f[p + 3], Gn = on - pe, Ti = jn - Bn, Cr = Math.sqrt(Gn * Gn + Ti * Ti);
          t.moveTo(pe + Cr, Bn), t[x(382)](pe, Bn, Cr, 0, 2 * Math.PI, !0), ++l;
          break;
        case pt.CLOSE_PATH:
          t.closePath(), ++l;
          break;
        case pt[x(390)]:
          p = B[1], y = B[2];
          const Qr = B[3], $r = B[4], li = B[5];
          W[x(376)] = Qr, W.feature = q, !(l in D) && (D[l] = []);
          const Mr = D[l];
          li ? li(f, p, y, 2, Mr) : (Mr[0] = f[p], Mr[1] = f[p + 1], Mr[x(339)] = 2), c && (c.zIndex = B[6]), $r(Mr, W), ++l;
          break;
        case pt.DRAW_IMAGE:
          p = B[1], y = B[2], E = B[3], v = B[4], m = B[5];
          let ts = B[6];
          const p0 = B[7], nv = B[8], rv = B[9], nh = B[10];
          let fc = B[11];
          const rh = B[12];
          let d0 = B[13];
          d = B[14] || x(389);
          const ko = B[15];
          if (!E && B[x(339)] >= 20) {
            S = B[19], I = B[20], L = B[21], M = B[22];
            const es = this[x(384)](S, I, L, M);
            E = es.label, B[3] = E;
            const g0 = B[23];
            v = (es[x(411)] - g0) * this.pixelRatio, B[4] = v;
            const ns = B[24];
            m = (es[x(404)] - ns) * this[x(344)], B[5] = m, ts = E[x(330)], B[6] = ts, d0 = E.width, B[13] = d0;
          }
          let iv;
          B.length > 25 && (iv = B[25]);
          let sv, ih, sh;
          B[x(339)] > 17 ? (sv = B[16], ih = B[17], sh = B[18]) : (sv = S0, ih = !1, sh = !1), nh && X ? fc += F : !nh && !X && (fc -= F);
          let O6 = 0;
          for (; p < y; p += 2) {
            if (iv && iv[O6++] < d0 / this.pixelRatio) continue;
            const es = this[x(358)](E[x(392)], E[x(330)], f[p], f[p + 1], d0, ts, v, m, nv, rv, fc, rh, s, sv, ih || sh, q), g0 = [t, e, E, es, p0, ih ? O : null, sh ? k : null];
            if (u) {
              let ns, oo, rs;
              if (ko) {
                const Pn = y - p;
                if (!ko[Pn]) {
                  ko[Pn] = { args: g0, declutterMode: d };
                  continue;
                }
                const ti = ko[Pn];
                ns = ti.args, oo = ti.declutterMode, delete ko[Pn], rs = e5(ns);
              }
              let Bo, Go;
              if (ns && (oo !== x(389) || !u[x(355)](rs)) && (Bo = !0), (d !== x(389) || !u.collides(es[x(323)])) && (Go = !0), oo === "declutter" && d === x(389)) {
                const Pn = Bo && Go;
                Bo = Pn, Go = Pn;
              }
              Bo && (oo !== x(334) && u[x(363)](rs), this[x(369)][x(370)](this, ns)), Go && (d !== x(334) && u[x(363)](es[x(323)]), this[x(369)][x(370)](this, g0));
            } else this[x(369)][x(370)](this, g0);
          }
          ++l;
          break;
        case pt[x(412)]:
          const ib = B[1], sb = B[2], ov = B[3], R6 = B[4];
          M = B[5];
          const A6 = B[6], ob = B[7], ab = B[8];
          L = B[9];
          const av = B[10];
          S = B[11], I = B[12];
          const ub = [B[13], B[13]];
          d = B[14] || x(389);
          const uv = this[x(383)][I], lc = uv[x(371)], hc = [uv[x(331)][0] * ob, uv[x(331)][1] * ob];
          let pc;
          lc in this[x(335)] ? pc = this[x(335)][lc] : (pc = {}, this[x(335)][lc] = pc);
          const xb = C4(f, ib, sb, 2), cb = Math[x(401)](hc[0]) * Fb(lc, S, pc);
          if (R6 || cb <= xb) {
            const es = this[x(383)][I][x(319)], g0 = (xb - cb) * bv(S, es), ns = W7(f, ib, sb, 2, S, g0, A6, Math[x(401)](hc[0]), Fb, lc, pc, X ? 0 : this[x(366)]);
            t: if (ns) {
              const oo = [];
              let rs, Bo, Go, Pn, ti;
              if (L) for (rs = 0, Bo = ns[x(339)]; rs < Bo; ++rs) {
                ti = ns[rs], Go = ti[4], Pn = this[x(353)](Go, I, "", L), v = ti[2] + (hc[0] < 0 ? -av : av), m = ov * Pn[x(330)] + (0.5 - ov) * 2 * av * hc[1] / hc[0] - ab;
                const Yo = this[x(358)](Pn[x(392)], Pn[x(330)], ti[0], ti[1], Pn[x(392)], Pn[x(330)], v, m, 0, 0, ti[3], ub, !1, S0, !1, q);
                if (u && d === x(389) && u[x(355)](Yo[x(323)])) break t;
                oo[x(375)]([t, e, Pn, Yo, 1, null, null]);
              }
              if (M) for (rs = 0, Bo = ns.length; rs < Bo; ++rs) {
                ti = ns[rs], Go = ti[4], Pn = this[x(353)](Go, I, M, ""), v = ti[2], m = ov * Pn[x(330)] - ab;
                const Yo = this[x(358)](Pn[x(392)], Pn[x(330)], ti[0], ti[1], Pn[x(392)], Pn[x(330)], v, m, 0, 0, ti[3], ub, !1, S0, !1, q);
                if (u && d === x(389) && u.collides(Yo[x(323)])) break t;
                oo.push([t, e, Pn, Yo, 1, null, null]);
              }
              u && d !== x(334) && u[x(408)](oo[x(378)](e5));
              for (let Yo = 0, T6 = oo[x(339)]; Yo < T6; ++Yo)
                this[x(369)][x(370)](this, oo[Yo]);
            }
          }
          ++l;
          break;
        case pt[x(351)]:
          if (o !== void 0) {
            q = B[1];
            const es = o(q, $, d);
            if (es) return es;
          }
          ++l;
          break;
        case pt[x(379)]:
          U ? N++ : this[x(393)](t), ++l;
          break;
        case pt[x(386)]:
          for (p = B[1], y = B[2], V = f[p], tt = f[p + 1], t[x(346)](V, tt), g = V + 0.5 | 0, _ = tt + 0.5 | 0, p += 2; p < y; p += 2)
            V = f[p], tt = f[p + 1], b = V + 0.5 | 0, w = tt + 0.5 | 0, (p == y - 2 || b !== g || w !== _) && (t[x(341)](V, tt), g = b, _ = w);
          ++l;
          break;
        case pt.SET_FILL_STYLE:
          O = B, this[x(423)] = B[2], N && (this[x(393)](t), N = 0, P && (t[x(336)](), P = 0)), t[x(422)] = B[1], ++l;
          break;
        case pt.SET_STROKE_STYLE:
          k = B, P && (t[x(336)](), P = 0), this[x(373)](t, B), ++l;
          break;
        case pt[x(380)]:
          U ? P++ : t[x(336)](), ++l;
          break;
        default:
          ++l;
          break;
      }
    }
    return N && this[x(393)](t), P && t.stroke(), void 0;
  }
  [_e(321)](t, e, n, i, s, o) {
    const a = _e;
    this[a(366)] = i, this[a(385)](t, e, n, this[a(345)], s, void 0, void 0, o);
  }
  [_e(324)](t, e, n, i, s) {
    const o = _e;
    return this[o(366)] = n, this[o(385)](t, [t[o(424)][o(392)], t.canvas[o(330)]], e, this[o(368)], !0, i, s);
  }
}
const Ze = Yd;
(function(r, t) {
  const e = Yd, n = r();
  for (; ; )
    try {
      if (-parseInt(e(449)) / 1 + -parseInt(e(426)) / 2 * (parseInt(e(413)) / 3) + -parseInt(e(404)) / 4 * (-parseInt(e(430)) / 5) + parseInt(e(424)) / 6 + -parseInt(e(411)) / 7 + parseInt(e(403)) / 8 + -parseInt(e(407)) / 9 * (parseInt(e(435)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Xd, 535987);
const Yu = [Ze(415), Ze(420), Ze(410), Ze(419), Ze(450), Ze(448)], j4 = [Ze(419), "Text"], Z7 = Yu[Ze(406)]((r) => !j4[Ze(451)](r));
class K7 {
  constructor(t, e, n, i, s, o, a) {
    const u = Ze;
    this[u(417)] = t, this.overlaps_ = i, this.pixelRatio_ = n, this[u(454)] = e, this[u(446)] = o, this[u(433)] = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = Qo(), this[u(432)] = null, this.deferredZIndexContexts_ = {}, this[u(437)](s, a);
  }
  [Ze(458)](t, e) {
    const n = Ze, i = this[n(408)](e);
    t.beginPath(), t[n(431)](i[0], i[1]), t.lineTo(i[2], i[3]), t[n(445)](i[4], i[5]), t[n(445)](i[6], i[7]), t[n(458)]();
  }
  [Ze(437)](t, e) {
    const n = Ze;
    for (const i in t) {
      let s = this[n(433)][i];
      s === void 0 && (s = {}, this[n(433)][i] = s);
      const o = t[i];
      for (const a in o) {
        const u = o[a];
        s[a] = new J7(this[n(454)], this.pixelRatio_, this[n(443)], u, e);
      }
    }
  }
  [Ze(457)](t) {
    const e = Ze;
    for (const n in this[e(433)]) {
      const i = this[e(433)][n];
      for (let s = 0, o = t[e(428)]; s < o; ++s)
        if (t[s] in i) return !0;
    }
    return !1;
  }
  [Ze(439)](t, e, n, i, s, o) {
    const a = Ze;
    i = Math.round(i);
    const u = i * 2 + 1, x = O0(this[a(447)], i + 0.5, i + 0.5, 1 / e, -1 / e, -n, -t[0], -t[1]), c = !this[a(416)];
    c && (this.hitDetectionContext_ = Ui(u, u, void 0, { willReadFrequently: !0 }));
    const f = this[a(416)];
    f.canvas[a(442)] !== u || f[a(438)][a(444)] !== u ? (f[a(438)][a(442)] = u, f.canvas.height = u) : !c && f[a(409)](0, 0, u, u);
    let l;
    this[a(446)] !== void 0 && (l = Hs(), n4(l, t), ec(l, e * (this[a(446)] + i), l));
    const h = j7(i);
    let p;
    function y(w, E, S) {
      const I = a, L = f[I(422)](0, 0, u, u).data;
      for (let M = 0, N = h.length; M < N; M++)
        if (L[h[M]] > 0) {
          if (!o || S === I(456) || p !== I(419) && p !== "Text" || o[I(451)](w)) {
            const P = (h[M] - 3) / 4, O = i - P % u, k = i - (P / u | 0), D = s(w, E, O * O + k * k);
            if (D) return D;
          }
          f[I(409)](0, 0, u, u);
          break;
        }
    }
    const v = Object[a(441)](this[a(433)])[a(427)](Number);
    v[a(440)](P0);
    let m, d, g, _, b;
    for (m = v.length - 1; m >= 0; --m) {
      const w = v[m][a(452)]();
      for (g = this[a(433)][w], d = Yu[a(428)] - 1; d >= 0; --d)
        if (p = Yu[d], _ = g[p], _ !== void 0 && (b = _[a(453)](f, x, n, y, l), b))
          return b;
    }
  }
  [Ze(408)](t) {
    const e = this.maxExtent_;
    if (!e) return null;
    const n = e[0], i = e[1], s = e[2], o = e[3], a = [n, i, n, o, s, o, s, i];
    return Ga(a, 0, 8, 2, t, a), a;
  }
  isEmpty() {
    return sx(this[Ze(433)]);
  }
  [Ze(414)](t, e, n, i, s, o, a) {
    const u = Ze, x = Object[u(441)](this[u(433)])[u(427)](Number);
    x[u(440)](P0), o = o || Yu;
    const c = Yu[u(428)];
    let f, l, h, p, y;
    for (a && x[u(418)](), f = 0, l = x[u(428)]; f < l; ++f) {
      const v = x[f][u(452)]();
      for (y = this[u(433)][v], h = 0, p = o[u(428)]; h < p; ++h) {
        const m = o[h], d = y[m];
        if (d !== void 0) {
          const g = a === null ? void 0 : d.getZIndexContext(), _ = g ? g[u(434)]() : t, b = this.maxExtent_ && m !== u(419) && m !== u(450);
          if (b && (_[u(429)](), this[u(458)](_, n)), !g || m === u(450) || m === u(419) ? d[u(414)](_, e, n, i, s, a) : g.pushFunction((w) => d[u(414)](w, e, n, i, s, a)), b && _[u(405)](), g) {
            g[u(421)]();
            const w = x[f] * c + h;
            !this.deferredZIndexContexts_[w] && (this[u(412)][w] = []), this[u(412)][w][u(455)](g);
          }
        }
      }
    }
    this.renderedContext_ = t;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this[Ze(432)];
  }
  [Ze(425)]() {
    const t = Ze, e = this[t(412)], n = Object[t(441)](e)[t(427)](Number).sort(P0);
    for (let i = 0, s = n.length; i < s; ++i)
      e[n[i]][t(436)]((o) => {
        const a = t;
        o[a(423)](this[a(432)]), o.clear();
      }), e[n[i]].length = 0;
  }
}
function Yd(r, t) {
  const e = Xd();
  return Yd = function(n, i) {
    return n = n - 403, e[n];
  }, Yd(r, t);
}
const Iv = {};
function j7(r) {
  const t = Ze;
  if (Iv[r] !== void 0) return Iv[r];
  const e = r * 2 + 1, n = r * r, i = new Array(n + 1);
  for (let o = 0; o <= r; ++o)
    for (let a = 0; a <= r; ++a) {
      const u = o * o + a * a;
      if (u > n) break;
      let x = i[u];
      !x && (x = [], i[u] = x), x[t(455)](((r + o) * e + (r + a)) * 4 + 3), o > 0 && x[t(455)](((r - o) * e + (r + a)) * 4 + 3), a > 0 && (x[t(455)](((r + o) * e + (r - a)) * 4 + 3), o > 0 && x[t(455)](((r - o) * e + (r - a)) * 4 + 3));
    }
  const s = [];
  for (let o = 0, a = i[t(428)]; o < a; ++o)
    i[o] && s[t(455)](...i[o]);
  return Iv[r] = s, s;
}
function Xd() {
  const r = ["restore", "filter", "422091jZjGVw", "getClipCoords", "clearRect", "LineString", "2828000zmETae", "deferredZIndexContexts_", "3iuQUDj", "execute", "Polygon", "hitDetectionContext_", "maxExtent_", "reverse", "Image", "Circle", "offset", "getImageData", "draw", "4051518sWVUUT", "renderDeferred", "483034dqRpxo", "map", "length", "save", "505ahEaau", "moveTo", "renderedContext_", "executorsByZIndex_", "getContext", "40jnoohT", "forEach", "createExecutors_", "canvas", "forEachFeatureAtCoordinate", "sort", "keys", "width", "overlaps_", "height", "lineTo", "renderBuffer_", "hitDetectionTransform_", "Default", "344325YfqEEA", "Text", "includes", "toString", "executeHitDetection", "resolution_", "push", "none", "hasExecutors", "clip", "8240736eUgQth", "320UjbWrv"];
  return Xd = function() {
    return r;
  }, Xd();
}
const fe = jf;
(function(r, t) {
  const e = jf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(181)) / 1 + -parseInt(e(183)) / 2 + -parseInt(e(170)) / 3 * (-parseInt(e(186)) / 4) + -parseInt(e(205)) / 5 + parseInt(e(278)) / 6 + -parseInt(e(213)) / 7 * (parseInt(e(168)) / 8) + parseInt(e(229)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(qd, 262777);
function qd() {
  const r = ["imageScale_", "sqrt", "setStyle", "lineDash", "getOrigin", "getFlatMidpoint", "atan2", "length", "imageOpacity_", "getImage", "getEndss", "742311UMqBMp", "imageOriginY_", "userTransform_", "imageAnchorY_", "textScale_", "drawMultiPolygon", "transform", "font", "lineTo", "drawGeometry", "moveToLineTo_", "drawPoint", "strokeText", "textOffsetY_", "setTextStyle", "viewRotation_", "imageOriginX_", "contextFillState_", "scale", "setContextFillState_", "textStrokeState_", "setImageStyle", "miterLimit", "lineCap", "getColor", "getRotation", "getStride", "imageHeight_", "getMiterLimit", "getType", "getRotateWithView", "apply", "textFillState_", "setContextTextState_", "setTransform", "drawImages_", "getEnds", "drawRings_", "getText", "getPixelRatio", "strokeState_", "text_", "extent_", "LineString", "imageAnchorX_", "transformRotation_", "getLineDashOffset", "getFont", "squaredTolerance_", "2367372TrvENM", "tmpLocalTransform_", "drawMultiLineString", "pixelRatio_", "transform_", "drawGeometryCollection", "lineDashOffset", "MultiLineString", "drawPolygon", "pixelCoordinates_", "getScaleArray", "textState_", "simplifyTransformed", "MultiPolygon", "imageRotateWithView_", "save", "setLineDash", "getOffsetX", "fill", "getOffsetY", "setContextStrokeState_", "drawLineString", "drawFeature", "2455112TOwlTs", "getLineDash", "768gBgsbM", "getStroke", "getAnchor", "fillStyle", "getFlatCoordinates", "drawText_", "closePath", "contextTextState_", "moveTo", "fillState_", "translate", "10363yzOnto", "lineWidth", "157500MHmlEV", "drawCircle", "getOpacity", "7012QPMfwM", "getGeometriesArray", "drawImage", "contextStrokeState_", "reduce", "image_", "context_", "imageRotation_", "getExtent", "strokeStyle", "textRotation_", "textRotateWithView_", "arc", "textOffsetX_", "getSize", "getFill", "lineJoin", "setFillStrokeStyle", "stroke", "1335150wPNpmH", "getLineJoin", "GeometryCollection", "textAlign", "beginPath", "drawMultiPoint", "getFlatInteriorPoint", "textBaseline", "7CNikql", "fillText", "getWidth", "imageWidth_", "restore"];
  return qd = function() {
    return r;
  }, qd();
}
function jf(r, t) {
  const e = qd();
  return jf = function(n, i) {
    return n = n - 166, e[n];
  }, jf(r, t);
}
class Q7 extends Z4 {
  constructor(t, e, n, i, s, o, a) {
    const u = jf;
    super(), this.context_ = t, this[u(281)] = e, this[u(271)] = n, this[u(282)] = i, this[u(274)] = i ? h4(Math[u(224)](i[1], i[0]), 10) : 0, this[u(244)] = s, this[u(277)] = o, this[u(231)] = a, this[u(246)] = null, this[u(189)] = null, this.contextTextState_ = null, this[u(179)] = null, this.strokeState_ = null, this[u(191)] = null, this[u(273)] = 0, this[u(232)] = 0, this[u(256)] = 0, this[u(226)] = 0, this[u(245)] = 0, this[u(230)] = 0, this[u(292)] = !1, this.imageRotation_ = 0, this[u(218)] = [0, 0], this[u(216)] = 0, this[u(270)] = "", this.textOffsetX_ = 0, this[u(242)] = 0, this[u(197)] = !1, this[u(196)] = 0, this[u(233)] = [0, 0], this[u(261)] = null, this[u(249)] = null, this[u(289)] = null, this[u(287)] = [], this[u(279)] = Qo();
  }
  [fe(264)](t, e, n, i) {
    const s = fe;
    if (!this[s(191)]) return;
    const o = Ga(t, e, n, i, this[s(282)], this[s(287)]), a = this.context_, u = this.tmpLocalTransform_, x = a.globalAlpha;
    this[s(226)] != 1 && (a.globalAlpha = x * this[s(226)]);
    let c = this[s(193)];
    this[s(274)] === 0 && (c -= this[s(244)]), this.imageRotateWithView_ && (c += this[s(244)]);
    for (let f = 0, l = o[s(225)]; f < l; f += 2) {
      const h = o[f] - this.imageAnchorX_, p = o[f + 1] - this.imageAnchorY_;
      if (c !== 0 || this[s(218)][0] != 1 || this[s(218)][1] != 1) {
        const y = h + this.imageAnchorX_, v = p + this.imageAnchorY_;
        O0(u, y, v, 1, 1, c, -y, -v), a[s(293)](), a[s(235)][s(260)](a, u), a[s(180)](y, v), a.scale(this[s(218)][0], this[s(218)][1]), a[s(188)](this.image_, this[s(245)], this[s(230)], this[s(216)], this[s(256)], -this.imageAnchorX_, -this[s(232)], this[s(216)], this[s(256)]), a[s(217)]();
      } else a.drawImage(this[s(191)], this.imageOriginX_, this[s(230)], this[s(216)], this[s(256)], h, p, this[s(216)], this[s(256)]);
    }
    this[s(226)] != 1 && (a.globalAlpha = x);
  }
  [fe(175)](t, e, n, i) {
    const s = fe;
    if (!this.textState_ || this[s(270)] === "") return;
    this[s(261)] && this[s(248)](this[s(261)]), this.textStrokeState_ && this[s(298)](this[s(249)]), this[s(262)](this.textState_);
    const o = Ga(t, e, n, i, this[s(282)], this[s(287)]), a = this.context_;
    let u = this[s(196)];
    for (this[s(274)] === 0 && (u -= this.viewRotation_), this[s(197)] && (u += this[s(244)]); e < n; e += i) {
      const x = o[e] + this[s(199)], c = o[e + 1] + this[s(242)];
      u !== 0 || this[s(233)][0] != 1 || this[s(233)][1] != 1 ? (a[s(293)](), a.translate(x - this[s(199)], c - this[s(242)]), a.rotate(u), a[s(180)](this.textOffsetX_, this[s(242)]), a[s(247)](this[s(233)][0], this[s(233)][1]), this[s(249)] && a[s(241)](this[s(270)], 0, 0), this[s(261)] && a[s(214)](this[s(270)], 0, 0), a[s(217)]()) : (this[s(249)] && a.strokeText(this[s(270)], x, c), this[s(261)] && a[s(214)](this.text_, x, c));
    }
  }
  moveToLineTo_(t, e, n, i, s) {
    const o = fe, a = this[o(192)], u = Ga(t, e, n, i, this.transform_, this.pixelCoordinates_);
    a[o(178)](u[0], u[1]);
    let x = u[o(225)];
    s && (x -= 2);
    for (let c = 2; c < x; c += 2)
      a[o(237)](u[c], u[c + 1]);
    return s && a[o(176)](), n;
  }
  drawRings_(t, e, n, i) {
    const s = fe;
    for (let o = 0, a = n[s(225)]; o < a; ++o)
      e = this[s(239)](t, e, n[o], i, !0);
    return e;
  }
  [fe(184)](t) {
    const e = fe;
    if (this[e(277)] && (t = t[e(290)](this[e(277)], this[e(231)])), !!hs(this[e(271)], t[e(194)]())) {
      if (this[e(179)] || this[e(269)]) {
        this.fillState_ && this.setContextFillState_(this[e(179)]), this[e(269)] && this[e(298)](this[e(269)]);
        const n = q8(t, this.transform_, this[e(287)]), i = n[2] - n[0], s = n[3] - n[1], o = Math[e(219)](i * i + s * s), a = this.context_;
        a.beginPath(), a[e(198)](n[0], n[1], o, 0, 2 * Math.PI), this[e(179)] && a[e(296)](), this.strokeState_ && a[e(204)]();
      }
      this[e(270)] !== "" && this[e(175)](t.getCenter(), 0, 2, 2);
    }
  }
  setStyle(t) {
    const e = fe;
    this[e(203)](t.getFill(), t[e(171)]()), this[e(250)](t[e(227)]()), this[e(243)](t.getText());
  }
  [fe(263)](t) {
    this.transform_ = t;
  }
  [fe(238)](t) {
    const e = fe;
    switch (t[e(258)]()) {
      case "Point":
        this[e(240)](t);
        break;
      case e(272):
        this.drawLineString(t);
        break;
      case "Polygon":
        this[e(286)](t);
        break;
      case "MultiPoint":
        this[e(210)](t);
        break;
      case e(285):
        this[e(280)](t);
        break;
      case e(291):
        this[e(234)](t);
        break;
      case e(207):
        this[e(283)](t);
        break;
      case "Circle":
        this.drawCircle(t);
        break;
    }
  }
  [fe(167)](t, e) {
    const n = fe, i = e.getGeometryFunction()(t);
    i && (this[n(220)](e), this[n(238)](i));
  }
  drawGeometryCollection(t) {
    const e = fe, n = t[e(187)]();
    for (let i = 0, s = n[e(225)]; i < s; ++i)
      this[e(238)](n[i]);
  }
  [fe(240)](t) {
    const e = fe;
    this[e(277)] && (t = t[e(290)](this[e(277)], this[e(231)]));
    const n = t.getFlatCoordinates(), i = t[e(255)]();
    this[e(191)] && this.drawImages_(n, 0, n[e(225)], i), this[e(270)] !== "" && this[e(175)](n, 0, n[e(225)], i);
  }
  [fe(210)](t) {
    const e = fe;
    this[e(277)] && (t = t[e(290)](this[e(277)], this[e(231)]));
    const n = t[e(174)](), i = t[e(255)]();
    this[e(191)] && this.drawImages_(n, 0, n[e(225)], i), this[e(270)] !== "" && this[e(175)](n, 0, n[e(225)], i);
  }
  [fe(166)](t) {
    const e = fe;
    if (this[e(277)] && (t = t[e(290)](this[e(277)], this[e(231)])), !!hs(this[e(271)], t.getExtent())) {
      if (this.strokeState_) {
        this[e(298)](this[e(269)]);
        const n = this[e(192)], i = t[e(174)]();
        n.beginPath(), this[e(239)](i, 0, i[e(225)], t[e(255)](), !1), n[e(204)]();
      }
      if (this[e(270)] !== "") {
        const n = t[e(223)]();
        this.drawText_(n, 0, 2, 2);
      }
    }
  }
  [fe(280)](t) {
    const e = fe;
    this[e(277)] && (t = t[e(290)](this[e(277)], this[e(231)]));
    const n = t[e(194)]();
    if (hs(this.extent_, n)) {
      if (this[e(269)]) {
        this[e(298)](this[e(269)]);
        const i = this[e(192)], s = t[e(174)]();
        let o = 0;
        const a = t[e(265)](), u = t[e(255)]();
        i[e(209)]();
        for (let x = 0, c = a[e(225)]; x < c; ++x)
          o = this.moveToLineTo_(s, o, a[x], u, !1);
        i.stroke();
      }
      if (this.text_ !== "") {
        const i = t.getFlatMidpoints();
        this[e(175)](i, 0, i[e(225)], 2);
      }
    }
  }
  [fe(286)](t) {
    const e = fe;
    if (this.squaredTolerance_ && (t = t[e(290)](this.squaredTolerance_, this[e(231)])), !!hs(this[e(271)], t[e(194)]())) {
      if (this[e(269)] || this.fillState_) {
        this.fillState_ && this[e(248)](this[e(179)]), this[e(269)] && this[e(298)](this[e(269)]);
        const n = this[e(192)];
        n[e(209)](), this[e(266)](t.getOrientedFlatCoordinates(), 0, t[e(265)](), t[e(255)]()), this[e(179)] && n[e(296)](), this[e(269)] && n[e(204)]();
      }
      if (this.text_ !== "") {
        const n = t[e(211)]();
        this[e(175)](n, 0, 2, 2);
      }
    }
  }
  [fe(234)](t) {
    const e = fe;
    if (this[e(277)] && (t = t.simplifyTransformed(this[e(277)], this[e(231)])), !!hs(this.extent_, t[e(194)]())) {
      if (this[e(269)] || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this[e(179)]), this[e(269)] && this[e(298)](this[e(269)]);
        const n = this.context_, i = t.getOrientedFlatCoordinates();
        let s = 0;
        const o = t[e(228)](), a = t[e(255)]();
        n[e(209)]();
        for (let u = 0, x = o[e(225)]; u < x; ++u) {
          const c = o[u];
          s = this[e(266)](i, s, c, a);
        }
        this.fillState_ && n.fill(), this[e(269)] && n.stroke();
      }
      if (this[e(270)] !== "") {
        const n = t.getFlatInteriorPoints();
        this[e(175)](n, 0, n[e(225)], 2);
      }
    }
  }
  [fe(248)](t) {
    const e = fe, n = this.context_, i = this.contextFillState_;
    i ? i[e(173)] != t.fillStyle && (i[e(173)] = t[e(173)], n[e(173)] = t[e(173)]) : (n[e(173)] = t.fillStyle, this[e(246)] = { fillStyle: t.fillStyle });
  }
  setContextStrokeState_(t) {
    const e = fe, n = this[e(192)], i = this[e(189)];
    i ? (i[e(252)] != t[e(252)] && (i[e(252)] = t[e(252)], n.lineCap = t[e(252)]), !uu(i[e(221)], t[e(221)]) && n[e(294)](i[e(221)] = t[e(221)]), i[e(284)] != t[e(284)] && (i.lineDashOffset = t[e(284)], n[e(284)] = t[e(284)]), i.lineJoin != t[e(202)] && (i.lineJoin = t[e(202)], n[e(202)] = t[e(202)]), i[e(182)] != t[e(182)] && (i[e(182)] = t[e(182)], n[e(182)] = t[e(182)]), i[e(251)] != t[e(251)] && (i.miterLimit = t[e(251)], n[e(251)] = t.miterLimit), i[e(195)] != t[e(195)] && (i[e(195)] = t[e(195)], n[e(195)] = t[e(195)])) : (n.lineCap = t[e(252)], n[e(294)](t.lineDash), n[e(284)] = t[e(284)], n.lineJoin = t.lineJoin, n[e(182)] = t[e(182)], n.miterLimit = t[e(251)], n.strokeStyle = t[e(195)], this.contextStrokeState_ = { lineCap: t[e(252)], lineDash: t[e(221)], lineDashOffset: t[e(284)], lineJoin: t[e(202)], lineWidth: t.lineWidth, miterLimit: t[e(251)], strokeStyle: t[e(195)] });
  }
  [fe(262)](t) {
    const e = fe, n = this[e(192)], i = this.contextTextState_, s = t[e(208)] ? t[e(208)] : Nf;
    i ? (i[e(236)] != t[e(236)] && (i[e(236)] = t[e(236)], n[e(236)] = t[e(236)]), i[e(208)] != s && (i[e(208)] = s, n[e(208)] = s), i[e(212)] != t[e(212)] && (i[e(212)] = t[e(212)], n[e(212)] = t[e(212)])) : (n[e(236)] = t[e(236)], n[e(208)] = s, n[e(212)] = t[e(212)], this[e(177)] = { font: t[e(236)], textAlign: s, textBaseline: t[e(212)] });
  }
  [fe(203)](t, e) {
    const n = fe;
    if (!t) this[n(179)] = null;
    else {
      const i = t.getColor();
      this.fillState_ = { fillStyle: yo(i || gi) };
    }
    if (!e) this[n(269)] = null;
    else {
      const i = e[n(253)](), s = e.getLineCap(), o = e[n(169)](), a = e[n(275)](), u = e[n(206)](), x = e[n(215)](), c = e[n(257)](), f = o || ea;
      this.strokeState_ = { lineCap: s !== void 0 ? s : _x, lineDash: this[n(281)] === 1 ? f : f.map((l) => l * this[n(281)]), lineDashOffset: (a || na) * this.pixelRatio_, lineJoin: u !== void 0 ? u : bx, lineWidth: (x !== void 0 ? x : Of) * this[n(281)], miterLimit: c !== void 0 ? c : Pf, strokeStyle: yo(i || Lf) };
    }
  }
  setImageStyle(t) {
    const e = fe;
    let n;
    if (!t || !(n = t[e(200)]())) {
      this[e(191)] = null;
      return;
    }
    const i = t[e(268)](this[e(281)]), s = t[e(172)](), o = t[e(222)]();
    this[e(191)] = t[e(227)](this[e(281)]), this[e(273)] = s[0] * i, this[e(232)] = s[1] * i, this[e(256)] = n[1] * i, this.imageOpacity_ = t[e(185)](), this[e(245)] = o[0], this[e(230)] = o[1], this[e(292)] = t[e(259)](), this[e(193)] = t[e(254)]();
    const a = t[e(288)]();
    this.imageScale_ = [a[0] * this[e(281)] / i, a[1] * this.pixelRatio_ / i], this[e(216)] = n[0] * i;
  }
  setTextStyle(t) {
    const e = fe;
    if (!t) this[e(270)] = "";
    else {
      const n = t[e(201)]();
      if (!n) this[e(261)] = null;
      else {
        const p = n[e(253)]();
        this.textFillState_ = { fillStyle: yo(p || gi) };
      }
      const i = t[e(171)]();
      if (!i) this[e(249)] = null;
      else {
        const p = i[e(253)](), y = i.getLineCap(), v = i[e(169)](), m = i[e(275)](), d = i.getLineJoin(), g = i.getWidth(), _ = i[e(257)]();
        this[e(249)] = { lineCap: y !== void 0 ? y : _x, lineDash: v || ea, lineDashOffset: m || na, lineJoin: d !== void 0 ? d : bx, lineWidth: g !== void 0 ? g : Of, miterLimit: _ !== void 0 ? _ : Pf, strokeStyle: yo(p || Lf) };
      }
      const s = t[e(276)](), o = t[e(295)](), a = t[e(297)](), u = t[e(259)](), x = t[e(254)](), c = t[e(288)](), f = t[e(267)](), l = t.getTextAlign(), h = t.getTextBaseline();
      this.textState_ = { font: s !== void 0 ? s : G4, textAlign: l !== void 0 ? l : Nf, textBaseline: h !== void 0 ? h : Yp }, this[e(270)] = f !== void 0 ? Array.isArray(f) ? f[e(190)]((p, y, v) => p += v % 2 ? " " : y, "") : f : "", this[e(199)] = o !== void 0 ? this[e(281)] * o : 0, this[e(242)] = a !== void 0 ? this[e(281)] * a : 0, this[e(197)] = u !== void 0 ? u : !1, this.textRotation_ = x !== void 0 ? x : 0, this[e(233)] = [this[e(281)] * c[0], this[e(281)] * c[1]];
    }
  }
}
(function(r, t) {
  const e = Qf, n = r();
  for (; ; )
    try {
      if (-parseInt(e(266)) / 1 * (parseInt(e(295)) / 2) + parseInt(e(294)) / 3 * (parseInt(e(299)) / 4) + parseInt(e(276)) / 5 * (-parseInt(e(297)) / 6) + -parseInt(e(313)) / 7 + parseInt(e(271)) / 8 * (-parseInt(e(275)) / 9) + -parseInt(e(298)) / 10 + parseInt(e(286)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(zd, 403267);
function Qf(r, t) {
  const e = zd();
  return Qf = function(n, i) {
    return n = n - 265, e[n];
  }, Qf(r, t);
}
function zd() {
  const r = ["keys", "drawGeometry", "imageSmoothingEnabled", "fillRect", "setColor", "push", "getRotateWithView", "getAnchor", "clone", "2897965wDehXm", "getOrigin", "length", "getFill", "Multi", "LineString", "5rXFKEP", "setImage", "width", "Polygon", "getExtent", "16WBeqkw", "floor", "isArray", "padStart", "2716290vXBanr", "58925pJIElS", "GeometryCollection", "getImageData", "setTransform", "setText", "canvas", "getStyleFunction", "getType", "data", "fillStyle", "36665420QMntct", "#00000", "getStroke", "getSize", "toString", "pixels", "getImageSize", "Point", "87gkqMuF", "308090WlNnUX", "replace", "258bTsLue", "7808510fHECuz", "20068ZKpRvW", "getRotation", "map", "getScale", "getGeometryFunction"];
  return zd = function() {
    return r;
  }, zd();
}
const go = 0.5;
function $7(r, t, e, n, i, s, o, a, u) {
  const x = Qf, c = i, f = r[0] * go, l = r[1] * go, h = Ui(f, l);
  h[x(306)] = !1;
  const p = h.canvas, y = new Q7(h, go, i, null, o, a, null), v = e.length, m = Math[x(272)]((256 * 256 * 256 - 1) / v), d = {};
  for (let _ = 1; _ <= v; ++_) {
    const b = e[_ - 1], w = b[x(282)]() || n;
    if (!w) continue;
    let E = w(b, s);
    if (!E) continue;
    !Array[x(273)](E) && (E = [E]);
    const S = _ * m, I = S[x(290)](16)[x(274)](7, x(287));
    for (let L = 0, M = E[x(315)]; L < M; ++L) {
      const N = E[L], P = N[x(303)]()(b);
      if (!P || !hs(c, P[x(270)]())) continue;
      const O = N[x(312)](), k = O[x(316)]();
      k && k[x(308)](I);
      const D = O[x(288)]();
      D && (D.setColor(I), D.setLineDash(null)), O[x(280)](void 0);
      const F = N.getImage();
      if (F) {
        const q = F[x(292)]();
        if (!q) continue;
        const V = Ui(q[0], q[1], void 0, { alpha: !1 }), tt = V[x(281)];
        V[x(285)] = I, V[x(307)](0, 0, tt[x(268)], tt.height), O[x(267)](new rc({ img: tt, anchor: F[x(311)](), anchorXUnits: "pixels", anchorYUnits: x(291), offset: F[x(314)](), opacity: 1, size: F[x(289)](), scale: F[x(302)](), rotation: F[x(300)](), rotateWithView: F[x(310)]() }));
      }
      const X = O.getZIndex() || 0;
      let W = d[X];
      !W && (W = {}, d[X] = W, W[x(269)] = [], W.Circle = [], W[x(265)] = [], W[x(293)] = []);
      const U = P[x(283)]();
      if (U === x(277)) {
        const q = P.getGeometriesArrayRecursive();
        for (let V = 0, tt = q[x(315)]; V < tt; ++V) {
          const $ = q[V];
          W[$.getType().replace("Multi", "")].push($, O);
        }
      } else W[U[x(296)](x(317), "")][x(309)](P, O);
    }
  }
  const g = Object[x(304)](d)[x(301)](Number).sort(P0);
  for (let _ = 0, b = g[x(315)]; _ < b; ++_) {
    const w = d[g[_]];
    for (const E in w) {
      const S = w[E];
      for (let I = 0, L = S[x(315)]; I < L; I += 2) {
        y.setStyle(S[I + 1]);
        for (let M = 0, N = t[x(315)]; M < N; ++M)
          y[x(279)](t[M]), y[x(305)](S[I]);
      }
    }
  }
  return h[x(278)](0, 0, p[x(268)], p.height);
}
function tC(r, t, e) {
  const n = Qf, i = [];
  if (e) {
    const s = Math[n(272)](Math.round(r[0]) * go), o = Math[n(272)](Math.round(r[1]) * go), a = (Tr(s, 0, e[n(268)] - 1) + Tr(o, 0, e.height - 1) * e.width) * 4, u = e[n(284)][a], x = e[n(284)][a + 1], c = e[n(284)][a + 2], f = c + 256 * (x + 256 * u), l = Math[n(272)]((256 * 256 * 256 - 1) / t[n(315)]);
    f && f % l === 0 && i[n(309)](t[f / l - 1]);
  }
  return i;
}
(function(r, t) {
  const e = Ci, n = r();
  for (; ; )
    try {
      if (parseInt(e(169)) / 1 + parseInt(e(177)) / 2 + parseInt(e(189)) / 3 * (parseInt(e(184)) / 4) + parseInt(e(188)) / 5 + parseInt(e(163)) / 6 + parseInt(e(183)) / 7 * (-parseInt(e(151)) / 8) + -parseInt(e(155)) / 9 * (parseInt(e(157)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Ud, 101263);
const eC = 0.5, Q4 = { Point: xC, LineString: oC, Polygon: fC, MultiPoint: cC, MultiLineString: aC, MultiPolygon: uC, GeometryCollection: sC, Circle: rC };
function Ud() {
  const r = ["getZIndex", "drawMultiLineString", "drawPoint", "getHitDetectionRenderer", "then", "194474gMMUwh", "drawText", "Default", "Text", "all", "getOpacity", "ERROR", "length", "253608ChqSkM", "getGeometries", "setFillStrokeStyle", "drawCustom", "getStroke", "getImageState", "8631umDsDw", "5596XLiYME", "Image", "load", "push", "871205kTfnmZ", "282TMyUcJ", "setTextStyle", "getBuilder", "ready", "LOADED", "getFill", "drawMultiPolygon", "Circle", "getType", "808cYHbmr", "getImage", "LineString", "getText", "144639nfvedu", "getGeometryFunction", "290dwvUPy", "getRenderer", "GeometryCollection", "Polygon", "getGeometriesArray", "simplifyTransformed", "388980WCDFXR"];
  return Ud = function() {
    return r;
  }, Ud();
}
function nC(r, t) {
  return parseInt(ve(r), 10) - parseInt(ve(t), 10);
}
function r5(r, t) {
  const e = $4(r, t);
  return e * e;
}
function $4(r, t) {
  return eC * r / t;
}
function Ci(r, t) {
  const e = Ud();
  return Ci = function(n, i) {
    return n = n - 151, e[n];
  }, Ci(r, t);
}
function rC(r, t, e, n, i) {
  const s = Ci, o = e[s(194)](), a = e[s(181)]();
  if (o || a) {
    const x = r[s(191)](e[s(164)](), s(196));
    x[s(179)](o, a), x.drawCircle(t, n, i);
  }
  const u = e.getText();
  if (u && u.getText()) {
    const x = r[s(191)](e.getZIndex(), "Text");
    x[s(190)](u), x[s(170)](t, n);
  }
}
function i5(r, t, e, n, i, s, o, a) {
  const u = Ci, x = [], c = e[u(152)]();
  if (c) {
    let h = !0;
    const p = c[u(182)]();
    p == Et[u(193)] || p == Et[u(175)] ? h = !1 : p == Et.IDLE && c[u(186)](), h && x.push(c[u(192)]());
  }
  const f = e.getFill();
  f && f.loading() && x[u(187)](f[u(192)]());
  const l = x.length > 0;
  return l && Promise[u(173)](x)[u(168)](() => i(null)), iC(r, t, e, n, s, o, a), l;
}
function iC(r, t, e, n, i, s, o) {
  const a = Ci, u = e[a(156)]()(t);
  if (!u) return;
  const x = u[a(162)](n, i);
  if (e[a(158)]()) tw(r, x, e, t, o);
  else {
    const f = Q4[x[a(197)]()];
    f(r, x, e, t, o, s);
  }
}
function tw(r, t, e, n, i) {
  const s = Ci;
  if (t.getType() == s(159)) {
    const a = t[s(178)]();
    for (let u = 0, x = a.length; u < x; ++u)
      tw(r, a[u], e, n, i);
    return;
  }
  r[s(191)](e[s(164)](), s(171))[s(180)](t, n, e[s(158)](), e[s(167)](), i);
}
function sC(r, t, e, n, i, s) {
  const o = Ci, a = t[o(161)]();
  let u, x;
  for (u = 0, x = a[o(176)]; u < x; ++u) {
    const c = Q4[a[u][o(197)]()];
    c(r, a[u], e, n, i, s);
  }
}
function oC(r, t, e, n, i) {
  const s = Ci, o = e[s(181)]();
  if (o) {
    const u = r[s(191)](e[s(164)](), s(153));
    u.setFillStrokeStyle(null, o), u.drawLineString(t, n, i);
  }
  const a = e[s(154)]();
  if (a && a[s(154)]()) {
    const u = r[s(191)](e[s(164)](), s(172));
    u.setTextStyle(a), u[s(170)](t, n, i);
  }
}
function aC(r, t, e, n, i) {
  const s = Ci, o = e.getStroke();
  if (o) {
    const u = r[s(191)](e.getZIndex(), s(153));
    u.setFillStrokeStyle(null, o), u[s(165)](t, n, i);
  }
  const a = e[s(154)]();
  if (a && a.getText()) {
    const u = r[s(191)](e.getZIndex(), s(172));
    u[s(190)](a), u.drawText(t, n, i);
  }
}
function uC(r, t, e, n, i) {
  const s = Ci, o = e[s(194)](), a = e[s(181)]();
  if (a || o) {
    const x = r.getBuilder(e.getZIndex(), s(160));
    x[s(179)](o, a), x[s(195)](t, n, i);
  }
  const u = e[s(154)]();
  if (u && u[s(154)]()) {
    const x = r[s(191)](e[s(164)](), "Text");
    x.setTextStyle(u), x[s(170)](t, n, i);
  }
}
function xC(r, t, e, n, i, s) {
  const o = Ci, a = e[o(152)](), u = e[o(154)](), x = u && u.getText(), c = s && a && x ? {} : void 0;
  if (a) {
    if (a[o(182)]() != Et[o(193)]) return;
    const f = r[o(191)](e[o(164)](), o(185));
    f.setImageStyle(a, c), f[o(166)](t, n, i);
  }
  if (x) {
    const f = r[o(191)](e[o(164)](), "Text");
    f[o(190)](u, c), f[o(170)](t, n, i);
  }
}
function cC(r, t, e, n, i, s) {
  const o = Ci, a = e[o(152)](), u = a && a[o(174)]() !== 0, x = e[o(154)](), c = x && x.getText(), f = s && u && c ? {} : void 0;
  if (u) {
    if (a[o(182)]() != Et[o(193)]) return;
    const l = r.getBuilder(e[o(164)](), o(185));
    l.setImageStyle(a, f), l.drawMultiPoint(t, n, i);
  }
  if (c) {
    const l = r[o(191)](e[o(164)](), o(172));
    l[o(190)](x, f), l[o(170)](t, n, i);
  }
}
function fC(r, t, e, n, i) {
  const s = Ci, o = e[s(194)](), a = e[s(181)]();
  if (o || a) {
    const x = r[s(191)](e[s(164)](), s(160));
    x.setFillStrokeStyle(o, a), x.drawPolygon(t, n, i);
  }
  const u = e[s(154)]();
  if (u && u.getText()) {
    const x = r[s(191)](e[s(164)](), s(172));
    x[s(190)](u), x[s(170)](t, n, i);
  }
}
const Rn = Cx;
(function(r, t) {
  const e = Cx, n = r();
  for (; ; )
    try {
      if (-parseInt(e(217)) / 1 + parseInt(e(204)) / 2 + -parseInt(e(187)) / 3 + parseInt(e(189)) / 4 + -parseInt(e(207)) / 5 + -parseInt(e(199)) / 6 * (-parseInt(e(195)) / 7) + parseInt(e(150)) / 8 * (parseInt(e(201)) / 9) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Vd, 736063);
function Cx(r, t) {
  const e = Vd();
  return Cx = function(n, i) {
    return n = n - 144, e[n];
  }, Cx(r, t);
}
function Vd() {
  const r = ["25338RHSSxJ", "ceil", "9fJwnIN", "viewHints", "renderFrame", "1968940eerelG", "width", "animatingOrInteracting_", "6803380KUWBod", "renderedFrameDeclutter_", "geometry", "getOverlaps", "execute", "clipping", "ANIMATING", "finish", "renderedFeatures_", "globalAlpha", "1454446oDCiBa", "renderedExtent_", "renderedCenter_", "length", "getFeatures", "declutter", "renderDeferred", "size", "viewState", "container", "renderDeclutter", "resolution", "renderedRenderOrder_", "context", "frameState", "resetDrawContext_", "opacity", "pixelRatio", "center", "renderedRevision_", "renderedRotation_", "replayGroup_", "getDeclutter", "map", "extent", "layerStatesArray", "bind", "renderedPixelRatio_", "max", "getRenderOrder", "handleFontsChanged", "clipUnrotated", "INTERACTING", "targetContext_", "10747680CIPHky", "getRenderBuffer", "getUpdateWhileAnimating", "changed", "floor", "postRender", "prepareFrame", "rotation", "canWrapX", "getExtent", "getUpdateWhileInteracting", "hitDetectionImageData_", "renderFeature", "canvas", "clipped_", "push", "getVisible", "getRevision", "getStyleFunction", "opacity_", "loadFeatures", "renderWorlds", "hasListener", "renderedProjection_", "setDrawContext_", "some", "distanceSq", "value", "wrappedRenderedExtent_", "handleStyleImageChange_", "ready", "replayGroupChanged", "round", "renderedResolution_", "projection", "boundHandleStyleImageChange_", "getLayer", "2579655WNIkOY", "slice", "2471036ePyxmq", "forEachFeatureAtCoordinate", "isEmpty", "restore", "getRenderTransform", "height", "2429dtYMUv", "splice", "getWrapX", "getSource"];
  return Vd = function() {
    return r;
  }, Vd();
}
class lC extends V7 {
  constructor(t) {
    const e = Cx;
    super(t), this[e(185)] = this[e(179)][e(243)](this), this.animatingOrInteracting_, this[e(161)] = null, this[e(164)] = !1, this[e(215)] = null, this[e(236)] = -1, this[e(183)] = NaN, this.renderedExtent_ = Hs(), this[e(178)] = Hs(), this.renderedRotation_, this[e(219)] = null, this[e(173)] = null, this[e(244)] = 1, this[e(229)] = null, this[e(208)], this.replayGroup_ = null, this[e(181)] = !0, this[e(212)] = !0, this[e(149)] = null, this[e(169)] = 1;
  }
  [Rn(171)](t, e, n) {
    const i = Rn, s = e[i(241)], o = e.viewState, a = o[i(235)], u = o[i(228)], x = o[i(184)], c = o[i(157)], f = x[i(159)](), l = this.getLayer()[i(198)](), h = this[i(186)]()[i(239)](), p = e.pixelRatio, y = e[i(202)], v = !(y[us[i(213)]] || y[us[i(148)]]), m = this[i(230)], d = Math[i(182)](vi(s) / u * p), g = Math.round(xa(s) / u * p), _ = l[i(197)]() && x[i(158)](), b = _ ? vi(f) : null, w = _ ? Math[i(200)]((s[2] - f[2]) / b) + 1 : 1;
    let E = _ ? Math[i(154)]((s[0] - f[0]) / b) : 0;
    do {
      let S = this[i(193)](a, u, 0, p, d, g, E * b);
      e[i(222)] && (S = S[i(188)](0)), t[i(211)](m, [m.canvas[i(205)], m[i(163)][i(194)]], S, c, v, n === void 0 ? Yu : n ? j4 : Z7, n ? h && e.declutter[h] : void 0);
    } while (++E < w);
  }
  [Rn(174)]() {
    const t = Rn;
    this[t(169)] !== 1 && (this.targetContext_ = this[t(230)], this[t(230)] = Ui(this.context[t(163)][t(205)], this[t(230)][t(163)][t(194)], t5));
  }
  [Rn(232)]() {
    const t = Rn;
    if (this[t(169)] !== 1) {
      const e = this.targetContext_.globalAlpha;
      this[t(149)][t(216)] = this[t(169)], this[t(149)].drawImage(this[t(230)][t(163)], 0, 0), this.targetContext_.globalAlpha = e, b9(this[t(230)]), t5.push(this[t(230)][t(163)]), this.context = this[t(149)], this[t(149)] = null;
    }
  }
  [Rn(227)](t) {
    const e = Rn;
    !this.replayGroup_ || !this[e(186)]()[e(239)]() || this[e(171)](this[e(238)], t, !0);
  }
  renderDeferredInternal(t) {
    const e = Rn;
    this[e(238)] && (this[e(238)][e(223)](), this[e(164)] && this.context[e(192)](), this.resetDrawContext_());
  }
  [Rn(203)](t, e) {
    const n = Rn, i = t[n(242)][t.layerIndex];
    this.opacity_ = i[n(233)];
    const s = t[n(225)];
    this.prepareContainer(t, e);
    const o = this[n(230)], a = this.replayGroup_;
    let u = a && !a[n(191)]();
    if (!u && !(this[n(186)]()[n(172)](C0.PRERENDER) || this[n(186)]().hasListener(C0.POSTRENDER)))
      return null;
    if (this[n(174)](), this.preRender(o, t), s[n(184)], this.clipped_ = !1, u && i[n(241)] && this[n(212)]) {
      const x = Bu(i[n(241)]);
      u = hs(x, t[n(241)]), this.clipped_ = u && !Fu(x, t[n(241)]), this[n(164)] && this[n(147)](o, t, x);
    }
    return u && this[n(171)](a, t, this.getLayer()[n(239)]() ? !1 : void 0), !t[n(222)] && this[n(164)] && o[n(192)](), this[n(155)](o, t), this[n(237)] !== s[n(157)] && (this.renderedRotation_ = s[n(157)], this[n(161)] = null), !t[n(222)] && this.resetDrawContext_(), this[n(226)];
  }
  [Rn(221)](t) {
    return new Promise((e) => {
      const n = Cx;
      if (this[n(231)] && !this[n(161)] && !this[n(206)]) {
        const i = this[n(231)][n(224)][n(188)](), s = this[n(219)], o = this[n(183)], a = this.renderedRotation_, u = this[n(173)], x = this[n(178)], c = this[n(186)](), f = [], l = i[0] * go, h = i[1] * go;
        f[n(165)](this[n(193)](s, o, a, go, l, h, 0)[n(188)]());
        const p = c[n(198)](), y = u.getExtent();
        if (p.getWrapX() && u[n(158)]() && !Fu(y, x)) {
          let v = x[0];
          const m = vi(y);
          let d = 0, g;
          for (; v < y[0]; )
            --d, g = m * d, f[n(165)](this.getRenderTransform(s, o, a, go, l, h, g)[n(188)]()), v += m;
          for (d = 0, v = x[2]; v > y[2]; )
            ++d, g = m * d, f[n(165)](this[n(193)](s, o, a, go, l, h, g)[n(188)]()), v -= m;
        }
        this.hitDetectionImageData_ = $7(i, f, this[n(215)], c[n(168)](), x, o, a, r5(o, this[n(244)]));
      }
      e(tC(t, this[n(215)], this[n(161)]));
    });
  }
  [Rn(190)](t, e, n, i, s) {
    const o = Rn;
    if (!this[o(238)]) return;
    const a = e[o(225)][o(228)], u = e[o(225)].rotation, x = this[o(186)](), c = {}, f = function(y, v, m) {
      const d = o, g = ve(y), _ = c[g];
      if (_) {
        if (_ !== !0 && m < _[d(176)]) {
          if (m === 0) return c[g] = !0, s[d(196)](s.lastIndexOf(_), 1), i(y, x, v);
          _[d(209)] = v, _.distanceSq = m;
        }
      } else {
        if (m === 0) return c[g] = !0, i(y, x, v);
        s[d(165)](c[g] = { feature: y, layer: x, geometry: v, distanceSq: m, callback: i });
      }
    };
    let l;
    const h = [this[o(238)]], p = this[o(186)]().getDeclutter();
    return h[o(175)]((y) => {
      const v = o;
      return l = y.forEachFeatureAtCoordinate(t, a, u, n, f, p && e.declutter[p] ? e[v(222)][p].all()[v(240)]((m) => m[v(177)]) : null);
    }), l;
  }
  [Rn(146)]() {
    const t = Rn, e = this[t(186)]();
    e[t(166)]() && this[t(238)] && e[t(153)]();
  }
  [Rn(179)](t) {
    this.renderIfReadyAndVisible();
  }
  [Rn(156)](t) {
    const e = Rn, n = this.getLayer(), i = n[e(198)]();
    if (!i) return !1;
    const s = t[e(202)][us[e(213)]], o = t[e(202)][us.INTERACTING], a = n[e(152)](), u = n[e(160)]();
    if (this[e(180)] && !a && s || !u && o) return this[e(206)] = !0, !0;
    this[e(206)] = !1;
    const x = t[e(241)], c = t[e(225)], f = c.projection, l = c[e(228)], h = t[e(234)], p = n[e(167)](), y = n[e(151)]();
    let v = n[e(145)]();
    v === void 0 && (v = nC);
    const m = c[e(235)][e(188)](), d = ec(x, y * l), g = d[e(188)](), _ = [d[e(188)]()], b = f[e(159)]();
    if (i[e(197)]() && f.canWrapX() && !Fu(b, t[e(241)])) {
      const k = vi(b), D = Math[e(144)](vi(d) / 2, k);
      d[0] = b[0] - D, d[2] = b[2] + D, P8(m, f);
      const F = c4(_[0], f);
      F[0] < b[0] && F[2] < b[2] ? _[e(165)]([F[0] + k, F[1], F[2] + k, F[3]]) : F[0] > b[0] && F[2] > b[2] && _[e(165)]([F[0] - k, F[1], F[2] - k, F[3]]);
    }
    if (this[e(180)] && this[e(183)] == l && this[e(236)] == p && this[e(229)] == v && this[e(208)] === !!t[e(222)] && Fu(this.wrappedRenderedExtent_, d)) return !uu(this[e(218)], g) && (this[e(161)] = null, this[e(218)] = g), this[e(219)] = m, this[e(181)] = !1, !0;
    this[e(238)] = null;
    const w = new Y7($4(l, h), d, l, h);
    let E;
    for (let k = 0, D = _.length; k < D; ++k)
      i[e(170)](_[k], l, f);
    const S = r5(l, h);
    let I = !0;
    const L = (k, D) => {
      const F = e;
      let X;
      const W = k[F(168)]() || n[F(168)]();
      if (W && (X = W(k, l)), X) {
        const U = this[F(162)](k, S, X, w, E, this[F(186)]()[F(239)](), D);
        I = I && !U;
      }
    }, M = py(d), N = i.getFeaturesInExtent(M);
    v && N.sort(v);
    for (let k = 0, D = N[e(220)]; k < D; ++k)
      L(N[k], k);
    this[e(215)] = N, this[e(180)] = I;
    const P = w[e(214)](), O = new K7(d, l, h, i[e(210)](), P, n.getRenderBuffer(), !!t[e(222)]);
    return this[e(183)] = l, this[e(236)] = p, this[e(229)] = v, this[e(208)] = !!t.declutter, this.renderedExtent_ = g, this[e(178)] = d, this.renderedCenter_ = m, this[e(173)] = f, this.renderedPixelRatio_ = h, this.replayGroup_ = O, this[e(161)] = null, this.replayGroupChanged = !0, !0;
  }
  [Rn(162)](t, e, n, i, s, o, a) {
    const u = Rn;
    if (!n) return !1;
    let x = !1;
    if (Array.isArray(n)) for (let c = 0, f = n.length; c < f; ++c)
      x = i5(i, t, n[c], e, this[u(185)], s, o, a) || x;
    else x = i5(i, t, n, e, this[u(185)], s, o, a);
    return x;
  }
}
var hC = Wd;
(function(r, t) {
  for (var e = Wd, n = r(); ; )
    try {
      var i = -parseInt(e(175)) / 1 * (-parseInt(e(174)) / 2) + parseInt(e(167)) / 3 * (-parseInt(e(173)) / 4) + -parseInt(e(170)) / 5 + -parseInt(e(168)) / 6 * (parseInt(e(172)) / 7) + -parseInt(e(177)) / 8 + parseInt(e(169)) / 9 * (-parseInt(e(176)) / 10) + parseInt(e(178)) / 11;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Hd, 289219);
function Wd(r, t) {
  var e = Hd();
  return Wd = function(n, i) {
    n = n - 167;
    var s = e[n];
    return s;
  }, Wd(r, t);
}
class Bl extends R7 {
  constructor(t) {
    super(t);
  }
  [hC(171)]() {
    return new lC(this);
  }
}
function Hd() {
  var r = ["55892FIASVp", "48hJszKS", "6581cEqlcP", "10eKGEWh", "2701640rfBwyz", "17714686igMFEE", "111vkRoNw", "2100bbrBXr", "2779335TUKXsX", "592900nRdeRD", "createRenderer", "3941VAiaWV"];
  return Hd = function() {
    return r;
  }, Hd();
}
var Iu = Jd;
(function(r, t) {
  for (var e = Jd, n = r(); ; )
    try {
      var i = parseInt(e(145)) / 1 + parseInt(e(153)) / 2 * (-parseInt(e(154)) / 3) + parseInt(e(158)) / 4 + parseInt(e(157)) / 5 + parseInt(e(150)) / 6 + parseInt(e(149)) / 7 + parseInt(e(151)) / 8 * (-parseInt(e(148)) / 9);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Zd, 386381);
function Jd(r, t) {
  var e = Zd();
  return Jd = function(n, i) {
    n = n - 144;
    var s = e[n];
    return s;
  }, Jd(r, t);
}
const Or = { SINGLECLICK: Iu(147), CLICK: rr.CLICK, DBLCLICK: rr.DBLCLICK, POINTERDRAG: Iu(152), POINTERMOVE: Iu(155), POINTERDOWN: Iu(146), POINTERUP: "pointerup", POINTEROVER: Iu(144), POINTEROUT: "pointerout", POINTERENTER: Iu(156), POINTERLEAVE: "pointerleave", POINTERCANCEL: "pointercancel" };
function Zd() {
  var r = ["2246420vbrwHW", "193460VDiUhq", "pointerover", "511130CjPPIq", "pointerdown", "singleclick", "81GCrgdK", "2983449KuRJLC", "4209900iMGuIm", "1301056EjaPtS", "pointerdrag", "1126GtNzXZ", "1527UsuNaZ", "pointermove", "pointerenter"];
  return Zd = function() {
    return r;
  }, Zd();
}
const wu = $f;
(function(r, t) {
  const e = $f, n = r();
  for (; ; )
    try {
      if (parseInt(e(468)) / 1 * (-parseInt(e(471)) / 2) + parseInt(e(475)) / 3 * (parseInt(e(486)) / 4) + parseInt(e(470)) / 5 * (parseInt(e(482)) / 6) + -parseInt(e(478)) / 7 * (parseInt(e(494)) / 8) + -parseInt(e(489)) / 9 * (parseInt(e(496)) / 10) + parseInt(e(483)) / 11 + -parseInt(e(487)) / 12 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Kd, 178063);
function $f(r, t) {
  const e = Kd();
  return $f = function(n, i) {
    return n = n - 468, e[n];
  }, $f(r, t);
}
function Kd() {
  const r = ["getPointerCount", "updateTrackedPointers_", "49676luXPyS", "590616FgcIXw", "handlingDownUpSequence", "36UrMaBQ", "handleDragEvent", "POINTERDOWN", "handleMoveEvent", "originalEvent", "24KevkoD", "preventDefault", "351210cxUoGw", "handleDownEvent", "89671QLhTYK", "length", "430igvYQG", "2oybxCr", "clientX", "handleEvent", "handleUpEvent", "57ohbfgW", "targetPointers", "POINTERUP", "30009ZOFOuH", "POINTERDRAG", "stopDown", "type", "9054lMOTXA", "1150182aqphoa"];
  return Kd = function() {
    return r;
  }, Kd();
}
class Iy extends hy {
  constructor(t) {
    const e = $f;
    t = t || {}, super(t), t[e(497)] && (this[e(497)] = t[e(497)]), t[e(490)] && (this[e(490)] = t[e(490)]), t.handleMoveEvent && (this[e(492)] = t[e(492)]), t[e(474)] && (this[e(474)] = t[e(474)]), t[e(480)] && (this[e(480)] = t[e(480)]), this.handlingDownUpSequence = !1, this[e(476)] = [];
  }
  [wu(484)]() {
    const t = wu;
    return this[t(476)][t(469)];
  }
  handleDownEvent(t) {
    return !1;
  }
  handleDragEvent(t) {
  }
  [wu(473)](t) {
    const e = wu;
    if (!t[e(493)]) return !0;
    let n = !1;
    if (this[e(485)](t), this[e(488)]) {
      if (t.type == Or[e(479)]) this.handleDragEvent(t), t[e(493)][e(495)]();
      else if (t[e(481)] == Or[e(477)]) {
        const i = this[e(474)](t);
        this[e(488)] = i && this[e(476)][e(469)] > 0;
      }
    } else if (t[e(481)] == Or[e(491)]) {
      const i = this[e(497)](t);
      this[e(488)] = i, n = this[e(480)](i);
    } else t[e(481)] == Or.POINTERMOVE && this[e(492)](t);
    return !n;
  }
  [wu(492)](t) {
  }
  [wu(474)](t) {
    return !1;
  }
  stopDown(t) {
    return t;
  }
  updateTrackedPointers_(t) {
    t.activePointers && (this.targetPointers = t.activePointers);
  }
}
var wt = po;
(function(r, t) {
  for (var e = po, n = r(); ; )
    try {
      var i = parseInt(e(278)) / 1 * (parseInt(e(295)) / 2) + parseInt(e(259)) / 3 * (-parseInt(e(319)) / 4) + parseInt(e(238)) / 5 + parseInt(e(305)) / 6 + parseInt(e(288)) / 7 * (-parseInt(e(289)) / 8) + -parseInt(e(350)) / 9 + -parseInt(e(256)) / 10 * (parseInt(e(311)) / 11);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(jd, 164548);
function jd() {
  var r = ["_featureListeners", "feature", "getRadius", "propertychange", "setGeometry", "_movePoint", "angle_", "nwse-resize", "shiftKey", "getText", "buffer", "addCondition", "center", "constraint_", "getFeatures", "previousCursor_", "translateFeature", "function", "stretch", "features", "auto", "getType", "getSource", "setScale", "setCenterAndRadius", "_isRectangle", "handles_", "change", "setDisplacement", "pixel_", "stroke", "translateBBox", "setCenter", "getAnchor", "hitTolerance", "coordinate", "clone", "atan2", "noFlip", "1482150vnqMQL", "selection", "item", "_pointRadius", "unshift", "opt_", "nesw-resize", "clear", "getView", "Point", "getCoordinateFromPixel", "handle", "translate", "bind", "overlayLayer_", "handleDragEvent_", "pointer", "keepRectangle", "10LxzVSj", "indexOf", "features_", "266313HrvGma", "ew-resize", "ispt", "getPixelFromCoordinate", "iscircle_", "mode_", "getFeatureAtPixel_", "getViewport", "rotate0", "default", "layers_", "_filter", "length", "removeAt", "getMap", "getExtent", "getTargetElement", "filter", "prototype", "66853LyPtKz", "start", "select", "handleUpEvent_", "forEach", "map", "setStyle", "dispatchEvent", "set", "selection_", "1281jyVWnk", "1928qOupVs", "Circle", "ns-resize", "test", "_handleEvent", "option", "6IsArhm", "setPointRadius", "addFeature", "keepAspectRatio", "rotate", "enableRotatedTransform", "metaKey", "setMap", "bbox_", "pixel", "1696752ovCVwA", "layers", "getGeometry", "handleDownEvent_", "push", "scaling", "3048639tzZMSB", "Polygon", "rotatedExtent_", "includes", "isUpdating_", "getLength", "setActive", "getArray", "4UjvEKv", "style", "fill", "watchFeatures_", "originalEvent", "cursor", "constraint", "modifyCenter", "rotatedGeoms_", "ispt_", "coordinate_", "_projectVectorOnVector", "get", "setDefaultStyle", "getGeometryRotateToZero_", "getRotation", "getCoordinates", "_countVector", "isTouch", "translating", "drawSketch_", "Cursors", "center_", "setOffsetX", "getCenter", "geoms_", "addFn_", "scale", "setSelection", "handleMoveEvent_", "move", "1846890MUNxhx"];
  return jd = function() {
    return r;
  }, jd();
}
function po(r, t) {
  var e = jd();
  return po = function(n, i) {
    n = n - 212;
    var s = e[n];
    return s;
  }, po(r, t);
}
var ew = class extends Iy {
  constructor(t) {
    var e = po;
    t = t || {}, super({ handleDownEvent: function(i) {
      var s = po;
      return n[s(308)](i);
    }, handleDragEvent: function(i) {
      var s = po;
      return this[s(253)](i);
    }, handleMoveEvent: function(i) {
      var s = po;
      return this[s(348)](i);
    }, handleUpEvent: function(i) {
      var s = po;
      return this[s(281)](i);
    } });
    var n = this;
    this.selection_ = new aa(), this[e(225)] = new aa(), this[e(252)] = new Bl({ source: new vy({ features: this[e(225)], useSpatialIndex: !1, wrapX: !1 }), name: "Transform overlay", displayInLayerSwitcher: !1, style: function(i) {
      var s = e;
      return n[s(320)][(i[s(331)](s(249)) || s(268)) + (i.get("constraint") || "") + (i[s(331)](s(294)) || "")];
    } }), this[e(258)] = t[e(218)], typeof t[e(276)] === e(216) && (this._filter = t[e(276)]), this[e(269)] = t[e(306)] ? t.layers instanceof Array ? t[e(306)] : [t.layers] : null, this[e(293)] = t.condition || function() {
      return !0;
    }, this[e(345)] = t[e(362)] || function() {
      return !1;
    }, this[e(296)](t.pointRadius), this[e(286)](e(215), t.translateFeature !== !1), this[e(286)](e(250), t[e(250)] !== !1), this[e(286)](e(230), t.translateBBox === !0), this[e(286)]("stretch", t[e(217)] !== !1), this[e(286)]("scale", t[e(346)] !== !1), this.set(e(299), t[e(299)] !== !1), this[e(286)](e(298), t[e(298)] || function(i) {
      var s = e;
      return i[s(323)][s(359)];
    }), this[e(286)]("modifyCenter", t[e(326)] || function(i) {
      var s = e;
      return i[s(323)][s(301)] || i[s(323)].ctrlKey;
    }), this[e(286)]("noFlip", t[e(237)] || !1), this[e(286)](e(239), t.selection !== !1), this[e(286)](e(233), t[e(233)] || 0), this.set(e(300), t.enableRotatedTransform || !1), this.set(e(255), t[e(255)] || !1), this[e(286)]("buffer", t[e(361)] || 0), this.on(e(354), function() {
      var i = e;
      this[i(339)]();
    }), this.setDefaultStyle();
  }
  [wt(302)](t) {
    var e = wt, n = this[e(273)]();
    if (n) {
      var i = n[e(275)]();
      n.removeLayer(this.overlayLayer_), this.previousCursor_ && i && (i[e(320)][e(324)] = this[e(214)]), this[e(214)] = void 0;
    }
    super[e(302)](t), this[e(252)][e(302)](t), t === null && this.select(null), t !== null && (this[e(337)] = /touch/[e(292)](t[e(266)]().className), this.setDefaultStyle());
  }
  [wt(317)](t) {
    var e = wt;
    this[e(280)](null), this[e(252)] && this[e(252)].setVisible(t), super[e(317)](t);
  }
  [wt(332)](t) {
    var e = wt;
    t = t || {};
    var n = t.pointStroke || new ys({ color: [255, 0, 0, 1], width: 1 }), i = t[e(229)] || new ys({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] }), s = t[e(321)] || new Hr({ color: [255, 0, 0, 0.01] }), o = t.pointFill || new Hr({ color: [255, 255, 255, 0.8] }), a = new _o({ fill: o, stroke: n, radius: this[e(337)] ? 12 : 6, displacement: this[e(337)] ? [24, -24] : [12, -12], points: 15 });
    a[e(227)] || (a[e(232)]()[0] = this[e(337)] ? -10 : -5);
    var u = new _o({ fill: o, stroke: n, radius: this.isTouch ? 16 : 8, points: 4, angle: Math.PI / 4 }), x = new _o({ fill: o, stroke: n, radius: this[e(337)] ? 12 : 6, points: 4, angle: Math.PI / 4 });
    function c(f, l, h) {
      return [new En({ image: f, stroke: l, fill: h })];
    }
    this[e(320)] = { default: c(u, i, s), translate: c(u, n, o), rotate: c(a, n, o), rotate0: c(u, n, o), scale: c(u, n, o), scale1: c(u, n, o), scale2: c(u, n, o), scale3: c(u, n, o), scalev: c(x, n, o), scaleh1: c(x, n, o), scalev2: c(x, n, o), scaleh3: c(x, n, o) }, this[e(339)]();
  }
  [wt(284)](t, e) {
    var n = wt;
    if (e) {
      e instanceof Array ? this[n(320)][t] = e : this[n(320)][t] = [e];
      for (var i = 0; i < this[n(320)][t].length; i++) {
        var s = this[n(320)][t][i].getImage();
        s && (t == n(299) && (s[n(232)]()[0] = -5), this.isTouch && s[n(222)](1.8));
        var o = this[n(320)][t][i][n(360)]();
        o && (t == n(299) && o[n(342)](this.isTouch ? 14 : 7), this[n(337)] && o[n(222)](1.8));
      }
      this.drawSketch_();
    }
  }
  [wt(265)](t) {
    var e = wt, n = this;
    return this.getMap().forEachFeatureAtPixel(t, function(i, s) {
      var o = po, a = !1;
      if (!s) {
        if (i === n[o(303)]) return n.get("translateBBox") ? { feature: i, handle: o(250), constraint: "", option: "" } : !1;
        if (n[o(225)][o(282)](function(x) {
          x === i && (a = !0);
        }), a) return { feature: i, handle: i[o(331)](o(249)), constraint: i[o(331)]("constraint"), option: i.get(o(294)) };
      }
      if (!n[o(331)](o(239)))
        return n[o(287)][o(318)]().some(function(x) {
          return i === x;
        }) ? { feature: i } : null;
      if (n[o(270)])
        return n._filter(i, s) ? { feature: i } : null;
      if (n[o(269)]) {
        for (var u = 0; u < n[o(269)][o(271)]; u++)
          if (n.layers_[u] === s) return { feature: i };
        return null;
      } else
        return n[o(258)] ? (n[o(258)][o(282)](function(x) {
          x === i && (a = !0);
        }), a ? { feature: i } : null) : { feature: i };
    }, { hitTolerance: this.get(e(233)) }) || {};
  }
  getGeometryRotateToZero_(t, e) {
    var n = wt, i = t[n(307)](), s = this[n(273)]().getView()[n(334)]();
    if (s === 0 || !this[n(331)]("enableRotatedTransform")) return e ? i[n(235)]() : i;
    var o = i[n(235)]();
    return o[n(299)](s * -1, this[n(273)]()[n(246)]()[n(343)]()), o;
  }
  [wt(224)](t) {
    var e = wt;
    if (this[e(331)](e(255)) && t[e(220)]() === e(312)) {
      var n = t[e(335)]()[0];
      return n.length === 5;
    }
    return !1;
  }
  drawSketch_(t) {
    var e = wt, n, i, s, o = this.selection_[e(240)](0) && this[e(224)](this.selection_[e(240)](0)[e(307)]());
    if (this[e(252)][e(221)]()[e(245)](), !!this[e(287)][e(316)]()) {
      var a = this[e(273)]()[e(246)]().getRotation(), u = this[e(333)](this.selection_.item(0))[e(274)](), x;
      o && (x = this.getGeometryRotateToZero_(this[e(287)][e(240)](0))[e(335)]()[0].slice(0, 4), x[e(242)](x[3])), u = ec(u, this[e(331)]("buffer")), this[e(287)][e(282)]((function(v) {
        var m = e, d = this[m(333)](v)[m(274)]();
        kh(u, d);
      }).bind(this));
      var c = this.selection_[e(316)]() === 1 ? this[e(241)](this[e(287)][e(240)](0)) : 0;
      if (c && !(c instanceof Array) && (c = [c, c]), t === !0) !this[e(328)] && (this[e(252)].getSource()[e(297)](new An({ geometry: new tr(this.center_), handle: e(267) })), s = Gu(u), this[e(331)](e(300)) && a !== 0 && s[e(299)](a, this[e(273)]()[e(246)]()[e(343)]()), i = this[e(303)] = new An(s), this[e(252)].getSource()[e(297)](i));
      else {
        if (this[e(328)]) {
          var f = this[e(273)]()[e(262)]([u[0], u[1]]);
          if (f) {
            var l = c && c[0] || 10, h = c && c[1] || 10;
            u = di([this[e(273)]()[e(248)]([f[0] - l, f[1] - h]), this[e(273)]().getCoordinateFromPixel([f[0] + l, f[1] + h])]);
          }
        }
        s = o ? new F0([x]) : Gu(u), this[e(331)](e(300)) && a !== 0 && s[e(299)](a, this.getMap().getView()[e(343)]()), i = this[e(303)] = new An(s);
        var p = [], y = s[e(335)]()[0];
        if (!this[e(328)] || c) {
          if (p.push(i), !this[e(263)] && !this[e(328)] && this.get(e(217)) && this[e(331)](e(346))) for (n = 0; n < y.length - 1; n++)
            i = new An({ geometry: new tr([(y[n][0] + y[n + 1][0]) / 2, (y[n][1] + y[n + 1][1]) / 2]), handle: e(346), constraint: n % 2 ? "h" : "v", option: n }), p[e(309)](i);
          if (this[e(331)](e(346))) for (n = 0; n < y[e(271)] - 1; n++)
            i = new An({ geometry: new tr(y[n]), handle: e(346), option: n }), p[e(309)](i);
          this[e(331)]("translate") && !this[e(331)](e(215)) && (i = new An({ geometry: new tr([(y[0][0] + y[2][0]) / 2, (y[0][1] + y[2][1]) / 2]), handle: e(250) }), p.push(i));
        }
        !this[e(263)] && this[e(331)](e(299)) && (i = new An({ geometry: new tr(y[3]), handle: e(299) }), p[e(309)](i)), this.overlayLayer_[e(221)]().addFeatures(p);
      }
    }
  }
  [wt(280)](t, e) {
    var n = wt;
    if (!t) {
      this[n(287)] && (this[n(287)][n(245)](), this.drawSketch_());
      return;
    }
    if (!(!t.getGeometry || !t[n(307)]())) {
      if (e) this[n(287)].push(t);
      else {
        var i = this[n(287)][n(318)]().indexOf(t);
        this[n(287)].removeAt(i);
      }
      this.ispt_ = this[n(287)][n(316)]() === 1 ? this[n(287)][n(240)](0)[n(307)]()[n(220)]() == n(247) : !1, this[n(263)] = this[n(287)][n(316)]() === 1 ? this.selection_[n(240)](0)[n(307)]()[n(220)]() == "Circle" : !1, this.drawSketch_(), this[n(322)](), this.dispatchEvent({ type: n(280), feature: t, features: this.selection_ });
    }
  }
  [wt(347)](t) {
    var e = wt;
    this[e(287)][e(245)](), t[e(282)]((function(n) {
      var i = e;
      this[i(287)][i(309)](n);
    })[e(251)](this)), this[e(328)] = this[e(287)][e(316)]() === 1 ? this[e(287)].item(0)[e(307)]().getType() == e(247) : !1, this[e(263)] = this[e(287)][e(316)]() === 1 ? this.selection_[e(240)](0)[e(307)]().getType() == e(290) : !1, this[e(339)](), this[e(322)](), this[e(285)]({ type: e(280), features: this[e(287)] });
  }
  [wt(322)]() {
    var t = wt;
    this._featureListeners && this[t(351)].forEach(function(e) {
      qc(e);
    }), this[t(351)] = [], this[t(287)][t(282)]((function(e) {
      var n = t;
      this._featureListeners[n(309)](e.on(n(226), (function() {
        var i = n;
        !this.isUpdating_ && this[i(339)]();
      })[n(251)](this)));
    })[t(251)](this));
  }
  [wt(308)](t) {
    var e = wt;
    if (this[e(293)](t, this.selection_)) {
      var n = this[e(265)](t[e(304)]), i = n[e(352)];
      if (this[e(287)][e(316)]() && this.selection_[e(318)]()[e(257)](i) >= 0 && (this[e(328)] && this[e(331)](e(250)) || this[e(331)](e(215))) && (n.handle = e(250)), n[e(249)]) {
        this[e(264)] = n[e(249)], this.opt_ = n[e(294)], this.constraint_ = n[e(325)];
        var s = this[e(273)]()[e(246)]()[e(334)]();
        this[e(329)] = i[e(331)](e(249)) ? i[e(307)]()[e(335)]() : t.coordinate, this[e(228)] = this[e(273)]()[e(248)](this[e(329)]), this.geoms_ = [], this[e(327)] = [];
        for (var o = Hs(), a = Hs(), u = 0, x; x = this[e(287)][e(240)](u); u++)
          if (this[e(344)].push(x[e(307)]()[e(235)]()), o = kh(o, x[e(307)]()[e(274)]()), this.get(e(300)) && s !== 0) {
            var c = this[e(333)](x, !0);
            this[e(327)][e(309)](c), a = kh(a, c[e(274)]());
          }
        if (this.extent_ = Gu(o)[e(335)]()[0], this[e(331)]("enableRotatedTransform") && s !== 0 && (this[e(313)] = Gu(a)[e(335)]()[0]), this.mode_ === "rotate") {
          this.center_ = this[e(343)]() || ua(o);
          var f = t.map.getTargetElement();
          f[e(320)][e(324)] = this[e(340)][e(267)], this[e(214)] = f.style[e(324)];
        } else this[e(341)] = ua(o);
        return this[e(357)] = Math[e(236)](this[e(341)][1] - t[e(234)][1], this[e(341)][0] - t[e(234)][0]), this[e(285)]({ type: this[e(264)] + e(279), feature: this[e(287)].item(0), features: this[e(287)], pixel: t[e(304)], coordinate: t.coordinate }), !0;
      } else if (this.get(e(239))) {
        if (i) {
          this[e(345)](t) || this.selection_[e(245)]();
          var l = this[e(287)].getArray()[e(257)](i);
          l < 0 ? this[e(287)][e(309)](i) : this.selection_[e(272)](l);
        } else this.selection_.clear();
        return this[e(328)] = this[e(287)][e(316)]() === 1 ? this[e(287)][e(240)](0)[e(307)]()[e(220)]() == e(247) : !1, this[e(263)] = this[e(287)][e(316)]() === 1 ? this[e(287)].item(0)[e(307)]().getType() == e(290) : !1, this[e(339)](), this.watchFeatures_(), this.dispatchEvent({ type: e(280), feature: i, features: this[e(287)], pixel: t[e(304)], coordinate: t[e(234)] }), !1;
      }
    }
  }
  [wt(343)]() {
    return this.get("center");
  }
  [wt(231)](t) {
    var e = wt;
    return this[e(286)](e(363), t);
  }
  [wt(253)](t) {
    var e = wt;
    if (this[e(293)](t, this.features_)) {
      var n = this[e(273)]()[e(246)]().getRotation(), i, s, o, a, u = [this[e(329)][0], this[e(329)][1]], x = [t.coordinate[0], t[e(234)][1]];
      switch (this[e(315)] = !0, this.mode_) {
        case e(299): {
          var c = Math[e(236)](this.center_[1] - x[1], this[e(341)][0] - x[0]);
          if (!this[e(261)]) for (i = 0, o; o = this[e(287)][e(240)](i); i++)
            a = this[e(344)][i][e(235)](), a[e(299)](c - this.angle_, this[e(341)]), a[e(220)]() == e(290) && a[e(223)](a.getCenter(), a[e(353)]()), o[e(355)](a);
          this[e(339)](!0), this.dispatchEvent({ type: "rotating", feature: this[e(287)][e(240)](0), features: this[e(287)], angle: c - this.angle_, pixel: t[e(304)], coordinate: t[e(234)] });
          break;
        }
        case "translate": {
          var f = x[0] - u[0], l = x[1] - u[1];
          for (i = 0, o; o = this[e(287)][e(240)](i); i++)
            o[e(307)]()[e(250)](f, l);
          this[e(225)].forEach(function(L) {
            var M = e;
            L[M(307)]()[M(250)](f, l);
          }), this[e(329)] = t[e(234)], this[e(285)]({ type: e(338), feature: this.selection_[e(240)](0), features: this[e(287)], delta: [f, l], pixel: t[e(304)], coordinate: t.coordinate });
          break;
        }
        case "scale": {
          var h = this[e(341)];
          if (this[e(331)](e(326))(t)) {
            var p = this.extent_;
            this[e(331)](e(300)) && n !== 0 && (p = this.rotatedExtent_), h = p[(Number(this[e(243)]) + 2) % 4];
          }
          var y = this[e(344)][e(271)] == 1 && this[e(224)](this[e(344)][0]), v = this[e(212)], m = this[e(243)], d = this[e(329)], g = t[e(234)];
          if (this[e(331)](e(300)) && n !== 0) {
            var _ = new tr(this.coordinate_);
            _[e(299)](n * -1, h), d = _[e(335)]();
            var b = new tr(t[e(234)]);
            b[e(299)](n * -1, h), g = b[e(335)]();
          }
          var w = (g[0] - h[0]) / (d[0] - h[0]), E = (g[1] - h[1]) / (d[1] - h[1]), S = [g[0] - d[0], g[1] - d[1]];
          if (this[e(331)](e(300)) && n !== 0) {
            var I = new tr(h);
            I.rotate(n * -1, this.getMap()[e(246)]()[e(343)]()), h = I[e(335)]();
          }
          for (this[e(331)](e(237)) && (w < 0 && (w = -w), E < 0 && (E = -E)), this.constraint_ ? this[e(212)] == "h" ? w = 1 : E = 1 : this[e(331)](e(298))(t) && (w = E = Math.min(w, E)), i = 0, o; o = this[e(287)][e(240)](i); i++)
            a = n === 0 || !this[e(331)](e(300)) ? this[e(344)][i].clone() : this[e(327)][i][e(235)](), a.applyTransform((function(L, M, N) {
              var P = e;
              if (N < 2) return M;
              if (y) {
                var O = [[6], [0, 8], [2], [4]], k = [L[0], L[1]], D = [L[2], L[3]], F = [L[4], L[5]], X = [L[6], L[7]], W = [L[8], L[9]];
                if (v) {
                  var U = m % 2 === 0 ? this[P(336)](k, D) : this[P(336)](X, k), q = this[P(330)](S, U), V = m + 1 < O[P(271)] ? m + 1 : 0, tt = [...O[m], ...O[V]];
                  for (s = 0; s < L.length; s += N)
                    M[s] = tt[P(314)](s) ? L[s] + q[0] : L[s], M[s + 1] = tt[P(314)](s) ? L[s + 1] + q[1] : L[s + 1];
                } else {
                  var $, B;
                  switch (m) {
                    case 0:
                      S = this._countVector(X, g), $ = this._projectVectorOnVector(S, this._countVector(F, X)), B = this._projectVectorOnVector(S, this[P(336)](k, X)), [M[0], M[1]] = this[P(356)](k, $), [M[4], M[5]] = this._movePoint(F, B), [M[6], M[7]] = this._movePoint(X, S), [M[8], M[9]] = this._movePoint(W, $);
                      break;
                    case 1:
                      S = this[P(336)](k, g), $ = this._projectVectorOnVector(S, this._countVector(X, k)), B = this[P(330)](S, this._countVector(D, k)), [M[0], M[1]] = this[P(356)](k, S), [M[2], M[3]] = this[P(356)](D, $), [M[6], M[7]] = this[P(356)](X, B), [M[8], M[9]] = this._movePoint(W, S);
                      break;
                    case 2:
                      S = this[P(336)](D, g), $ = this._projectVectorOnVector(S, this._countVector(k, D)), B = this[P(330)](S, this[P(336)](F, D)), [M[0], M[1]] = this._movePoint(k, B), [M[2], M[3]] = this._movePoint(D, S), [M[4], M[5]] = this[P(356)](F, $), [M[8], M[9]] = this[P(356)](W, B);
                      break;
                    case 3:
                      S = this._countVector(F, g), $ = this[P(330)](S, this[P(336)](D, F)), B = this._projectVectorOnVector(S, this[P(336)](X, F)), [M[2], M[3]] = this[P(356)](D, B), [M[4], M[5]] = this[P(356)](F, S), [M[6], M[7]] = this[P(356)](X, $);
                      break;
                  }
                }
              } else
                for (s = 0; s < L[P(271)]; s += N)
                  w != 1 && (M[s] = h[0] + (L[s] - h[0]) * w), E != 1 && (M[s + 1] = h[1] + (L[s + 1] - h[1]) * E);
              return a[P(220)]() == "Circle" && a.setCenterAndRadius(a.getCenter(), a[P(353)]()), M;
            })[e(251)](this)), this.get("enableRotatedTransform") && n !== 0 && a[e(299)](n, this.getMap()[e(246)]()[e(343)]()), o[e(355)](a);
          this[e(339)](), this[e(285)]({ type: e(310), feature: this[e(287)][e(240)](0), features: this.selection_, scale: [w, E], pixel: t[e(304)], coordinate: t.coordinate });
          break;
        }
      }
      this[e(315)] = !1;
    }
  }
  handleMoveEvent_(t) {
    var e = wt;
    if (this._handleEvent(t, this[e(258)]) && !this[e(264)]) {
      var n = this[e(265)](t[e(304)]), i = t.map[e(275)]();
      if (n[e(352)]) {
        var s = n.handle ? this[e(340)][(n.handle || e(268)) + (n[e(325)] || "") + (n[e(294)] || "")] : this[e(340)].select;
        this[e(214)] === void 0 && (this[e(214)] = i[e(320)][e(324)]), i[e(320)][e(324)] = s;
      } else
        this[e(214)] !== void 0 && (i.style[e(324)] = this[e(214)]), this[e(214)] = void 0;
    }
  }
  handleUpEvent_(t) {
    var e = wt;
    if (this[e(264)] === e(299)) {
      var n = t[e(283)][e(275)]();
      n[e(320)].cursor = this[e(340)].default, this[e(214)] = void 0;
    }
    return this.dispatchEvent({ type: this[e(264)] + "end", feature: this.selection_[e(240)](0), features: this[e(287)], oldgeom: this[e(344)][0], oldgeoms: this.geoms_ }), this[e(339)](), this[e(264)] = null, !1;
  }
  [wt(296)](t) {
    var e = wt;
    typeof t == "function" ? this[e(241)] = t : this._pointRadius = function() {
      return t;
    };
  }
  [wt(213)]() {
    var t = wt;
    return this[t(287)];
  }
  [wt(330)](t, e) {
    var n = (t[0] * e[0] + t[1] * e[1]) / (e[0] * e[0] + e[1] * e[1]);
    return [e[0] * n, e[1] * n];
  }
  [wt(336)](t, e) {
    return [e[0] - t[0], e[1] - t[1]];
  }
  [wt(356)](t, e) {
    return [t[0] + e[0], t[1] + e[1]];
  }
};
ew[wt(277)][wt(340)] = { default: wt(219), select: wt(254), translate: "move", rotate: "move", rotate0: wt(349), scale: "nesw-resize", scale1: wt(358), scale2: wt(244), scale3: wt(358), scalev: wt(260), scaleh1: wt(291), scalev2: wt(260), scaleh3: "ns-resize" };
var pC = class extends ew {
  constructor(t) {
    super(t), this.set("interactionType", t.interactionType), this.setActive(!0);
  }
};
function Qd() {
  const r = ["5UlXDDp", "getRootNode", "291WNRLEF", "length", "type", "2049096Bkrlhd", "2206116yFPJLW", "pen", "button", "hasAttribute", "DBLCLICK", "getTargetElement", "mapBrowserEvent must originate from a pointer event", "map", "ctrlKey", "27TUShdR", "pointermove", "SELECT", "SINGLECLICK", "pointerType", "8066WsIHpM", "5824496YzNXIA", "11062392pEvBlc", "shiftKey", "1463716OIInHT", "CLICK", "touch", "10qYCaFg", "altKey", "originalEvent", "activeElement", "contains", "mouse", "getOwnerDocument", "host", "isContentEditable", "metaKey", "7345870aetrmU"];
  return Qd = function() {
    return r;
  }, Qd();
}
(function(r, t) {
  const e = Ja, n = r();
  for (; ; )
    try {
      if (parseInt(e(128)) / 1 + -parseInt(e(124)) / 2 * (-parseInt(e(144)) / 3) + -parseInt(e(125)) / 4 * (-parseInt(e(142)) / 5) + parseInt(e(148)) / 6 + -parseInt(e(141)) / 7 + -parseInt(e(147)) / 8 * (parseInt(e(157)) / 9) + parseInt(e(131)) / 10 * (-parseInt(e(126)) / 11) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Qd, 855234);
const dC = function(r) {
  const t = Ja, e = r[t(133)];
  return e.altKey && !(e[t(140)] || e[t(156)]) && !e[t(127)];
}, Rm = ix, Am = x_, nw = function(r) {
  const t = Ja;
  return r.type == Or[t(122)];
}, gC = function(r) {
  const t = Ja, e = r[t(133)];
  return !e.altKey && !(e[t(140)] || e[t(156)]) && !e[t(127)];
}, k_ = function(r) {
  const t = Ja, e = r[t(133)];
  return !e[t(132)] && !(e[t(140)] || e[t(156)]) && e[t(127)];
};
function Ja(r, t) {
  const e = Qd();
  return Ja = function(n, i) {
    return n = n - 122, e[n];
  }, Ja(r, t);
}
const yC = function(r) {
  const t = Ja, e = r.originalEvent;
  return dr(e !== void 0, t(154)), e.isPrimary && e[t(150)] === 0;
}, st = tl;
(function(r, t) {
  const e = tl, n = r();
  for (; ; )
    try {
      if (-parseInt(e(560)) / 1 + parseInt(e(549)) / 2 + parseInt(e(616)) / 3 + -parseInt(e(515)) / 4 + parseInt(e(504)) / 5 * (-parseInt(e(518)) / 6) + parseInt(e(620)) / 7 * (parseInt(e(531)) / 8) + parseInt(e(570)) / 9 * (parseInt(e(507)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})($d, 673502);
function tl(r, t) {
  const e = $d();
  return tl = function(n, i) {
    return n = n - 470, e[n];
  }, tl(r, t);
}
const s5 = 0, Vc = 1, o5 = [0, 0, 0, 0], ju = [], wv = { MODIFYSTART: "modifystart", MODIFYEND: st(581) };
class Ev extends Oo {
  constructor(t, e, n) {
    super(t), this.features = e, this.mapBrowserEvent = n;
  }
}
class rw extends Iy {
  constructor(t) {
    const e = st;
    super(t), this.on, this.once, this.un, this[e(563)] = this.handleFeatureChange_[e(587)](this), this[e(471)] = t[e(479)] ? t[e(479)] : yC, this.defaultDeleteCondition_ = function(i) {
      return dC(i) && nw(i);
    }, this[e(562)] = t[e(492)] ? t[e(492)] : this[e(541)], this[e(485)] = t[e(565)] ? t[e(565)] : Rm, this[e(588)] = null, this[e(540)] = null, this.lastPixel_ = [0, 0], this[e(571)] = !1, this[e(597)] = null, this[e(618)] = new y1(), this[e(510)] = t[e(606)] !== void 0 ? t[e(606)] : 10, this[e(604)] = !1, this[e(506)] = !1, this[e(596)] = [], this.overlay_ = new Bl({ source: new vy({ useSpatialIndex: !1, wrapX: !!t[e(590)] }), style: t[e(600)] ? t.style : mC(), updateWhileAnimating: !0, updateWhileInteracting: !0 }), this[e(505)] = { Point: this.writePointGeometry_[e(587)](this), LineString: this[e(577)][e(587)](this), LinearRing: this[e(577)][e(587)](this), Polygon: this.writePolygonGeometry_[e(587)](this), MultiPoint: this[e(478)].bind(this), MultiLineString: this[e(548)][e(587)](this), MultiPolygon: this.writeMultiPolygonGeometry_[e(587)](this), Circle: this.writeCircleGeometry_[e(587)](this), GeometryCollection: this[e(514)][e(587)](this) }, this.source_ = null, this[e(602)] = null;
    let n;
    if (t[e(538)] ? n = t.features : t[e(555)] && (this[e(513)] = t[e(555)], n = new aa(this[e(513)][e(525)]()), this.source_.addEventListener(Xr.ADDFEATURE, this[e(613)][e(587)](this)), this[e(513)][e(511)](Xr[e(493)], this.handleSourceRemove_.bind(this))), !n) throw new Error("The modify interaction requires features, a source or a layer");
    t.hitDetection && (this.hitDetection_ = t[e(579)]), this.features_ = n, this[e(612)][e(558)](this[e(542)][e(587)](this)), this[e(612)].addEventListener(_i.ADD, this[e(621)][e(587)](this)), this[e(612)][e(511)](_i[e(578)], this[e(574)][e(587)](this)), this[e(559)] = null, this[e(486)] = [0, 0], this[e(487)] = t[e(575)] === void 0 ? !this[e(602)] : t[e(575)];
  }
  [st(542)](t) {
    const e = st, n = t[e(545)]();
    if (n) {
      const s = this.SEGMENT_WRITERS_[n.getType()];
      s && s(t, n);
    }
    const i = this[e(509)]();
    i && i.isRendered() && this.getActive() && this[e(615)](this[e(556)], i), t[e(511)](rr.CHANGE, this[e(563)]);
  }
  [st(551)](t, e) {
    const n = st;
    if (!this[n(597)]) {
      this.featuresBeingModified_ = new aa();
      const i = this[n(597)].getArray();
      for (let s = 0, o = e[n(490)]; s < o; ++s) {
        const a = e[s];
        for (let u = 0, x = a.length; u < x; ++u) {
          const c = a[u][n(592)];
          c && !i[n(482)](c) && this[n(597)][n(534)](c);
        }
      }
      this[n(597)][n(586)]() === 0 ? this.featuresBeingModified_ = null : this[n(475)](new Ev(wv[n(470)], this[n(597)], t));
    }
  }
  [st(536)](t) {
    const e = st;
    this[e(480)](t), this[e(588)] && this[e(612)].getLength() === 0 && (this[e(503)][e(580)]().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t[e(572)](rr.CHANGE, this[e(563)]);
  }
  [st(480)](t) {
    const e = st, n = this[e(618)], i = [];
    n.forEach(function(s) {
      const o = e;
      t === s.feature && i[o(534)](s);
    });
    for (let s = i[e(490)] - 1; s >= 0; --s) {
      const o = i[s];
      for (let a = this[e(596)][e(490)] - 1; a >= 0; --a)
        this.dragSegments_[a][0] === o && this.dragSegments_.splice(a, 1);
      n[e(498)](o);
    }
  }
  [st(594)](t) {
    const e = st;
    this[e(588)] && !t && (this[e(503)][e(580)]()[e(496)](this[e(588)]), this.vertexFeature_ = null), super[e(594)](t);
  }
  [st(582)](t) {
    const e = st;
    this.overlay_[e(582)](t), super[e(582)](t);
  }
  [st(561)]() {
    return this[st(503)];
  }
  [st(613)](t) {
    const e = st;
    t[e(592)] && this[e(612)][e(534)](t[e(592)]);
  }
  [st(539)](t) {
    const e = st;
    t.feature && this[e(612)][e(498)](t[e(592)]);
  }
  [st(621)](t) {
    const e = st;
    this[e(542)](t[e(521)]);
  }
  [st(547)](t) {
    const e = st;
    if (!this[e(506)]) {
      const n = t.target;
      this[e(536)](n), this[e(542)](n);
    }
  }
  [st(574)](t) {
    const e = st;
    this.removeFeature_(t[e(521)]);
  }
  [st(589)](t, e) {
    const n = st, i = e[n(554)](), s = { feature: t, geometry: e, segment: [i, i] };
    this[n(618)][n(585)](e[n(605)](), s);
  }
  [st(478)](t, e) {
    const n = st, i = e.getCoordinates();
    for (let s = 0, o = i[n(490)]; s < o; ++s) {
      const a = i[s], u = { feature: t, geometry: e, depth: [s], index: s, segment: [a, a] };
      this[n(618)][n(585)](e.getExtent(), u);
    }
  }
  writeLineStringGeometry_(t, e) {
    const n = st, i = e[n(554)]();
    for (let s = 0, o = i[n(490)] - 1; s < o; ++s) {
      const a = i.slice(s, s + 2), u = { feature: t, geometry: e, index: s, segment: a };
      this[n(618)].insert(di(a), u);
    }
  }
  [st(548)](t, e) {
    const n = st, i = e[n(554)]();
    for (let s = 0, o = i[n(490)]; s < o; ++s) {
      const a = i[s];
      for (let u = 0, x = a.length - 1; u < x; ++u) {
        const c = a[n(483)](u, u + 2), f = { feature: t, geometry: e, depth: [s], index: u, segment: c };
        this[n(618)][n(585)](di(c), f);
      }
    }
  }
  [st(557)](t, e) {
    const n = st, i = e[n(554)]();
    for (let s = 0, o = i[n(490)]; s < o; ++s) {
      const a = i[s];
      for (let u = 0, x = a[n(490)] - 1; u < x; ++u) {
        const c = a[n(483)](u, u + 2), f = { feature: t, geometry: e, depth: [s], index: u, segment: c };
        this[n(618)].insert(di(c), f);
      }
    }
  }
  [st(519)](t, e) {
    const n = st, i = e[n(554)]();
    for (let s = 0, o = i[n(490)]; s < o; ++s) {
      const a = i[s];
      for (let u = 0, x = a[n(490)]; u < x; ++u) {
        const c = a[u];
        for (let f = 0, l = c[n(490)] - 1; f < l; ++f) {
          const h = c.slice(f, f + 2), p = { feature: t, geometry: e, depth: [u, s], index: f, segment: h };
          this[n(618)][n(585)](di(h), p);
        }
      }
    }
  }
  [st(523)](t, e) {
    const n = st, i = e[n(476)](), s = { feature: t, geometry: e, index: s5, segment: [i, i] }, o = { feature: t, geometry: e, index: Vc, segment: [i, i] }, a = [s, o];
    s.featureSegments = a, o[n(569)] = a, this[n(618)][n(585)](zc(i), s);
    let u = e;
    this[n(618)][n(585)](u.getExtent(), o);
  }
  [st(514)](t, e) {
    const n = st, i = e[n(526)]();
    for (let s = 0; s < i[n(490)]; ++s) {
      const o = i[s], a = this[n(505)][o.getType()];
      a(t, o);
    }
  }
  [st(524)](t, e, n) {
    const i = st;
    let s = this.vertexFeature_;
    return s ? s.getGeometry()[i(508)](t) : (s = new An(new tr(t)), this[i(588)] = s, this.overlay_[i(580)]()[i(481)](s)), s[i(494)](i(538), e), s[i(494)](i(591), n), s;
  }
  [st(595)](t) {
    const e = st;
    if (!t[e(533)]) return !0;
    this[e(559)] = t;
    let n;
    return !t[e(622)][e(516)]()[e(617)]() && t[e(593)] == Or[e(566)] && !this[e(584)] && this[e(603)](t), this[e(588)] && this[e(562)](t) && (t[e(593)] != Or[e(598)] || !this[e(571)] ? n = this[e(522)]() : n = !0), t.type == Or[e(598)] && (this[e(571)] = !1), super.handleEvent(t) && !n;
  }
  handleDragEvent(t) {
    const e = st;
    this.ignoreNextSingleClick_ = !1, this[e(551)](t, this[e(596)]);
    const n = [t.coordinate[0] + this[e(486)][0], t[e(473)][1] + this[e(486)][1]], i = [], s = [];
    for (let o = 0, a = this[e(596)][e(490)]; o < a; ++o) {
      const u = this[e(596)][o], x = u[0], c = x.feature;
      !i[e(482)](c) && i[e(534)](c);
      const f = x[e(552)];
      !s.includes(f) && s[e(534)](f);
      const l = x.depth;
      let h;
      const p = x[e(614)], y = u[1];
      for (; n.length < f[e(568)](); )
        n[e(534)](p[y][n[e(490)]]);
      switch (f[e(500)]()) {
        case "Point":
          h = n, p[0] = n, p[1] = n;
          break;
        case e(472):
          h = f.getCoordinates(), h[x[e(529)]] = n, p[0] = n, p[1] = n;
          break;
        case "LineString":
          h = f[e(554)](), h[x.index + y] = n, p[y] = n;
          break;
        case e(610):
          h = f[e(554)](), h[l[0]][x[e(529)] + y] = n, p[y] = n;
          break;
        case "Polygon":
          h = f.getCoordinates(), h[l[0]][x[e(529)] + y] = n, p[y] = n;
          break;
        case e(502):
          h = f[e(554)](), h[l[1]][l[0]][x[e(529)] + y] = n, p[y] = n;
          break;
        case e(567):
          if (p[0] = n, p[1] = n, x[e(529)] === s5) this[e(506)] = !0, f[e(495)](n), this.changingFeature_ = !1;
          else {
            this[e(506)] = !0, t.map.getView()[e(512)]();
            let v = A1(cn(f[e(476)]()), cn(n));
            f.setRadius(v), this.changingFeature_ = !1;
          }
          break;
      }
      h && this[e(619)](f, h);
    }
    this[e(524)](n, i, s);
  }
  handleDownEvent(t) {
    const e = st;
    if (!this[e(471)](t)) return !1;
    const n = t[e(473)];
    this.handlePointerAtPixel_(t[e(477)], t.map, n), this[e(596)].length = 0, this[e(597)] = null;
    const i = this[e(588)];
    if (i) {
      t[e(622)][e(516)]()[e(512)]();
      const s = [], o = i[e(545)]()[e(554)](), a = di([o]), u = this[e(618)][e(550)](a), x = {};
      u[e(528)](vC);
      for (let c = 0, f = u[e(490)]; c < f; ++c) {
        const l = u[c], h = l.segment;
        let p = ve(l[e(552)]);
        const y = l[e(599)];
        if (y && (p += "-" + y[e(608)]("-")), !x[p] && (x[p] = new Array(2)), l[e(552)][e(500)]() === e(567) && l[e(529)] === Vc) {
          const v = u5(n, l);
          Ys(v, o) && !x[p][0] && (this[e(596)][e(534)]([l, 0]), x[p][0] = l);
          continue;
        }
        if (Ys(h[0], o) && !x[p][0]) {
          this[e(596)][e(534)]([l, 0]), x[p][0] = l;
          continue;
        }
        if (Ys(h[1], o) && !x[p][1]) {
          if (x[p][0] && x[p][0][e(529)] === 0) {
            let v = l.geometry[e(554)]();
            switch (l.geometry[e(500)]()) {
              case e(537):
              case e(610):
                continue;
              case e(502):
                v = v[y[1]];
              case "Polygon":
                if (l.index !== v[y[0]].length - 2) continue;
                break;
            }
          }
          this[e(596)].push([l, 1]), x[p][1] = l;
          continue;
        }
        ve(h) in this[e(540)] && !x[p][0] && !x[p][1] && this[e(485)](t) && s[e(534)](l);
      }
      s[e(490)] && this[e(551)](t, [s]);
      for (let c = s.length - 1; c >= 0; --c)
        this[e(576)](s[c], o);
    }
    return !!this.vertexFeature_;
  }
  [st(564)](t) {
    const e = st;
    for (let n = this[e(596)][e(490)] - 1; n >= 0; --n) {
      const i = this[e(596)][n][0], s = i[e(552)];
      if (s.getType() === e(567)) {
        const o = s.getCenter(), a = i[e(569)][0], u = i[e(569)][1];
        a[e(614)][0] = o, a[e(614)][1] = o, u[e(614)][0] = o, u[e(614)][1] = o, this[e(618)][e(553)](zc(o), a);
        let x = s;
        this[e(618)][e(553)](x[e(605)](), u);
      } else this[e(618)].update(di(i[e(614)]), i);
    }
    return this[e(597)] && (this[e(475)](new Ev(wv[e(544)], this[e(597)], t)), this[e(597)] = null), !1;
  }
  [st(603)](t) {
    const e = st;
    this.lastPixel_ = t[e(477)], this[e(615)](t[e(477)], t[e(622)], t[e(473)]);
  }
  handlePointerAtPixel_(t, e, n) {
    const i = st, s = n || e[i(532)](t);
    e[i(516)]()[i(512)]();
    const o = function(x, c) {
      return a5(s, x) - a5(s, c);
    };
    let a, u;
    if (this[i(602)]) {
      const x = typeof this[i(602)] === i(497) ? (c) => c === this[i(602)] : void 0;
      e[i(543)](t, (c, f, l) => {
        const h = i;
        l && l[h(500)]() === h(488) && (l = new tr(cx(l[h(554)]())));
        const p = l || c[h(545)]();
        if (c instanceof An && this[h(612)][h(517)]()[h(482)](c)) {
          u = p;
          const y = c[h(545)]()[h(607)]().slice(0, 2);
          a = [{ feature: c, geometry: u, segment: [y, y] }];
        }
        return !0;
      }, { layerFilter: x });
    }
    if (!a) {
      const x = Bu(zc(s, o5)), c = e.getView()[i(499)]() * this[i(510)], f = py(ec(x, c, o5));
      a = this[i(618)][i(550)](f);
    }
    if (a && a[i(490)] > 0) {
      const x = a[i(528)](o)[0], c = x[i(614)];
      let f = u5(s, x);
      const l = e[i(573)](f);
      let h = A1(t, l);
      if (u || h <= this[i(510)]) {
        const p = {};
        if (p[ve(c)] = !0, !this[i(487)] && (this[i(486)][0] = f[0] - s[0], this.delta_[1] = f[1] - s[1]), x.geometry.getType() === i(567) && x[i(529)] === Vc) this[i(604)] = !0, this[i(524)](f, [x[i(592)]], [x[i(552)]]);
        else {
          const y = e[i(573)](c[0]), v = e[i(573)](c[1]), m = ta(l, y), d = ta(l, v);
          h = Math[i(546)](Math.min(m, d)), this[i(604)] = h <= this[i(510)], this.snappedToVertex_ && (f = m > d ? c[1] : c[0]), this.createOrUpdateVertexFeature_(f, [x[i(592)]], [x.geometry]);
          const g = {};
          g[ve(x[i(552)])] = !0;
          for (let _ = 1, b = a.length; _ < b; ++_) {
            const w = a[_][i(614)];
            if (Ys(c[0], w[0]) && Ys(c[1], w[1]) || Ys(c[0], w[1]) && Ys(c[1], w[0])) {
              const E = ve(a[_][i(552)]);
              !(E in g) && (g[E] = !0, p[ve(w)] = !0);
            } else break;
          }
        }
        this.vertexSegments_ = p;
        return;
      }
    }
    this.vertexFeature_ && (this[i(503)][i(580)]()[i(496)](this[i(588)]), this.vertexFeature_ = null);
  }
  [st(576)](t, e) {
    const n = st, i = t[n(614)], s = t[n(592)], o = t[n(552)], a = t[n(599)], u = t[n(529)];
    let x;
    for (; e[n(490)] < o[n(568)](); )
      e[n(534)](0);
    switch (o[n(500)]()) {
      case n(610):
        x = o[n(554)](), x[a[0]][n(501)](u + 1, 0, e);
        break;
      case n(609):
        x = o.getCoordinates(), x[a[0]].splice(u + 1, 0, e);
        break;
      case n(502):
        x = o[n(554)](), x[a[1]][a[0]][n(501)](u + 1, 0, e);
        break;
      case n(537):
        x = o[n(554)](), x[n(501)](u + 1, 0, e);
        break;
      default:
        return;
    }
    this[n(619)](o, x);
    const c = this[n(618)];
    c[n(498)](t), this[n(530)](o, u, a, 1);
    const f = { segment: [i[0], e], feature: s, geometry: o, depth: a, index: u };
    c[n(585)](di(f[n(614)]), f), this[n(596)][n(534)]([f, 1]);
    const l = { segment: [e, i[1]], feature: s, geometry: o, depth: a, index: u + 1 };
    c[n(585)](di(l[n(614)]), l), this.dragSegments_[n(534)]([l, 0]), this[n(571)] = !0;
  }
  [st(522)]() {
    const t = st;
    if (this[t(559)] && this[t(559)][t(593)] != Or[t(535)]) {
      const e = this[t(559)];
      this[t(551)](e, this[t(596)]);
      const n = this[t(520)]();
      return this[t(597)] && this.dispatchEvent(new Ev(wv.MODIFYEND, this[t(597)], e)), this[t(597)] = null, n;
    }
    return !1;
  }
  [st(520)]() {
    const t = st, e = this.dragSegments_, n = {};
    let i = !1, s, o, a, u, x, c, f, l, h, p, y;
    for (x = e[t(490)] - 1; x >= 0; --x)
      a = e[x], p = a[0], y = ve(p[t(592)]), p[t(599)] && (y += "-" + p[t(599)].join("-")), !(y in n) && (n[y] = {}), a[1] === 0 ? (n[y][t(583)] = p, n[y][t(529)] = p.index) : a[1] == 1 && (n[y].left = p, n[y][t(529)] = p[t(529)] + 1);
    for (y in n) {
      switch (h = n[y][t(583)], f = n[y][t(489)], c = n[y][t(529)], l = c - 1, f !== void 0 ? p = f : p = h, l < 0 && (l = 0), u = p[t(552)], o = u[t(554)](), s = o, i = !1, u[t(500)]()) {
        case t(610):
          o[p[t(599)][0]].length > 2 && (o[p[t(599)][0]][t(501)](c, 1), i = !0);
          break;
        case t(537):
          o[t(490)] > 2 && (o[t(501)](c, 1), i = !0);
          break;
        case t(502):
          s = s[p[t(599)][1]];
        case t(609):
          s = s[p[t(599)][0]], s.length > 4 && (c == s[t(490)] - 1 && (c = 0), s[t(501)](c, 1), i = !0, c === 0 && (s[t(527)](), s[t(534)](s[0]), l = s[t(490)] - 1));
          break;
      }
      if (i) {
        this[t(619)](u, o);
        const v = [];
        if (f !== void 0 && (this[t(618)][t(498)](f), v[t(534)](f.segment[0])), h !== void 0 && (this[t(618)][t(498)](h), v[t(534)](h[t(614)][1])), f !== void 0 && h !== void 0) {
          const m = { depth: p[t(599)], feature: p[t(592)], geometry: p[t(552)], index: l, segment: v };
          this[t(618)].insert(di(m[t(614)]), m);
        }
        this[t(530)](u, c, p.depth, -1), this[t(588)] && (this[t(503)][t(580)]()[t(496)](this[t(588)]), this[t(588)] = null), e[t(490)] = 0;
      }
    }
    return i;
  }
  setGeometryCoordinates_(t, e) {
    const n = st;
    this.changingFeature_ = !0, t[n(508)](e), this[n(506)] = !1;
  }
  updateSegmentIndices_(t, e, n, i) {
    const s = st;
    this[s(618)][s(474)](t[s(605)](), function(o) {
      const a = s;
      o.geometry === t && (n === void 0 || o[a(599)] === void 0 || uu(o[a(599)], n)) && o.index > e && (o[a(529)] += i);
    });
  }
}
function vC(r, t) {
  const e = st;
  return r.index - t[e(529)];
}
function a5(r, t, e) {
  const n = st, i = t[n(552)];
  if (i.getType() === "Circle") {
    let o = i;
    if (t[n(529)] === Vc) {
      const a = ta(o[n(476)](), cn(r)), u = Math[n(546)](a) - o.getRadius();
      return u * u;
    }
  }
  const s = cn(r);
  return ju[0] = cn(t[n(614)][0]), ju[1] = cn(t[n(614)][1]), M8(s, ju);
}
function u5(r, t, e) {
  const n = st, i = t[n(552)];
  if (i.getType() === "Circle" && t.index === Vc)
    return cx(i.getClosestPoint(cn(r)));
  const s = cn(r);
  return ju[0] = cn(t[n(614)][0]), ju[1] = cn(t[n(614)][1]), cx(p_(s, ju));
}
function $d() {
  const r = ["element", "removePoint", "writeCircleGeometry_", "createOrUpdateVertexFeature_", "getFeatures", "getGeometriesArray", "pop", "sort", "index", "updateSegmentIndices_", "7531312PFGFbJ", "getCoordinateFromPixel", "originalEvent", "push", "POINTERDRAG", "removeFeature_", "LineString", "features", "handleSourceRemove_", "vertexSegments_", "defaultDeleteCondition_", "addFeature_", "forEachFeatureAtPixel", "MODIFYEND", "getGeometry", "sqrt", "handleFeatureChange_", "writeMultiLineStringGeometry_", "503874jUsYcZ", "getInExtent", "willModifyFeatures_", "geometry", "update", "getCoordinates", "source", "lastPixel_", "writePolygonGeometry_", "forEach", "lastPointerEvent_", "999052PRfqTz", "getOverlay", "deleteCondition_", "boundHandleFeatureChange_", "handleUpEvent", "insertVertexCondition", "POINTERMOVE", "Circle", "getStride", "featureSegments", "5952159XNQKXi", "ignoreNextSingleClick_", "removeEventListener", "getPixelFromCoordinate", "handleFeatureRemove_", "snapToPointer", "insertVertex_", "writeLineStringGeometry_", "REMOVE", "hitDetection", "getSource", "modifyend", "setMap", "right", "handlingDownUpSequence", "insert", "getLength", "bind", "vertexFeature_", "writePointGeometry_", "wrapX", "geometries", "feature", "type", "setActive", "handleEvent", "dragSegments_", "featuresBeingModified_", "SINGLECLICK", "depth", "style", "transform", "hitDetection_", "handlePointerMove_", "snappedToVertex_", "getExtent", "pixelTolerance", "getFlatCoordinates", "join", "Polygon", "MultiLineString", "getRadius", "features_", "handleSourceAdd_", "segment", "handlePointerAtPixel_", "1414434QQkUlW", "getInteracting", "rBush_", "setGeometryCoordinates_", "7JsqwQU", "handleFeatureAdd_", "map", "MODIFYSTART", "condition_", "MultiPoint", "coordinate", "forEachInExtent", "dispatchEvent", "getCenter", "pixel", "writeMultiPointGeometry_", "condition", "removeFeatureSegmentData_", "addFeature", "includes", "slice", "clone", "insertVertexCondition_", "delta_", "snapToPointer_", "Point", "left", "length", "setRadius", "deleteCondition", "REMOVEFEATURE", "set", "setCenter", "removeFeature", "object", "remove", "getResolution", "getType", "splice", "MultiPolygon", "overlay_", "53145nRdllz", "SEGMENT_WRITERS_", "changingFeature_", "10QPONRt", "setCoordinates", "getMap", "pixelTolerance_", "addEventListener", "getProjection", "source_", "writeGeometryCollectionGeometry_", "1891732NYHKLa", "getView", "getArray", "102vADtiG", "writeMultiPolygonGeometry_", "removeVertex_"];
  return $d = function() {
    return r;
  }, $d();
}
function mC() {
  const r = R_();
  return function(t, e) {
    return r[tl(488)];
  };
}
var x5 = tg;
(function(r, t) {
  for (var e = tg, n = r(); ; )
    try {
      var i = -parseInt(e(337)) / 1 + -parseInt(e(326)) / 2 + -parseInt(e(331)) / 3 * (parseInt(e(334)) / 4) + -parseInt(e(338)) / 5 * (-parseInt(e(332)) / 6) + parseInt(e(325)) / 7 + parseInt(e(333)) / 8 + parseInt(e(336)) / 9 * (parseInt(e(328)) / 10);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(eg, 906080);
function tg(r, t) {
  var e = eg();
  return tg = function(n, i) {
    n = n - 324;
    var s = e[n];
    return s;
  }, tg(r, t);
}
rw.prototype[x5(324)] = function() {
  var r = x5, t = {};
  this[r(335)].forEach(function(i) {
    var s = r, o = i[0][s(329)];
    window && window.ol && window.ol[s(327)], t[ve(o)] = o;
  });
  var e = [];
  for (var n in t) e[r(330)](t[n]);
  return e;
};
function eg() {
  var r = ["388863KhKqVP", "783424jKJxlH", "5zPSbzB", "getModifiedFeatures", "4448913QkXQEy", "1560600OuITYm", "util", "250YAtnlX", "feature", "push", "113943bUlCUd", "8010180aCaGwN", "5075456LqCcrq", "128ZHEmHt", "dragSegments_"];
  return eg = function() {
    return r;
  }, eg();
}
var _C = class extends rw {
  constructor(t) {
    super(t), this.set("interactionType", t.interactionType), this.setActive(!0);
  }
};
function ng() {
  const r = ["618284FcjqOG", "segment", "657594fjIYhF", "3942JealjS", "30yKErWC", "4878258CTgcLw", "505461UkAEdc", "snap", "108810UpaxqG", "3tyDEYy", "vertexPixel", "vertex", "2275984FVvJOf", "6418280FWdxbQ", "feature"];
  return ng = function() {
    return r;
  }, ng();
}
function rg(r, t) {
  const e = ng();
  return rg = function(n, i) {
    return n = n - 162, e[n];
  }, rg(r, t);
}
const iw = rg;
(function(r, t) {
  const e = rg, n = r();
  for (; ; )
    try {
      if (-parseInt(e(164)) / 1 + -parseInt(e(170)) / 2 * (parseInt(e(167)) / 3) + parseInt(e(173)) / 4 * (-parseInt(e(162)) / 5) + -parseInt(e(175)) / 6 + -parseInt(e(163)) / 7 + -parseInt(e(171)) / 8 + parseInt(e(176)) / 9 * (parseInt(e(166)) / 10) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ng, 586221);
const bC = { SNAP: iw(165) };
class IC extends Oo {
  constructor(t, e) {
    const n = iw;
    super(t), this[n(169)] = e[n(169)], this[n(168)] = e.vertexPixel, this[n(172)] = e[n(172)], this.segment = e[n(174)];
  }
}
const me = Mx;
(function(r, t) {
  const e = Mx, n = r();
  for (; ; )
    try {
      if (-parseInt(e(332)) / 1 + -parseInt(e(368)) / 2 + parseInt(e(317)) / 3 * (parseInt(e(334)) / 4) + -parseInt(e(315)) / 5 * (-parseInt(e(302)) / 6) + parseInt(e(356)) / 7 + -parseInt(e(296)) / 8 + parseInt(e(294)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ig, 542782);
function ig() {
  const r = ["coordinate", "pixel", "clear", "REMOVE", "getType", "dispatchEvent", "5285520jjgvHv", "handleFeatureAdd_", "497744iQCpXf", "CHANGE", "bind", "map", "getGeometriesArray", "source_", "402SOMxrg", "round", "segmentLineStringGeometry_", "ADD", "SNAP", "element", "snapTo", "source", "addFeature", "getProjection", "feature", "features_", "push", "28125yidyfA", "segmentPointGeometry_", "205113ZVMBJS", "getInExtent", "getGeometry", "stopDown", "getCoordinates", "handleFeatureChange_", "pendingFeatures_", "removeFeature", "transform", "target", "rBush_", "Circle", "insert", "slice", "vertex", "364003MCDtvI", "getMap", "4oJwavP", "setMap", "clone", "forEachInExtent", "segmentPolygonGeometry_", "updateFeature_", "load", "handleFeatureRemove_", "values", "edge_", "featuresListenerKeys_", "segment", "REMOVEFEATURE", "segmentCircleGeometry_", "getView", "segmentMultiLineStringGeometry_", "segmentGeometryCollectionGeometry_", "length", "getFeatures", "getFeatures_", "featureChangeListenerKeys_", "forEach", "1461516DoiAIU", "edge", "pixelTolerance", "ADDFEATURE", "handleDownEvent", "segmentMultiPolygonGeometry_", "segmentMultiPointGeometry_", "pixelTolerance_", "once", "vertex_", "getResolution", "features", "544622RYOTpS"];
  return ig = function() {
    return r;
  }, ig();
}
function c5(r) {
  const t = Mx;
  return r[t(312)] ? r.feature : r[t(307)] ? r[t(307)] : null;
}
const Sv = [];
class wC extends Iy {
  constructor(t) {
    const e = Mx;
    t = t || {};
    const n = t;
    !n[e(360)] && (n[e(360)] = ix), !n.stopDown && (n[e(320)] = x_), super(n), this.on, this[e(364)], this.un, this[e(301)] = t[e(309)] ? t.source : null, this[e(365)] = t[e(331)] !== void 0 ? t.vertex : !0, this[e(343)] = t[e(357)] !== void 0 ? t[e(357)] : !0, this[e(313)] = t[e(367)] ? t[e(367)] : null, this[e(344)] = [], this[e(354)] = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelTolerance_ = t.pixelTolerance !== void 0 ? t[e(358)] : 10, this.rBush_ = new y1(), this.GEOMETRY_SEGMENTERS_ = { Point: this[e(316)].bind(this), LineString: this[e(304)].bind(this), LinearRing: this[e(304)][e(298)](this), Polygon: this[e(338)][e(298)](this), MultiPoint: this[e(362)].bind(this), MultiLineString: this.segmentMultiLineStringGeometry_[e(298)](this), MultiPolygon: this.segmentMultiPolygonGeometry_[e(298)](this), GeometryCollection: this[e(350)][e(298)](this), Circle: this[e(347)][e(298)](this) };
  }
  [me(310)](t, e) {
    const n = me;
    e = e !== void 0 ? e : !0;
    const i = ve(t), s = t.getGeometry();
    if (s) {
      const o = this.GEOMETRY_SEGMENTERS_[s[n(373)]()];
      if (o) {
        this.indexedFeaturesExtents_[i] = s.getExtent(Hs());
        const a = [];
        if (o(a, s), a[n(351)] === 1) this[n(327)][n(329)](di(a[0]), { feature: t, segment: a[0] });
        else if (a[n(351)] > 1) {
          const u = a[n(299)]((c) => di(c)), x = a[n(299)]((c) => ({ feature: t, segment: c }));
          this[n(327)][n(340)](u, x);
        }
      }
    }
    e && (this[n(354)][i] = ii(t, rr[n(297)], this[n(322)], this));
  }
  [me(353)]() {
    const t = me;
    let e;
    return this[t(313)] ? e = this.features_ : this.source_ && (e = this[t(301)][t(352)]()), e;
  }
  handleEvent(t) {
    const e = me, n = this[e(308)](t[e(370)], t.coordinate, t[e(299)]);
    return n && (t[e(369)] = n[e(331)].slice(0, 2), t[e(370)] = n.vertexPixel, this[e(293)](new IC(bC[e(306)], { vertex: t[e(369)], vertexPixel: t[e(370)], feature: n[e(312)], segment: n.segment }))), super.handleEvent(t);
  }
  handleFeatureAdd_(t) {
    const e = c5(t);
    e && this.addFeature(e);
  }
  [me(341)](t) {
    const e = me, n = c5(t);
    n && this[e(324)](n);
  }
  [me(322)](t) {
    const e = me, n = t[e(326)];
    if (this.handlingDownUpSequence) {
      const i = ve(n);
      !(i in this[e(323)]) && (this[e(323)][i] = n);
    } else this.updateFeature_(n);
  }
  handleUpEvent(t) {
    const e = me, n = Object[e(342)](this[e(323)]);
    return n[e(351)] && (n[e(355)](this.updateFeature_[e(298)](this)), this[e(323)] = {}), !1;
  }
  [me(324)](t, e) {
    const n = me, i = e !== void 0 ? e : !0, s = ve(t), o = this.indexedFeaturesExtents_[s];
    if (o) {
      const a = this[n(327)], u = [];
      a[n(337)](o, function(x) {
        const c = n;
        t === x[c(312)] && u[c(314)](x);
      });
      for (let x = u.length - 1; x >= 0; --x)
        a.remove(u[x]);
    }
    i && (gs(this[n(354)][s]), delete this[n(354)][s]);
  }
  [me(335)](t) {
    const e = me, n = this[e(333)](), i = this.featuresListenerKeys_, s = this.getFeatures_();
    n && (i.forEach(gs), i[e(351)] = 0, this[e(327)][e(371)](), Object[e(342)](this.featureChangeListenerKeys_)[e(355)](gs), this[e(354)] = {}), super[e(335)](t), t && (this[e(313)] ? i[e(314)](ii(this[e(313)], _i[e(305)], this[e(295)], this), ii(this.features_, _i[e(372)], this.handleFeatureRemove_, this)) : this[e(301)] && i.push(ii(this[e(301)], Xr[e(359)], this[e(295)], this), ii(this.source_, Xr[e(346)], this.handleFeatureRemove_, this)), s.forEach((o) => this.addFeature(o)));
  }
  snapTo(t, e, n) {
    const i = me;
    n[i(348)]()[i(311)]();
    const s = cn(e), o = py(ec(di([s]), n[i(348)]()[i(366)]() * this[i(363)])), a = this[i(327)][i(318)](o), u = a[i(351)];
    if (u === 0) return null;
    let x, c = 1 / 0, f, l = null;
    const h = this[i(363)] * this[i(363)], p = () => {
      const y = i;
      if (x) {
        const v = n.getPixelFromCoordinate(x);
        if (ta(t, v) <= h) return { vertex: x, vertexPixel: [Math[y(303)](v[0]), Math[y(303)](v[1])], feature: f, segment: l };
      }
      return null;
    };
    if (this[i(365)]) {
      for (let v = 0; v < u; ++v) {
        const m = a[v];
        m[i(312)][i(319)]()[i(373)]() !== i(328) && m[i(345)][i(355)]((d) => {
          const g = i, _ = cn(d), b = ta(s, _);
          b < c && (x = d, c = b, f = m[g(312)]);
        });
      }
      const y = p();
      if (y) return y;
    }
    if (this.edge_) {
      for (let v = 0; v < u; ++v) {
        let m = null;
        const d = a[v];
        if (d[i(312)].getGeometry()[i(373)]() === i(328)) {
          let g = d[i(312)].getGeometry();
          m = S8(s, g);
        } else {
          const [g, _] = d[i(345)];
          _ && (Sv[0] = cn(g), Sv[1] = cn(_), m = p_(s, Sv));
        }
        if (m) {
          const g = ta(s, m);
          g < c && (x = cx(m), l = d[i(312)][i(319)]().getType() === i(328) ? null : d[i(345)], c = g, f = d[i(312)]);
        }
      }
      const y = p();
      if (y) return y;
    }
    return null;
  }
  [me(339)](t) {
    const e = me;
    this.removeFeature(t, !1), this[e(310)](t, !1);
  }
  [me(347)](t, e) {
    const n = me;
    this[n(333)]()[n(348)]()[n(311)]();
    const o = s9(e)[n(321)]()[0];
    for (let a = 0, u = o[n(351)] - 1; a < u; ++a)
      t[n(314)](o[n(330)](a, a + 2));
  }
  [me(350)](t, e) {
    const n = me, i = e[n(300)]();
    for (let s = 0; s < i[n(351)]; ++s) {
      const o = this.GEOMETRY_SEGMENTERS_[i[s][n(373)]()];
      o && o(t, i[s]);
    }
  }
  [me(304)](t, e) {
    const n = me, i = e.getCoordinates();
    for (let s = 0, o = i.length - 1; s < o; ++s)
      t.push(i[n(330)](s, s + 2));
  }
  [me(349)](t, e) {
    const n = me, i = e[n(321)]();
    for (let s = 0, o = i[n(351)]; s < o; ++s) {
      const a = i[s];
      for (let u = 0, x = a[n(351)] - 1; u < x; ++u)
        t[n(314)](a[n(330)](u, u + 2));
    }
  }
  [me(362)](t, e) {
    const n = me;
    e[n(321)]()[n(355)]((i) => {
      t[n(314)]([i]);
    });
  }
  [me(361)](t, e) {
    const n = me, i = e.getCoordinates();
    for (let s = 0, o = i[n(351)]; s < o; ++s) {
      const a = i[s];
      for (let u = 0, x = a[n(351)]; u < x; ++u) {
        const c = a[u];
        for (let f = 0, l = c[n(351)] - 1; f < l; ++f)
          t[n(314)](c.slice(f, f + 2));
      }
    }
  }
  [me(316)](t, e) {
    t[me(314)]([e.getCoordinates()]);
  }
  [me(338)](t, e) {
    const n = me, i = e[n(321)]();
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s];
      for (let u = 0, x = a[n(351)] - 1; u < x; ++u)
        t[n(314)](a[n(330)](u, u + 2));
    }
  }
}
function Mx(r, t) {
  const e = ig();
  return Mx = function(n, i) {
    return n = n - 293, e[n];
  }, Mx(r, t);
}
const EC = "4522702", SC = "MI14全", CC = "iconfont", MC = "", PC = "", LC = [
  {
    icon_id: "40594733",
    name: "热带低压",
    font_class: "SYMBOLS_371",
    unicode: "e751",
    unicode_decimal: 59217
  },
  {
    icon_id: "40091037",
    name: "过去12小时暖锋",
    font_class: "LINES_19",
    unicode: "e7b7",
    unicode_decimal: 59319
  },
  {
    icon_id: "40091155",
    name: "分流区",
    font_class: "LINESYMBOLS_1218",
    unicode: "e7b9",
    unicode_decimal: 59321
  },
  {
    icon_id: "40091142",
    name: "过去12小时冷锋",
    font_class: "LINES_18",
    unicode: "e7ba",
    unicode_decimal: 59322
  },
  {
    icon_id: "40091052",
    name: "湿轴",
    font_class: "LINESYMBOLS_1219",
    unicode: "e7bd",
    unicode_decimal: 59325
  },
  {
    icon_id: "40084617",
    name: "双实线",
    font_class: "LINESYMBOLS_1102",
    unicode: "e791",
    unicode_decimal: 59281
  },
  {
    icon_id: "40084624",
    name: "图像填充区（Color）",
    font_class: "FILLAREA_1101_1_0",
    unicode: "e792",
    unicode_decimal: 59282
  },
  {
    icon_id: "40084625",
    name: "图像填充区（Hatch+YouXieXian）",
    font_class: "FILLAREA_1101_2_5",
    unicode: "e793",
    unicode_decimal: 59283
  },
  {
    icon_id: "40084626",
    name: "图像填充区（None）",
    font_class: "FILLAREA_1101_0_0",
    unicode: "e794",
    unicode_decimal: 59284
  },
  {
    icon_id: "40084627",
    name: "图像填充区（Weather+Gale）",
    font_class: "REGION_8",
    unicode: "e795",
    unicode_decimal: 59285
  },
  {
    icon_id: "40084628",
    name: "图像填充区（Weather+Fog）",
    font_class: "REGION_32",
    unicode: "e796",
    unicode_decimal: 59286
  },
  {
    icon_id: "40084629",
    name: "图像填充区（Weather+Rain）",
    font_class: "REGION_1",
    unicode: "e797",
    unicode_decimal: 59287
  },
  {
    icon_id: "40084630",
    name: "图像填充区（Weather+Sand）",
    font_class: "REGION_4",
    unicode: "e798",
    unicode_decimal: 59288
  },
  {
    icon_id: "40084631",
    name: "图像填充区（Weather+Snow）",
    font_class: "REGION_2",
    unicode: "e799",
    unicode_decimal: 59289
  },
  {
    icon_id: "40084632",
    name: "图像填充区（Weather+ThunderStorm）",
    font_class: "REGION_16",
    unicode: "e79a",
    unicode_decimal: 59290
  },
  {
    icon_id: "40084802",
    name: "霾",
    font_class: "SYMBOLS_70",
    unicode: "e7a2",
    unicode_decimal: 59298
  },
  {
    icon_id: "40084803",
    name: "烟",
    font_class: "SYMBOLS_69",
    unicode: "e7a3",
    unicode_decimal: 59299
  },
  {
    icon_id: "40084780",
    name: "高压中心",
    font_class: "SYMBOLS_1601",
    unicode: "e7a4",
    unicode_decimal: 59300
  },
  {
    icon_id: "40084777",
    name: "低压中心",
    font_class: "SYMBOLS_1611",
    unicode: "e7a7",
    unicode_decimal: 59303
  },
  {
    icon_id: "40084748",
    name: "台风",
    font_class: "SYMBOLS_373",
    unicode: "e7a8",
    unicode_decimal: 59304
  },
  {
    icon_id: "40085422",
    name: "高温线",
    font_class: "LINES_39",
    unicode: "e7b5",
    unicode_decimal: 59317
  },
  {
    icon_id: "40084250",
    name: "低压中心D",
    font_class: "SYMBOLS_61",
    unicode: "e759",
    unicode_decimal: 59225
  },
  {
    icon_id: "40084256",
    name: "高压中心G",
    font_class: "SYMBOLS_60",
    unicode: "e75a",
    unicode_decimal: 59226
  },
  {
    icon_id: "40084266",
    name: "冷中心",
    font_class: "SYMBOLS_63",
    unicode: "e75b",
    unicode_decimal: 59227
  },
  {
    icon_id: "40084268",
    name: "暖中心N",
    font_class: "SYMBOLS_62",
    unicode: "e75c",
    unicode_decimal: 59228
  },
  {
    icon_id: "40084279",
    name: "文字标注",
    font_class: "NOTES_481",
    unicode: "e75d",
    unicode_decimal: 59229
  },
  {
    icon_id: "40084286",
    name: "静止锋",
    font_class: "LINES_41",
    unicode: "e75e",
    unicode_decimal: 59230
  },
  {
    icon_id: "40084287",
    name: "锢囚锋",
    font_class: "LINES_51",
    unicode: "e75f",
    unicode_decimal: 59231
  },
  {
    icon_id: "40084288",
    name: "冷锋",
    font_class: "LINES_21",
    unicode: "e760",
    unicode_decimal: 59232
  },
  {
    icon_id: "40084289",
    name: "暖锋",
    font_class: "LINES_31",
    unicode: "e761",
    unicode_decimal: 59233
  },
  {
    icon_id: "40084353",
    name: "霜冻线",
    font_class: "LINES_38",
    unicode: "e762",
    unicode_decimal: 59234
  },
  {
    icon_id: "40084358",
    name: "小雨",
    font_class: "SYMBOLS_26",
    unicode: "e763",
    unicode_decimal: 59235
  },
  {
    icon_id: "40084441",
    name: "暴雨",
    font_class: "SYMBOLS_64",
    unicode: "e764",
    unicode_decimal: 59236
  },
  {
    icon_id: "40084442",
    name: "大暴雨",
    font_class: "SYMBOLS_221",
    unicode: "e765",
    unicode_decimal: 59237
  },
  {
    icon_id: "40084443",
    name: "大雨",
    font_class: "SYMBOLS_55",
    unicode: "e766",
    unicode_decimal: 59238
  },
  {
    icon_id: "40084444",
    name: "阵雨",
    font_class: "SYMBOLS_25",
    unicode: "e767",
    unicode_decimal: 59239
  },
  {
    icon_id: "40084445",
    name: "中雨",
    font_class: "SYMBOLS_47",
    unicode: "e768",
    unicode_decimal: 59240
  },
  {
    icon_id: "40084448",
    name: "特大暴雨",
    font_class: "SYMBOLS_231",
    unicode: "e769",
    unicode_decimal: 59241
  },
  {
    icon_id: "40084458",
    name: "冻雨",
    font_class: "SYMBOLS_28",
    unicode: "e76a",
    unicode_decimal: 59242
  },
  {
    icon_id: "40084459",
    name: "轻冻雨",
    font_class: "SYMBOLS_27",
    unicode: "e777",
    unicode_decimal: 59255
  },
  {
    icon_id: "40084462",
    name: "小雪",
    font_class: "SYMBOLS_23",
    unicode: "e778",
    unicode_decimal: 59256
  },
  {
    icon_id: "40084463",
    name: "阵雪",
    font_class: "SYMBOLS_65",
    unicode: "e779",
    unicode_decimal: 59257
  },
  {
    icon_id: "40084464",
    name: "雨雪",
    font_class: "SYMBOLS_24",
    unicode: "e77a",
    unicode_decimal: 59258
  },
  {
    icon_id: "40084465",
    name: "中雪",
    font_class: "SYMBOLS_22",
    unicode: "e77b",
    unicode_decimal: 59259
  },
  {
    icon_id: "40084474",
    name: "大雪",
    font_class: "SYMBOLS_21",
    unicode: "e77c",
    unicode_decimal: 59260
  },
  {
    icon_id: "40084475",
    name: "暴雪",
    font_class: "SYMBOLS_66",
    unicode: "e77d",
    unicode_decimal: 59261
  },
  {
    icon_id: "40084523",
    name: "多云",
    font_class: "SYMBOLS_51",
    unicode: "e780",
    unicode_decimal: 59264
  },
  {
    icon_id: "40084524",
    name: "晴天",
    font_class: "SYMBOLS_50",
    unicode: "e781",
    unicode_decimal: 59265
  },
  {
    icon_id: "40084525",
    name: "阴天",
    font_class: "SYMBOLS_52",
    unicode: "e782",
    unicode_decimal: 59266
  },
  {
    icon_id: "40084596",
    name: "雷暴",
    font_class: "SYMBOLS_32",
    unicode: "e783",
    unicode_decimal: 59267
  },
  {
    icon_id: "40084597",
    name: "冰雹",
    font_class: "SYMBOLS_31",
    unicode: "e784",
    unicode_decimal: 59268
  },
  {
    icon_id: "40084598",
    name: "浮沉",
    font_class: "SYMBOLS_201",
    unicode: "e785",
    unicode_decimal: 59269
  },
  {
    icon_id: "40084599",
    name: "霜冻",
    font_class: "SYMBOLS_44",
    unicode: "e786",
    unicode_decimal: 59270
  },
  {
    icon_id: "40084600",
    name: "强沙尘暴",
    font_class: "SYMBOLS_46",
    unicode: "e787",
    unicode_decimal: 59271
  },
  {
    icon_id: "40084601",
    name: "沙尘暴",
    font_class: "SYMBOLS_211",
    unicode: "e788",
    unicode_decimal: 59272
  },
  {
    icon_id: "40084602",
    name: "扬尘",
    font_class: "SYMBOLS_45",
    unicode: "e789",
    unicode_decimal: 59273
  },
  {
    icon_id: "40085062",
    name: "10-11级风",
    font_class: "SYMBOLS_102",
    unicode: "e76e",
    unicode_decimal: 59246
  },
  {
    icon_id: "40085061",
    name: "9-10级风",
    font_class: "SYMBOLS_101",
    unicode: "e76f",
    unicode_decimal: 59247
  },
  {
    icon_id: "40085063",
    name: "3-4级风",
    font_class: "SYMBOLS_40",
    unicode: "e76b",
    unicode_decimal: 59243
  },
  {
    icon_id: "40085064",
    name: "无风",
    font_class: "SYMBOLS_43",
    unicode: "e770",
    unicode_decimal: 59248
  },
  {
    icon_id: "40085060",
    name: "7-8级风",
    font_class: "SYMBOLS_34",
    unicode: "e771",
    unicode_decimal: 59249
  },
  {
    icon_id: "40085059",
    name: "8-9级风",
    font_class: "SYMBOLS_35",
    unicode: "e772",
    unicode_decimal: 59250
  },
  {
    icon_id: "40085057",
    name: "6-7级风",
    font_class: "SYMBOLS_41",
    unicode: "e773",
    unicode_decimal: 59251
  },
  {
    icon_id: "40085058",
    name: "5-6级风",
    font_class: "SYMBOLS_33",
    unicode: "e774",
    unicode_decimal: 59252
  },
  {
    icon_id: "40085056",
    name: "4-5级风",
    font_class: "SYMBOLS_36",
    unicode: "e775",
    unicode_decimal: 59253
  },
  {
    icon_id: "40085055",
    name: "2-3级风",
    font_class: "SYMBOLS_39",
    unicode: "e776",
    unicode_decimal: 59254
  },
  {
    icon_id: "40085065",
    name: "11-12级风",
    font_class: "SYMBOLS_103",
    unicode: "e76c",
    unicode_decimal: 59244
  },
  {
    icon_id: "40085066",
    name: "旋转风",
    font_class: "SYMBOLS_42",
    unicode: "e76d",
    unicode_decimal: 59245
  },
  {
    icon_id: "40083691",
    name: "低压中心",
    font_class: "SYMBOLS_161",
    unicode: "e755",
    unicode_decimal: 59221
  },
  {
    icon_id: "40083687",
    name: "高压中心",
    font_class: "SYMBOLS_160",
    unicode: "e756",
    unicode_decimal: 59222
  },
  {
    icon_id: "40083183",
    name: "生成",
    font_class: "NOTES_NEW",
    unicode: "e735",
    unicode_decimal: 59189
  },
  {
    icon_id: "40083184",
    name: "合并",
    font_class: "NOTES_MERGE",
    unicode: "e736",
    unicode_decimal: 59190
  },
  {
    icon_id: "40083185",
    name: "文字标注",
    font_class: "NOTES_48",
    unicode: "e737",
    unicode_decimal: 59191
  },
  {
    icon_id: "40083186",
    name: "维持不动",
    font_class: "NOTES_STNRY",
    unicode: "e738",
    unicode_decimal: 59192
  },
  {
    icon_id: "40083187",
    name: "消失",
    font_class: "NOTES_DSIPT",
    unicode: "e739",
    unicode_decimal: 59193
  },
  {
    icon_id: "40083188",
    name: "吸收",
    font_class: "NOTES_ABSORB",
    unicode: "e73a",
    unicode_decimal: 59194
  },
  {
    icon_id: "40083210",
    name: "槽线、线条符号",
    font_class: "LINESYMBOLS_0",
    unicode: "e73b",
    unicode_decimal: 59195
  },
  {
    icon_id: "40083357",
    name: "轻雾",
    font_class: "SYMBOLS_29",
    unicode: "e740",
    unicode_decimal: 59200
  },
  {
    icon_id: "40083359",
    name: "雾",
    font_class: "SYMBOLS_30",
    unicode: "e741",
    unicode_decimal: 59201
  },
  {
    icon_id: "40083446",
    name: "箭头符号1",
    font_class: "LINESYMBOLS_1110",
    unicode: "e742",
    unicode_decimal: 59202
  },
  {
    icon_id: "40083447",
    name: "箭头符号2",
    font_class: "LINESYMBOLS_1111",
    unicode: "e743",
    unicode_decimal: 59203
  },
  {
    icon_id: "40083448",
    name: "箭头符号4",
    font_class: "LINESYMBOLS_1113",
    unicode: "e744",
    unicode_decimal: 59204
  },
  {
    icon_id: "40083449",
    name: "箭头符号3",
    font_class: "LINESYMBOLS_1112",
    unicode: "e745",
    unicode_decimal: 59205
  },
  {
    icon_id: "40083450",
    name: "箭头符号6",
    font_class: "LINESYMBOLS_1115",
    unicode: "e746",
    unicode_decimal: 59206
  },
  {
    icon_id: "40083451",
    name: "箭头符号5",
    font_class: "LINESYMBOLS_1114",
    unicode: "e747",
    unicode_decimal: 59207
  },
  {
    icon_id: "40083452",
    name: "箭头符号7",
    font_class: "LINESYMBOLS_1116",
    unicode: "e748",
    unicode_decimal: 59208
  },
  {
    icon_id: "40083461",
    name: "单点符号（空心圆）",
    font_class: "SYMBOLS_151",
    unicode: "e749",
    unicode_decimal: 59209
  },
  {
    icon_id: "40083462",
    name: "单点符号（空心正方形）",
    font_class: "SYMBOLS_155",
    unicode: "e74a",
    unicode_decimal: 59210
  },
  {
    icon_id: "40083463",
    name: "单点符号（空心三角）",
    font_class: "SYMBOLS_153",
    unicode: "e74b",
    unicode_decimal: 59211
  },
  {
    icon_id: "40083464",
    name: "单点符号（实心三角）",
    font_class: "SYMBOLS_154",
    unicode: "e74c",
    unicode_decimal: 59212
  },
  {
    icon_id: "40083465",
    name: "单点符号（实心正方形）",
    font_class: "SYMBOLS_156",
    unicode: "e74d",
    unicode_decimal: 59213
  },
  {
    icon_id: "40083466",
    name: "单点符号（实心五角星）",
    font_class: "SYMBOLS_152",
    unicode: "e74e",
    unicode_decimal: 59214
  },
  {
    icon_id: "40083467",
    name: "单点符号（实心圆）",
    font_class: "SYMBOLS_150",
    unicode: "e74f",
    unicode_decimal: 59215
  },
  {
    icon_id: "40083476",
    name: "台风",
    font_class: "SYMBOLS_37",
    unicode: "e750",
    unicode_decimal: 59216
  },
  {
    icon_id: "40083667",
    name: "未来低压中心",
    font_class: "SYMBOLS_162",
    unicode: "e752",
    unicode_decimal: 59218
  },
  {
    icon_id: "40083668",
    name: "未来高压中心",
    font_class: "SYMBOLS_163",
    unicode: "e753",
    unicode_decimal: 59219
  },
  {
    icon_id: "40083669",
    name: "未来台风中西",
    font_class: "SYMBOLS_372",
    unicode: "e754",
    unicode_decimal: 59220
  },
  {
    icon_id: "40075776",
    name: "减弱",
    font_class: "NOTES_WKN",
    unicode: "e734",
    unicode_decimal: 59188
  }
], NC = {
  id: EC,
  name: SC,
  font_family: CC,
  css_prefix_text: MC,
  description: PC,
  glyphs: LC
};
var yn = el;
function sg() {
  var r = ["lineTo", "square", "lineCap", "fontSize", "getWidth", "font", "getColor", "circle", "clearRect", "log", "99476IrZyxU", "setScale", "length", "bad font def", "9juCTzZ", "char", "diamond", "triangle", "lineWidth", "round", "getDeclutterMode", "fromCharCode", "gradient", "width", "11701168UdKETu", "getContext", "_radius", "fillStyle", "lozenge", "16164570ChpxXr", "strokeText", "getChecksum", "none", "5953576olqAVN", "addDefs", "getAnchor", "coma", "strokeWidth", "getDisplacement", "getGlyphName", "checksums_", "_fontStyle", "offsetY", "glyphs", "getOpacity", "string", "arc", "glyph", "quadraticCurveTo", "displacement", "_fontSize", "rotateWithView", "ban", "offsetX", "setTransform", "getFill", "fillText", "addColorStop", "_fill", "428514nEErEA", "fac", "number", "getImage", "lineJoin", "sans-serif", "search", "setOpacity", "radius", "beginPath", "getTextGlyph", "getScale", "createLinearGradient", "getFontInfo", "posX", "_stroke", "opacity", "_form", "moveTo", "text", "poi", "sign", "declutterMode", "cos", "1497063fofETH", "blazon", "fill", "drawMarker_", "translate", "fonts", "textBaseline", "6hdVNfE", "posY", "drawPath_", "glyphs_", "hexagon", "color", "middle", "strokeStyle", "_color", "size", "code", "_gradient", "fontStyle", "7EqiDDk", "defs", "_glyph", "theme", "center", "3464920Kihfkb", "getGlyph", "_offset", "bookmark", "charAt", "stroke"];
  return sg = function() {
    return r;
  }, sg();
}
(function(r, t) {
  for (var e = el, n = r(); ; )
    try {
      var i = parseInt(e(408)) / 1 + -parseInt(e(488)) / 2 * (-parseInt(e(481)) / 3) + parseInt(e(431)) / 4 + parseInt(e(392)) / 5 + parseInt(e(457)) / 6 + parseInt(e(387)) / 7 * (-parseInt(e(422)) / 8) + -parseInt(e(412)) / 9 * (parseInt(e(427)) / 10);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(sg, 770233);
function el(r, t) {
  var e = sg();
  return el = function(n, i) {
    n = n - 384;
    var s = e[n];
    return s;
  }, el(r, t);
}
var cs = class extends _o {
  constructor(t) {
    var e = el;
    t = t || {};
    var n = 0;
    t[e(397)] && (n = t[e(397)][e(402)]()), !t[e(447)] && (t.displacement = [t[e(451)] || 0, -t[e(440)] || 0]), super({ radius: t[e(465)], fill: t[e(483)], rotation: t.rotation, displacement: t.displacement, rotateWithView: t[e(449)], declutterMode: t[e(479)] }), typeof t[e(473)] == e(459) && this[e(464)](t[e(473)]), this[e(496)] = t[e(493)], this[e(448)] = t[e(401)] || 1, this[e(439)] = t[e(386)] || "", this[e(472)] = t[e(397)], this[e(456)] = t[e(483)], this._radius = t[e(465)] - n, this[e(474)] = t.form || e(430), this[e(385)] = t[e(420)], this._offset = [t.offsetX ? t.offsetX : 0, t[e(440)] ? t[e(440)] : 0], t[e(445)] ? this[e(389)] = this[e(393)](t[e(445)]) : this._glyph = this[e(467)](t[e(476)] || "", t[e(403)]), this[e(436)] || this[e(460)]();
  }
  static [yn(432)](t, e) {
    var n = yn, i = t;
    if (typeof t == n(443) && (i = { font: t, name: t, copyright: "" }), !i.font || typeof i[n(403)] !== n(443)) {
      console[n(407)](n(411));
      return;
    }
    var s = i[n(403)];
    cs[n(388)][n(486)][s] = i;
    for (var o in e) {
      var a = e[o];
      typeof a === n(443) && (a.length == 1 || a[n(410)] == 2) && (a = { char: a }), cs.defs[n(441)][o] = { font: i[n(403)], char: a[n(413)] || "" + String[n(419)](a[n(384)]) || "", theme: a[n(390)] || i.name, name: a.name || o, search: a[n(463)] || "" };
    }
  }
  clone() {
    var t = yn, e = new cs({ text: this[t(389)][t(413)], font: this._glyph[t(403)], color: this._color, fontSize: this._fontSize, fontStyle: this[t(439)], stroke: this[t(472)], fill: this[t(456)], radius: this[t(424)] + (this[t(472)] ? this[t(472)][t(402)]() : 0), form: this._form, gradient: this[t(385)], offsetX: this[t(394)][0], offsetY: this[t(394)][1], opacity: this[t(442)](), rotation: this.getRotation(), rotateWithView: this.getRotateWithView(), declutterMode: this.getDeclutterMode ? this[t(418)]() : null });
    return e[t(409)](this[t(468)]()), e;
  }
  [yn(453)]() {
    var t = yn;
    return this[t(456)];
  }
  getStroke() {
    var t = yn;
    return this[t(472)];
  }
  [yn(393)](t) {
    var e = yn;
    return t ? cs[e(388)][e(441)][t] || { font: "sans-serif", char: t[e(396)](0), theme: e(430), name: "none", search: "" } : this[e(389)];
  }
  [yn(467)](t, e) {
    var n = yn;
    return { font: e || n(462), char: String(t), theme: n(430), name: n(430), search: "" };
  }
  [yn(437)]() {
    var t = yn;
    for (var e in cs[t(388)][t(441)])
      if (cs[t(388)].glyphs[e] === this[t(389)]) return e;
    return "";
  }
  [yn(470)](t) {
    var e = yn;
    return cs.defs[e(486)][t[e(403)]];
  }
  [yn(460)](t) {
    var e = yn;
    t = t || 1;
    var n = super.getImage(t), i, s = 0;
    this[e(472)] && (i = Jo(this[e(472)][e(404)]()), s = this[e(472)][e(402)]());
    var o = { strokeStyle: i, strokeWidth: s, size: n[e(421)] / t }, a = n[e(423)]("2d");
    if (a[e(406)](0, 0, n[e(421)], n.height), this[e(484)](o, a, 0, 0, t), !this[e(436)]) {
      var u = this[e(433)]();
      u[0] = n.width / 2 - this[e(394)][0], u[1] = n[e(421)] / 2 - this._offset[1];
    }
    return n;
  }
  [yn(490)](t, e) {
    var n = yn, i = 2 * this[n(424)] + t.strokeWidth, s = t[n(435)] / 2, o = t[n(497)] / 2, a = { fac: 1, posX: t[n(497)] / 2, posY: t[n(497)] / 2 };
    switch (e[n(461)] = n(417), e[n(400)] = n(417), e[n(466)](), this[n(474)]) {
      case n(430): {
        a[n(458)] = 1;
        break;
      }
      case n(405):
      case "ban": {
        e[n(444)](o, o, i / 2, 0, 2 * Math.PI, !0);
        break;
      }
      case n(477): {
        e[n(444)](o, o - 0.4 * this._radius, 0.6 * this._radius, 0.15 * Math.PI, 0.85 * Math.PI, !0), e[n(398)](o - 0.89 * 0.05 * i, (0.95 + 0.45 * 0.05) * i + s), e.arc(o, 0.95 * i + s, 0.05 * i, 0.85 * Math.PI, 0.15 * Math.PI, !0), a = { fac: 0.45, posX: o, posY: o - 0.35 * this[n(424)] };
        break;
      }
      case "bubble": {
        e[n(444)](o, o - 0.2 * this[n(424)], 0.8 * this[n(424)], 0.4 * Math.PI, 0.6 * Math.PI, !0), e.lineTo(0.5 * i + s, i + s), a = { fac: 0.7, posX: o, posY: o - 0.2 * this[n(424)] };
        break;
      }
      case "marker": {
        e[n(444)](o, o - 0.2 * this._radius, 0.8 * this[n(424)], 0.25 * Math.PI, 0.75 * Math.PI, !0), e[n(398)](0.5 * i + s, i + s), a = { fac: 0.7, posX: o, posY: o - 0.2 * this[n(424)] };
        break;
      }
      case n(434): {
        e.moveTo(o + 0.8 * this[n(424)], o - 0.2 * this[n(424)]), e[n(446)](0.95 * i + s, 0.75 * i + s, 0.5 * i + s, i + s), e[n(444)](o, o - 0.2 * this[n(424)], 0.8 * this[n(424)], 0.45 * Math.PI, 0, !1), a = { fac: 0.7, posX: o, posY: o - 0.2 * this[n(424)] };
        break;
      }
      default: {
        var u;
        switch (this[n(474)]) {
          case "shield": {
            u = [0.05, 0, 0.95, 0, 0.95, 0.8, 0.5, 1, 0.05, 0.8, 0.05, 0], a[n(489)] = 0.45 * i + s;
            break;
          }
          case n(482): {
            u = [0.1, 0, 0.9, 0, 0.9, 0.8, 0.6, 0.8, 0.5, 1, 0.4, 0.8, 0.1, 0.8, 0.1, 0], a.fac = 0.8, a[n(489)] = 0.4 * i + s;
            break;
          }
          case n(395): {
            u = [0.05, 0, 0.95, 0, 0.95, 1, 0.5, 0.8, 0.05, 1, 0.05, 0], a.fac = 0.9, a[n(489)] = 0.4 * i + s;
            break;
          }
          case n(492): {
            u = [0.05, 0.2, 0.5, 0, 0.95, 0.2, 0.95, 0.8, 0.5, 1, 0.05, 0.8, 0.05, 0.2], a[n(458)] = 0.9, a[n(489)] = 0.5 * i + s;
            break;
          }
          case n(414): {
            u = [0.25, 0, 0.75, 0, 1, 0.2, 1, 0.4, 0.5, 1, 0, 0.4, 0, 0.2, 0.25, 0], a.fac = 0.75, a.posY = 0.35 * i + s;
            break;
          }
          case n(415): {
            u = [0, 0, 1, 0, 0.5, 1, 0, 0], a[n(458)] = 0.6, a[n(489)] = 0.3 * i + s;
            break;
          }
          case n(478): {
            u = [0.5, 0.05, 1, 0.95, 0, 0.95, 0.5, 0.05], a.fac = 0.7, a[n(489)] = 0.65 * i + s;
            break;
          }
          case n(426): {
            u = [0.5, 0, 1, 0.5, 0.5, 1, 0, 0.5, 0.5, 0], a.fac = 0.7;
            break;
          }
          case n(399):
          default: {
            u = [0, 0, 1, 0, 1, 1, 0, 1, 0, 0];
            break;
          }
        }
        for (var x = 0; x < u[n(410)]; x += 2) e.lineTo(u[x] * i + s, u[x + 1] * i + s);
      }
    }
    return e.closePath(), a;
  }
  [yn(484)](t, e, n, i, s) {
    var o = yn, a = this[o(456)] ? this[o(456)][o(404)]() : "#000", u = this[o(472)] ? this[o(472)][o(404)]() : "#000";
    this[o(474)] == o(430) && this[o(472)] && this[o(456)] && (u = this[o(456)][o(404)](), a = this[o(472)][o(404)]()), e[o(452)](s, 0, 0, s, 0, 0), e[o(485)](n, i);
    var x = this[o(490)](t, e, s);
    if (this[o(456)]) {
      if (this[o(385)] && this[o(474)] != o(430)) {
        var c = e[o(469)](0, 0, t.size / 2, t[o(497)]);
        c[o(455)](1, Jo(a)), c.addColorStop(0, Jo(u)), e[o(425)] = c;
      } else e.fillStyle = Jo(a);
      e[o(483)]();
    }
    if (this[o(472)] && t.strokeWidth && (e.strokeStyle = t.strokeStyle, e[o(416)] = t[o(435)], e[o(397)]()), this._glyph[o(413)]) {
      e[o(403)] = this._fontStyle + " " + 2 * x[o(458)] * this[o(424)] * this[o(448)] + "px " + this[o(389)][o(403)], e.strokeStyle = e[o(425)], e[o(416)] = t[o(435)] * (this[o(474)] == o(430) ? 2 : 1), e[o(425)] = Jo(this[o(496)] || u), e.textAlign = o(391), e[o(487)] = o(494);
      var f = this._glyph[o(413)];
      t[o(435)] && u != "transparent" && e[o(428)](f, x[o(471)], x[o(489)]), e[o(454)](f, x[o(471)], x.posY);
    }
    if (this[o(474)] == o(450) && this[o(472)] && t[o(435)]) {
      e[o(495)] = t[o(495)], e[o(416)] = t[o(435)];
      var l = this[o(424)] + t[o(435)], h = this[o(424)] * Math[o(480)](Math.PI / 4);
      e[o(475)](l + h, l - h), e[o(398)](l - h, l + h), e[o(397)]();
    }
  }
  [yn(429)]() {
    var t = yn, e = this._stroke !== null ? this[t(472)][t(429)]() : "-", n = this[t(456)] !== null ? this[t(456)][t(429)]() : "-", i = this[t(438)] === null || e != this[t(438)][1] || n != this[t(438)][2] || this[t(424)] != this.checksums_[3] || this._form + "-" + this[t(491)] != this.checksums_[4];
    if (i) {
      var s = "c" + e + n + (this[t(424)] !== void 0 ? this[t(424)].toString() : "-") + this[t(474)] + "-" + this[t(491)];
      this.checksums_ = [s, e, n, this[t(424)], this[t(474)] + "-" + this.glyphs_];
    }
    return this.checksums_[0];
  }
};
cs[yn(388)] = { fonts: {}, glyphs: {} };
var f5 = ag;
function og() {
  var r = ["16460ZlvhEN", "852KNMHbe", "9CrNPZM", "6438LONynx", "2505264MkQSkb", "2247940FSuMDA", "56gbyTeE", "20223995jnnAZl", "279QXuiNv", "p-helper-control-point-div", "1121771tqOOhY", "se_disabled", "5106444MCOmih"];
  return og = function() {
    return r;
  }, og();
}
(function(r, t) {
  for (var e = ag, n = r(); ; )
    try {
      var i = parseInt(e(305)) / 1 * (-parseInt(e(300)) / 2) + parseInt(e(301)) / 3 + parseInt(e(309)) / 4 + parseInt(e(297)) / 5 * (parseInt(e(298)) / 6) + parseInt(e(307)) / 7 * (parseInt(e(303)) / 8) + parseInt(e(299)) / 9 * (-parseInt(e(302)) / 10) + -parseInt(e(304)) / 11;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(og, 739494);
function ag(r, t) {
  var e = og();
  return ag = function(n, i) {
    n = n - 297;
    var s = e[n];
    return s;
  }, ag(r, t);
}
const bo = { TWO_PI: Math.PI * 2, HALF_PI: Math.PI / 2, FITTING_COUNT: 100, ZERO_TOLERANCE: 1e-4, HELPER_HIDDEN_DIV: "p-helper-hidden-div", HELPER_CONTROL_POINT_DIV: f5(306), HELPER_shizi: "mybkkd", SE_DISABLED: f5(308) };
(function(r, t) {
  const e = Qe, n = r();
  for (; ; )
    try {
      if (-parseInt(e(241)) / 1 + parseInt(e(262)) / 2 + parseInt(e(259)) / 3 * (parseInt(e(240)) / 4) + -parseInt(e(246)) / 5 + parseInt(e(252)) / 6 + parseInt(e(242)) / 7 * (parseInt(e(249)) / 8) + -parseInt(e(250)) / 9 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ug, 786407);
function bs(r, t) {
  const e = Qe;
  let n = t[0] - r[0], i = t[1] - r[1];
  return Math[e(256)](n * n + i * i);
}
function sw(r) {
  const t = Qe;
  let e = 0;
  for (let n = 0; n < r[t(234)] - 1; n++)
    e += bs(r[n], r[n + 1]);
  return e;
}
function OC(r) {
  return Math[Qe(253)](sw(r), 0.99);
}
function ug() {
  const r = ["TWO_PI", "FITTING_COUNT", "abs", "push", "4eDfhJe", "259301Jsdmsv", "6064660lfoPAk", "lines", "reverse", "cos", "930535CqKfEe", "atan2", "max", "8KHkgEb", "19964619ZOkiDc", "points", "5494080GTMjQA", "pow", "forEach", "ZERO_TOLERANCE", "sqrt", "sin", "toFixed", "373731jZtsqw", "floor", "asin", "3086938zlwpsD", "concat", "length", "angle"];
  return ug = function() {
    return r;
  }, ug();
}
function B_(r, t) {
  return [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2];
}
function xg(r, t) {
  return Math[Qe(247)](t[1] - r[1], t[0] - r[0]);
}
function RC(r, t, e) {
  let n = [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2], i = [n[0] - r[1] + t[1], n[1] + r[0] - t[0]], s = [(r[0] + e[0]) / 2, (r[1] + e[1]) / 2], o = [s[0] - r[1] + e[1], s[1] + r[0] - e[0]];
  return ow(n, i, s, o);
}
function ow(r, t, e, n) {
  if (r[1] == t[1]) {
    var i = (n[0] - e[0]) / (n[1] - e[1]), s = i * (r[1] - e[1]) + e[0], o = r[1];
    return [s, o];
  }
  if (e[1] == n[1]) {
    var a = (t[0] - r[0]) / (t[1] - r[1]);
    return s = a * (e[1] - r[1]) + r[0], o = e[1], [s, o];
  }
  return a = (t[0] - r[0]) / (t[1] - r[1]), i = (n[0] - e[0]) / (n[1] - e[1]), o = (a * r[1] - r[0] - i * e[1] + e[0]) / (a - i), s = a * o - a * r[1] + r[0], [s, o];
}
function cg(r, t) {
  const e = Qe, n = Math[e(261)](Math[e(238)](t[1] - r[1]) / bs(r, t));
  let i;
  return t[1] >= r[1] && t[0] >= r[0] ? i = n + Math.PI : t[1] >= r[1] && t[0] < r[0] ? i = bo[e(236)] - n : t[1] < r[1] && t[0] < r[0] ? i = n : t[1] < r[1] && t[0] >= r[0] && (i = Math.PI - n), i;
}
function AC(r, t, e) {
  const n = Qe, i = cg(t, r) - cg(t, e);
  return i < 0 ? i + bo[n(236)] : i;
}
function aw(r, t, e) {
  return (e[1] - r[1]) * (t[0] - r[0]) > (t[1] - r[1]) * (e[0] - r[0]);
}
function uw(r, t, e) {
  return [t[0] + r * (e[0] - t[0]), t[1] + r * (e[1] - t[1])];
}
function nl(r, t, e) {
  let n = bs(r, t), i = e / n;
  return uw(i, r, t);
}
function xw(r, t, e, n, i) {
  r = Math[Qe(248)](Math.min(r, 1), 0);
  const o = 1 - r, a = r * r, u = a * r, x = o * o, c = x * o, f = c * t[0] + 3 * x * r * e[0] + 3 * o * a * n[0] + u * i[0], l = c * t[1] + 3 * x * r * e[1] + 3 * o * a * n[1] + u * i[1];
  return [f, l];
}
function TC(r, t) {
  const e = Qe;
  let n = 0, i = r[0], s = [i];
  for (let o = 1; o < r[e(234)]; o++) {
    const a = r[o];
    let u = n + bs(i, a), x = t - n;
    for (; u >= t; ) {
      let c = nl(i, a, x);
      s.push(c), x = t, u -= t, i = c;
    }
    n = u, i = a;
  }
  return s[e(239)](i), s;
}
function G_(r, t, e = 10) {
  const n = Qe;
  if (!Array.isArray(r) || !t) return null;
  const i = [];
  let s = t / 2;
  return r[n(254)]((o, a) => {
    const u = n;
    if (!a) return;
    const x = r[a - 1];
    let c = xg(o, x);
    const f = Math.sqrt(Math[u(253)](o[0] - x[0], 2) + Math[u(253)](o[1] - x[1], 2)), l = s + f;
    if (l < t) s = l;
    else if (l === t) {
      a !== r[u(234)] - 1 && (c = (Math.PI - xg(r[a + 1], o)) / 2);
      const { prevs: p, nexts: y } = l5(o, r, a, e / 2);
      i[u(239)]({ point: o, angle: c, prevs: p, nexts: y }), s = 0;
    } else {
      const h = t - s;
      let p = f - h, y, v;
      for (; p > 0; ) {
        const m = p / f;
        y = o[0] - (o[0] - x[0]) * m, v = o[1] - (o[1] - x[1]) * m;
        const { prevs: d, nexts: g } = l5([y, v], r, a, e / 2);
        i[u(239)]({ point: [y, v], angle: c, prevs: d, nexts: g }), p -= t;
      }
      s = Math[u(256)](Math.pow(o[0] - y, 2) + Math[u(253)](o[1] - v, 2));
    }
  }), i;
}
function l5(r, t, e, n) {
  const i = Qe, s = [], o = [];
  let a = r, u = 0, x = 0, c = 0;
  for (let f = e; f > 0; f--) {
    if (c = bs(t[f - 1], a), u + c <= n) s[i(239)](t[f - 1]), u += c;
    else {
      c = n - u;
      const l = nl(a, t[f - 1], c);
      s[i(239)](l);
      break;
    }
    a = t[f - 1];
  }
  a = r;
  for (let f = e; f < t[i(234)]; f++) {
    if (c = bs(a, t[f]), x + c <= n) o[i(239)](t[f]), x += c;
    else {
      c = n - x;
      const l = nl(a, t[f], c);
      o[i(239)](l);
      break;
    }
    a = t[f];
  }
  return { prevs: s[i(244)](), nexts: o };
}
function DC(r, t) {
  const e = Qe;
  let n = kC(r), i = [];
  for (let s = 0; s < n.lineCount; s++) {
    let o = n[e(243)][s][e(251)], a = 0, u = o[0], x = [u];
    for (let c = 1; c < o[e(234)]; c++) {
      const f = o[c];
      let l = a + bs(u, f), h = t - a;
      for (; l >= t; ) {
        let p = nl(u, f, h);
        x[e(239)](p), h = t, l -= t, u = p;
      }
      a = l, u = f;
    }
    x.length >= 2 && i.push(x);
  }
  if (i[e(234)] == 0) {
    let s = FC(r);
    i[e(239)](s);
  }
  return i;
}
function Qe(r, t) {
  const e = ug();
  return Qe = function(n, i) {
    return n = n - 234, e[n];
  }, Qe(r, t);
}
function FC(r) {
  const t = Qe;
  var e = r[t(234)] % 2 === 0;
  if (e) {
    var n = r[t(234)] / 2 - 1, i = r[t(234)] / 2;
    return [r[n], r[i]];
  } else {
    var s = Math[t(260)](r[t(234)] / 2);
    return [r[s - 1], r[s]];
  }
}
function kC(r) {
  const t = Qe;
  let e = [], n = 0;
  function i(s, o) {
    return Math[Qe(247)](o[1] - s[1], o[0] - s[0]);
  }
  for (let s = 0; s < r[t(234)] - 1; s++) {
    let o = r[s], a = r[s + 1], u = i(o, a), x = u[t(258)](4);
    s === 0 || x !== e[n - 1][t(235)] ? (e[t(239)]({ angle: x, points: [o, a] }), n++) : e[n - 1][t(251)][t(239)](a);
  }
  return { lineCount: n, lines: e };
}
function BC(r, t, e, n, i) {
  const s = Qe, o = cg(r, t), a = i ? o + e : o - e, u = n * Math[s(245)](a), x = n * Math.sin(a);
  return [t[0] + u, t[1] + x];
}
function GC(r, t, e, n) {
  const i = Qe;
  let s = n - e;
  s = s < 0 ? s + bo[i(236)] : s;
  let o = [];
  for (let a = 0; a <= bo[i(237)]; a++) {
    const u = e + s * a / bo[i(237)];
    o[i(239)]([r[0] + t * Math[i(245)](u), r[1] + t * Math[i(257)](u)]);
  }
  return o;
}
function wy(r, t, e, n) {
  const i = Qe, s = Ey(t, e, n), o = Math[i(256)](s[0] * s[0] + s[1] * s[1]), a = s[0] / o, u = s[1] / o, x = bs(t, e), c = bs(e, n);
  let f, l;
  if (o > bo[i(255)])
    if (aw(t, e, n)) {
      const h = r * x;
      f = [e[0] - h * u, e[1] + h * a];
      const p = r * c;
      l = [e[0] + p * u, e[1] - p * a];
    } else {
      const h = r * x;
      f = [e[0] + h * u, e[1] - h * a];
      const p = r * c;
      l = [e[0] - p * u, e[1] + p * a];
    }
  else f = [e[0] + r * (t[0] - e[0]), e[1] + r * (t[1] - e[1])], l = [e[0] + r * (n[0] - e[0]), e[1] + r * (n[1] - e[1])];
  return [f, l];
}
function Ey(r, t, e) {
  let n = r[0] - t[0], i = r[1] - t[1];
  const s = Math.sqrt(n * n + i * i);
  n /= s, i /= s;
  let o = e[0] - t[0], a = e[1] - t[1];
  const u = Math.sqrt(o * o + a * a);
  return o /= u, a /= u, [n + o, i + a];
}
function YC(r, t) {
  const e = Qe;
  let i = [cw(t)];
  for (let a = 0; a < t[e(234)] - 2; a++) {
    const u = t[a], x = t[a + 1], c = t[a + 2], f = wy(r, u, x, c);
    i = i[e(263)](f);
  }
  const s = fw(t);
  i[e(239)](s);
  let o = [];
  for (let a = 0; a < t.length - 1; a++) {
    const u = t[a], x = t[a + 1];
    o[e(239)](u);
    for (let c = 0; c < bo[e(237)]; c++) {
      const f = xw(c / bo[e(237)], u, i[a * 2], i[a * 2 + 1], x);
      o[e(239)](f);
    }
    o[e(239)](x);
  }
  return o;
}
function cw(r) {
  const t = Qe, e = r[0], n = r[1], i = r[2], s = wy(0, e, n, i), o = s[0], a = Ey(e, n, i), u = Math.sqrt(a[0] * a[0] + a[1] * a[1]);
  let x, c;
  if (u > bo[t(255)]) {
    const f = B_(e, n), l = e[0] - f[0], h = e[1] - f[1], p = bs(e, n), y = 2 / p, v = -y * h, m = y * l, d = v * v - m * m, g = 2 * v * m, _ = m * m - v * v, b = o[0] - f[0], w = o[1] - f[1];
    x = f[0] + d * b + g * w, c = f[1] + g * b + _ * w;
  }
  return [x, c];
}
function fw(r) {
  const t = Qe, e = r[t(234)], n = r[e - 3], i = r[e - 2], s = r[e - 1], o = wy(0, n, i, s), a = o[1], u = Ey(n, i, s), x = Math[t(256)](u[0] * u[0] + u[1] * u[1]);
  let c, f;
  if (x > bo[t(255)]) {
    const l = B_(i, s), h = s[0] - l[0], p = s[1] - l[1], y = bs(i, s), v = 2 / y, m = -v * p, d = v * h, g = m * m - d * d, _ = 2 * m * d, b = d * d - m * m, w = a[0] - l[0], E = a[1] - l[1];
    c = l[0] + g * w + _ * E, f = l[1] + _ * w + b * E;
  }
  return [c, f];
}
function XC(r) {
  const t = Qe;
  if (r[t(234)] <= 2) return r;
  let e = [];
  const n = r[t(234)] - 1;
  for (let i = 0; i <= 1; i += 0.01) {
    let s = 0, o = 0;
    for (let a = 0; a <= n; a++) {
      const u = lw(n, a), x = Math[t(253)](i, a), c = Math[t(253)](1 - i, n - a);
      s += u * x * c * r[a][0], o += u * x * c * r[a][1];
    }
    e[t(239)]([s, o]);
  }
  return e[t(239)](r[n]), e;
}
function lw(r, t) {
  return Bh(r) / (Bh(t) * Bh(r - t));
}
function Bh(r) {
  if (r <= 1) return 1;
  if (r == 2) return 2;
  if (r == 3) return 6;
  if (r == 4) return 24;
  if (r == 5) return 120;
  let t = 1;
  for (let e = 1; e <= r; e++)
    t *= e;
  return t;
}
function qC(r) {
  const t = Qe;
  if (r[t(234)] <= 2) return r;
  const e = 2;
  let n = [];
  const i = r[t(234)] - e - 1;
  n[t(239)](r[0]);
  for (let s = 0; s <= i; s++)
    for (let o = 0; o <= 1; o += 0.05) {
      let a = 0, u = 0;
      for (let x = 0; x <= e; x++) {
        const c = hw(x, o);
        a += c * r[s + x][0], u += c * r[s + x][1];
      }
      n[t(239)]([a, u]);
    }
  return n[t(239)](r[r[t(234)] - 1]), n;
}
function hw(r, t) {
  const e = Qe;
  return r == 0 ? Math[e(253)](t - 1, 2) / 2 : r == 1 ? (-2 * Math[e(253)](t, 2) + 2 * t + 1) / 2 : r == 2 ? Math[e(253)](t, 2) / 2 : 0;
}
const Xa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  angle: xg,
  distance: bs,
  getAnchorPoints: G_,
  getAngleOfThreePoints: AC,
  getArcPoints: GC,
  getAzimuth: cg,
  getBaseLength: OC,
  getBezierPoints: XC,
  getBinomialFactor: lw,
  getBisectorNormals: wy,
  getCircleCenterOfThreePoints: RC,
  getCubicValue: xw,
  getCurvePoints: YC,
  getFactorial: Bh,
  getIntersectPoint: ow,
  getLeftMostControlPoint: cw,
  getNormal: Ey,
  getPointOnLine: uw,
  getPointOnLineByDistance: nl,
  getQBSplinePoints: qC,
  getQuadricBSplineFactor: hw,
  getRightMostControlPoint: fw,
  getThirdPoint: BC,
  isClockWise: aw,
  mid: B_,
  splitLineEvenly: TC,
  splitLineEvenlys: DC,
  wholeDistance: sw
}, Symbol.toStringTag, { value: "Module" }));
(function(r, t) {
  const e = fg, n = r();
  for (; ; )
    try {
      if (-parseInt(e(251)) / 1 * (parseInt(e(257)) / 2) + -parseInt(e(256)) / 3 * (-parseInt(e(253)) / 4) + -parseInt(e(252)) / 5 + parseInt(e(258)) / 6 + parseInt(e(259)) / 7 * (-parseInt(e(260)) / 8) + -parseInt(e(261)) / 9 + parseInt(e(254)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(lg, 556428);
function fg(r, t) {
  const e = lg();
  return fg = function(n, i) {
    return n = n - 250, e[n];
  }, fg(r, t);
}
function lg() {
  const r = ["757161JKJlOV", "keys", "216703hZasVg", "1160210xYkqJe", "4ZZafFv", "16930630nthtKU", "isArray", "177081PImNhY", "6JJwQgU", "793920uEBpTg", "77cYMQfL", "263056DSYPsg"];
  return lg = function() {
    return r;
  }, lg();
}
const zC = { Circle: x0, Fill: Hr, Icon: rc, Image: nc, IconImage: N_, RegularShape: _o, Stroke: ys, Style: En, Text: Dl, cme_style_FontSymbol: cs };
function Is(r) {
  const t = fg;
  if (!r || typeof r != "object") return r;
  const e = {};
  for (const n of Object[t(250)](r)) {
    const i = zC[n];
    if (i)
      return new i(Is(r[n]));
    Array[t(255)](r[n]) ? e[n] = r[n] : e[n] = Is(r[n]);
  }
  return e;
}
(function(r, t) {
  const e = rl, n = r();
  for (; ; )
    try {
      if (parseInt(e(155)) / 1 + -parseInt(e(164)) / 2 + -parseInt(e(163)) / 3 * (parseInt(e(157)) / 4) + -parseInt(e(144)) / 5 * (parseInt(e(145)) / 6) + -parseInt(e(154)) / 7 + parseInt(e(159)) / 8 * (parseInt(e(152)) / 9) + parseInt(e(146)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(hg, 347854);
function hg() {
  const r = ["color", "9bhYyAH", "restore", "3200162RmfzOD", "273611MBJtJY", "lineWidth", "420oqJPlY", "points", "4357256iPlRZc", "splitLineEvenly", "atan2", "translate", "5223wjhMxU", "999364SmcIRe", "stroke", "length", "moveTo", "options", "red", "lineTo", "save", "abs", "30XProtu", "164334JejOse", "8335730oJWLaQ", "context", "strokeStyle", "offset", "width"];
  return hg = function() {
    return r;
  }, hg();
}
function rl(r, t) {
  const e = hg();
  return rl = function(n, i) {
    return n = n - 139, e[n];
  }, rl(r, t);
}
function UC(r) {
  const t = rl;
  r = { lineStyle: { Style: { stroke: { Stroke: { color: t(140), width: 5, lineDash: [5, 10, 25] } } } }, options: { offset: 10, color: "red", width: 4 } };
  let e = Is(r.lineStyle), n = r[t(139)];
  const i = new En({ renderer: (s, o) => {
    const a = t, u = o[a(147)];
    u[a(142)]();
    const x = Xa[a(160)](s, 40);
    for (let c = 1; c < x[a(166)]; c++)
      console.log(a(158), x), VC(u, x[c - 1], x[c], n);
    u[a(153)]();
  } });
  return [e, i];
}
function VC(r, t, e, n) {
  const i = rl;
  let s = n[i(149)], o = n[i(151)], a = n[i(150)], u = 0;
  u = s > 0 ? 0 : Math.PI;
  const x = Math[i(161)](t[1] - e[1], t[0] - e[0]) + u, c = Math[i(143)](s), f = (t[0] + e[0]) / 2, l = (t[1] + e[1]) / 2;
  r[i(148)] = o, r[i(156)] = a, r.save(), r[i(162)](f, l), r.rotate(x), r.beginPath(), r[i(167)](0, 0), r[i(141)](0, c), r[i(165)](), r[i(153)]();
}
(function(r, t) {
  const e = pg, n = r();
  for (; ; )
    try {
      if (parseInt(e(428)) / 1 + parseInt(e(432)) / 2 * (parseInt(e(417)) / 3) + parseInt(e(420)) / 4 * (-parseInt(e(413)) / 5) + -parseInt(e(429)) / 6 * (parseInt(e(409)) / 7) + -parseInt(e(410)) / 8 * (-parseInt(e(408)) / 9) + parseInt(e(415)) / 10 * (-parseInt(e(427)) / 11) + -parseInt(e(419)) / 12 * (parseInt(e(426)) / 13) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(dg, 273722);
function pg(r, t) {
  const e = dg();
  return pg = function(n, i) {
    return n = n - 401, e[n];
  }, pg(r, t);
}
function h5(r) {
  const t = pg;
  let e = Is(r[t(416)]);
  const n = r[t(424)], i = ((n == null ? void 0 : n[t(430)]) || 10) * 2, s = (n == null ? void 0 : n.distance) || 120, o = !!(n != null && n[t(422)]) || !1;
  let a = new En({ renderer: (u, x) => {
    const c = t, f = x[c(431)];
    f[c(435)]();
    let l = G_(u, s, i);
    f.fillStyle = (n == null ? void 0 : n.color) || c(414);
    for (let h = 0; h < l[c(405)]; h++) {
      const { point: p, angle: y, prevs: v, nexts: m } = l[h], d = o ? y : y + Math.PI, g = p[0] + Math.sin(d) * i * Math.SQRT2 / 2, _ = p[1] - Math.cos(d) * i * Math[c(433)] / 2, b = v[c(404)]([p])[c(404)](m)[c(404)]([[g, _]]);
      f[c(412)](), f[c(421)](b[0][0], b[0][1]), b[c(411)]((w) => f[c(403)](w[0], w[1])), f[c(401)](), f[c(407)]();
    }
    f.restore();
  } });
  return [e, a];
}
function dg() {
  const r = ["SQRT2", "getThirdPoint", "save", "angle", "fill", "fillStyle", "lineTo", "concat", "length", "mid", "closePath", "144khQRCQ", "483SZBxHT", "250736KsUEOk", "forEach", "beginPath", "210YBJMDS", "#00f", "124940WuUVvG", "lineStyle", "714wbCgvv", "getPointOnLineByDistance", "360GdYwIS", "23564xFuIaH", "moveTo", "clockwise", "sqrt_2", "options", "color", "256646qwyTsc", "55NreMgB", "269889STHjPi", "8886pMWsOl", "radius", "context", "4258HMYZSi"];
  return dg = function() {
    return r;
  }, dg();
}
function gg(r, t) {
  const e = yg();
  return gg = function(n, i) {
    return n = n - 153, e[n];
  }, gg(r, t);
}
(function(r, t) {
  const e = gg, n = r();
  for (; ; )
    try {
      if (-parseInt(e(179)) / 1 + -parseInt(e(167)) / 2 * (parseInt(e(161)) / 3) + parseInt(e(182)) / 4 * (parseInt(e(170)) / 5) + parseInt(e(158)) / 6 * (-parseInt(e(180)) / 7) + -parseInt(e(162)) / 8 + parseInt(e(165)) / 9 * (-parseInt(e(155)) / 10) + -parseInt(e(183)) / 11 * (-parseInt(e(181)) / 12) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(yg, 702401);
function WC(r) {
  const t = gg;
  let e = Is(r.lineStyle);
  const n = r[t(172)], i = (n == null ? void 0 : n[t(175)]) || 10, s = (n == null ? void 0 : n[t(156)]) || 120, o = !!(n != null && n[t(176)]) || !1;
  let a = new En({ renderer: (u, x) => {
    const c = t, f = x[c(173)];
    f[c(160)]();
    let l = G_(u, s, i);
    f.fillStyle = (n == null ? void 0 : n[c(153)]) || c(177);
    for (let h = 0; h < l[c(159)]; h++) {
      const { point: p, prevs: y, nexts: v } = l[h], m = y[c(174)]([p])[c(174)](v), d = Xa[c(164)](p, y[0]), g = Xa[c(164)](p, v[v[c(159)] - 1]);
      f[c(168)](), f[c(166)](m[0][0], p[0][1]), m[c(184)]((_) => f.lineTo(_[0], _[1])), f.arc(p[0], p[1], i, d, g, o), f[c(169)](), f.closePath();
    }
    f[c(171)]();
  } });
  return [e, a];
}
function yg() {
  const r = ["12rYqFch", "1695912gMcUYm", "47331691tBhKeF", "forEach", "color", "mid", "310610lJlgaA", "distance", "rgb(0,0,255)", "6XPGoeW", "length", "save", "15JzyAfl", "7165928iBhRxY", "sqrt_2", "angle", "387xssIjQ", "moveTo", "163794VyRhbU", "beginPath", "fill", "10jnmSVF", "restore", "options", "context", "concat", "radius", "clockwise", "#f00", "fillStyle", "1205670fqCTKo", "4213419PLbPLX"];
  return yg = function() {
    return r;
  }, yg();
}
(function(r, t) {
  const e = mg, n = r();
  for (; ; )
    try {
      if (parseInt(e(220)) / 1 * (-parseInt(e(214)) / 2) + parseInt(e(221)) / 3 * (-parseInt(e(198)) / 4) + -parseInt(e(207)) / 5 + parseInt(e(219)) / 6 * (-parseInt(e(215)) / 7) + parseInt(e(203)) / 8 + parseInt(e(223)) / 9 + parseInt(e(226)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(vg, 745294);
function vg() {
  const r = ["fillStyle", "1842995AWjEfy", "#f00", "clockwise", "restore", "radius", "#00f", "context", "6qBAqmA", "14EhunQs", "length", "getAnchorPoints", "beginPath", "1252650LRpFZH", "431153JrlXEi", "9pFhLAc", "cos", "3425544WKJdtc", "sqrt_2", "arc", "18214370gVHadp", "save", "getThirdPoint", "concat", "angle", "getPointOnLineByDistance", "117556RUuSRX", "closePath", "SQRT2", "lineTo", "moveTo", "5688128Gahbkd", "forEach", "fill"];
  return vg = function() {
    return r;
  }, vg();
}
function mg(r, t) {
  const e = vg();
  return mg = function(n, i) {
    return n = n - 194, e[n];
  }, mg(r, t);
}
function HC(r) {
  const t = mg;
  let e = Is(r.lineStyle);
  const n = r.options, i = n[t(211)] || 10, s = n.distance || 120, o = !!(n != null && n[t(209)]) || !1;
  let a = new En({ renderer: (u, x) => {
    const c = t, f = x[c(213)];
    f[c(227)]();
    let l = Xa[c(217)](u, s, i * 2);
    for (let h = 0; h < l[c(216)]; h++) {
      const { point: p, angle: y, prevs: v, nexts: m } = l[h];
      if (h % 2) {
        const d = v[c(195)]([p])[c(195)](m), g = Xa[c(196)](p, v[0]), _ = xg(p, m[m[c(216)] - 1]);
        f.beginPath(), f[c(202)](d[0][0], p[0][1]), d[c(204)]((b) => f[c(201)](b[0], b[1])), f[c(225)](p[0], p[1], i, g, _, o), f[c(206)] = c(208);
      } else {
        const d = o ? y + Math.PI : y, g = p[0] + Math.sin(d) * i * Math[c(200)], _ = p[1] - Math[c(222)](d) * i * Math[c(200)], b = v[c(195)]([p])[c(195)](m)[c(195)]([[g, _]]);
        f.beginPath(), f[c(202)](b[0][0], b[0][1]), b.forEach((w) => f[c(201)](w[0], w[1])), f[c(206)] = c(212);
      }
      f.fill(), f[c(199)]();
    }
    f[c(210)]();
  } });
  return [e, a];
}
function _g() {
  const r = ["getPointOnLineByDistance", "radius", "1355560tNXdfW", "clockwise", "fillStyle", "concat", "lineTo", "moveTo", "3287564LQGDRD", "save", "restore", "413801ssLUUF", "9405olvMsD", "#00f", "length", "angle", "1466724UewDRP", "distance", "SQRT2", "4949080FnQrzg", "mid", "forEach", "9yqPxqM", "861194DgMrHV", "color", "closePath", "options", "arc", "#f00", "sin", "context", "getThirdPoint", "beginPath", "12BYsbKe", "getAnchorPoints", "fill"];
  return _g = function() {
    return r;
  }, _g();
}
(function(r, t) {
  const e = bg, n = r();
  for (; ; )
    try {
      if (parseInt(e(475)) / 1 + -parseInt(e(487)) / 2 + -parseInt(e(480)) / 3 + -parseInt(e(502)) / 4 + parseInt(e(476)) / 5 * (parseInt(e(497)) / 6) + parseInt(e(472)) / 7 + parseInt(e(483)) / 8 * (parseInt(e(486)) / 9) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(_g, 247455);
function JC(r) {
  const t = bg;
  let e = Is(r.lineStyle);
  const n = r[t(490)] || {}, i = n[t(501)] || 10, s = n[t(481)] || 120, o = !!(n != null && n[t(503)]) || !1;
  let a = new En({ renderer: (u, x) => {
    const c = t, f = x[c(494)];
    f[c(473)]();
    let l = Xa[c(498)](u, s, i * 2);
    for (let h = 0; h < l[c(478)]; h++) {
      const { point: p, angle: y, prevs: v, nexts: m } = l[h];
      if (h % 2) {
        const d = v[c(469)]([p])[c(469)](m), g = Xa[c(479)](p, v[0]), _ = Xa[c(479)](p, m[m[c(478)] - 1]);
        f[c(496)](), f[c(471)](d[0][0], p[0][1]), d[c(485)]((b) => f[c(470)](b[0], b[1])), f[c(491)](p[0], p[1], i, g, _, !o), f[c(468)] = c(492);
      } else {
        const d = p[0] + Math[c(493)](y) * i * Math[c(482)], g = p[1] - Math.cos(y) * i * Math[c(482)], _ = v.concat([p])[c(469)](m)[c(469)]([[d, g]]);
        f[c(496)](), f[c(471)](_[0][0], _[0][1]), _.forEach((b) => f[c(470)](b[0], b[1])), f.fillStyle = c(477);
      }
      f.fill(), f[c(489)]();
    }
    f[c(474)]();
  } });
  return [e, a];
}
function bg(r, t) {
  const e = _g();
  return bg = function(n, i) {
    return n = n - 468, e[n];
  }, bg(r, t);
}
var Xn = 63710088e-1, Sy = {
  centimeters: Xn * 100,
  centimetres: Xn * 100,
  degrees: Xn / 111325,
  feet: Xn * 3.28084,
  inches: Xn * 39.37,
  kilometers: Xn / 1e3,
  kilometres: Xn / 1e3,
  meters: Xn,
  metres: Xn,
  miles: Xn / 1609.344,
  millimeters: Xn * 1e3,
  millimetres: Xn * 1e3,
  nauticalmiles: Xn / 1852,
  radians: 1,
  yards: Xn * 1.0936
}, pw = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1e3,
  millimetres: 1e3,
  nauticalmiles: 1 / 1852,
  radians: 1 / Xn,
  yards: 1.0936133
}, Ig = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function Tn(r, t, e) {
  e === void 0 && (e = {});
  var n = { type: "Feature" };
  return (e.id === 0 || e.id) && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.properties = t || {}, n.geometry = r, n;
}
function dw(r, t, e) {
  switch (r) {
    case "Point":
      return Pt(t).geometry;
    case "LineString":
      return ge(t).geometry;
    case "Polygon":
      return Nt(t).geometry;
    case "MultiPoint":
      return Gl(t).geometry;
    case "MultiLineString":
      return c0(t).geometry;
    case "MultiPolygon":
      return Mi(t).geometry;
    default:
      throw new Error(r + " is invalid");
  }
}
function Pt(r, t, e) {
  if (e === void 0 && (e = {}), !r)
    throw new Error("coordinates is required");
  if (!Array.isArray(r))
    throw new Error("coordinates must be an Array");
  if (r.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Wn(r[0]) || !Wn(r[1]))
    throw new Error("coordinates must contain numbers");
  var n = {
    type: "Point",
    coordinates: r
  };
  return Tn(n, t, e);
}
function gw(r, t, e) {
  return e === void 0 && (e = {}), ht(r.map(function(n) {
    return Pt(n, t);
  }), e);
}
function Nt(r, t, e) {
  e === void 0 && (e = {});
  for (var n = 0, i = r; n < i.length; n++) {
    var s = i[n];
    if (s.length < 4)
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    for (var o = 0; o < s[s.length - 1].length; o++)
      if (s[s.length - 1][o] !== s[0][o])
        throw new Error("First and last Position are not equivalent.");
  }
  var a = {
    type: "Polygon",
    coordinates: r
  };
  return Tn(a, t, e);
}
function yw(r, t, e) {
  return e === void 0 && (e = {}), ht(r.map(function(n) {
    return Nt(n, t);
  }), e);
}
function ge(r, t, e) {
  if (e === void 0 && (e = {}), r.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  var n = {
    type: "LineString",
    coordinates: r
  };
  return Tn(n, t, e);
}
function vw(r, t, e) {
  return e === void 0 && (e = {}), ht(r.map(function(n) {
    return ge(n, t);
  }), e);
}
function ht(r, t) {
  t === void 0 && (t = {});
  var e = { type: "FeatureCollection" };
  return t.id && (e.id = t.id), t.bbox && (e.bbox = t.bbox), e.features = r, e;
}
function c0(r, t, e) {
  e === void 0 && (e = {});
  var n = {
    type: "MultiLineString",
    coordinates: r
  };
  return Tn(n, t, e);
}
function Gl(r, t, e) {
  e === void 0 && (e = {});
  var n = {
    type: "MultiPoint",
    coordinates: r
  };
  return Tn(n, t, e);
}
function Mi(r, t, e) {
  e === void 0 && (e = {});
  var n = {
    type: "MultiPolygon",
    coordinates: r
  };
  return Tn(n, t, e);
}
function Y_(r, t, e) {
  e === void 0 && (e = {});
  var n = {
    type: "GeometryCollection",
    geometries: r
  };
  return Tn(n, t, e);
}
function mw(r, t) {
  if (t === void 0 && (t = 0), t && !(t >= 0))
    throw new Error("precision must be a positive number");
  var e = Math.pow(10, t || 0);
  return Math.round(r * e) / e;
}
function Px(r, t) {
  t === void 0 && (t = "kilometers");
  var e = Sy[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return r * e;
}
function X0(r, t) {
  t === void 0 && (t = "kilometers");
  var e = Sy[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return r / e;
}
function wg(r, t) {
  return Za(X0(r, t));
}
function q0(r) {
  var t = r % 360;
  return t < 0 && (t += 360), t;
}
function Za(r) {
  var t = r % (2 * Math.PI);
  return t * 180 / Math.PI;
}
function Un(r) {
  var t = r % 360;
  return t * Math.PI / 180;
}
function z0(r, t, e) {
  if (t === void 0 && (t = "kilometers"), e === void 0 && (e = "kilometers"), !(r >= 0))
    throw new Error("length must be a positive number");
  return Px(X0(r, t), e);
}
function _w(r, t, e) {
  if (t === void 0 && (t = "meters"), e === void 0 && (e = "kilometers"), !(r >= 0))
    throw new Error("area must be a positive number");
  var n = Ig[t];
  if (!n)
    throw new Error("invalid original units");
  var i = Ig[e];
  if (!i)
    throw new Error("invalid final units");
  return r / n * i;
}
function Wn(r) {
  return !isNaN(r) && r !== null && !Array.isArray(r);
}
function we(r) {
  return !!r && r.constructor === Object;
}
function bw(r) {
  if (!r)
    throw new Error("bbox is required");
  if (!Array.isArray(r))
    throw new Error("bbox must be an Array");
  if (r.length !== 4 && r.length !== 6)
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  r.forEach(function(t) {
    if (!Wn(t))
      throw new Error("bbox must only contain numbers");
  });
}
function Iw(r) {
  if (!r)
    throw new Error("id is required");
  if (["string", "number"].indexOf(typeof r) === -1)
    throw new Error("id must be a number or a string");
}
const ZC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  areaFactors: Ig,
  bearingToAzimuth: q0,
  convertArea: _w,
  convertLength: z0,
  degreesToRadians: Un,
  earthRadius: Xn,
  factors: Sy,
  feature: Tn,
  featureCollection: ht,
  geometry: dw,
  geometryCollection: Y_,
  isNumber: Wn,
  isObject: we,
  lengthToDegrees: wg,
  lengthToRadians: X0,
  lineString: ge,
  lineStrings: vw,
  multiLineString: c0,
  multiPoint: Gl,
  multiPolygon: Mi,
  point: Pt,
  points: gw,
  polygon: Nt,
  polygons: yw,
  radiansToDegrees: Za,
  radiansToLength: Px,
  round: mw,
  unitsFactors: pw,
  validateBBox: bw,
  validateId: Iw
}, Symbol.toStringTag, { value: "Module" }));
function hn(r, t, e) {
  if (r !== null)
    for (var n, i, s, o, a, u, x, c = 0, f = 0, l, h = r.type, p = h === "FeatureCollection", y = h === "Feature", v = p ? r.features.length : 1, m = 0; m < v; m++) {
      x = p ? r.features[m].geometry : y ? r.geometry : r, l = x ? x.type === "GeometryCollection" : !1, a = l ? x.geometries.length : 1;
      for (var d = 0; d < a; d++) {
        var g = 0, _ = 0;
        if (o = l ? x.geometries[d] : x, o !== null) {
          u = o.coordinates;
          var b = o.type;
          switch (c = e && (b === "Polygon" || b === "MultiPolygon") ? 1 : 0, b) {
            case null:
              break;
            case "Point":
              if (t(
                u,
                f,
                m,
                g,
                _
              ) === !1)
                return !1;
              f++, g++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < u.length; n++) {
                if (t(
                  u[n],
                  f,
                  m,
                  g,
                  _
                ) === !1)
                  return !1;
                f++, b === "MultiPoint" && g++;
              }
              b === "LineString" && g++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < u.length; n++) {
                for (i = 0; i < u[n].length - c; i++) {
                  if (t(
                    u[n][i],
                    f,
                    m,
                    g,
                    _
                  ) === !1)
                    return !1;
                  f++;
                }
                b === "MultiLineString" && g++, b === "Polygon" && _++;
              }
              b === "Polygon" && g++;
              break;
            case "MultiPolygon":
              for (n = 0; n < u.length; n++) {
                for (_ = 0, i = 0; i < u[n].length; i++) {
                  for (s = 0; s < u[n][i].length - c; s++) {
                    if (t(
                      u[n][i][s],
                      f,
                      m,
                      g,
                      _
                    ) === !1)
                      return !1;
                    f++;
                  }
                  _++;
                }
                g++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < o.geometries.length; n++)
                if (hn(o.geometries[n], t, e) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function X_(r, t, e, n) {
  var i = e;
  return hn(
    r,
    function(s, o, a, u, x) {
      o === 0 && e === void 0 ? i = s : i = t(
        i,
        s,
        o,
        a,
        u,
        x
      );
    },
    n
  ), i;
}
function q_(r, t) {
  var e;
  switch (r.type) {
    case "FeatureCollection":
      for (e = 0; e < r.features.length && t(r.features[e].properties, e) !== !1; e++)
        ;
      break;
    case "Feature":
      t(r.properties, 0);
      break;
  }
}
function ww(r, t, e) {
  var n = e;
  return q_(r, function(i, s) {
    s === 0 && e === void 0 ? n = i : n = t(n, i, s);
  }), n;
}
function he(r, t) {
  if (r.type === "Feature")
    t(r, 0);
  else if (r.type === "FeatureCollection")
    for (var e = 0; e < r.features.length && t(r.features[e], e) !== !1; e++)
      ;
}
function z_(r, t, e) {
  var n = e;
  return he(r, function(i, s) {
    s === 0 && e === void 0 ? n = i : n = t(n, i, s);
  }), n;
}
function Lx(r) {
  var t = [];
  return hn(r, function(e) {
    t.push(e);
  }), t;
}
function Pi(r, t) {
  var e, n, i, s, o, a, u, x, c, f, l = 0, h = r.type === "FeatureCollection", p = r.type === "Feature", y = h ? r.features.length : 1;
  for (e = 0; e < y; e++) {
    for (a = h ? r.features[e].geometry : p ? r.geometry : r, x = h ? r.features[e].properties : p ? r.properties : {}, c = h ? r.features[e].bbox : p ? r.bbox : void 0, f = h ? r.features[e].id : p ? r.id : void 0, u = a ? a.type === "GeometryCollection" : !1, o = u ? a.geometries.length : 1, i = 0; i < o; i++) {
      if (s = u ? a.geometries[i] : a, s === null) {
        if (t(
          null,
          l,
          x,
          c,
          f
        ) === !1)
          return !1;
        continue;
      }
      switch (s.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (t(
            s,
            l,
            x,
            c,
            f
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < s.geometries.length; n++)
            if (t(
              s.geometries[n],
              l,
              x,
              c,
              f
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    l++;
  }
}
function U_(r, t, e) {
  var n = e;
  return Pi(
    r,
    function(i, s, o, a, u) {
      s === 0 && e === void 0 ? n = i : n = t(
        n,
        i,
        s,
        o,
        a,
        u
      );
    }
  ), n;
}
function sr(r, t) {
  Pi(r, function(e, n, i, s, o) {
    var a = e === null ? null : e.type;
    switch (a) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return t(
          Tn(e, i, { bbox: s, id: o }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var u;
    switch (a) {
      case "MultiPoint":
        u = "Point";
        break;
      case "MultiLineString":
        u = "LineString";
        break;
      case "MultiPolygon":
        u = "Polygon";
        break;
    }
    for (var x = 0; x < e.coordinates.length; x++) {
      var c = e.coordinates[x], f = {
        type: u,
        coordinates: c
      };
      if (t(Tn(f, i), n, x) === !1)
        return !1;
    }
  });
}
function Ew(r, t, e) {
  var n = e;
  return sr(
    r,
    function(i, s, o) {
      s === 0 && o === 0 && e === void 0 ? n = i : n = t(
        n,
        i,
        s,
        o
      );
    }
  ), n;
}
function Zo(r, t) {
  sr(r, function(e, n, i) {
    var s = 0;
    if (e.geometry) {
      var o = e.geometry.type;
      if (!(o === "Point" || o === "MultiPoint")) {
        var a, u = 0, x = 0, c = 0;
        if (hn(
          e,
          function(f, l, h, p, y) {
            if (a === void 0 || n > u || p > x || y > c) {
              a = f, u = n, x = p, c = y, s = 0;
              return;
            }
            var v = ge(
              [a, f],
              e.properties
            );
            if (t(
              v,
              n,
              i,
              y,
              s
            ) === !1)
              return !1;
            s++, a = f;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
function V_(r, t, e) {
  var n = e, i = !1;
  return Zo(
    r,
    function(s, o, a, u, x) {
      i === !1 && e === void 0 ? n = s : n = t(
        n,
        s,
        o,
        a,
        u,
        x
      ), i = !0;
    }
  ), n;
}
function W_(r, t) {
  if (!r) throw new Error("geojson is required");
  sr(r, function(e, n, i) {
    if (e.geometry !== null) {
      var s = e.geometry.type, o = e.geometry.coordinates;
      switch (s) {
        case "LineString":
          if (t(e, n, i, 0, 0) === !1)
            return !1;
          break;
        case "Polygon":
          for (var a = 0; a < o.length; a++)
            if (t(
              ge(o[a], e.properties),
              n,
              i,
              a
            ) === !1)
              return !1;
          break;
      }
    }
  });
}
function H_(r, t, e) {
  var n = e;
  return W_(
    r,
    function(i, s, o, a) {
      s === 0 && e === void 0 ? n = i : n = t(
        n,
        i,
        s,
        o,
        a
      );
    }
  ), n;
}
function Sw(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.featureIndex || 0, n = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, s = t.segmentIndex || 0, o = t.properties, a;
  switch (r.type) {
    case "FeatureCollection":
      e < 0 && (e = r.features.length + e), o = o || r.features[e].properties, a = r.features[e].geometry;
      break;
    case "Feature":
      o = o || r.properties, a = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      a = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (a === null) return null;
  var u = a.coordinates;
  switch (a.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      return s < 0 && (s = u.length + s - 1), ge(
        [u[s], u[s + 1]],
        o,
        t
      );
    case "Polygon":
      return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), ge(
        [
          u[i][s],
          u[i][s + 1]
        ],
        o,
        t
      );
    case "MultiLineString":
      return n < 0 && (n = u.length + n), s < 0 && (s = u[n].length + s - 1), ge(
        [
          u[n][s],
          u[n][s + 1]
        ],
        o,
        t
      );
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), s < 0 && (s = u[n][i].length - s - 1), ge(
        [
          u[n][i][s],
          u[n][i][s + 1]
        ],
        o,
        t
      );
  }
  throw new Error("geojson is invalid");
}
function Cw(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.featureIndex || 0, n = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, s = t.coordIndex || 0, o = t.properties, a;
  switch (r.type) {
    case "FeatureCollection":
      e < 0 && (e = r.features.length + e), o = o || r.features[e].properties, a = r.features[e].geometry;
      break;
    case "Feature":
      o = o || r.properties, a = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      a = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (a === null) return null;
  var u = a.coordinates;
  switch (a.type) {
    case "Point":
      return Pt(u, o, t);
    case "MultiPoint":
      return n < 0 && (n = u.length + n), Pt(u[n], o, t);
    case "LineString":
      return s < 0 && (s = u.length + s), Pt(u[s], o, t);
    case "Polygon":
      return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s), Pt(u[i][s], o, t);
    case "MultiLineString":
      return n < 0 && (n = u.length + n), s < 0 && (s = u[n].length + s), Pt(u[n][s], o, t);
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), s < 0 && (s = u[n][i].length - s), Pt(
        u[n][i][s],
        o,
        t
      );
  }
  throw new Error("geojson is invalid");
}
const KC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  coordAll: Lx,
  coordEach: hn,
  coordReduce: X_,
  featureEach: he,
  featureReduce: z_,
  findPoint: Cw,
  findSegment: Sw,
  flattenEach: sr,
  flattenReduce: Ew,
  geomEach: Pi,
  geomReduce: U_,
  lineEach: W_,
  lineReduce: H_,
  propEach: q_,
  propReduce: ww,
  segmentEach: Zo,
  segmentReduce: V_
}, Symbol.toStringTag, { value: "Module" }));
function Cn(r) {
  var t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return hn(r, function(e) {
    t[0] > e[0] && (t[0] = e[0]), t[1] > e[1] && (t[1] = e[1]), t[2] < e[0] && (t[2] = e[0]), t[3] < e[1] && (t[3] = e[1]);
  }), t;
}
Cn.default = Cn;
function Ae(r) {
  if (!r)
    throw new Error("coord is required");
  if (!Array.isArray(r)) {
    if (r.type === "Feature" && r.geometry !== null && r.geometry.type === "Point")
      return r.geometry.coordinates;
    if (r.type === "Point")
      return r.coordinates;
  }
  if (Array.isArray(r) && r.length >= 2 && !Array.isArray(r[0]) && !Array.isArray(r[1]))
    return r;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function gt(r) {
  if (Array.isArray(r))
    return r;
  if (r.type === "Feature") {
    if (r.geometry !== null)
      return r.geometry.coordinates;
  } else if (r.coordinates)
    return r.coordinates;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function J_(r) {
  if (r.length > 1 && Wn(r[0]) && Wn(r[1]))
    return !0;
  if (Array.isArray(r[0]) && r[0].length)
    return J_(r[0]);
  throw new Error("coordinates must only contain numbers");
}
function Mw(r, t, e) {
  if (!t || !e)
    throw new Error("type and name required");
  if (!r || r.type !== t)
    throw new Error("Invalid input to " + e + ": must be a " + t + ", given " + r.type);
}
function il(r, t, e) {
  if (!r)
    throw new Error("No feature passed");
  if (!e)
    throw new Error(".featureOf() requires a name");
  if (!r || r.type !== "Feature" || !r.geometry)
    throw new Error("Invalid input to " + e + ", Feature with geometry required");
  if (!r.geometry || r.geometry.type !== t)
    throw new Error("Invalid input to " + e + ": must be a " + t + ", given " + r.geometry.type);
}
function Ia(r, t, e) {
  if (!r)
    throw new Error("No featureCollection passed");
  if (!e)
    throw new Error(".collectionOf() requires a name");
  if (!r || r.type !== "FeatureCollection")
    throw new Error("Invalid input to " + e + ", FeatureCollection required");
  for (var n = 0, i = r.features; n < i.length; n++) {
    var s = i[n];
    if (!s || s.type !== "Feature" || !s.geometry)
      throw new Error("Invalid input to " + e + ", Feature with geometry required");
    if (!s.geometry || s.geometry.type !== t)
      throw new Error("Invalid input to " + e + ": must be a " + t + ", given " + s.geometry.type);
  }
}
function ke(r) {
  return r.type === "Feature" ? r.geometry : r;
}
function oi(r, t) {
  return r.type === "FeatureCollection" ? "FeatureCollection" : r.type === "GeometryCollection" ? "GeometryCollection" : r.type === "Feature" && r.geometry !== null ? r.geometry.type : r.type;
}
const jC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  collectionOf: Ia,
  containsNumber: J_,
  featureOf: il,
  geojsonType: Mw,
  getCoord: Ae,
  getCoords: gt,
  getGeom: ke,
  getType: oi
}, Symbol.toStringTag, { value: "Module" }));
var Cy = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ao(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function QC(r) {
  if (r.__esModule) return r;
  var t = r.default;
  if (typeof t == "function") {
    var e = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(e, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), e;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var p5 = Object.getOwnPropertySymbols, $C = Object.prototype.hasOwnProperty, tM = Object.prototype.propertyIsEnumerable;
function eM(r) {
  if (r == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(r);
}
function nM() {
  try {
    if (!Object.assign)
      return !1;
    var r = new String("abc");
    if (r[5] = "de", Object.getOwnPropertyNames(r)[0] === "5")
      return !1;
    for (var t = {}, e = 0; e < 10; e++)
      t["_" + String.fromCharCode(e)] = e;
    var n = Object.getOwnPropertyNames(t).map(function(s) {
      return t[s];
    });
    if (n.join("") !== "0123456789")
      return !1;
    var i = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(s) {
      i[s] = s;
    }), Object.keys(Object.assign({}, i)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var rM = nM() ? Object.assign : function(r, t) {
  for (var e, n = eM(r), i, s = 1; s < arguments.length; s++) {
    e = Object(arguments[s]);
    for (var o in e)
      $C.call(e, o) && (n[o] = e[o]);
    if (p5) {
      i = p5(e);
      for (var a = 0; a < i.length; a++)
        tM.call(e, i[a]) && (n[i[a]] = e[i[a]]);
    }
  }
  return n;
};
const Z_ = /* @__PURE__ */ Ao(rM);
/**
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */
var d5 = {
  successCallback: null,
  verbose: !1
}, dh = {};
function iM(r, t, e) {
  e = e || {};
  for (var n = Object.keys(d5), i = 0; i < n.length; i++) {
    var s = n[i], o = e[s];
    o = typeof o < "u" && o !== null ? o : d5[s], dh[s] = o;
  }
  dh.verbose && console.log(
    "MarchingSquaresJS-isoContours: computing isocontour for " + t
  );
  var a = aM(sM(r, t));
  return typeof dh.successCallback == "function" && dh.successCallback(a), a;
}
function Ee(r, t, e) {
  return (r - t) / (e - t);
}
function sM(r, t) {
  for (var e = r.length - 1, n = r[0].length - 1, i = { rows: e, cols: n, cells: [] }, s = 0; s < e; ++s) {
    i.cells[s] = [];
    for (var o = 0; o < n; ++o) {
      var a = 0, u = r[s + 1][o], x = r[s + 1][o + 1], c = r[s][o + 1], f = r[s][o];
      if (!(isNaN(u) || isNaN(x) || isNaN(c) || isNaN(f))) {
        a |= u >= t ? 8 : 0, a |= x >= t ? 4 : 0, a |= c >= t ? 2 : 0, a |= f >= t ? 1 : 0;
        var l = !1;
        if (a === 5 || a === 10) {
          var h = (u + x + c + f) / 4;
          a === 5 && h < t ? (a = 10, l = !0) : a === 10 && h < t && (a = 5, l = !0);
        }
        if (a !== 0 && a !== 15) {
          var p, y, v, m;
          p = y = v = m = 0.5, a === 1 ? (v = 1 - Ee(t, u, f), y = 1 - Ee(t, c, f)) : a === 2 ? (y = Ee(t, f, c), m = 1 - Ee(t, x, c)) : a === 3 ? (v = 1 - Ee(t, u, f), m = 1 - Ee(t, x, c)) : a === 4 ? (p = Ee(t, u, x), m = Ee(t, c, x)) : a === 5 ? (p = Ee(t, u, x), m = Ee(t, c, x), y = 1 - Ee(t, c, f), v = 1 - Ee(t, u, f)) : a === 6 ? (y = Ee(t, f, c), p = Ee(t, u, x)) : a === 7 ? (v = 1 - Ee(t, u, f), p = Ee(t, u, x)) : a === 8 ? (v = Ee(t, f, u), p = 1 - Ee(t, x, u)) : a === 9 ? (y = 1 - Ee(t, c, f), p = 1 - Ee(t, x, u)) : a === 10 ? (p = 1 - Ee(t, x, u), m = 1 - Ee(t, x, c), y = Ee(t, f, c), v = Ee(t, f, u)) : a === 11 ? (p = 1 - Ee(t, x, u), m = 1 - Ee(t, x, c)) : a === 12 ? (v = Ee(t, f, u), m = Ee(t, c, x)) : a === 13 ? (y = 1 - Ee(t, c, f), m = Ee(t, c, x)) : a === 14 ? (v = Ee(t, f, u), y = Ee(t, f, c)) : console.log(
            "MarchingSquaresJS-isoContours: Illegal cval detected: " + a
          ), i.cells[s][o] = {
            cval: a,
            flipped: l,
            top: p,
            right: m,
            bottom: y,
            left: v
          };
        }
      }
    }
  }
  return i;
}
function oM(r) {
  return r.cval === 5 || r.cval === 10;
}
function Pw(r) {
  return r.cval === 0 || r.cval === 15;
}
function g5(r) {
  !Pw(r) && r.cval !== 5 && r.cval !== 10 && (r.cval = 15);
}
function Cv(r, t) {
  if (t === "top")
    return [r.top, 1];
  if (t === "bottom")
    return [r.bottom, 0];
  if (t === "right")
    return [1, r.right];
  if (t === "left")
    return [0, r.left];
}
function aM(r) {
  var t = [], e = 0, n = 1e-7;
  return r.cells.forEach(function(i, s) {
    i.forEach(function(o, a) {
      if (typeof o < "u" && !oM(o) && !Pw(o)) {
        var u = uM(r.cells, s, a), x = !1;
        if (u.info === "mergeable") {
          for (var c = u.path[u.path.length - 1][0], f = u.path[u.path.length - 1][1], l = e - 1; l >= 0; l--)
            if (Math.abs(t[l][0][0] - c) <= n && Math.abs(t[l][0][1] - f) <= n) {
              for (var h = u.path.length - 2; h >= 0; --h)
                t[l].unshift(u.path[h]);
              x = !0;
              break;
            }
        }
        x || (t[e++] = u.path);
      }
    });
  }), t;
}
function uM(r, t, e) {
  var n = r.length, i = [], s = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0], o = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0], a, u, x = [
    "none",
    "left",
    "bottom",
    "left",
    "right",
    "none",
    "bottom",
    "left",
    "top",
    "top",
    "none",
    "top",
    "right",
    "right",
    "bottom",
    "none"
  ], c = [
    "none",
    "bottom",
    "right",
    "right",
    "top",
    "top",
    "top",
    "top",
    "left",
    "bottom",
    "right",
    "right",
    "left",
    "bottom",
    "left",
    "none"
  ], h, f = r[t][e], l = f.cval, h = x[l], p = Cv(f, h);
  i.push([e + p[0], t + p[1]]), h = c[l], p = Cv(f, h), i.push([e + p[0], t + p[1]]), g5(f);
  for (var y = e + s[l], v = t + o[l], m = l; y >= 0 && v >= 0 && v < n && (y != e || v != t) && (f = r[v][y], !(typeof f > "u")); ) {
    if (l = f.cval, l === 0 || l === 15)
      return { path: i, info: "mergeable" };
    h = c[l], a = s[l], u = o[l], (l === 5 || l === 10) && (l === 5 ? f.flipped ? o[m] === -1 ? (h = "left", a = -1, u = 0) : (h = "right", a = 1, u = 0) : s[m] === -1 && (h = "bottom", a = 0, u = -1) : l === 10 && (f.flipped ? s[m] === -1 ? (h = "top", a = 0, u = 1) : (h = "bottom", a = 0, u = -1) : o[m] === 1 && (h = "left", a = -1, u = 0))), p = Cv(f, h), i.push([y + p[0], v + p[1]]), g5(f), y += a, v += u, m = l;
  }
  return { path: i, info: "closed" };
}
function xM(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.zProperty || "elevation", n = t.flip, i = t.flags;
  Ia(r, "Point", "input must contain Points");
  for (var s = cM(r, n), o = [], a = 0; a < s.length; a++) {
    for (var u = s[a], x = [], c = 0; c < u.length; c++) {
      var f = u[c];
      f.properties[e] ? x.push(f.properties[e]) : x.push(0), i === !0 && (f.properties.matrixPosition = [a, c]);
    }
    o.push(x);
  }
  return o;
}
function cM(r, t) {
  var e = {};
  he(r, function(s) {
    var o = gt(s)[1];
    e[o] || (e[o] = []), e[o].push(s);
  });
  var n = Object.keys(e).map(function(s) {
    var o = e[s], a = o.sort(function(u, x) {
      return gt(u)[0] - gt(x)[0];
    });
    return a;
  }), i = n.sort(function(s, o) {
    return t ? gt(s[0])[1] - gt(o[0])[1] : gt(o[0])[1] - gt(s[0])[1];
  });
  return i;
}
function fM(r, t, e) {
  if (e = e || {}, !we(e)) throw new Error("options is invalid");
  var n = e.zProperty || "elevation", i = e.commonProperties || {}, s = e.breaksProperties || [];
  if (Ia(r, "Point", "Input must contain Points"), !t) throw new Error("breaks is required");
  if (!Array.isArray(t)) throw new Error("breaks must be an Array");
  if (!we(i))
    throw new Error("commonProperties must be an Object");
  if (!Array.isArray(s))
    throw new Error("breaksProperties must be an Array");
  var o = xM(r, { zProperty: n, flip: !0 }), a = lM(
    o,
    t,
    n,
    i,
    s
  ), u = hM(a, o, r);
  return ht(u);
}
function lM(r, t, e, n, i) {
  for (var s = [], o = 1; o < t.length; o++) {
    var a = +t[o], u = Z_({}, n, i[o]);
    u[e] = a;
    var x = c0(iM(r, a), u);
    s.push(x);
  }
  return s;
}
function hM(r, t, e) {
  var n = Cn(e), i = n[2] - n[0], s = n[3] - n[1], o = n[0], a = n[1], u = t[0].length - 1, x = t.length - 1, c = i / u, f = s / x, l = function(h) {
    h[0] = h[0] * c + o, h[1] = h[1] * f + a;
  };
  return r.forEach(function(h) {
    hn(h, l);
  }), r;
}
var K_ = { exports: {} }, Lw = { exports: {} };
(function(r, t) {
  (function(e, n) {
    r.exports = n();
  })(Cy, function() {
    function e(d, g, _, b, w) {
      (function E(S, I, L, M, N) {
        for (; M > L; ) {
          if (M - L > 600) {
            var P = M - L + 1, O = I - L + 1, k = Math.log(P), D = 0.5 * Math.exp(2 * k / 3), F = 0.5 * Math.sqrt(k * D * (P - D) / P) * (O - P / 2 < 0 ? -1 : 1), X = Math.max(L, Math.floor(I - O * D / P + F)), W = Math.min(M, Math.floor(I + (P - O) * D / P + F));
            E(S, I, X, W, N);
          }
          var U = S[I], q = L, V = M;
          for (n(S, L, I), N(S[M], U) > 0 && n(S, L, M); q < V; ) {
            for (n(S, q, V), q++, V--; N(S[q], U) < 0; ) q++;
            for (; N(S[V], U) > 0; ) V--;
          }
          N(S[L], U) === 0 ? n(S, L, V) : n(S, ++V, M), V <= I && (L = V + 1), I <= V && (M = V - 1);
        }
      })(d, g, _ || 0, b || d.length - 1, w || i);
    }
    function n(d, g, _) {
      var b = d[g];
      d[g] = d[_], d[_] = b;
    }
    function i(d, g) {
      return d < g ? -1 : d > g ? 1 : 0;
    }
    var s = function(d) {
      d === void 0 && (d = 9), this._maxEntries = Math.max(4, d), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
    };
    function o(d, g, _) {
      if (!_) return g.indexOf(d);
      for (var b = 0; b < g.length; b++) if (_(d, g[b])) return b;
      return -1;
    }
    function a(d, g) {
      u(d, 0, d.children.length, g, d);
    }
    function u(d, g, _, b, w) {
      w || (w = v(null)), w.minX = 1 / 0, w.minY = 1 / 0, w.maxX = -1 / 0, w.maxY = -1 / 0;
      for (var E = g; E < _; E++) {
        var S = d.children[E];
        x(w, d.leaf ? b(S) : S);
      }
      return w;
    }
    function x(d, g) {
      return d.minX = Math.min(d.minX, g.minX), d.minY = Math.min(d.minY, g.minY), d.maxX = Math.max(d.maxX, g.maxX), d.maxY = Math.max(d.maxY, g.maxY), d;
    }
    function c(d, g) {
      return d.minX - g.minX;
    }
    function f(d, g) {
      return d.minY - g.minY;
    }
    function l(d) {
      return (d.maxX - d.minX) * (d.maxY - d.minY);
    }
    function h(d) {
      return d.maxX - d.minX + (d.maxY - d.minY);
    }
    function p(d, g) {
      return d.minX <= g.minX && d.minY <= g.minY && g.maxX <= d.maxX && g.maxY <= d.maxY;
    }
    function y(d, g) {
      return g.minX <= d.maxX && g.minY <= d.maxY && g.maxX >= d.minX && g.maxY >= d.minY;
    }
    function v(d) {
      return { children: d, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
    }
    function m(d, g, _, b, w) {
      for (var E = [g, _]; E.length; ) if (!((_ = E.pop()) - (g = E.pop()) <= b)) {
        var S = g + Math.ceil((_ - g) / b / 2) * b;
        e(d, S, g, _, w), E.push(g, S, S, _);
      }
    }
    return s.prototype.all = function() {
      return this._all(this.data, []);
    }, s.prototype.search = function(d) {
      var g = this.data, _ = [];
      if (!y(d, g)) return _;
      for (var b = this.toBBox, w = []; g; ) {
        for (var E = 0; E < g.children.length; E++) {
          var S = g.children[E], I = g.leaf ? b(S) : S;
          y(d, I) && (g.leaf ? _.push(S) : p(d, I) ? this._all(S, _) : w.push(S));
        }
        g = w.pop();
      }
      return _;
    }, s.prototype.collides = function(d) {
      var g = this.data;
      if (!y(d, g)) return !1;
      for (var _ = []; g; ) {
        for (var b = 0; b < g.children.length; b++) {
          var w = g.children[b], E = g.leaf ? this.toBBox(w) : w;
          if (y(d, E)) {
            if (g.leaf || p(d, E)) return !0;
            _.push(w);
          }
        }
        g = _.pop();
      }
      return !1;
    }, s.prototype.load = function(d) {
      if (!d || !d.length) return this;
      if (d.length < this._minEntries) {
        for (var g = 0; g < d.length; g++) this.insert(d[g]);
        return this;
      }
      var _ = this._build(d.slice(), 0, d.length - 1, 0);
      if (this.data.children.length) if (this.data.height === _.height) this._splitRoot(this.data, _);
      else {
        if (this.data.height < _.height) {
          var b = this.data;
          this.data = _, _ = b;
        }
        this._insert(_, this.data.height - _.height - 1, !0);
      }
      else this.data = _;
      return this;
    }, s.prototype.insert = function(d) {
      return d && this._insert(d, this.data.height - 1), this;
    }, s.prototype.clear = function() {
      return this.data = v([]), this;
    }, s.prototype.remove = function(d, g) {
      if (!d) return this;
      for (var _, b, w, E = this.data, S = this.toBBox(d), I = [], L = []; E || I.length; ) {
        if (E || (E = I.pop(), b = I[I.length - 1], _ = L.pop(), w = !0), E.leaf) {
          var M = o(d, E.children, g);
          if (M !== -1) return E.children.splice(M, 1), I.push(E), this._condense(I), this;
        }
        w || E.leaf || !p(E, S) ? b ? (_++, E = b.children[_], w = !1) : E = null : (I.push(E), L.push(_), _ = 0, b = E, E = E.children[0]);
      }
      return this;
    }, s.prototype.toBBox = function(d) {
      return d;
    }, s.prototype.compareMinX = function(d, g) {
      return d.minX - g.minX;
    }, s.prototype.compareMinY = function(d, g) {
      return d.minY - g.minY;
    }, s.prototype.toJSON = function() {
      return this.data;
    }, s.prototype.fromJSON = function(d) {
      return this.data = d, this;
    }, s.prototype._all = function(d, g) {
      for (var _ = []; d; ) d.leaf ? g.push.apply(g, d.children) : _.push.apply(_, d.children), d = _.pop();
      return g;
    }, s.prototype._build = function(d, g, _, b) {
      var w, E = _ - g + 1, S = this._maxEntries;
      if (E <= S) return a(w = v(d.slice(g, _ + 1)), this.toBBox), w;
      b || (b = Math.ceil(Math.log(E) / Math.log(S)), S = Math.ceil(E / Math.pow(S, b - 1))), (w = v([])).leaf = !1, w.height = b;
      var I = Math.ceil(E / S), L = I * Math.ceil(Math.sqrt(S));
      m(d, g, _, L, this.compareMinX);
      for (var M = g; M <= _; M += L) {
        var N = Math.min(M + L - 1, _);
        m(d, M, N, I, this.compareMinY);
        for (var P = M; P <= N; P += I) {
          var O = Math.min(P + I - 1, N);
          w.children.push(this._build(d, P, O, b - 1));
        }
      }
      return a(w, this.toBBox), w;
    }, s.prototype._chooseSubtree = function(d, g, _, b) {
      for (; b.push(g), !g.leaf && b.length - 1 !== _; ) {
        for (var w = 1 / 0, E = 1 / 0, S = void 0, I = 0; I < g.children.length; I++) {
          var L = g.children[I], M = l(L), N = (P = d, O = L, (Math.max(O.maxX, P.maxX) - Math.min(O.minX, P.minX)) * (Math.max(O.maxY, P.maxY) - Math.min(O.minY, P.minY)) - M);
          N < E ? (E = N, w = M < w ? M : w, S = L) : N === E && M < w && (w = M, S = L);
        }
        g = S || g.children[0];
      }
      var P, O;
      return g;
    }, s.prototype._insert = function(d, g, _) {
      var b = _ ? d : this.toBBox(d), w = [], E = this._chooseSubtree(b, this.data, g, w);
      for (E.children.push(d), x(E, b); g >= 0 && w[g].children.length > this._maxEntries; ) this._split(w, g), g--;
      this._adjustParentBBoxes(b, w, g);
    }, s.prototype._split = function(d, g) {
      var _ = d[g], b = _.children.length, w = this._minEntries;
      this._chooseSplitAxis(_, w, b);
      var E = this._chooseSplitIndex(_, w, b), S = v(_.children.splice(E, _.children.length - E));
      S.height = _.height, S.leaf = _.leaf, a(_, this.toBBox), a(S, this.toBBox), g ? d[g - 1].children.push(S) : this._splitRoot(_, S);
    }, s.prototype._splitRoot = function(d, g) {
      this.data = v([d, g]), this.data.height = d.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
    }, s.prototype._chooseSplitIndex = function(d, g, _) {
      for (var b, w, E, S, I, L, M, N = 1 / 0, P = 1 / 0, O = g; O <= _ - g; O++) {
        var k = u(d, 0, O, this.toBBox), D = u(d, O, _, this.toBBox), F = (w = k, E = D, S = void 0, I = void 0, L = void 0, M = void 0, S = Math.max(w.minX, E.minX), I = Math.max(w.minY, E.minY), L = Math.min(w.maxX, E.maxX), M = Math.min(w.maxY, E.maxY), Math.max(0, L - S) * Math.max(0, M - I)), X = l(k) + l(D);
        F < N ? (N = F, b = O, P = X < P ? X : P) : F === N && X < P && (P = X, b = O);
      }
      return b || _ - g;
    }, s.prototype._chooseSplitAxis = function(d, g, _) {
      var b = d.leaf ? this.compareMinX : c, w = d.leaf ? this.compareMinY : f;
      this._allDistMargin(d, g, _, b) < this._allDistMargin(d, g, _, w) && d.children.sort(b);
    }, s.prototype._allDistMargin = function(d, g, _, b) {
      d.children.sort(b);
      for (var w = this.toBBox, E = u(d, 0, g, w), S = u(d, _ - g, _, w), I = h(E) + h(S), L = g; L < _ - g; L++) {
        var M = d.children[L];
        x(E, d.leaf ? w(M) : M), I += h(E);
      }
      for (var N = _ - g - 1; N >= g; N--) {
        var P = d.children[N];
        x(S, d.leaf ? w(P) : P), I += h(S);
      }
      return I;
    }, s.prototype._adjustParentBBoxes = function(d, g, _) {
      for (var b = _; b >= 0; b--) x(g[b], d);
    }, s.prototype._condense = function(d) {
      for (var g = d.length - 1, _ = void 0; g >= 0; g--) d[g].children.length === 0 ? g > 0 ? (_ = d[g - 1].children).splice(_.indexOf(d[g]), 1) : this.clear() : a(d[g], this.toBBox);
    }, s;
  });
})(Lw);
var pM = Lw.exports;
class dM {
  constructor(t = [], e = gM) {
    if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0)
      for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
  }
  push(t) {
    this.data.push(t), this.length++, this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    const t = this.data[0], e = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;
  }
  peek() {
    return this.data[0];
  }
  _up(t) {
    const { data: e, compare: n } = this, i = e[t];
    for (; t > 0; ) {
      const s = t - 1 >> 1, o = e[s];
      if (n(i, o) >= 0) break;
      e[t] = o, t = s;
    }
    e[t] = i;
  }
  _down(t) {
    const { data: e, compare: n } = this, i = this.length >> 1, s = e[t];
    for (; t < i; ) {
      let o = (t << 1) + 1, a = e[o];
      const u = o + 1;
      if (u < this.length && n(e[u], a) < 0 && (o = u, a = e[u]), n(a, s) >= 0) break;
      e[t] = a, t = o;
    }
    e[t] = s;
  }
}
function gM(r, t) {
  return r < t ? -1 : r > t ? 1 : 0;
}
const yM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: dM
}, Symbol.toStringTag, { value: "Module" })), vM = /* @__PURE__ */ QC(yM);
var My = { exports: {} }, mM = function(t, e, n, i) {
  var s = t[0], o = t[1], a = !1;
  n === void 0 && (n = 0), i === void 0 && (i = e.length);
  for (var u = (i - n) / 2, x = 0, c = u - 1; x < u; c = x++) {
    var f = e[n + x * 2 + 0], l = e[n + x * 2 + 1], h = e[n + c * 2 + 0], p = e[n + c * 2 + 1], y = l > o != p > o && s < (h - f) * (o - l) / (p - l) + f;
    y && (a = !a);
  }
  return a;
}, _M = function(t, e, n, i) {
  var s = t[0], o = t[1], a = !1;
  n === void 0 && (n = 0), i === void 0 && (i = e.length);
  for (var u = i - n, x = 0, c = u - 1; x < u; c = x++) {
    var f = e[x + n][0], l = e[x + n][1], h = e[c + n][0], p = e[c + n][1], y = l > o != p > o && s < (h - f) * (o - l) / (p - l) + f;
    y && (a = !a);
  }
  return a;
}, Nw = mM, Ow = _M;
My.exports = function(t, e, n, i) {
  return e.length > 0 && Array.isArray(e[0]) ? Ow(t, e, n, i) : Nw(t, e, n, i);
};
My.exports.nested = Ow;
My.exports.flat = Nw;
var bM = My.exports, Tm = { exports: {} };
(function(r, t) {
  (function(e, n) {
    n(t);
  })(Cy, function(e) {
    const i = 33306690738754706e-32;
    function s(y, v, m, d, g) {
      let _, b, w, E, S = v[0], I = d[0], L = 0, M = 0;
      I > S == I > -S ? (_ = S, S = v[++L]) : (_ = I, I = d[++M]);
      let N = 0;
      if (L < y && M < m) for (I > S == I > -S ? (w = _ - ((b = S + _) - S), S = v[++L]) : (w = _ - ((b = I + _) - I), I = d[++M]), _ = b, w !== 0 && (g[N++] = w); L < y && M < m; ) I > S == I > -S ? (w = _ - ((b = _ + S) - (E = b - _)) + (S - E), S = v[++L]) : (w = _ - ((b = _ + I) - (E = b - _)) + (I - E), I = d[++M]), _ = b, w !== 0 && (g[N++] = w);
      for (; L < y; ) w = _ - ((b = _ + S) - (E = b - _)) + (S - E), S = v[++L], _ = b, w !== 0 && (g[N++] = w);
      for (; M < m; ) w = _ - ((b = _ + I) - (E = b - _)) + (I - E), I = d[++M], _ = b, w !== 0 && (g[N++] = w);
      return _ === 0 && N !== 0 || (g[N++] = _), N;
    }
    function o(y) {
      return new Float64Array(y);
    }
    const a = 33306690738754716e-32, u = 22204460492503146e-32, x = 11093356479670487e-47, c = o(4), f = o(8), l = o(12), h = o(16), p = o(4);
    e.orient2d = function(y, v, m, d, g, _) {
      const b = (v - _) * (m - g), w = (y - g) * (d - _), E = b - w;
      if (b === 0 || w === 0 || b > 0 != w > 0) return E;
      const S = Math.abs(b + w);
      return Math.abs(E) >= a * S ? E : -function(I, L, M, N, P, O, k) {
        let D, F, X, W, U, q, V, tt, $, B, _t, pe, Bn, on, jn, Gn, Ti, Cr;
        const Qr = I - P, $r = M - P, li = L - O, Mr = N - O;
        U = (jn = (tt = Qr - (V = (q = 134217729 * Qr) - (q - Qr))) * (B = Mr - ($ = (q = 134217729 * Mr) - (q - Mr))) - ((on = Qr * Mr) - V * $ - tt * $ - V * B)) - (_t = jn - (Ti = (tt = li - (V = (q = 134217729 * li) - (q - li))) * (B = $r - ($ = (q = 134217729 * $r) - (q - $r))) - ((Gn = li * $r) - V * $ - tt * $ - V * B))), c[0] = jn - (_t + U) + (U - Ti), U = (Bn = on - ((pe = on + _t) - (U = pe - on)) + (_t - U)) - (_t = Bn - Gn), c[1] = Bn - (_t + U) + (U - Gn), U = (Cr = pe + _t) - pe, c[2] = pe - (Cr - U) + (_t - U), c[3] = Cr;
        let ts = function(fc, rh) {
          let d0 = rh[0];
          for (let ko = 1; ko < fc; ko++) d0 += rh[ko];
          return d0;
        }(4, c), p0 = u * k;
        if (ts >= p0 || -ts >= p0 || (D = I - (Qr + (U = I - Qr)) + (U - P), X = M - ($r + (U = M - $r)) + (U - P), F = L - (li + (U = L - li)) + (U - O), W = N - (Mr + (U = N - Mr)) + (U - O), D === 0 && F === 0 && X === 0 && W === 0) || (p0 = x * k + i * Math.abs(ts), (ts += Qr * W + Mr * D - (li * X + $r * F)) >= p0 || -ts >= p0)) return ts;
        U = (jn = (tt = D - (V = (q = 134217729 * D) - (q - D))) * (B = Mr - ($ = (q = 134217729 * Mr) - (q - Mr))) - ((on = D * Mr) - V * $ - tt * $ - V * B)) - (_t = jn - (Ti = (tt = F - (V = (q = 134217729 * F) - (q - F))) * (B = $r - ($ = (q = 134217729 * $r) - (q - $r))) - ((Gn = F * $r) - V * $ - tt * $ - V * B))), p[0] = jn - (_t + U) + (U - Ti), U = (Bn = on - ((pe = on + _t) - (U = pe - on)) + (_t - U)) - (_t = Bn - Gn), p[1] = Bn - (_t + U) + (U - Gn), U = (Cr = pe + _t) - pe, p[2] = pe - (Cr - U) + (_t - U), p[3] = Cr;
        const nv = s(4, c, 4, p, f);
        U = (jn = (tt = Qr - (V = (q = 134217729 * Qr) - (q - Qr))) * (B = W - ($ = (q = 134217729 * W) - (q - W))) - ((on = Qr * W) - V * $ - tt * $ - V * B)) - (_t = jn - (Ti = (tt = li - (V = (q = 134217729 * li) - (q - li))) * (B = X - ($ = (q = 134217729 * X) - (q - X))) - ((Gn = li * X) - V * $ - tt * $ - V * B))), p[0] = jn - (_t + U) + (U - Ti), U = (Bn = on - ((pe = on + _t) - (U = pe - on)) + (_t - U)) - (_t = Bn - Gn), p[1] = Bn - (_t + U) + (U - Gn), U = (Cr = pe + _t) - pe, p[2] = pe - (Cr - U) + (_t - U), p[3] = Cr;
        const rv = s(nv, f, 4, p, l);
        U = (jn = (tt = D - (V = (q = 134217729 * D) - (q - D))) * (B = W - ($ = (q = 134217729 * W) - (q - W))) - ((on = D * W) - V * $ - tt * $ - V * B)) - (_t = jn - (Ti = (tt = F - (V = (q = 134217729 * F) - (q - F))) * (B = X - ($ = (q = 134217729 * X) - (q - X))) - ((Gn = F * X) - V * $ - tt * $ - V * B))), p[0] = jn - (_t + U) + (U - Ti), U = (Bn = on - ((pe = on + _t) - (U = pe - on)) + (_t - U)) - (_t = Bn - Gn), p[1] = Bn - (_t + U) + (U - Gn), U = (Cr = pe + _t) - pe, p[2] = pe - (Cr - U) + (_t - U), p[3] = Cr;
        const nh = s(rv, l, 4, p, h);
        return h[nh - 1];
      }(y, v, m, d, g, _, S);
    }, e.orient2dfast = function(y, v, m, d, g, _) {
      return (v - _) * (m - g) - (y - g) * (d - _);
    }, Object.defineProperty(e, "__esModule", { value: !0 });
  });
})(Tm, Tm.exports);
var IM = Tm.exports, y5 = pM, Gh = vM, wM = bM, EM = IM.orient2d;
Gh.default && (Gh = Gh.default);
K_.exports = Rw;
K_.exports.default = Rw;
function Rw(r, t, e) {
  t = Math.max(0, t === void 0 ? 2 : t), e = e || 0;
  var n = LM(r), i = new y5(16);
  i.toBBox = function(d) {
    return {
      minX: d[0],
      minY: d[1],
      maxX: d[0],
      maxY: d[1]
    };
  }, i.compareMinX = function(d, g) {
    return d[0] - g[0];
  }, i.compareMinY = function(d, g) {
    return d[1] - g[1];
  }, i.load(r);
  for (var s = [], o = 0, a; o < n.length; o++) {
    var u = n[o];
    i.remove(u), a = _5(u, a), s.push(a);
  }
  var x = new y5(16);
  for (o = 0; o < s.length; o++) x.insert(Mv(s[o]));
  for (var c = t * t, f = e * e; s.length; ) {
    var l = s.shift(), h = l.p, p = l.next.p, y = Pv(h, p);
    if (!(y < f)) {
      var v = y / c;
      u = SM(i, l.prev.p, h, p, l.next.next.p, v, x), u && Math.min(Pv(u, h), Pv(u, p)) <= v && (s.push(l), s.push(_5(u, l)), i.remove(u), x.remove(l), x.insert(Mv(l)), x.insert(Mv(l.next)));
    }
  }
  l = a;
  var m = [];
  do
    m.push(l.p), l = l.next;
  while (l !== a);
  return m.push(l.p), m;
}
function SM(r, t, e, n, i, s, o) {
  for (var a = new Gh([], CM), u = r.data; u; ) {
    for (var x = 0; x < u.children.length; x++) {
      var c = u.children[x], f = u.leaf ? Lv(c, e, n) : MM(e, n, c);
      f > s || a.push({
        node: c,
        dist: f
      });
    }
    for (; a.length && !a.peek().node.children; ) {
      var l = a.pop(), h = l.node, p = Lv(h, t, e), y = Lv(h, n, i);
      if (l.dist < p && l.dist < y && m5(e, h, o) && m5(n, h, o)) return h;
    }
    u = a.pop(), u && (u = u.node);
  }
  return null;
}
function CM(r, t) {
  return r.dist - t.dist;
}
function MM(r, t, e) {
  if (v5(r, e) || v5(t, e)) return 0;
  var n = gh(r[0], r[1], t[0], t[1], e.minX, e.minY, e.maxX, e.minY);
  if (n === 0) return 0;
  var i = gh(r[0], r[1], t[0], t[1], e.minX, e.minY, e.minX, e.maxY);
  if (i === 0) return 0;
  var s = gh(r[0], r[1], t[0], t[1], e.maxX, e.minY, e.maxX, e.maxY);
  if (s === 0) return 0;
  var o = gh(r[0], r[1], t[0], t[1], e.minX, e.maxY, e.maxX, e.maxY);
  return o === 0 ? 0 : Math.min(n, i, s, o);
}
function v5(r, t) {
  return r[0] >= t.minX && r[0] <= t.maxX && r[1] >= t.minY && r[1] <= t.maxY;
}
function m5(r, t, e) {
  for (var n = Math.min(r[0], t[0]), i = Math.min(r[1], t[1]), s = Math.max(r[0], t[0]), o = Math.max(r[1], t[1]), a = e.search({ minX: n, minY: i, maxX: s, maxY: o }), u = 0; u < a.length; u++)
    if (PM(a[u].p, a[u].next.p, r, t)) return !1;
  return !0;
}
function Xu(r, t, e) {
  return EM(r[0], r[1], t[0], t[1], e[0], e[1]);
}
function PM(r, t, e, n) {
  return r !== n && t !== e && Xu(r, t, e) > 0 != Xu(r, t, n) > 0 && Xu(e, n, r) > 0 != Xu(e, n, t) > 0;
}
function Mv(r) {
  var t = r.p, e = r.next.p;
  return r.minX = Math.min(t[0], e[0]), r.minY = Math.min(t[1], e[1]), r.maxX = Math.max(t[0], e[0]), r.maxY = Math.max(t[1], e[1]), r;
}
function LM(r) {
  for (var t = r[0], e = r[0], n = r[0], i = r[0], s = 0; s < r.length; s++) {
    var o = r[s];
    o[0] < t[0] && (t = o), o[0] > n[0] && (n = o), o[1] < e[1] && (e = o), o[1] > i[1] && (i = o);
  }
  var a = [t, e, n, i], u = a.slice();
  for (s = 0; s < r.length; s++)
    wM(r[s], a) || u.push(r[s]);
  return OM(u);
}
function _5(r, t) {
  var e = {
    p: r,
    prev: null,
    next: null,
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  };
  return t ? (e.next = t.next, e.prev = t, t.next.prev = e, t.next = e) : (e.prev = e, e.next = e), e;
}
function Pv(r, t) {
  var e = r[0] - t[0], n = r[1] - t[1];
  return e * e + n * n;
}
function Lv(r, t, e) {
  var n = t[0], i = t[1], s = e[0] - n, o = e[1] - i;
  if (s !== 0 || o !== 0) {
    var a = ((r[0] - n) * s + (r[1] - i) * o) / (s * s + o * o);
    a > 1 ? (n = e[0], i = e[1]) : a > 0 && (n += s * a, i += o * a);
  }
  return s = r[0] - n, o = r[1] - i, s * s + o * o;
}
function gh(r, t, e, n, i, s, o, a) {
  var u = e - r, x = n - t, c = o - i, f = a - s, l = r - i, h = t - s, p = u * u + x * x, y = u * c + x * f, v = c * c + f * f, m = u * l + x * h, d = c * l + f * h, g = p * v - y * y, _, b, w, E, S = g, I = g;
  g === 0 ? (b = 0, S = 1, E = d, I = v) : (b = y * d - v * m, E = p * d - y * m, b < 0 ? (b = 0, E = d, I = v) : b > S && (b = S, E = d + y, I = v)), E < 0 ? (E = 0, -m < 0 ? b = 0 : -m > p ? b = S : (b = -m, S = p)) : E > I && (E = I, -m + y < 0 ? b = 0 : -m + y > p ? b = S : (b = -m + y, S = p)), _ = b === 0 ? 0 : b / S, w = E === 0 ? 0 : E / I;
  var L = (1 - _) * r + _ * e, M = (1 - _) * t + _ * n, N = (1 - w) * i + w * o, P = (1 - w) * s + w * a, O = N - L, k = P - M;
  return O * O + k * k;
}
function NM(r, t) {
  return r[0] === t[0] ? r[1] - t[1] : r[0] - t[0];
}
function OM(r) {
  r.sort(NM);
  for (var t = [], e = 0; e < r.length; e++) {
    for (; t.length >= 2 && Xu(t[t.length - 2], t[t.length - 1], r[e]) <= 0; )
      t.pop();
    t.push(r[e]);
  }
  for (var n = [], i = r.length - 1; i >= 0; i--) {
    for (; n.length >= 2 && Xu(n[n.length - 2], n[n.length - 1], r[i]) <= 0; )
      n.pop();
    n.push(r[i]);
  }
  return n.pop(), t.pop(), t.concat(n);
}
var RM = K_.exports;
const AM = /* @__PURE__ */ Ao(RM);
function Aw(r, t) {
  t === void 0 && (t = {}), t.concavity = t.concavity || 1 / 0;
  var e = [];
  if (hn(r, function(i) {
    e.push([i[0], i[1]]);
  }), !e.length)
    return null;
  var n = AM(e, t.concavity);
  return n.length > 3 ? Nt([n]) : null;
}
function Fe(r, t, e) {
  if (e === void 0 && (e = {}), !r)
    throw new Error("point is required");
  if (!t)
    throw new Error("polygon is required");
  var n = Ae(r), i = ke(t), s = i.type, o = t.bbox, a = i.coordinates;
  if (o && TM(n, o) === !1)
    return !1;
  s === "Polygon" && (a = [a]);
  for (var u = !1, x = 0; x < a.length && !u; x++)
    if (b5(n, a[x][0], e.ignoreBoundary)) {
      for (var c = !1, f = 1; f < a[x].length && !c; )
        b5(n, a[x][f], !e.ignoreBoundary) && (c = !0), f++;
      c || (u = !0);
    }
  return u;
}
function b5(r, t, e) {
  var n = !1;
  t[0][0] === t[t.length - 1][0] && t[0][1] === t[t.length - 1][1] && (t = t.slice(0, t.length - 1));
  for (var i = 0, s = t.length - 1; i < t.length; s = i++) {
    var o = t[i][0], a = t[i][1], u = t[s][0], x = t[s][1], c = r[1] * (o - u) + a * (u - r[0]) + x * (r[0] - o) === 0 && (o - r[0]) * (u - r[0]) <= 0 && (a - r[1]) * (x - r[1]) <= 0;
    if (c)
      return !e;
    var f = a > r[1] != x > r[1] && r[0] < (u - o) * (r[1] - a) / (x - a) + o;
    f && (n = !n);
  }
  return n;
}
function TM(r, t) {
  return t[0] <= r[0] && t[1] <= r[1] && t[2] >= r[0] && t[3] >= r[1];
}
function Dm(r, t) {
  var e = [];
  return he(r, function(n) {
    var i = !1;
    if (n.geometry.type === "Point")
      Pi(t, function(o) {
        Fe(n, o) && (i = !0);
      }), i && e.push(n);
    else if (n.geometry.type === "MultiPoint") {
      var s = [];
      Pi(t, function(o) {
        hn(n, function(a) {
          Fe(a, o) && (i = !0, s.push(a));
        });
      }), i && e.push(Gl(s));
    } else
      throw new Error("Input geometry must be a Point or MultiPoint");
  }), ht(e);
}
function Ie(r, t, e) {
  e === void 0 && (e = {});
  var n = Ae(r), i = Ae(t), s = Un(i[1] - n[1]), o = Un(i[0] - n[0]), a = Un(n[1]), u = Un(i[1]), x = Math.pow(Math.sin(s / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(a) * Math.cos(u);
  return Px(2 * Math.atan2(Math.sqrt(x), Math.sqrt(1 - x)), e.units);
}
function Tw(r, t) {
  var e = !1;
  return ht(kM(r.features.map(function(n) {
    var i = {
      x: n.geometry.coordinates[0],
      y: n.geometry.coordinates[1]
    };
    return t ? i.z = n.properties[t] : n.geometry.coordinates.length === 3 && (e = !0, i.z = n.geometry.coordinates[2]), i;
  })).map(function(n) {
    var i = [n.a.x, n.a.y], s = [n.b.x, n.b.y], o = [n.c.x, n.c.y], a = {};
    return e ? (i.push(n.a.z), s.push(n.b.z), o.push(n.c.z)) : a = {
      a: n.a.z,
      b: n.b.z,
      c: n.c.z
    }, Nt([[i, s, o, i]], a);
  }));
}
var I5 = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t, e, n) {
      this.a = t, this.b = e, this.c = n;
      var i = e.x - t.x, s = e.y - t.y, o = n.x - t.x, a = n.y - t.y, u = i * (t.x + e.x) + s * (t.y + e.y), x = o * (t.x + n.x) + a * (t.y + n.y), c = 2 * (i * (n.y - e.y) - s * (n.x - e.x)), f, l;
      this.x = (a * u - s * x) / c, this.y = (i * x - o * u) / c, f = this.x - t.x, l = this.y - t.y, this.r = f * f + l * l;
    }
    return r;
  }()
);
function DM(r, t) {
  return t.x - r.x;
}
function FM(r) {
  var t = r.length, e, n, i, s, o;
  t: for (; t; )
    for (n = r[--t], e = r[--t], i = t; i; )
      if (o = r[--i], s = r[--i], e === s && n === o || e === o && n === s) {
        r.splice(t, 2), r.splice(i, 2), t -= 2;
        continue t;
      }
}
function kM(r) {
  if (r.length < 3)
    return [];
  r.sort(DM);
  for (var t = r.length - 1, e = r[t].x, n = r[0].x, i = r[t].y, s = i, o = 1e-12, a, u, x, c, f, l; t--; )
    r[t].y < i && (i = r[t].y), r[t].y > s && (s = r[t].y);
  var h = n - e, p = s - i, y = h > p ? h : p, v = (n + e) * 0.5, m = (s + i) * 0.5, d = [
    new I5({
      __sentinel: !0,
      x: v - 20 * y,
      y: m - y
    }, {
      __sentinel: !0,
      x: v,
      y: m + 20 * y
    }, {
      __sentinel: !0,
      x: v + 20 * y,
      y: m - y
    })
  ], g = [], _ = [], b;
  for (t = r.length; t--; ) {
    for (_.length = 0, b = d.length; b--; ) {
      if (h = r[t].x - d[b].x, h > 0 && h * h > d[b].r) {
        g.push(d[b]), d.splice(b, 1);
        continue;
      }
      p = r[t].y - d[b].y, !(h * h + p * p > d[b].r) && (_.push(d[b].a, d[b].b, d[b].b, d[b].c, d[b].c, d[b].a), d.splice(b, 1));
    }
    for (FM(_), b = _.length; b; )
      u = _[--b], a = _[--b], x = r[t], c = u.x - a.x, f = u.y - a.y, l = 2 * (c * (x.y - u.y) - f * (x.x - u.x)), Math.abs(l) > o && d.push(new I5(a, u, x));
  }
  for (Array.prototype.push.apply(g, d), t = g.length; t--; )
    (g[t].a.__sentinel || g[t].b.__sentinel || g[t].c.__sentinel) && g.splice(t, 1);
  return g;
}
function br(r) {
  if (!r)
    throw new Error("geojson is required");
  switch (r.type) {
    case "Feature":
      return Dw(r);
    case "FeatureCollection":
      return BM(r);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return j_(r);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function Dw(r) {
  var t = { type: "Feature" };
  return Object.keys(r).forEach(function(e) {
    switch (e) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        t[e] = r[e];
    }
  }), t.properties = Fw(r.properties), t.geometry = j_(r.geometry), t;
}
function Fw(r) {
  var t = {};
  return r && Object.keys(r).forEach(function(e) {
    var n = r[e];
    typeof n == "object" ? n === null ? t[e] = null : Array.isArray(n) ? t[e] = n.map(function(i) {
      return i;
    }) : t[e] = Fw(n) : t[e] = n;
  }), t;
}
function BM(r) {
  var t = { type: "FeatureCollection" };
  return Object.keys(r).forEach(function(e) {
    switch (e) {
      case "type":
      case "features":
        return;
      default:
        t[e] = r[e];
    }
  }), t.features = r.features.map(function(e) {
    return Dw(e);
  }), t;
}
function j_(r) {
  var t = { type: r.type };
  return r.bbox && (t.bbox = r.bbox), r.type === "GeometryCollection" ? (t.geometries = r.geometries.map(function(e) {
    return j_(e);
  }), t) : (t.coordinates = kw(r.coordinates), t);
}
function kw(r) {
  var t = r;
  return typeof t[0] != "object" ? t.slice() : t.map(function(e) {
    return kw(e);
  });
}
function GM(r, t) {
  if (t === void 0 && (t = {}), t = t || {}, !we(t))
    throw new Error("options is invalid");
  var e = t.mutate;
  if (oi(r) !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (!r.features.length)
    throw new Error("geojson is empty");
  (e === !1 || e === void 0) && (r = br(r));
  var n = [], i = H_(r, function(s, o) {
    var a = YM(s, o);
    return a || (n.push(s), o);
  });
  return i && n.push(i), n.length ? n.length === 1 ? n[0] : c0(n.map(function(s) {
    return s.coordinates;
  })) : null;
}
function yh(r) {
  return r[0].toString() + "," + r[1].toString();
}
function YM(r, t) {
  var e = r.geometry.coordinates, n = t.geometry.coordinates, i = yh(e[0]), s = yh(e[e.length - 1]), o = yh(n[0]), a = yh(n[n.length - 1]), u;
  if (i === a)
    u = n.concat(e.slice(1));
  else if (o === s)
    u = e.concat(n.slice(1));
  else if (i === o)
    u = e.slice(1).reverse().concat(n);
  else if (s === a)
    u = e.concat(n.reverse().slice(1));
  else
    return null;
  return ge(u);
}
function XM(r) {
  return r;
}
function qM(r) {
  if (r == null) return XM;
  var t, e, n = r.scale[0], i = r.scale[1], s = r.translate[0], o = r.translate[1];
  return function(a, u) {
    u || (t = e = 0);
    var x = 2, c = a.length, f = new Array(c);
    for (f[0] = (t += a[0]) * n + s, f[1] = (e += a[1]) * i + o; x < c; ) f[x] = a[x], ++x;
    return f;
  };
}
function zM(r, t) {
  for (var e, n = r.length, i = n - t; i < --n; ) e = r[i], r[i++] = r[n], r[n] = e;
}
function Bw(r, t) {
  var e = qM(r.transform), n = r.arcs;
  function i(c, f) {
    f.length && f.pop();
    for (var l = n[c < 0 ? ~c : c], h = 0, p = l.length; h < p; ++h)
      f.push(e(l[h], h));
    c < 0 && zM(f, p);
  }
  function s(c) {
    return e(c);
  }
  function o(c) {
    for (var f = [], l = 0, h = c.length; l < h; ++l) i(c[l], f);
    return f.length < 2 && f.push(f[0]), f;
  }
  function a(c) {
    for (var f = o(c); f.length < 4; ) f.push(f[0]);
    return f;
  }
  function u(c) {
    return c.map(a);
  }
  function x(c) {
    var f = c.type, l;
    switch (f) {
      case "GeometryCollection":
        return { type: f, geometries: c.geometries.map(x) };
      case "Point":
        l = s(c.coordinates);
        break;
      case "MultiPoint":
        l = c.coordinates.map(s);
        break;
      case "LineString":
        l = o(c.arcs);
        break;
      case "MultiLineString":
        l = c.arcs.map(o);
        break;
      case "Polygon":
        l = u(c.arcs);
        break;
      case "MultiPolygon":
        l = c.arcs.map(u);
        break;
      default:
        return null;
    }
    return { type: f, coordinates: l };
  }
  return x(t);
}
function UM(r, t) {
  var e = {}, n = {}, i = {}, s = [], o = -1;
  t.forEach(function(x, c) {
    var f = r.arcs[x < 0 ? ~x : x], l;
    f.length < 3 && !f[1][0] && !f[1][1] && (l = t[++o], t[o] = x, t[c] = l);
  }), t.forEach(function(x) {
    var c = a(x), f = c[0], l = c[1], h, p;
    if (h = i[f])
      if (delete i[h.end], h.push(x), h.end = l, p = n[l]) {
        delete n[p.start];
        var y = p === h ? h : h.concat(p);
        n[y.start = h.start] = i[y.end = p.end] = y;
      } else
        n[h.start] = i[h.end] = h;
    else if (h = n[l])
      if (delete n[h.start], h.unshift(x), h.start = f, p = i[f]) {
        delete i[p.end];
        var v = p === h ? h : p.concat(h);
        n[v.start = p.start] = i[v.end = h.end] = v;
      } else
        n[h.start] = i[h.end] = h;
    else
      h = [x], n[h.start = f] = i[h.end = l] = h;
  });
  function a(x) {
    var c = r.arcs[x < 0 ? ~x : x], f = c[0], l;
    return r.transform ? (l = [0, 0], c.forEach(function(h) {
      l[0] += h[0], l[1] += h[1];
    })) : l = c[c.length - 1], x < 0 ? [l, f] : [f, l];
  }
  function u(x, c) {
    for (var f in x) {
      var l = x[f];
      delete c[l.start], delete l.start, delete l.end, l.forEach(function(h) {
        e[h < 0 ? ~h : h] = 1;
      }), s.push(l);
    }
  }
  return u(i, n), u(n, i), t.forEach(function(x) {
    e[x < 0 ? ~x : x] || s.push([x]);
  }), s;
}
function VM(r) {
  for (var t = -1, e = r.length, n, i = r[e - 1], s = 0; ++t < e; ) n = i, i = r[t], s += n[0] * i[1] - n[1] * i[0];
  return Math.abs(s);
}
function WM(r) {
  return Bw(r, HM.apply(this, arguments));
}
function HM(r, t) {
  var e = {}, n = [], i = [];
  t.forEach(s);
  function s(u) {
    switch (u.type) {
      case "GeometryCollection":
        u.geometries.forEach(s);
        break;
      case "Polygon":
        o(u.arcs);
        break;
      case "MultiPolygon":
        u.arcs.forEach(o);
        break;
    }
  }
  function o(u) {
    u.forEach(function(x) {
      x.forEach(function(c) {
        (e[c = c < 0 ? ~c : c] || (e[c] = [])).push(u);
      });
    }), n.push(u);
  }
  function a(u) {
    return VM(Bw(r, { type: "Polygon", arcs: [u] }).coordinates[0]);
  }
  return n.forEach(function(u) {
    if (!u._) {
      var x = [], c = [u];
      for (u._ = 1, i.push(x); u = c.pop(); )
        x.push(u), u.forEach(function(f) {
          f.forEach(function(l) {
            e[l < 0 ? ~l : l].forEach(function(h) {
              h._ || (h._ = 1, c.push(h));
            });
          });
        });
    }
  }), n.forEach(function(u) {
    delete u._;
  }), {
    type: "MultiPolygon",
    arcs: i.map(function(u) {
      var x = [], c;
      if (u.forEach(function(y) {
        y.forEach(function(v) {
          v.forEach(function(m) {
            e[m < 0 ? ~m : m].length < 2 && x.push(m);
          });
        });
      }), x = UM(r, x), (c = x.length) > 1)
        for (var f = 1, l = a(x[0]), h, p; f < c; ++f)
          (h = a(x[f])) > l && (p = x[0], x[0] = x[f], x[f] = p, l = h);
      return x;
    }).filter(function(u) {
      return u.length > 0;
    })
  };
}
var Q_ = Object.prototype.hasOwnProperty;
function JM(r) {
  var t = 1 / 0, e = 1 / 0, n = -1 / 0, i = -1 / 0;
  function s(f) {
    f != null && Q_.call(o, f.type) && o[f.type](f);
  }
  var o = {
    GeometryCollection: function(f) {
      f.geometries.forEach(s);
    },
    Point: function(f) {
      a(f.coordinates);
    },
    MultiPoint: function(f) {
      f.coordinates.forEach(a);
    },
    LineString: function(f) {
      u(f.arcs);
    },
    MultiLineString: function(f) {
      f.arcs.forEach(u);
    },
    Polygon: function(f) {
      f.arcs.forEach(u);
    },
    MultiPolygon: function(f) {
      f.arcs.forEach(x);
    }
  };
  function a(f) {
    var l = f[0], h = f[1];
    l < t && (t = l), l > n && (n = l), h < e && (e = h), h > i && (i = h);
  }
  function u(f) {
    f.forEach(a);
  }
  function x(f) {
    f.forEach(u);
  }
  for (var c in r)
    s(r[c]);
  return n >= t && i >= e ? [t, e, n, i] : void 0;
}
function ZM(r, t, e, n, i) {
  arguments.length === 3 && (n = Array, i = null);
  for (var s = new n(r = 1 << Math.max(4, Math.ceil(Math.log(r) / Math.LN2))), o = r - 1, a = 0; a < r; ++a)
    s[a] = i;
  function u(f) {
    for (var l = t(f) & o, h = s[l], p = 0; h != i; ) {
      if (e(h, f)) return !0;
      if (++p >= r) throw new Error("full hashset");
      h = s[l = l + 1 & o];
    }
    return s[l] = f, !0;
  }
  function x(f) {
    for (var l = t(f) & o, h = s[l], p = 0; h != i; ) {
      if (e(h, f)) return !0;
      if (++p >= r) break;
      h = s[l = l + 1 & o];
    }
    return !1;
  }
  function c() {
    for (var f = [], l = 0, h = s.length; l < h; ++l) {
      var p = s[l];
      p != i && f.push(p);
    }
    return f;
  }
  return {
    add: u,
    has: x,
    values: c
  };
}
function $_(r, t, e, n, i, s) {
  arguments.length === 3 && (n = s = Array, i = null);
  for (var o = new n(r = 1 << Math.max(4, Math.ceil(Math.log(r) / Math.LN2))), a = new s(r), u = r - 1, x = 0; x < r; ++x)
    o[x] = i;
  function c(p, y) {
    for (var v = t(p) & u, m = o[v], d = 0; m != i; ) {
      if (e(m, p)) return a[v] = y;
      if (++d >= r) throw new Error("full hashmap");
      m = o[v = v + 1 & u];
    }
    return o[v] = p, a[v] = y, y;
  }
  function f(p, y) {
    for (var v = t(p) & u, m = o[v], d = 0; m != i; ) {
      if (e(m, p)) return a[v];
      if (++d >= r) throw new Error("full hashmap");
      m = o[v = v + 1 & u];
    }
    return o[v] = p, a[v] = y, y;
  }
  function l(p, y) {
    for (var v = t(p) & u, m = o[v], d = 0; m != i; ) {
      if (e(m, p)) return a[v];
      if (++d >= r) break;
      m = o[v = v + 1 & u];
    }
    return y;
  }
  function h() {
    for (var p = [], y = 0, v = o.length; y < v; ++y) {
      var m = o[y];
      m != i && p.push(m);
    }
    return p;
  }
  return {
    set: c,
    maybeSet: f,
    // set if unset
    get: l,
    keys: h
  };
}
function w0(r, t) {
  return r[0] === t[0] && r[1] === t[1];
}
var Gw = new ArrayBuffer(16), w5 = new Float64Array(Gw), vh = new Uint32Array(Gw);
function Fm(r) {
  w5[0] = r[0], w5[1] = r[1];
  var t = vh[0] ^ vh[1];
  return t = t << 5 ^ t >> 7 ^ vh[2] ^ vh[3], t & 2147483647;
}
function KM(r) {
  var t = r.coordinates, e = r.lines, n = r.rings, i = w(), s = new Int32Array(t.length), o = new Int32Array(t.length), a = new Int32Array(t.length), u = new Int8Array(t.length), x = 0, c, f, l, h, p;
  for (c = 0, f = t.length; c < f; ++c)
    s[c] = o[c] = a[c] = -1;
  for (c = 0, f = e.length; c < f; ++c) {
    var y = e[c], v = y[0], m = y[1];
    for (h = i[v], p = i[++v], ++x, u[h] = 1; ++v <= m; )
      b(c, l = h, h = p, p = i[v]);
    ++x, u[p] = 1;
  }
  for (c = 0, f = t.length; c < f; ++c)
    s[c] = -1;
  for (c = 0, f = n.length; c < f; ++c) {
    var d = n[c], g = d[0] + 1, _ = d[1];
    for (l = i[_ - 1], h = i[g - 1], p = i[g], b(c, l, h, p); ++g <= _; )
      b(c, l = h, h = p, p = i[g]);
  }
  function b(M, N, P, O) {
    if (s[P] !== M) {
      s[P] = M;
      var k = o[P];
      if (k >= 0) {
        var D = a[P];
        (k !== N || D !== O) && (k !== O || D !== N) && (++x, u[P] = 1);
      } else
        o[P] = N, a[P] = O;
    }
  }
  function w() {
    for (var M = $_(t.length * 1.4, E, S, Int32Array, -1, Int32Array), N = new Int32Array(t.length), P = 0, O = t.length; P < O; ++P)
      N[P] = M.maybeSet(P, P);
    return N;
  }
  function E(M) {
    return Fm(t[M]);
  }
  function S(M, N) {
    return w0(t[M], t[N]);
  }
  s = o = a = null;
  var I = ZM(x * 1.4, Fm, w0), L;
  for (c = 0, f = t.length; c < f; ++c)
    u[L = i[c]] && I.add(t[L]);
  return I;
}
function jM(r) {
  var t = KM(r), e = r.coordinates, n = r.lines, i = r.rings, s, o, a;
  for (o = 0, a = n.length; o < a; ++o)
    for (var u = n[o], x = u[0], c = u[1]; ++x < c; )
      t.has(e[x]) && (s = { 0: x, 1: u[1] }, u[1] = x, u = u.next = s);
  for (o = 0, a = i.length; o < a; ++o)
    for (var f = i[o], l = f[0], h = l, p = f[1], y = t.has(e[l]); ++h < p; )
      t.has(e[h]) && (y ? (s = { 0: h, 1: f[1] }, f[1] = h, f = f.next = s) : (QM(e, l, p, p - h), e[p] = e[l], y = !0, h = l));
  return r;
}
function QM(r, t, e, n) {
  Nv(r, t, e), Nv(r, t, t + n), Nv(r, t + n, e);
}
function Nv(r, t, e) {
  for (var n = t + (e-- - t >> 1), i; t < n; ++t, --e)
    i = r[t], r[t] = r[e], r[e] = i;
}
function $M(r) {
  var t = r.coordinates, e = r.lines, n, i = r.rings, s, o = e.length + i.length, a, u;
  for (delete r.lines, delete r.rings, a = 0, u = e.length; a < u; ++a)
    for (n = e[a]; n = n.next; ) ++o;
  for (a = 0, u = i.length; a < u; ++a)
    for (s = i[a]; s = s.next; ) ++o;
  var x = $_(o * 2 * 1.4, Fm, w0), c = r.arcs = [];
  for (a = 0, u = e.length; a < u; ++a) {
    n = e[a];
    do
      f(n);
    while (n = n.next);
  }
  for (a = 0, u = i.length; a < u; ++a)
    if (s = i[a], s.next)
      do
        f(s);
      while (s = s.next);
    else
      l(s);
  function f(d) {
    var g, _, b, w, E, S, I, L;
    if (b = x.get(g = t[d[0]])) {
      for (I = 0, L = b.length; I < L; ++I)
        if (w = b[I], h(w, d)) {
          d[0] = w[0], d[1] = w[1];
          return;
        }
    }
    if (E = x.get(_ = t[d[1]])) {
      for (I = 0, L = E.length; I < L; ++I)
        if (S = E[I], p(S, d)) {
          d[1] = S[0], d[0] = S[1];
          return;
        }
    }
    b ? b.push(d) : x.set(g, [d]), E ? E.push(d) : x.set(_, [d]), c.push(d);
  }
  function l(d) {
    var g, _, b, w, E;
    if (_ = x.get(g = t[d[0]]))
      for (w = 0, E = _.length; w < E; ++w) {
        if (b = _[w], y(b, d)) {
          d[0] = b[0], d[1] = b[1];
          return;
        }
        if (v(b, d)) {
          d[0] = b[1], d[1] = b[0];
          return;
        }
      }
    if (_ = x.get(g = t[d[0] + m(d)]))
      for (w = 0, E = _.length; w < E; ++w) {
        if (b = _[w], y(b, d)) {
          d[0] = b[0], d[1] = b[1];
          return;
        }
        if (v(b, d)) {
          d[0] = b[1], d[1] = b[0];
          return;
        }
      }
    _ ? _.push(d) : x.set(g, [d]), c.push(d);
  }
  function h(d, g) {
    var _ = d[0], b = g[0], w = d[1], E = g[1];
    if (_ - w !== b - E) return !1;
    for (; _ <= w; ++_, ++b) if (!w0(t[_], t[b])) return !1;
    return !0;
  }
  function p(d, g) {
    var _ = d[0], b = g[0], w = d[1], E = g[1];
    if (_ - w !== b - E) return !1;
    for (; _ <= w; ++_, --E) if (!w0(t[_], t[E])) return !1;
    return !0;
  }
  function y(d, g) {
    var _ = d[0], b = g[0], w = d[1], E = g[1], S = w - _;
    if (S !== E - b) return !1;
    for (var I = m(d), L = m(g), M = 0; M < S; ++M)
      if (!w0(t[_ + (M + I) % S], t[b + (M + L) % S])) return !1;
    return !0;
  }
  function v(d, g) {
    var _ = d[0], b = g[0], w = d[1], E = g[1], S = w - _;
    if (S !== E - b) return !1;
    for (var I = m(d), L = S - m(g), M = 0; M < S; ++M)
      if (!w0(t[_ + (M + I) % S], t[E - (M + L) % S])) return !1;
    return !0;
  }
  function m(d) {
    for (var g = d[0], _ = d[1], b = g, w = b, E = t[b]; ++b < _; ) {
      var S = t[b];
      (S[0] < E[0] || S[0] === E[0] && S[1] < E[1]) && (w = b, E = S);
    }
    return w - g;
  }
  return r;
}
function tP(r) {
  var t = -1, e = [], n = [], i = [];
  function s(f) {
    f && Q_.call(o, f.type) && o[f.type](f);
  }
  var o = {
    GeometryCollection: function(f) {
      f.geometries.forEach(s);
    },
    LineString: function(f) {
      f.arcs = a(f.arcs);
    },
    MultiLineString: function(f) {
      f.arcs = f.arcs.map(a);
    },
    Polygon: function(f) {
      f.arcs = f.arcs.map(u);
    },
    MultiPolygon: function(f) {
      f.arcs = f.arcs.map(x);
    }
  };
  function a(f) {
    for (var l = 0, h = f.length; l < h; ++l) i[++t] = f[l];
    var p = { 0: t - h + 1, 1: t };
    return e.push(p), p;
  }
  function u(f) {
    for (var l = 0, h = f.length; l < h; ++l) i[++t] = f[l];
    var p = { 0: t - h + 1, 1: t };
    return n.push(p), p;
  }
  function x(f) {
    return f.map(u);
  }
  for (var c in r)
    s(r[c]);
  return {
    type: "Topology",
    coordinates: i,
    lines: e,
    rings: n,
    objects: r
  };
}
function eP(r) {
  var t = {}, e;
  for (e in r) t[e] = nP(r[e]);
  return t;
}
function nP(r) {
  return r == null ? { type: null } : (r.type === "FeatureCollection" ? rP : r.type === "Feature" ? Yw : t2)(r);
}
function rP(r) {
  var t = { type: "GeometryCollection", geometries: r.features.map(Yw) };
  return r.bbox != null && (t.bbox = r.bbox), t;
}
function Yw(r) {
  var t = t2(r.geometry), e;
  r.id != null && (t.id = r.id), r.bbox != null && (t.bbox = r.bbox);
  for (e in r.properties) {
    t.properties = r.properties;
    break;
  }
  return t;
}
function t2(r) {
  if (r == null) return { type: null };
  var t = r.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: r.geometries.map(t2) } : r.type === "Point" || r.type === "MultiPoint" ? { type: r.type, coordinates: r.coordinates } : { type: r.type, arcs: r.coordinates };
  return r.bbox != null && (t.bbox = r.bbox), t;
}
function iP(r, t) {
  var e = JM(r = eP(r)), n = $M(jM(tP(r))), i = n.coordinates, s = $_(n.arcs.length * 1.4, sP, oP);
  r = n.objects, n.bbox = e, n.arcs = n.arcs.map(function(f, l) {
    return s.set(f, l), i.slice(f[0], f[1] + 1);
  }), delete n.coordinates, i = null;
  function o(f) {
    f && Q_.call(a, f.type) && a[f.type](f);
  }
  var a = {
    GeometryCollection: function(f) {
      f.geometries.forEach(o);
    },
    LineString: function(f) {
      f.arcs = u(f.arcs);
    },
    MultiLineString: function(f) {
      f.arcs = f.arcs.map(u);
    },
    Polygon: function(f) {
      f.arcs = f.arcs.map(u);
    },
    MultiPolygon: function(f) {
      f.arcs = f.arcs.map(x);
    }
  };
  function u(f) {
    var l = [];
    do {
      var h = s.get(f);
      l.push(f[0] < f[1] ? h : ~h);
    } while (f = f.next);
    return l;
  }
  function x(f) {
    return f.map(u);
  }
  for (var c in r)
    o(r[c]);
  return n;
}
function sP(r) {
  var t = r[0], e = r[1], n;
  return e < t && (n = t, t = e, e = n), t + 31 * e;
}
function oP(r, t) {
  var e = r[0], n = r[1], i = t[0], s = t[1], o;
  return n < e && (o = e, e = n, n = o), s < i && (o = i, i = s, s = o), e === i && n === s;
}
function aP(r, t) {
  if (t === void 0 && (t = {}), oi(r) !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (!r.features.length)
    throw new Error("geojson is empty");
  (t.mutate === !1 || t.mutate === void 0) && (r = br(r));
  var e = [];
  sr(r, function(s) {
    e.push(s.geometry);
  });
  var n = iP({ geoms: Y_(e).geometry }), i = WM(n, n.objects.geoms.geometries);
  return i;
}
function uP(r, t) {
  if (t === void 0 && (t = {}), t = t || {}, !we(t))
    throw new Error("options is invalid");
  var e = t.mutate;
  if (oi(r) !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (!r.features.length)
    throw new Error("geojson is empty");
  (e === !1 || e === void 0) && (r = br(r));
  var n = xP(r);
  if (!n)
    throw new Error("geojson must be homogenous");
  var i = r;
  switch (n) {
    case "LineString":
      return GM(i, t);
    case "Polygon":
      return aP(i, t);
    default:
      throw new Error(n + " is not supported");
  }
}
function xP(r) {
  var t = {};
  sr(r, function(n) {
    t[n.geometry.type] = !0;
  });
  var e = Object.keys(t);
  return e.length === 1 ? e[0] : null;
}
function cP(r, t) {
  t === void 0 && (t = {});
  var e = t.maxEdge || 1 / 0, n = fP(r), i = Tw(n);
  if (i.features = i.features.filter(function(o) {
    var a = o.geometry.coordinates[0][0], u = o.geometry.coordinates[0][1], x = o.geometry.coordinates[0][2], c = Ie(a, u, t), f = Ie(u, x, t), l = Ie(a, x, t);
    return c <= e && f <= e && l <= e;
  }), i.features.length < 1)
    return null;
  var s = uP(i);
  return s.coordinates.length === 1 && (s.coordinates = s.coordinates[0], s.type = "Polygon"), Tn(s);
}
function fP(r) {
  var t = [], e = {};
  return he(r, function(n) {
    if (n.geometry) {
      var i = n.geometry.coordinates.join("-");
      Object.prototype.hasOwnProperty.call(e, i) || (t.push(n), e[i] = !0);
    }
  }), ht(t);
}
var e2 = { exports: {} }, Xw = { exports: {} };
(function(r, t) {
  (function(e, n) {
    r.exports = n();
  })(Cy, function() {
    function e(o, a, u, x, c) {
      n(o, a, u || 0, x || o.length - 1, c || s);
    }
    function n(o, a, u, x, c) {
      for (; x > u; ) {
        if (x - u > 600) {
          var f = x - u + 1, l = a - u + 1, h = Math.log(f), p = 0.5 * Math.exp(2 * h / 3), y = 0.5 * Math.sqrt(h * p * (f - p) / f) * (l - f / 2 < 0 ? -1 : 1), v = Math.max(u, Math.floor(a - l * p / f + y)), m = Math.min(x, Math.floor(a + (f - l) * p / f + y));
          n(o, a, v, m, c);
        }
        var d = o[a], g = u, _ = x;
        for (i(o, u, a), c(o[x], d) > 0 && i(o, u, x); g < _; ) {
          for (i(o, g, _), g++, _--; c(o[g], d) < 0; ) g++;
          for (; c(o[_], d) > 0; ) _--;
        }
        c(o[u], d) === 0 ? i(o, u, _) : (_++, i(o, _, x)), _ <= a && (u = _ + 1), a <= _ && (x = _ - 1);
      }
    }
    function i(o, a, u) {
      var x = o[a];
      o[a] = o[u], o[u] = x;
    }
    function s(o, a) {
      return o < a ? -1 : o > a ? 1 : 0;
    }
    return e;
  });
})(Xw);
var qw = Xw.exports;
e2.exports = sl;
e2.exports.default = sl;
var lP = qw;
function sl(r, t) {
  if (!(this instanceof sl)) return new sl(r, t);
  this._maxEntries = Math.max(4, r || 9), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), t && this._initFormat(t), this.clear();
}
sl.prototype = {
  all: function() {
    return this._all(this.data, []);
  },
  search: function(r) {
    var t = this.data, e = [], n = this.toBBox;
    if (!_h(r, t)) return e;
    for (var i = [], s, o, a, u; t; ) {
      for (s = 0, o = t.children.length; s < o; s++)
        a = t.children[s], u = t.leaf ? n(a) : a, _h(r, u) && (t.leaf ? e.push(a) : Rv(r, u) ? this._all(a, e) : i.push(a));
      t = i.pop();
    }
    return e;
  },
  collides: function(r) {
    var t = this.data, e = this.toBBox;
    if (!_h(r, t)) return !1;
    for (var n = [], i, s, o, a; t; ) {
      for (i = 0, s = t.children.length; i < s; i++)
        if (o = t.children[i], a = t.leaf ? e(o) : o, _h(r, a)) {
          if (t.leaf || Rv(r, a)) return !0;
          n.push(o);
        }
      t = n.pop();
    }
    return !1;
  },
  load: function(r) {
    if (!(r && r.length)) return this;
    if (r.length < this._minEntries) {
      for (var t = 0, e = r.length; t < e; t++)
        this.insert(r[t]);
      return this;
    }
    var n = this._build(r.slice(), 0, r.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        var i = this.data;
        this.data = n, n = i;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  },
  insert: function(r) {
    return r && this._insert(r, this.data.height - 1), this;
  },
  clear: function() {
    return this.data = Au([]), this;
  },
  remove: function(r, t) {
    if (!r) return this;
    for (var e = this.data, n = this.toBBox(r), i = [], s = [], o, a, u, x; e || i.length; ) {
      if (e || (e = i.pop(), a = i[i.length - 1], o = s.pop(), x = !0), e.leaf && (u = hP(r, e.children, t), u !== -1))
        return e.children.splice(u, 1), i.push(e), this._condense(i), this;
      !x && !e.leaf && Rv(e, n) ? (i.push(e), s.push(o), o = 0, a = e, e = e.children[0]) : a ? (o++, e = a.children[o], x = !1) : e = null;
    }
    return this;
  },
  toBBox: function(r) {
    return r;
  },
  compareMinX: E5,
  compareMinY: S5,
  toJSON: function() {
    return this.data;
  },
  fromJSON: function(r) {
    return this.data = r, this;
  },
  _all: function(r, t) {
    for (var e = []; r; )
      r.leaf ? t.push.apply(t, r.children) : e.push.apply(e, r.children), r = e.pop();
    return t;
  },
  _build: function(r, t, e, n) {
    var i = e - t + 1, s = this._maxEntries, o;
    if (i <= s)
      return o = Au(r.slice(t, e + 1)), Eu(o, this.toBBox), o;
    n || (n = Math.ceil(Math.log(i) / Math.log(s)), s = Math.ceil(i / Math.pow(s, n - 1))), o = Au([]), o.leaf = !1, o.height = n;
    var a = Math.ceil(i / s), u = a * Math.ceil(Math.sqrt(s)), x, c, f, l;
    for (C5(r, t, e, u, this.compareMinX), x = t; x <= e; x += u)
      for (f = Math.min(x + u - 1, e), C5(r, x, f, a, this.compareMinY), c = x; c <= f; c += a)
        l = Math.min(c + a - 1, f), o.children.push(this._build(r, c, l, n - 1));
    return Eu(o, this.toBBox), o;
  },
  _chooseSubtree: function(r, t, e, n) {
    for (var i, s, o, a, u, x, c, f; n.push(t), !(t.leaf || n.length - 1 === e); ) {
      for (c = f = 1 / 0, i = 0, s = t.children.length; i < s; i++)
        o = t.children[i], u = Ov(o), x = pP(r, o) - u, x < f ? (f = x, c = u < c ? u : c, a = o) : x === f && u < c && (c = u, a = o);
      t = a || t.children[0];
    }
    return t;
  },
  _insert: function(r, t, e) {
    var n = this.toBBox, i = e ? r : n(r), s = [], o = this._chooseSubtree(i, this.data, t, s);
    for (o.children.push(r), Rc(o, i); t >= 0 && s[t].children.length > this._maxEntries; )
      this._split(s, t), t--;
    this._adjustParentBBoxes(i, s, t);
  },
  // split overflowed node into two
  _split: function(r, t) {
    var e = r[t], n = e.children.length, i = this._minEntries;
    this._chooseSplitAxis(e, i, n);
    var s = this._chooseSplitIndex(e, i, n), o = Au(e.children.splice(s, e.children.length - s));
    o.height = e.height, o.leaf = e.leaf, Eu(e, this.toBBox), Eu(o, this.toBBox), t ? r[t - 1].children.push(o) : this._splitRoot(e, o);
  },
  _splitRoot: function(r, t) {
    this.data = Au([r, t]), this.data.height = r.height + 1, this.data.leaf = !1, Eu(this.data, this.toBBox);
  },
  _chooseSplitIndex: function(r, t, e) {
    var n, i, s, o, a, u, x, c;
    for (u = x = 1 / 0, n = t; n <= e - t; n++)
      i = Oc(r, 0, n, this.toBBox), s = Oc(r, n, e, this.toBBox), o = dP(i, s), a = Ov(i) + Ov(s), o < u ? (u = o, c = n, x = a < x ? a : x) : o === u && a < x && (x = a, c = n);
    return c;
  },
  // sorts node children by the best axis for split
  _chooseSplitAxis: function(r, t, e) {
    var n = r.leaf ? this.compareMinX : E5, i = r.leaf ? this.compareMinY : S5, s = this._allDistMargin(r, t, e, n), o = this._allDistMargin(r, t, e, i);
    s < o && r.children.sort(n);
  },
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin: function(r, t, e, n) {
    r.children.sort(n);
    var i = this.toBBox, s = Oc(r, 0, t, i), o = Oc(r, e - t, e, i), a = mh(s) + mh(o), u, x;
    for (u = t; u < e - t; u++)
      x = r.children[u], Rc(s, r.leaf ? i(x) : x), a += mh(s);
    for (u = e - t - 1; u >= t; u--)
      x = r.children[u], Rc(o, r.leaf ? i(x) : x), a += mh(o);
    return a;
  },
  _adjustParentBBoxes: function(r, t, e) {
    for (var n = e; n >= 0; n--)
      Rc(t[n], r);
  },
  _condense: function(r) {
    for (var t = r.length - 1, e; t >= 0; t--)
      r[t].children.length === 0 ? t > 0 ? (e = r[t - 1].children, e.splice(e.indexOf(r[t]), 1)) : this.clear() : Eu(r[t], this.toBBox);
  },
  _initFormat: function(r) {
    var t = ["return a", " - b", ";"];
    this.compareMinX = new Function("a", "b", t.join(r[0])), this.compareMinY = new Function("a", "b", t.join(r[1])), this.toBBox = new Function(
      "a",
      "return {minX: a" + r[0] + ", minY: a" + r[1] + ", maxX: a" + r[2] + ", maxY: a" + r[3] + "};"
    );
  }
};
function hP(r, t, e) {
  if (!e) return t.indexOf(r);
  for (var n = 0; n < t.length; n++)
    if (e(r, t[n])) return n;
  return -1;
}
function Eu(r, t) {
  Oc(r, 0, r.children.length, t, r);
}
function Oc(r, t, e, n, i) {
  i || (i = Au(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (var s = t, o; s < e; s++)
    o = r.children[s], Rc(i, r.leaf ? n(o) : o);
  return i;
}
function Rc(r, t) {
  return r.minX = Math.min(r.minX, t.minX), r.minY = Math.min(r.minY, t.minY), r.maxX = Math.max(r.maxX, t.maxX), r.maxY = Math.max(r.maxY, t.maxY), r;
}
function E5(r, t) {
  return r.minX - t.minX;
}
function S5(r, t) {
  return r.minY - t.minY;
}
function Ov(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function mh(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function pP(r, t) {
  return (Math.max(t.maxX, r.maxX) - Math.min(t.minX, r.minX)) * (Math.max(t.maxY, r.maxY) - Math.min(t.minY, r.minY));
}
function dP(r, t) {
  var e = Math.max(r.minX, t.minX), n = Math.max(r.minY, t.minY), i = Math.min(r.maxX, t.maxX), s = Math.min(r.maxY, t.maxY);
  return Math.max(0, i - e) * Math.max(0, s - n);
}
function Rv(r, t) {
  return r.minX <= t.minX && r.minY <= t.minY && t.maxX <= r.maxX && t.maxY <= r.maxY;
}
function _h(r, t) {
  return t.minX <= r.maxX && t.minY <= r.maxY && t.maxX >= r.minX && t.maxY >= r.minY;
}
function Au(r) {
  return {
    children: r,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function C5(r, t, e, n, i) {
  for (var s = [t, e], o; s.length; )
    e = s.pop(), t = s.pop(), !(e - t <= n) && (o = t + Math.ceil((e - t) / n / 2) * n, lP(r, o, t, e, i), s.push(t, o, o, e));
}
var gP = e2.exports;
const yP = /* @__PURE__ */ Ao(gP);
function vP(r, t, e, n) {
  var i = yP(6), s = t.features.map(function(o) {
    var a;
    return {
      minX: o.geometry.coordinates[0],
      minY: o.geometry.coordinates[1],
      maxX: o.geometry.coordinates[0],
      maxY: o.geometry.coordinates[1],
      property: (a = o.properties) === null || a === void 0 ? void 0 : a[e]
    };
  });
  return i.load(s), r.features.forEach(function(o) {
    o.properties || (o.properties = {});
    var a = Cn(o), u = i.search({
      minX: a[0],
      minY: a[1],
      maxX: a[2],
      maxY: a[3]
    }), x = [];
    u.forEach(function(c) {
      Fe([c.minX, c.minY], o) && x.push(c.property);
    }), o.properties[n] = x;
  }), r;
}
function mP(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.mutate;
  if (!r) throw new Error("geojson is required");
  return (e === !1 || e === void 0) && (r = br(r)), hn(r, function(n) {
    var i = n[0], s = n[1];
    n[0] = s, n[1] = i;
  }), r;
}
function U0(r, t) {
  t === void 0 && (t = {});
  var e = typeof t == "object" ? t.mutate : t;
  if (!r)
    throw new Error("geojson is required");
  var n = oi(r), i = [];
  switch (n) {
    case "LineString":
      i = Av(r);
      break;
    case "MultiLineString":
    case "Polygon":
      gt(r).forEach(function(o) {
        i.push(Av(o));
      });
      break;
    case "MultiPolygon":
      gt(r).forEach(function(o) {
        var a = [];
        o.forEach(function(u) {
          a.push(Av(u));
        }), i.push(a);
      });
      break;
    case "Point":
      return r;
    case "MultiPoint":
      var s = {};
      gt(r).forEach(function(o) {
        var a = o.join("-");
        Object.prototype.hasOwnProperty.call(s, a) || (i.push(o), s[a] = !0);
      });
      break;
    default:
      throw new Error(n + " geometry not supported");
  }
  return r.coordinates ? e === !0 ? (r.coordinates = i, r) : { type: n, coordinates: i } : e === !0 ? (r.geometry.coordinates = i, r) : Tn({ type: n, coordinates: i }, r.properties, {
    bbox: r.bbox,
    id: r.id
  });
}
function Av(r) {
  var t = gt(r);
  if (t.length === 2 && !M5(t[0], t[1]))
    return t;
  var e = [], n = t.length - 1, i = e.length;
  e.push(t[0]);
  for (var s = 1; s < n; s++) {
    var o = e[e.length - 1];
    t[s][0] === o[0] && t[s][1] === o[1] || (e.push(t[s]), i = e.length, i > 2 && P5(e[i - 3], e[i - 1], e[i - 2]) && e.splice(e.length - 2, 1));
  }
  if (e.push(t[t.length - 1]), i = e.length, M5(t[0], t[t.length - 1]) && i < 4)
    throw new Error("invalid polygon");
  return P5(e[i - 3], e[i - 1], e[i - 2]) && e.splice(e.length - 2, 1), e;
}
function M5(r, t) {
  return r[0] === t[0] && r[1] === t[1];
}
function P5(r, t, e) {
  var n = e[0], i = e[1], s = r[0], o = r[1], a = t[0], u = t[1], x = n - s, c = i - o, f = a - s, l = u - o, h = x * l - c * f;
  return h !== 0 ? !1 : Math.abs(f) >= Math.abs(l) ? f > 0 ? s <= n && n <= a : a <= n && n <= s : l > 0 ? o <= i && i <= u : u <= i && i <= o;
}
function _P(r, t) {
  var e = r.x - t.x, n = r.y - t.y;
  return e * e + n * n;
}
function bP(r, t, e) {
  var n = t.x, i = t.y, s = e.x - n, o = e.y - i;
  if (s !== 0 || o !== 0) {
    var a = ((r.x - n) * s + (r.y - i) * o) / (s * s + o * o);
    a > 1 ? (n = e.x, i = e.y) : a > 0 && (n += s * a, i += o * a);
  }
  return s = r.x - n, o = r.y - i, s * s + o * o;
}
function IP(r, t) {
  for (var e = r[0], n = [e], i, s = 1, o = r.length; s < o; s++)
    i = r[s], _P(i, e) > t && (n.push(i), e = i);
  return e !== i && n.push(i), n;
}
function km(r, t, e, n, i) {
  for (var s = n, o, a = t + 1; a < e; a++) {
    var u = bP(r[a], r[t], r[e]);
    u > s && (o = a, s = u);
  }
  s > n && (o - t > 1 && km(r, t, o, n, i), i.push(r[o]), e - o > 1 && km(r, o, e, n, i));
}
function wP(r, t) {
  var e = r.length - 1, n = [r[0]];
  return km(r, 0, e, t, n), n.push(r[e]), n;
}
function Bm(r, t, e) {
  if (r.length <= 2) return r;
  var n = t !== void 0 ? t * t : 1;
  return r = e ? r : IP(r, n), r = wP(r, n), r;
}
function EP(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.tolerance !== void 0 ? t.tolerance : 1, n = t.highQuality || !1, i = t.mutate || !1;
  if (!r) throw new Error("geojson is required");
  if (e && e < 0) throw new Error("invalid tolerance");
  return i !== !0 && (r = br(r)), Pi(r, function(s) {
    SP(s, e, n);
  }), r;
}
function SP(r, t, e) {
  var n = r.type;
  if (n === "Point" || n === "MultiPoint") return r;
  U0(r, !0);
  var i = r.coordinates;
  switch (n) {
    case "LineString":
      r.coordinates = L5(
        i,
        t,
        e
      );
      break;
    case "MultiLineString":
      r.coordinates = i.map(function(s) {
        return L5(s, t, e);
      });
      break;
    case "Polygon":
      r.coordinates = N5(
        i,
        t,
        e
      );
      break;
    case "MultiPolygon":
      r.coordinates = i.map(function(s) {
        return N5(s, t, e);
      });
  }
  return r;
}
function L5(r, t, e) {
  return Bm(
    r.map(function(n) {
      return { x: n[0], y: n[1], z: n[2] };
    }),
    t,
    e
  ).map(function(n) {
    return n.z ? [n.x, n.y, n.z] : [n.x, n.y];
  });
}
function N5(r, t, e) {
  return r.map(function(n) {
    var i = n.map(function(o) {
      return { x: o[0], y: o[1] };
    });
    if (i.length < 4)
      throw new Error("invalid polygon");
    for (var s = Bm(i, t, e).map(function(o) {
      return [o.x, o.y];
    }); !CP(s); )
      t -= t * 0.01, s = Bm(i, t, e).map(function(o) {
        return [o.x, o.y];
      });
    return (s[s.length - 1][0] !== s[0][0] || s[s.length - 1][1] !== s[0][1]) && s.push(s[0]), s;
  });
}
function CP(r) {
  return r.length < 3 ? !1 : !(r.length === 3 && r[2][0] === r[0][0] && r[2][1] === r[0][1]);
}
var MP = (
  /** @class */
  function() {
    function r(t) {
      this.points = t.points || [], this.duration = t.duration || 1e4, this.sharpness = t.sharpness || 0.85, this.centers = [], this.controls = [], this.stepLength = t.stepLength || 60, this.length = this.points.length, this.delay = 0;
      for (var e = 0; e < this.length; e++)
        this.points[e].z = this.points[e].z || 0;
      for (var e = 0; e < this.length - 1; e++) {
        var n = this.points[e], i = this.points[e + 1];
        this.centers.push({
          x: (n.x + i.x) / 2,
          y: (n.y + i.y) / 2,
          z: (n.z + i.z) / 2
        });
      }
      this.controls.push([this.points[0], this.points[0]]);
      for (var e = 0; e < this.centers.length - 1; e++) {
        var s = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2, o = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2, a = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2;
        this.controls.push([
          {
            x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + s),
            y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + o),
            z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + a)
          },
          {
            x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + s),
            y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + o),
            z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + a)
          }
        ]);
      }
      return this.controls.push([
        this.points[this.length - 1],
        this.points[this.length - 1]
      ]), this.steps = this.cacheSteps(this.stepLength), this;
    }
    return r.prototype.cacheSteps = function(t) {
      var e = [], n = this.pos(0);
      e.push(0);
      for (var i = 0; i < this.duration; i += 10) {
        var s = this.pos(i), o = Math.sqrt((s.x - n.x) * (s.x - n.x) + (s.y - n.y) * (s.y - n.y) + (s.z - n.z) * (s.z - n.z));
        o > t && (e.push(i), n = s);
      }
      return e;
    }, r.prototype.vector = function(t) {
      var e = this.pos(t + 10), n = this.pos(t - 10);
      return {
        angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14,
        speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z))
      };
    }, r.prototype.pos = function(t) {
      var e = t - this.delay;
      e < 0 && (e = 0), e > this.duration && (e = this.duration - 1);
      var n = e / this.duration;
      if (n >= 1)
        return this.points[this.length - 1];
      var i = Math.floor((this.points.length - 1) * n), s = (this.length - 1) * n - i;
      return PP(s, this.points[i], this.controls[i][1], this.controls[i + 1][0], this.points[i + 1]);
    }, r;
  }()
);
function PP(r, t, e, n, i) {
  var s = LP(r), o = {
    x: i.x * s[0] + n.x * s[1] + e.x * s[2] + t.x * s[3],
    y: i.y * s[0] + n.y * s[1] + e.y * s[2] + t.y * s[3],
    z: i.z * s[0] + n.z * s[1] + e.z * s[2] + t.z * s[3]
  };
  return o;
}
function LP(r) {
  var t = r * r, e = t * r;
  return [
    e,
    3 * t * (1 - r),
    3 * r * (1 - r) * (1 - r),
    (1 - r) * (1 - r) * (1 - r)
  ];
}
function O5(r, t) {
  t === void 0 && (t = {});
  for (var e = t.resolution || 1e4, n = t.sharpness || 0.85, i = [], s = ke(r).coordinates.map(function(x) {
    return { x: x[0], y: x[1] };
  }), o = new MP({
    duration: e,
    points: s,
    sharpness: n
  }), a = function(x) {
    var c = o.pos(x);
    Math.floor(x / 100) % 2 === 0 && i.push([c.x, c.y]);
  }, u = 0; u < o.duration; u += 10)
    a(u);
  return a(o.duration), ge(i, t.properties);
}
function NP(r, t, e, n) {
  return r = br(r), t = br(t), he(r, function(i) {
    i.properties || (i.properties = {}), he(t, function(s) {
      i.properties[n] === void 0 && Fe(i, s) && (i.properties[n] = s.properties[e]);
    });
  }), r;
}
function OP(r, t) {
  if (!r) throw new Error("featurecollection is required");
  if (t == null) throw new Error("num is required");
  if (typeof t != "number") throw new Error("num must be a number");
  var e = ht(
    RP(r.features, t)
  );
  return e;
}
function RP(r, t) {
  for (var e = r.slice(0), n = r.length, i = n - t, s, o; n-- > i; )
    o = Math.floor((n + 1) * Math.random()), s = e[o], e[o] = e[n], e[n] = s;
  return e.slice(i);
}
function n2(r, t) {
  t === void 0 && (t = {});
  var e = Number(r[0]), n = Number(r[1]), i = Number(r[2]), s = Number(r[3]);
  if (r.length === 6)
    throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  var o = [e, n], a = [e, s], u = [i, s], x = [i, n];
  return Nt([[o, x, u, a, o]], t.properties, { bbox: r, id: t.id });
}
function zw(r) {
  return n2(Cn(r));
}
function Uw(r) {
  var t = r[0], e = r[1], n = r[2], i = r[3], s = Ie(r.slice(0, 2), [n, e]), o = Ie(r.slice(0, 2), [t, i]);
  if (s >= o) {
    var a = (e + i) / 2;
    return [
      t,
      a - (n - t) / 2,
      n,
      a + (n - t) / 2
    ];
  } else {
    var u = (t + n) / 2;
    return [
      u - (i - e) / 2,
      e,
      u + (i - e) / 2,
      i
    ];
  }
}
function Eo(r, t, e, n) {
  n === void 0 && (n = {});
  var i = Ae(r), s = Un(i[0]), o = Un(i[1]), a = Un(e), u = X0(t, n.units), x = Math.asin(Math.sin(o) * Math.cos(u) + Math.cos(o) * Math.sin(u) * Math.cos(a)), c = s + Math.atan2(Math.sin(a) * Math.sin(u) * Math.cos(o), Math.cos(u) - Math.sin(o) * Math.sin(x)), f = Za(c), l = Za(x);
  return Pt([f, l], n.properties);
}
function r2(r, t, e) {
  e === void 0 && (e = {});
  for (var n = e.steps || 64, i = e.properties ? e.properties : !Array.isArray(r) && r.type === "Feature" && r.properties ? r.properties : {}, s = [], o = 0; o < n; o++)
    s.push(Eo(r, t, o * -360 / n, e).geometry.coordinates);
  return s.push(s[0]), Nt([s], i);
}
function fa(r, t, e) {
  if (e === void 0 && (e = {}), e.final === !0)
    return AP(r, t);
  var n = Ae(r), i = Ae(t), s = Un(n[0]), o = Un(i[0]), a = Un(n[1]), u = Un(i[1]), x = Math.sin(o - s) * Math.cos(u), c = Math.cos(a) * Math.sin(u) - Math.sin(a) * Math.cos(u) * Math.cos(o - s);
  return Za(Math.atan2(x, c));
}
function AP(r, t) {
  var e = fa(t, r);
  return e = (e + 180) % 360, e;
}
function TP(r, t) {
  var e = Ie(r, t), n = fa(r, t), i = Eo(r, e / 2, n);
  return i;
}
function Py(r, t) {
  t === void 0 && (t = {});
  var e = Cn(r), n = (e[0] + e[2]) / 2, i = (e[1] + e[3]) / 2;
  return Pt([n, i], t.properties, t);
}
function Ka(r, t) {
  t === void 0 && (t = {});
  var e = 0, n = 0, i = 0;
  return hn(r, function(s) {
    e += s[0], n += s[1], i++;
  }, !0), Pt([e / i, n / i], t.properties);
}
function Vw(r, t) {
  switch (t === void 0 && (t = {}), oi(r)) {
    case "Point":
      return Pt(Ae(r), t.properties);
    case "Polygon":
      var e = [];
      hn(r, function(_) {
        e.push(_);
      });
      var n = Ka(r, { properties: t.properties }), i = n.geometry.coordinates, s = 0, o = 0, a = 0, u, x, c, f, l, h, p, y, v = e.map(function(_) {
        return [_[0] - i[0], _[1] - i[1]];
      });
      for (u = 0; u < e.length - 1; u++)
        x = v[u], f = x[0], h = x[1], c = v[u + 1], l = c[0], p = c[1], y = f * p - l * h, a += y, s += (f + l) * y, o += (h + p) * y;
      if (a === 0)
        return n;
      var m = a * 0.5, d = 1 / (6 * m);
      return Pt([i[0] + d * s, i[1] + d * o], t.properties);
    default:
      var g = Aw(r);
      return g ? Vw(g, { properties: t.properties }) : Ka(r, { properties: t.properties });
  }
}
function DP(r) {
  var t = {
    MultiPoint: {
      coordinates: [],
      properties: []
    },
    MultiLineString: {
      coordinates: [],
      properties: []
    },
    MultiPolygon: {
      coordinates: [],
      properties: []
    }
  };
  return he(r, function(e) {
    var n, i, s, o;
    switch ((o = e.geometry) === null || o === void 0 ? void 0 : o.type) {
      case "Point":
        t.MultiPoint.coordinates.push(e.geometry.coordinates), t.MultiPoint.properties.push(e.properties);
        break;
      case "MultiPoint":
        (n = t.MultiPoint.coordinates).push.apply(n, e.geometry.coordinates), t.MultiPoint.properties.push(e.properties);
        break;
      case "LineString":
        t.MultiLineString.coordinates.push(e.geometry.coordinates), t.MultiLineString.properties.push(e.properties);
        break;
      case "MultiLineString":
        (i = t.MultiLineString.coordinates).push.apply(i, e.geometry.coordinates), t.MultiLineString.properties.push(e.properties);
        break;
      case "Polygon":
        t.MultiPolygon.coordinates.push(e.geometry.coordinates), t.MultiPolygon.properties.push(e.properties);
        break;
      case "MultiPolygon":
        (s = t.MultiPolygon.coordinates).push.apply(s, e.geometry.coordinates), t.MultiPolygon.properties.push(e.properties);
        break;
    }
  }), ht(Object.keys(t).filter(function(e) {
    return t[e].coordinates.length;
  }).sort().map(function(e) {
    var n = { type: e, coordinates: t[e].coordinates }, i = { collectedProperties: t[e].properties };
    return Tn(n, i);
  }));
}
function Ly(r) {
  var t = [];
  return r.type === "FeatureCollection" ? he(r, function(e) {
    hn(e, function(n) {
      t.push(Pt(n, e.properties));
    });
  }) : hn(r, function(e) {
    t.push(Pt(e, r.properties));
  }), ht(t);
}
var i2 = { exports: {} };
i2.exports = Ny;
i2.exports.default = Ny;
function Ny(r, t, e) {
  e = e || 2;
  var n = t && t.length, i = n ? t[0] * e : r.length, s = Ww(r, 0, i, e, !0), o = [];
  if (!s || s.next === s.prev) return o;
  var a, u, x, c, f, l, h;
  if (n && (s = YP(r, t, s, e)), r.length > 80 * e) {
    a = x = r[0], u = c = r[1];
    for (var p = e; p < i; p += e)
      f = r[p], l = r[p + 1], f < a && (a = f), l < u && (u = l), f > x && (x = f), l > c && (c = l);
    h = Math.max(x - a, c - u), h = h !== 0 ? 32767 / h : 0;
  }
  return ol(s, o, e, a, u, h, 0), o;
}
function Ww(r, t, e, n, i) {
  var s, o;
  if (i === Xm(r, t, e, n) > 0)
    for (s = t; s < e; s += n) o = R5(s, r[s], r[s + 1], o);
  else
    for (s = e - n; s >= t; s -= n) o = R5(s, r[s], r[s + 1], o);
  return o && Oy(o, o.next) && (ul(o), o = o.next), o;
}
function V0(r, t) {
  if (!r) return r;
  t || (t = r);
  var e = r, n;
  do
    if (n = !1, !e.steiner && (Oy(e, e.next) || wn(e.prev, e, e.next) === 0)) {
      if (ul(e), e = t = e.prev, e === e.next) break;
      n = !0;
    } else
      e = e.next;
  while (n || e !== t);
  return t;
}
function ol(r, t, e, n, i, s, o) {
  if (r) {
    !o && s && VP(r, n, i, s);
    for (var a = r, u, x; r.prev !== r.next; ) {
      if (u = r.prev, x = r.next, s ? kP(r, n, i, s) : FP(r)) {
        t.push(u.i / e | 0), t.push(r.i / e | 0), t.push(x.i / e | 0), ul(r), r = x.next, a = x.next;
        continue;
      }
      if (r = x, r === a) {
        o ? o === 1 ? (r = BP(V0(r), t, e), ol(r, t, e, n, i, s, 2)) : o === 2 && GP(r, t, e, n, i, s) : ol(V0(r), t, e, n, i, s, 1);
        break;
      }
    }
  }
}
function FP(r) {
  var t = r.prev, e = r, n = r.next;
  if (wn(t, e, n) >= 0) return !1;
  for (var i = t.x, s = e.x, o = n.x, a = t.y, u = e.y, x = n.y, c = i < s ? i < o ? i : o : s < o ? s : o, f = a < u ? a < x ? a : x : u < x ? u : x, l = i > s ? i > o ? i : o : s > o ? s : o, h = a > u ? a > x ? a : x : u > x ? u : x, p = n.next; p !== t; ) {
    if (p.x >= c && p.x <= l && p.y >= f && p.y <= h && qu(i, a, s, u, o, x, p.x, p.y) && wn(p.prev, p, p.next) >= 0) return !1;
    p = p.next;
  }
  return !0;
}
function kP(r, t, e, n) {
  var i = r.prev, s = r, o = r.next;
  if (wn(i, s, o) >= 0) return !1;
  for (var a = i.x, u = s.x, x = o.x, c = i.y, f = s.y, l = o.y, h = a < u ? a < x ? a : x : u < x ? u : x, p = c < f ? c < l ? c : l : f < l ? f : l, y = a > u ? a > x ? a : x : u > x ? u : x, v = c > f ? c > l ? c : l : f > l ? f : l, m = Gm(h, p, t, e, n), d = Gm(y, v, t, e, n), g = r.prevZ, _ = r.nextZ; g && g.z >= m && _ && _.z <= d; ) {
    if (g.x >= h && g.x <= y && g.y >= p && g.y <= v && g !== i && g !== o && qu(a, c, u, f, x, l, g.x, g.y) && wn(g.prev, g, g.next) >= 0 || (g = g.prevZ, _.x >= h && _.x <= y && _.y >= p && _.y <= v && _ !== i && _ !== o && qu(a, c, u, f, x, l, _.x, _.y) && wn(_.prev, _, _.next) >= 0)) return !1;
    _ = _.nextZ;
  }
  for (; g && g.z >= m; ) {
    if (g.x >= h && g.x <= y && g.y >= p && g.y <= v && g !== i && g !== o && qu(a, c, u, f, x, l, g.x, g.y) && wn(g.prev, g, g.next) >= 0) return !1;
    g = g.prevZ;
  }
  for (; _ && _.z <= d; ) {
    if (_.x >= h && _.x <= y && _.y >= p && _.y <= v && _ !== i && _ !== o && qu(a, c, u, f, x, l, _.x, _.y) && wn(_.prev, _, _.next) >= 0) return !1;
    _ = _.nextZ;
  }
  return !0;
}
function BP(r, t, e) {
  var n = r;
  do {
    var i = n.prev, s = n.next.next;
    !Oy(i, s) && Hw(i, n, n.next, s) && al(i, s) && al(s, i) && (t.push(i.i / e | 0), t.push(n.i / e | 0), t.push(s.i / e | 0), ul(n), ul(n.next), n = r = s), n = n.next;
  } while (n !== r);
  return V0(n);
}
function GP(r, t, e, n, i, s) {
  var o = r;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && JP(o, a)) {
        var u = Jw(o, a);
        o = V0(o, o.next), u = V0(u, u.next), ol(o, t, e, n, i, s, 0), ol(u, t, e, n, i, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== r);
}
function YP(r, t, e, n) {
  var i = [], s, o, a, u, x;
  for (s = 0, o = t.length; s < o; s++)
    a = t[s] * n, u = s < o - 1 ? t[s + 1] * n : r.length, x = Ww(r, a, u, n, !1), x === x.next && (x.steiner = !0), i.push(HP(x));
  for (i.sort(XP), s = 0; s < i.length; s++)
    e = qP(i[s], e);
  return e;
}
function XP(r, t) {
  return r.x - t.x;
}
function qP(r, t) {
  var e = zP(r, t);
  if (!e)
    return t;
  var n = Jw(e, r);
  return V0(n, n.next), V0(e, e.next);
}
function zP(r, t) {
  var e = t, n = r.x, i = r.y, s = -1 / 0, o;
  do {
    if (i <= e.y && i >= e.next.y && e.next.y !== e.y) {
      var a = e.x + (i - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (a <= n && a > s && (s = a, o = e.x < e.next.x ? e : e.next, a === n))
        return o;
    }
    e = e.next;
  } while (e !== t);
  if (!o) return null;
  var u = o, x = o.x, c = o.y, f = 1 / 0, l;
  e = o;
  do
    n >= e.x && e.x >= x && n !== e.x && qu(i < c ? n : s, i, x, c, i < c ? s : n, i, e.x, e.y) && (l = Math.abs(i - e.y) / (n - e.x), al(e, r) && (l < f || l === f && (e.x > o.x || e.x === o.x && UP(o, e))) && (o = e, f = l)), e = e.next;
  while (e !== u);
  return o;
}
function UP(r, t) {
  return wn(r.prev, r, t.prev) < 0 && wn(t.next, r, r.next) < 0;
}
function VP(r, t, e, n) {
  var i = r;
  do
    i.z === 0 && (i.z = Gm(i.x, i.y, t, e, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== r);
  i.prevZ.nextZ = null, i.prevZ = null, WP(i);
}
function WP(r) {
  var t, e, n, i, s, o, a, u, x = 1;
  do {
    for (e = r, r = null, s = null, o = 0; e; ) {
      for (o++, n = e, a = 0, t = 0; t < x && (a++, n = n.nextZ, !!n); t++)
        ;
      for (u = x; a > 0 || u > 0 && n; )
        a !== 0 && (u === 0 || !n || e.z <= n.z) ? (i = e, e = e.nextZ, a--) : (i = n, n = n.nextZ, u--), s ? s.nextZ = i : r = i, i.prevZ = s, s = i;
      e = n;
    }
    s.nextZ = null, x *= 2;
  } while (o > 1);
  return r;
}
function Gm(r, t, e, n, i) {
  return r = (r - e) * i | 0, t = (t - n) * i | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, r | t << 1;
}
function HP(r) {
  var t = r, e = r;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== r);
  return e;
}
function qu(r, t, e, n, i, s, o, a) {
  return (i - o) * (t - a) >= (r - o) * (s - a) && (r - o) * (n - a) >= (e - o) * (t - a) && (e - o) * (s - a) >= (i - o) * (n - a);
}
function JP(r, t) {
  return r.next.i !== t.i && r.prev.i !== t.i && !ZP(r, t) && // dones't intersect other edges
  (al(r, t) && al(t, r) && KP(r, t) && // locally visible
  (wn(r.prev, r, t.prev) || wn(r, t.prev, t)) || // does not create opposite-facing sectors
  Oy(r, t) && wn(r.prev, r, r.next) > 0 && wn(t.prev, t, t.next) > 0);
}
function wn(r, t, e) {
  return (t.y - r.y) * (e.x - t.x) - (t.x - r.x) * (e.y - t.y);
}
function Oy(r, t) {
  return r.x === t.x && r.y === t.y;
}
function Hw(r, t, e, n) {
  var i = Ih(wn(r, t, e)), s = Ih(wn(r, t, n)), o = Ih(wn(e, n, r)), a = Ih(wn(e, n, t));
  return !!(i !== s && o !== a || i === 0 && bh(r, e, t) || s === 0 && bh(r, n, t) || o === 0 && bh(e, r, n) || a === 0 && bh(e, t, n));
}
function bh(r, t, e) {
  return t.x <= Math.max(r.x, e.x) && t.x >= Math.min(r.x, e.x) && t.y <= Math.max(r.y, e.y) && t.y >= Math.min(r.y, e.y);
}
function Ih(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function ZP(r, t) {
  var e = r;
  do {
    if (e.i !== r.i && e.next.i !== r.i && e.i !== t.i && e.next.i !== t.i && Hw(e, e.next, r, t)) return !0;
    e = e.next;
  } while (e !== r);
  return !1;
}
function al(r, t) {
  return wn(r.prev, r, r.next) < 0 ? wn(r, t, r.next) >= 0 && wn(r, r.prev, t) >= 0 : wn(r, t, r.prev) < 0 || wn(r, r.next, t) < 0;
}
function KP(r, t) {
  var e = r, n = !1, i = (r.x + t.x) / 2, s = (r.y + t.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && i < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next;
  while (e !== r);
  return n;
}
function Jw(r, t) {
  var e = new Ym(r.i, r.x, r.y), n = new Ym(t.i, t.x, t.y), i = r.next, s = t.prev;
  return r.next = t, t.prev = r, e.next = i, i.prev = e, n.next = e, e.prev = n, s.next = n, n.prev = s, n;
}
function R5(r, t, e, n) {
  var i = new Ym(r, t, e);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function ul(r) {
  r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function Ym(r, t, e) {
  this.i = r, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Ny.deviation = function(r, t, e, n) {
  var i = t && t.length, s = i ? t[0] * e : r.length, o = Math.abs(Xm(r, 0, s, e));
  if (i)
    for (var a = 0, u = t.length; a < u; a++) {
      var x = t[a] * e, c = a < u - 1 ? t[a + 1] * e : r.length;
      o -= Math.abs(Xm(r, x, c, e));
    }
  var f = 0;
  for (a = 0; a < n.length; a += 3) {
    var l = n[a] * e, h = n[a + 1] * e, p = n[a + 2] * e;
    f += Math.abs(
      (r[l] - r[p]) * (r[h + 1] - r[l + 1]) - (r[l] - r[h]) * (r[p + 1] - r[l + 1])
    );
  }
  return o === 0 && f === 0 ? 0 : Math.abs((f - o) / o);
};
function Xm(r, t, e, n) {
  for (var i = 0, s = t, o = e - n; s < e; s += n)
    i += (r[o] - r[s]) * (r[s + 1] + r[o + 1]), o = s;
  return i;
}
Ny.flatten = function(r) {
  for (var t = r[0][0].length, e = { vertices: [], holes: [], dimensions: t }, n = 0, i = 0; i < r.length; i++) {
    for (var s = 0; s < r[i].length; s++)
      for (var o = 0; o < t; o++) e.vertices.push(r[i][s][o]);
    i > 0 && (n += r[i - 1].length, e.holes.push(n));
  }
  return e;
};
var jP = i2.exports;
const QP = /* @__PURE__ */ Ao(jP);
function $P(r) {
  if (!r.geometry || r.geometry.type !== "Polygon" && r.geometry.type !== "MultiPolygon")
    throw new Error("input must be a Polygon or MultiPolygon");
  var t = { type: "FeatureCollection", features: [] };
  return r.geometry.type === "Polygon" ? t.features = A5(r.geometry.coordinates) : r.geometry.coordinates.forEach(function(e) {
    t.features = t.features.concat(A5(e));
  }), t;
}
function A5(r) {
  var t = tL(r), e = 2, n = QP(t.vertices, t.holes, e), i = [], s = [];
  n.forEach(function(u, x) {
    var c = n[x];
    s.push([t.vertices[c * e], t.vertices[c * e + 1]]);
  });
  for (var o = 0; o < s.length; o += 3) {
    var a = s.slice(o, o + 3);
    a.push(s[o]), i.push(Nt([a]));
  }
  return i;
}
function tL(r) {
  for (var t = r[0][0].length, e = { vertices: [], holes: [], dimensions: t }, n = 0, i = 0; i < r.length; i++) {
    for (var s = 0; s < r[i].length; s++)
      for (var o = 0; o < t; o++) e.vertices.push(r[i][s][o]);
    i > 0 && (n += r[i - 1].length, e.holes.push(n));
  }
  return e;
}
function Eg(r, t) {
  if (!r)
    throw new Error("targetPoint is required");
  if (!t)
    throw new Error("points is required");
  var e, n = 1 / 0, i = 0;
  return he(t, function(s, o) {
    var a = Ie(r, s);
    a < n && (i = o, n = a);
  }), e = br(t.features[i]), e.properties.featureIndex = i, e.properties.distanceToPoint = n, e;
}
function W0(r) {
  if (!r)
    throw new Error("geojson is required");
  var t = [];
  return sr(r, function(e) {
    eL(e, t);
  }), ht(t);
}
function eL(r, t) {
  var e = [], n = r.geometry;
  if (n !== null) {
    switch (n.type) {
      case "Polygon":
        e = gt(n);
        break;
      case "LineString":
        e = [gt(n)];
    }
    e.forEach(function(i) {
      var s = nL(i, r.properties);
      s.forEach(function(o) {
        o.id = t.length, t.push(o);
      });
    });
  }
}
function nL(r, t) {
  var e = [];
  return r.reduce(function(n, i) {
    var s = ge([n, i], t);
    return s.bbox = rL(n, i), e.push(s), i;
  }), e;
}
function rL(r, t) {
  var e = r[0], n = r[1], i = t[0], s = t[1], o = e < i ? e : i, a = n < s ? n : s, u = e > i ? e : i, x = n > s ? n : s;
  return [o, a, u, x];
}
var s2 = { exports: {} }, Zw = { exports: {} };
(function(r, t) {
  (function(e, n) {
    r.exports = n();
  })(Cy, function() {
    function e(d, g, _, b, w) {
      (function E(S, I, L, M, N) {
        for (; M > L; ) {
          if (M - L > 600) {
            var P = M - L + 1, O = I - L + 1, k = Math.log(P), D = 0.5 * Math.exp(2 * k / 3), F = 0.5 * Math.sqrt(k * D * (P - D) / P) * (O - P / 2 < 0 ? -1 : 1), X = Math.max(L, Math.floor(I - O * D / P + F)), W = Math.min(M, Math.floor(I + (P - O) * D / P + F));
            E(S, I, X, W, N);
          }
          var U = S[I], q = L, V = M;
          for (n(S, L, I), N(S[M], U) > 0 && n(S, L, M); q < V; ) {
            for (n(S, q, V), q++, V--; N(S[q], U) < 0; ) q++;
            for (; N(S[V], U) > 0; ) V--;
          }
          N(S[L], U) === 0 ? n(S, L, V) : n(S, ++V, M), V <= I && (L = V + 1), I <= V && (M = V - 1);
        }
      })(d, g, _ || 0, b || d.length - 1, w || i);
    }
    function n(d, g, _) {
      var b = d[g];
      d[g] = d[_], d[_] = b;
    }
    function i(d, g) {
      return d < g ? -1 : d > g ? 1 : 0;
    }
    var s = function(d) {
      d === void 0 && (d = 9), this._maxEntries = Math.max(4, d), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
    };
    function o(d, g, _) {
      if (!_) return g.indexOf(d);
      for (var b = 0; b < g.length; b++) if (_(d, g[b])) return b;
      return -1;
    }
    function a(d, g) {
      u(d, 0, d.children.length, g, d);
    }
    function u(d, g, _, b, w) {
      w || (w = v(null)), w.minX = 1 / 0, w.minY = 1 / 0, w.maxX = -1 / 0, w.maxY = -1 / 0;
      for (var E = g; E < _; E++) {
        var S = d.children[E];
        x(w, d.leaf ? b(S) : S);
      }
      return w;
    }
    function x(d, g) {
      return d.minX = Math.min(d.minX, g.minX), d.minY = Math.min(d.minY, g.minY), d.maxX = Math.max(d.maxX, g.maxX), d.maxY = Math.max(d.maxY, g.maxY), d;
    }
    function c(d, g) {
      return d.minX - g.minX;
    }
    function f(d, g) {
      return d.minY - g.minY;
    }
    function l(d) {
      return (d.maxX - d.minX) * (d.maxY - d.minY);
    }
    function h(d) {
      return d.maxX - d.minX + (d.maxY - d.minY);
    }
    function p(d, g) {
      return d.minX <= g.minX && d.minY <= g.minY && g.maxX <= d.maxX && g.maxY <= d.maxY;
    }
    function y(d, g) {
      return g.minX <= d.maxX && g.minY <= d.maxY && g.maxX >= d.minX && g.maxY >= d.minY;
    }
    function v(d) {
      return { children: d, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
    }
    function m(d, g, _, b, w) {
      for (var E = [g, _]; E.length; ) if (!((_ = E.pop()) - (g = E.pop()) <= b)) {
        var S = g + Math.ceil((_ - g) / b / 2) * b;
        e(d, S, g, _, w), E.push(g, S, S, _);
      }
    }
    return s.prototype.all = function() {
      return this._all(this.data, []);
    }, s.prototype.search = function(d) {
      var g = this.data, _ = [];
      if (!y(d, g)) return _;
      for (var b = this.toBBox, w = []; g; ) {
        for (var E = 0; E < g.children.length; E++) {
          var S = g.children[E], I = g.leaf ? b(S) : S;
          y(d, I) && (g.leaf ? _.push(S) : p(d, I) ? this._all(S, _) : w.push(S));
        }
        g = w.pop();
      }
      return _;
    }, s.prototype.collides = function(d) {
      var g = this.data;
      if (!y(d, g)) return !1;
      for (var _ = []; g; ) {
        for (var b = 0; b < g.children.length; b++) {
          var w = g.children[b], E = g.leaf ? this.toBBox(w) : w;
          if (y(d, E)) {
            if (g.leaf || p(d, E)) return !0;
            _.push(w);
          }
        }
        g = _.pop();
      }
      return !1;
    }, s.prototype.load = function(d) {
      if (!d || !d.length) return this;
      if (d.length < this._minEntries) {
        for (var g = 0; g < d.length; g++) this.insert(d[g]);
        return this;
      }
      var _ = this._build(d.slice(), 0, d.length - 1, 0);
      if (this.data.children.length) if (this.data.height === _.height) this._splitRoot(this.data, _);
      else {
        if (this.data.height < _.height) {
          var b = this.data;
          this.data = _, _ = b;
        }
        this._insert(_, this.data.height - _.height - 1, !0);
      }
      else this.data = _;
      return this;
    }, s.prototype.insert = function(d) {
      return d && this._insert(d, this.data.height - 1), this;
    }, s.prototype.clear = function() {
      return this.data = v([]), this;
    }, s.prototype.remove = function(d, g) {
      if (!d) return this;
      for (var _, b, w, E = this.data, S = this.toBBox(d), I = [], L = []; E || I.length; ) {
        if (E || (E = I.pop(), b = I[I.length - 1], _ = L.pop(), w = !0), E.leaf) {
          var M = o(d, E.children, g);
          if (M !== -1) return E.children.splice(M, 1), I.push(E), this._condense(I), this;
        }
        w || E.leaf || !p(E, S) ? b ? (_++, E = b.children[_], w = !1) : E = null : (I.push(E), L.push(_), _ = 0, b = E, E = E.children[0]);
      }
      return this;
    }, s.prototype.toBBox = function(d) {
      return d;
    }, s.prototype.compareMinX = function(d, g) {
      return d.minX - g.minX;
    }, s.prototype.compareMinY = function(d, g) {
      return d.minY - g.minY;
    }, s.prototype.toJSON = function() {
      return this.data;
    }, s.prototype.fromJSON = function(d) {
      return this.data = d, this;
    }, s.prototype._all = function(d, g) {
      for (var _ = []; d; ) d.leaf ? g.push.apply(g, d.children) : _.push.apply(_, d.children), d = _.pop();
      return g;
    }, s.prototype._build = function(d, g, _, b) {
      var w, E = _ - g + 1, S = this._maxEntries;
      if (E <= S) return a(w = v(d.slice(g, _ + 1)), this.toBBox), w;
      b || (b = Math.ceil(Math.log(E) / Math.log(S)), S = Math.ceil(E / Math.pow(S, b - 1))), (w = v([])).leaf = !1, w.height = b;
      var I = Math.ceil(E / S), L = I * Math.ceil(Math.sqrt(S));
      m(d, g, _, L, this.compareMinX);
      for (var M = g; M <= _; M += L) {
        var N = Math.min(M + L - 1, _);
        m(d, M, N, I, this.compareMinY);
        for (var P = M; P <= N; P += I) {
          var O = Math.min(P + I - 1, N);
          w.children.push(this._build(d, P, O, b - 1));
        }
      }
      return a(w, this.toBBox), w;
    }, s.prototype._chooseSubtree = function(d, g, _, b) {
      for (; b.push(g), !g.leaf && b.length - 1 !== _; ) {
        for (var w = 1 / 0, E = 1 / 0, S = void 0, I = 0; I < g.children.length; I++) {
          var L = g.children[I], M = l(L), N = (P = d, O = L, (Math.max(O.maxX, P.maxX) - Math.min(O.minX, P.minX)) * (Math.max(O.maxY, P.maxY) - Math.min(O.minY, P.minY)) - M);
          N < E ? (E = N, w = M < w ? M : w, S = L) : N === E && M < w && (w = M, S = L);
        }
        g = S || g.children[0];
      }
      var P, O;
      return g;
    }, s.prototype._insert = function(d, g, _) {
      var b = _ ? d : this.toBBox(d), w = [], E = this._chooseSubtree(b, this.data, g, w);
      for (E.children.push(d), x(E, b); g >= 0 && w[g].children.length > this._maxEntries; ) this._split(w, g), g--;
      this._adjustParentBBoxes(b, w, g);
    }, s.prototype._split = function(d, g) {
      var _ = d[g], b = _.children.length, w = this._minEntries;
      this._chooseSplitAxis(_, w, b);
      var E = this._chooseSplitIndex(_, w, b), S = v(_.children.splice(E, _.children.length - E));
      S.height = _.height, S.leaf = _.leaf, a(_, this.toBBox), a(S, this.toBBox), g ? d[g - 1].children.push(S) : this._splitRoot(_, S);
    }, s.prototype._splitRoot = function(d, g) {
      this.data = v([d, g]), this.data.height = d.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
    }, s.prototype._chooseSplitIndex = function(d, g, _) {
      for (var b, w, E, S, I, L, M, N = 1 / 0, P = 1 / 0, O = g; O <= _ - g; O++) {
        var k = u(d, 0, O, this.toBBox), D = u(d, O, _, this.toBBox), F = (w = k, E = D, S = void 0, I = void 0, L = void 0, M = void 0, S = Math.max(w.minX, E.minX), I = Math.max(w.minY, E.minY), L = Math.min(w.maxX, E.maxX), M = Math.min(w.maxY, E.maxY), Math.max(0, L - S) * Math.max(0, M - I)), X = l(k) + l(D);
        F < N ? (N = F, b = O, P = X < P ? X : P) : F === N && X < P && (P = X, b = O);
      }
      return b || _ - g;
    }, s.prototype._chooseSplitAxis = function(d, g, _) {
      var b = d.leaf ? this.compareMinX : c, w = d.leaf ? this.compareMinY : f;
      this._allDistMargin(d, g, _, b) < this._allDistMargin(d, g, _, w) && d.children.sort(b);
    }, s.prototype._allDistMargin = function(d, g, _, b) {
      d.children.sort(b);
      for (var w = this.toBBox, E = u(d, 0, g, w), S = u(d, _ - g, _, w), I = h(E) + h(S), L = g; L < _ - g; L++) {
        var M = d.children[L];
        x(E, d.leaf ? w(M) : M), I += h(E);
      }
      for (var N = _ - g - 1; N >= g; N--) {
        var P = d.children[N];
        x(S, d.leaf ? w(P) : P), I += h(S);
      }
      return I;
    }, s.prototype._adjustParentBBoxes = function(d, g, _) {
      for (var b = _; b >= 0; b--) x(g[b], d);
    }, s.prototype._condense = function(d) {
      for (var g = d.length - 1, _ = void 0; g >= 0; g--) d[g].children.length === 0 ? g > 0 ? (_ = d[g - 1].children).splice(_.indexOf(d[g]), 1) : this.clear() : a(d[g], this.toBBox);
    }, s;
  });
})(Zw);
var iL = Zw.exports, o2 = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.earthRadius = 63710088e-1, r.factors = {
    centimeters: r.earthRadius * 100,
    centimetres: r.earthRadius * 100,
    degrees: r.earthRadius / 111325,
    feet: r.earthRadius * 3.28084,
    inches: r.earthRadius * 39.37,
    kilometers: r.earthRadius / 1e3,
    kilometres: r.earthRadius / 1e3,
    meters: r.earthRadius,
    metres: r.earthRadius,
    miles: r.earthRadius / 1609.344,
    millimeters: r.earthRadius * 1e3,
    millimetres: r.earthRadius * 1e3,
    nauticalmiles: r.earthRadius / 1852,
    radians: 1,
    yards: r.earthRadius * 1.0936
  }, r.unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1e3,
    kilometres: 1 / 1e3,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1e3,
    millimetres: 1e3,
    nauticalmiles: 1 / 1852,
    radians: 1 / r.earthRadius,
    yards: 1.0936133
  }, r.areaFactors = {
    acres: 247105e-9,
    centimeters: 1e4,
    centimetres: 1e4,
    feet: 10.763910417,
    hectares: 1e-4,
    inches: 1550.003100006,
    kilometers: 1e-6,
    kilometres: 1e-6,
    meters: 1,
    metres: 1,
    miles: 386e-9,
    millimeters: 1e6,
    millimetres: 1e6,
    yards: 1.195990046
  };
  function t(M, N, P) {
    P === void 0 && (P = {});
    var O = { type: "Feature" };
    return (P.id === 0 || P.id) && (O.id = P.id), P.bbox && (O.bbox = P.bbox), O.properties = N || {}, O.geometry = M, O;
  }
  r.feature = t;
  function e(M, N, P) {
    switch (M) {
      case "Point":
        return n(N).geometry;
      case "LineString":
        return a(N).geometry;
      case "Polygon":
        return s(N).geometry;
      case "MultiPoint":
        return f(N).geometry;
      case "MultiLineString":
        return c(N).geometry;
      case "MultiPolygon":
        return l(N).geometry;
      default:
        throw new Error(M + " is invalid");
    }
  }
  r.geometry = e;
  function n(M, N, P) {
    if (P === void 0 && (P = {}), !M)
      throw new Error("coordinates is required");
    if (!Array.isArray(M))
      throw new Error("coordinates must be an Array");
    if (M.length < 2)
      throw new Error("coordinates must be at least 2 numbers long");
    if (!E(M[0]) || !E(M[1]))
      throw new Error("coordinates must contain numbers");
    var O = {
      type: "Point",
      coordinates: M
    };
    return t(O, N, P);
  }
  r.point = n;
  function i(M, N, P) {
    return P === void 0 && (P = {}), x(M.map(function(O) {
      return n(O, N);
    }), P);
  }
  r.points = i;
  function s(M, N, P) {
    P === void 0 && (P = {});
    for (var O = 0, k = M; O < k.length; O++) {
      var D = k[O];
      if (D.length < 4)
        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      for (var F = 0; F < D[D.length - 1].length; F++)
        if (D[D.length - 1][F] !== D[0][F])
          throw new Error("First and last Position are not equivalent.");
    }
    var X = {
      type: "Polygon",
      coordinates: M
    };
    return t(X, N, P);
  }
  r.polygon = s;
  function o(M, N, P) {
    return P === void 0 && (P = {}), x(M.map(function(O) {
      return s(O, N);
    }), P);
  }
  r.polygons = o;
  function a(M, N, P) {
    if (P === void 0 && (P = {}), M.length < 2)
      throw new Error("coordinates must be an array of two or more positions");
    var O = {
      type: "LineString",
      coordinates: M
    };
    return t(O, N, P);
  }
  r.lineString = a;
  function u(M, N, P) {
    return P === void 0 && (P = {}), x(M.map(function(O) {
      return a(O, N);
    }), P);
  }
  r.lineStrings = u;
  function x(M, N) {
    N === void 0 && (N = {});
    var P = { type: "FeatureCollection" };
    return N.id && (P.id = N.id), N.bbox && (P.bbox = N.bbox), P.features = M, P;
  }
  r.featureCollection = x;
  function c(M, N, P) {
    P === void 0 && (P = {});
    var O = {
      type: "MultiLineString",
      coordinates: M
    };
    return t(O, N, P);
  }
  r.multiLineString = c;
  function f(M, N, P) {
    P === void 0 && (P = {});
    var O = {
      type: "MultiPoint",
      coordinates: M
    };
    return t(O, N, P);
  }
  r.multiPoint = f;
  function l(M, N, P) {
    P === void 0 && (P = {});
    var O = {
      type: "MultiPolygon",
      coordinates: M
    };
    return t(O, N, P);
  }
  r.multiPolygon = l;
  function h(M, N, P) {
    P === void 0 && (P = {});
    var O = {
      type: "GeometryCollection",
      geometries: M
    };
    return t(O, N, P);
  }
  r.geometryCollection = h;
  function p(M, N) {
    if (N === void 0 && (N = 0), N && !(N >= 0))
      throw new Error("precision must be a positive number");
    var P = Math.pow(10, N || 0);
    return Math.round(M * P) / P;
  }
  r.round = p;
  function y(M, N) {
    N === void 0 && (N = "kilometers");
    var P = r.factors[N];
    if (!P)
      throw new Error(N + " units is invalid");
    return M * P;
  }
  r.radiansToLength = y;
  function v(M, N) {
    N === void 0 && (N = "kilometers");
    var P = r.factors[N];
    if (!P)
      throw new Error(N + " units is invalid");
    return M / P;
  }
  r.lengthToRadians = v;
  function m(M, N) {
    return g(v(M, N));
  }
  r.lengthToDegrees = m;
  function d(M) {
    var N = M % 360;
    return N < 0 && (N += 360), N;
  }
  r.bearingToAzimuth = d;
  function g(M) {
    var N = M % (2 * Math.PI);
    return N * 180 / Math.PI;
  }
  r.radiansToDegrees = g;
  function _(M) {
    var N = M % 360;
    return N * Math.PI / 180;
  }
  r.degreesToRadians = _;
  function b(M, N, P) {
    if (N === void 0 && (N = "kilometers"), P === void 0 && (P = "kilometers"), !(M >= 0))
      throw new Error("length must be a positive number");
    return y(v(M, N), P);
  }
  r.convertLength = b;
  function w(M, N, P) {
    if (N === void 0 && (N = "meters"), P === void 0 && (P = "kilometers"), !(M >= 0))
      throw new Error("area must be a positive number");
    var O = r.areaFactors[N];
    if (!O)
      throw new Error("invalid original units");
    var k = r.areaFactors[P];
    if (!k)
      throw new Error("invalid final units");
    return M / O * k;
  }
  r.convertArea = w;
  function E(M) {
    return !isNaN(M) && M !== null && !Array.isArray(M);
  }
  r.isNumber = E;
  function S(M) {
    return !!M && M.constructor === Object;
  }
  r.isObject = S;
  function I(M) {
    if (!M)
      throw new Error("bbox is required");
    if (!Array.isArray(M))
      throw new Error("bbox must be an Array");
    if (M.length !== 4 && M.length !== 6)
      throw new Error("bbox must be an Array of 4 or 6 numbers");
    M.forEach(function(N) {
      if (!E(N))
        throw new Error("bbox must only contain numbers");
    });
  }
  r.validateBBox = I;
  function L(M) {
    if (!M)
      throw new Error("id is required");
    if (["string", "number"].indexOf(typeof M) === -1)
      throw new Error("id must be a number or a string");
  }
  r.validateId = L;
})(o2);
var xr = {};
Object.defineProperty(xr, "__esModule", { value: !0 });
var zr = o2;
function Yl(r, t, e) {
  if (r !== null)
    for (var n, i, s, o, a, u, x, c = 0, f = 0, l, h = r.type, p = h === "FeatureCollection", y = h === "Feature", v = p ? r.features.length : 1, m = 0; m < v; m++) {
      x = p ? r.features[m].geometry : y ? r.geometry : r, l = x ? x.type === "GeometryCollection" : !1, a = l ? x.geometries.length : 1;
      for (var d = 0; d < a; d++) {
        var g = 0, _ = 0;
        if (o = l ? x.geometries[d] : x, o !== null) {
          u = o.coordinates;
          var b = o.type;
          switch (c = e && (b === "Polygon" || b === "MultiPolygon") ? 1 : 0, b) {
            case null:
              break;
            case "Point":
              if (t(
                u,
                f,
                m,
                g,
                _
              ) === !1)
                return !1;
              f++, g++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < u.length; n++) {
                if (t(
                  u[n],
                  f,
                  m,
                  g,
                  _
                ) === !1)
                  return !1;
                f++, b === "MultiPoint" && g++;
              }
              b === "LineString" && g++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < u.length; n++) {
                for (i = 0; i < u[n].length - c; i++) {
                  if (t(
                    u[n][i],
                    f,
                    m,
                    g,
                    _
                  ) === !1)
                    return !1;
                  f++;
                }
                b === "MultiLineString" && g++, b === "Polygon" && _++;
              }
              b === "Polygon" && g++;
              break;
            case "MultiPolygon":
              for (n = 0; n < u.length; n++) {
                for (_ = 0, i = 0; i < u[n].length; i++) {
                  for (s = 0; s < u[n][i].length - c; s++) {
                    if (t(
                      u[n][i][s],
                      f,
                      m,
                      g,
                      _
                    ) === !1)
                      return !1;
                    f++;
                  }
                  _++;
                }
                g++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < o.geometries.length; n++)
                if (Yl(o.geometries[n], t, e) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function sL(r, t, e, n) {
  var i = e;
  return Yl(
    r,
    function(s, o, a, u, x) {
      o === 0 && e === void 0 ? i = s : i = t(
        i,
        s,
        o,
        a,
        u,
        x
      );
    },
    n
  ), i;
}
function Kw(r, t) {
  var e;
  switch (r.type) {
    case "FeatureCollection":
      for (e = 0; e < r.features.length && t(r.features[e].properties, e) !== !1; e++)
        ;
      break;
    case "Feature":
      t(r.properties, 0);
      break;
  }
}
function oL(r, t, e) {
  var n = e;
  return Kw(r, function(i, s) {
    s === 0 && e === void 0 ? n = i : n = t(n, i, s);
  }), n;
}
function jw(r, t) {
  if (r.type === "Feature")
    t(r, 0);
  else if (r.type === "FeatureCollection")
    for (var e = 0; e < r.features.length && t(r.features[e], e) !== !1; e++)
      ;
}
function aL(r, t, e) {
  var n = e;
  return jw(r, function(i, s) {
    s === 0 && e === void 0 ? n = i : n = t(n, i, s);
  }), n;
}
function uL(r) {
  var t = [];
  return Yl(r, function(e) {
    t.push(e);
  }), t;
}
function a2(r, t) {
  var e, n, i, s, o, a, u, x, c, f, l = 0, h = r.type === "FeatureCollection", p = r.type === "Feature", y = h ? r.features.length : 1;
  for (e = 0; e < y; e++) {
    for (a = h ? r.features[e].geometry : p ? r.geometry : r, x = h ? r.features[e].properties : p ? r.properties : {}, c = h ? r.features[e].bbox : p ? r.bbox : void 0, f = h ? r.features[e].id : p ? r.id : void 0, u = a ? a.type === "GeometryCollection" : !1, o = u ? a.geometries.length : 1, i = 0; i < o; i++) {
      if (s = u ? a.geometries[i] : a, s === null) {
        if (t(
          null,
          l,
          x,
          c,
          f
        ) === !1)
          return !1;
        continue;
      }
      switch (s.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (t(
            s,
            l,
            x,
            c,
            f
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < s.geometries.length; n++)
            if (t(
              s.geometries[n],
              l,
              x,
              c,
              f
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    l++;
  }
}
function xL(r, t, e) {
  var n = e;
  return a2(
    r,
    function(i, s, o, a, u) {
      s === 0 && e === void 0 ? n = i : n = t(
        n,
        i,
        s,
        o,
        a,
        u
      );
    }
  ), n;
}
function Ry(r, t) {
  a2(r, function(e, n, i, s, o) {
    var a = e === null ? null : e.type;
    switch (a) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return t(
          zr.feature(e, i, { bbox: s, id: o }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var u;
    switch (a) {
      case "MultiPoint":
        u = "Point";
        break;
      case "MultiLineString":
        u = "LineString";
        break;
      case "MultiPolygon":
        u = "Polygon";
        break;
    }
    for (var x = 0; x < e.coordinates.length; x++) {
      var c = e.coordinates[x], f = {
        type: u,
        coordinates: c
      };
      if (t(zr.feature(f, i), n, x) === !1)
        return !1;
    }
  });
}
function cL(r, t, e) {
  var n = e;
  return Ry(
    r,
    function(i, s, o) {
      s === 0 && o === 0 && e === void 0 ? n = i : n = t(
        n,
        i,
        s,
        o
      );
    }
  ), n;
}
function Qw(r, t) {
  Ry(r, function(e, n, i) {
    var s = 0;
    if (e.geometry) {
      var o = e.geometry.type;
      if (!(o === "Point" || o === "MultiPoint")) {
        var a, u = 0, x = 0, c = 0;
        if (Yl(
          e,
          function(f, l, h, p, y) {
            if (a === void 0 || n > u || p > x || y > c) {
              a = f, u = n, x = p, c = y, s = 0;
              return;
            }
            var v = zr.lineString(
              [a, f],
              e.properties
            );
            if (t(
              v,
              n,
              i,
              y,
              s
            ) === !1)
              return !1;
            s++, a = f;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
function fL(r, t, e) {
  var n = e, i = !1;
  return Qw(
    r,
    function(s, o, a, u, x) {
      i === !1 && e === void 0 ? n = s : n = t(
        n,
        s,
        o,
        a,
        u,
        x
      ), i = !0;
    }
  ), n;
}
function $w(r, t) {
  if (!r) throw new Error("geojson is required");
  Ry(r, function(e, n, i) {
    if (e.geometry !== null) {
      var s = e.geometry.type, o = e.geometry.coordinates;
      switch (s) {
        case "LineString":
          if (t(e, n, i, 0, 0) === !1)
            return !1;
          break;
        case "Polygon":
          for (var a = 0; a < o.length; a++)
            if (t(
              zr.lineString(o[a], e.properties),
              n,
              i,
              a
            ) === !1)
              return !1;
          break;
      }
    }
  });
}
function lL(r, t, e) {
  var n = e;
  return $w(
    r,
    function(i, s, o, a) {
      s === 0 && e === void 0 ? n = i : n = t(
        n,
        i,
        s,
        o,
        a
      );
    }
  ), n;
}
function hL(r, t) {
  if (t = t || {}, !zr.isObject(t)) throw new Error("options is invalid");
  var e = t.featureIndex || 0, n = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, s = t.segmentIndex || 0, o = t.properties, a;
  switch (r.type) {
    case "FeatureCollection":
      e < 0 && (e = r.features.length + e), o = o || r.features[e].properties, a = r.features[e].geometry;
      break;
    case "Feature":
      o = o || r.properties, a = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      a = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (a === null) return null;
  var u = a.coordinates;
  switch (a.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      return s < 0 && (s = u.length + s - 1), zr.lineString(
        [u[s], u[s + 1]],
        o,
        t
      );
    case "Polygon":
      return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), zr.lineString(
        [
          u[i][s],
          u[i][s + 1]
        ],
        o,
        t
      );
    case "MultiLineString":
      return n < 0 && (n = u.length + n), s < 0 && (s = u[n].length + s - 1), zr.lineString(
        [
          u[n][s],
          u[n][s + 1]
        ],
        o,
        t
      );
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), s < 0 && (s = u[n][i].length - s - 1), zr.lineString(
        [
          u[n][i][s],
          u[n][i][s + 1]
        ],
        o,
        t
      );
  }
  throw new Error("geojson is invalid");
}
function pL(r, t) {
  if (t = t || {}, !zr.isObject(t)) throw new Error("options is invalid");
  var e = t.featureIndex || 0, n = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, s = t.coordIndex || 0, o = t.properties, a;
  switch (r.type) {
    case "FeatureCollection":
      e < 0 && (e = r.features.length + e), o = o || r.features[e].properties, a = r.features[e].geometry;
      break;
    case "Feature":
      o = o || r.properties, a = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      a = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (a === null) return null;
  var u = a.coordinates;
  switch (a.type) {
    case "Point":
      return zr.point(u, o, t);
    case "MultiPoint":
      return n < 0 && (n = u.length + n), zr.point(u[n], o, t);
    case "LineString":
      return s < 0 && (s = u.length + s), zr.point(u[s], o, t);
    case "Polygon":
      return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s), zr.point(u[i][s], o, t);
    case "MultiLineString":
      return n < 0 && (n = u.length + n), s < 0 && (s = u[n].length + s), zr.point(u[n][s], o, t);
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), s < 0 && (s = u[n][i].length - s), zr.point(
        u[n][i][s],
        o,
        t
      );
  }
  throw new Error("geojson is invalid");
}
xr.coordAll = uL;
xr.coordEach = Yl;
xr.coordReduce = sL;
xr.featureEach = jw;
xr.featureReduce = aL;
xr.findPoint = pL;
xr.findSegment = hL;
xr.flattenEach = Ry;
xr.flattenReduce = cL;
xr.geomEach = a2;
xr.geomReduce = xL;
xr.lineEach = $w;
xr.lineReduce = lL;
xr.propEach = Kw;
xr.propReduce = oL;
xr.segmentEach = Qw;
xr.segmentReduce = fL;
var Ay = {}, cr = {}, Ce = {};
Object.defineProperty(Ce, "__esModule", { value: !0 });
var pi = 63710088e-1, u2 = {
  centimeters: pi * 100,
  centimetres: pi * 100,
  degrees: 360 / (2 * Math.PI),
  feet: pi * 3.28084,
  inches: pi * 39.37,
  kilometers: pi / 1e3,
  kilometres: pi / 1e3,
  meters: pi,
  metres: pi,
  miles: pi / 1609.344,
  millimeters: pi * 1e3,
  millimetres: pi * 1e3,
  nauticalmiles: pi / 1852,
  radians: 1,
  yards: pi * 1.0936
}, qm = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  nauticalmiles: 29155334959812285e-23,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function f0(r, t, e = {}) {
  const n = { type: "Feature" };
  return (e.id === 0 || e.id) && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.properties = t || {}, n.geometry = r, n;
}
function dL(r, t, e = {}) {
  switch (r) {
    case "Point":
      return x2(t).geometry;
    case "LineString":
      return f2(t).geometry;
    case "Polygon":
      return c2(t).geometry;
    case "MultiPoint":
      return eE(t).geometry;
    case "MultiLineString":
      return tE(t).geometry;
    case "MultiPolygon":
      return nE(t).geometry;
    default:
      throw new Error(r + " is invalid");
  }
}
function x2(r, t, e = {}) {
  if (!r)
    throw new Error("coordinates is required");
  if (!Array.isArray(r))
    throw new Error("coordinates must be an Array");
  if (r.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Sg(r[0]) || !Sg(r[1]))
    throw new Error("coordinates must contain numbers");
  return f0({
    type: "Point",
    coordinates: r
  }, t, e);
}
function gL(r, t, e = {}) {
  return Ty(
    r.map((n) => x2(n, t)),
    e
  );
}
function c2(r, t, e = {}) {
  for (const i of r) {
    if (i.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (i[i.length - 1].length !== i[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let s = 0; s < i[i.length - 1].length; s++)
      if (i[i.length - 1][s] !== i[0][s])
        throw new Error("First and last Position are not equivalent.");
  }
  return f0({
    type: "Polygon",
    coordinates: r
  }, t, e);
}
function yL(r, t, e = {}) {
  return Ty(
    r.map((n) => c2(n, t)),
    e
  );
}
function f2(r, t, e = {}) {
  if (r.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return f0({
    type: "LineString",
    coordinates: r
  }, t, e);
}
function vL(r, t, e = {}) {
  return Ty(
    r.map((n) => f2(n, t)),
    e
  );
}
function Ty(r, t = {}) {
  const e = { type: "FeatureCollection" };
  return t.id && (e.id = t.id), t.bbox && (e.bbox = t.bbox), e.features = r, e;
}
function tE(r, t, e = {}) {
  return f0({
    type: "MultiLineString",
    coordinates: r
  }, t, e);
}
function eE(r, t, e = {}) {
  return f0({
    type: "MultiPoint",
    coordinates: r
  }, t, e);
}
function nE(r, t, e = {}) {
  return f0({
    type: "MultiPolygon",
    coordinates: r
  }, t, e);
}
function mL(r, t, e = {}) {
  return f0({
    type: "GeometryCollection",
    geometries: r
  }, t, e);
}
function _L(r, t = 0) {
  if (t && !(t >= 0))
    throw new Error("precision must be a positive number");
  const e = Math.pow(10, t || 0);
  return Math.round(r * e) / e;
}
function rE(r, t = "kilometers") {
  const e = u2[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return r * e;
}
function l2(r, t = "kilometers") {
  const e = u2[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return r / e;
}
function bL(r, t) {
  return iE(l2(r, t));
}
function IL(r) {
  let t = r % 360;
  return t < 0 && (t += 360), t;
}
function wL(r) {
  return r = r % 360, r > 0 ? r > 180 ? r - 360 : r : r < -180 ? r + 360 : r;
}
function iE(r) {
  return r % (2 * Math.PI) * 180 / Math.PI;
}
function EL(r) {
  return r % 360 * Math.PI / 180;
}
function SL(r, t = "kilometers", e = "kilometers") {
  if (!(r >= 0))
    throw new Error("length must be a positive number");
  return rE(l2(r, t), e);
}
function CL(r, t = "meters", e = "kilometers") {
  if (!(r >= 0))
    throw new Error("area must be a positive number");
  const n = qm[t];
  if (!n)
    throw new Error("invalid original units");
  const i = qm[e];
  if (!i)
    throw new Error("invalid final units");
  return r / n * i;
}
function Sg(r) {
  return !isNaN(r) && r !== null && !Array.isArray(r);
}
function ML(r) {
  return r !== null && typeof r == "object" && !Array.isArray(r);
}
function PL(r) {
  if (!r)
    throw new Error("bbox is required");
  if (!Array.isArray(r))
    throw new Error("bbox must be an Array");
  if (r.length !== 4 && r.length !== 6)
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  r.forEach((t) => {
    if (!Sg(t))
      throw new Error("bbox must only contain numbers");
  });
}
function LL(r) {
  if (!r)
    throw new Error("id is required");
  if (["string", "number"].indexOf(typeof r) === -1)
    throw new Error("id must be a number or a string");
}
Ce.areaFactors = qm;
Ce.azimuthToBearing = wL;
Ce.bearingToAzimuth = IL;
Ce.convertArea = CL;
Ce.convertLength = SL;
Ce.degreesToRadians = EL;
Ce.earthRadius = pi;
Ce.factors = u2;
Ce.feature = f0;
Ce.featureCollection = Ty;
Ce.geometry = dL;
Ce.geometryCollection = mL;
Ce.isNumber = Sg;
Ce.isObject = ML;
Ce.lengthToDegrees = bL;
Ce.lengthToRadians = l2;
Ce.lineString = f2;
Ce.lineStrings = vL;
Ce.multiLineString = tE;
Ce.multiPoint = eE;
Ce.multiPolygon = nE;
Ce.point = x2;
Ce.points = gL;
Ce.polygon = c2;
Ce.polygons = yL;
Ce.radiansToDegrees = iE;
Ce.radiansToLength = rE;
Ce.round = _L;
Ce.validateBBox = PL;
Ce.validateId = LL;
Object.defineProperty(cr, "__esModule", { value: !0 });
var Ur = Ce;
function Xl(r, t, e) {
  if (r !== null)
    for (var n, i, s, o, a, u, x, c = 0, f = 0, l, h = r.type, p = h === "FeatureCollection", y = h === "Feature", v = p ? r.features.length : 1, m = 0; m < v; m++) {
      x = p ? r.features[m].geometry : y ? r.geometry : r, l = x ? x.type === "GeometryCollection" : !1, a = l ? x.geometries.length : 1;
      for (var d = 0; d < a; d++) {
        var g = 0, _ = 0;
        if (o = l ? x.geometries[d] : x, o !== null) {
          u = o.coordinates;
          var b = o.type;
          switch (c = e && (b === "Polygon" || b === "MultiPolygon") ? 1 : 0, b) {
            case null:
              break;
            case "Point":
              if (t(
                u,
                f,
                m,
                g,
                _
              ) === !1)
                return !1;
              f++, g++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < u.length; n++) {
                if (t(
                  u[n],
                  f,
                  m,
                  g,
                  _
                ) === !1)
                  return !1;
                f++, b === "MultiPoint" && g++;
              }
              b === "LineString" && g++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < u.length; n++) {
                for (i = 0; i < u[n].length - c; i++) {
                  if (t(
                    u[n][i],
                    f,
                    m,
                    g,
                    _
                  ) === !1)
                    return !1;
                  f++;
                }
                b === "MultiLineString" && g++, b === "Polygon" && _++;
              }
              b === "Polygon" && g++;
              break;
            case "MultiPolygon":
              for (n = 0; n < u.length; n++) {
                for (_ = 0, i = 0; i < u[n].length; i++) {
                  for (s = 0; s < u[n][i].length - c; s++) {
                    if (t(
                      u[n][i][s],
                      f,
                      m,
                      g,
                      _
                    ) === !1)
                      return !1;
                    f++;
                  }
                  _++;
                }
                g++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < o.geometries.length; n++)
                if (Xl(o.geometries[n], t, e) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function NL(r, t, e, n) {
  var i = e;
  return Xl(
    r,
    function(s, o, a, u, x) {
      o === 0 && e === void 0 ? i = s : i = t(
        i,
        s,
        o,
        a,
        u,
        x
      );
    },
    n
  ), i;
}
function sE(r, t) {
  var e;
  switch (r.type) {
    case "FeatureCollection":
      for (e = 0; e < r.features.length && t(r.features[e].properties, e) !== !1; e++)
        ;
      break;
    case "Feature":
      t(r.properties, 0);
      break;
  }
}
function OL(r, t, e) {
  var n = e;
  return sE(r, function(i, s) {
    s === 0 && e === void 0 ? n = i : n = t(n, i, s);
  }), n;
}
function oE(r, t) {
  if (r.type === "Feature")
    t(r, 0);
  else if (r.type === "FeatureCollection")
    for (var e = 0; e < r.features.length && t(r.features[e], e) !== !1; e++)
      ;
}
function RL(r, t, e) {
  var n = e;
  return oE(r, function(i, s) {
    s === 0 && e === void 0 ? n = i : n = t(n, i, s);
  }), n;
}
function AL(r) {
  var t = [];
  return Xl(r, function(e) {
    t.push(e);
  }), t;
}
function h2(r, t) {
  var e, n, i, s, o, a, u, x, c, f, l = 0, h = r.type === "FeatureCollection", p = r.type === "Feature", y = h ? r.features.length : 1;
  for (e = 0; e < y; e++) {
    for (a = h ? r.features[e].geometry : p ? r.geometry : r, x = h ? r.features[e].properties : p ? r.properties : {}, c = h ? r.features[e].bbox : p ? r.bbox : void 0, f = h ? r.features[e].id : p ? r.id : void 0, u = a ? a.type === "GeometryCollection" : !1, o = u ? a.geometries.length : 1, i = 0; i < o; i++) {
      if (s = u ? a.geometries[i] : a, s === null) {
        if (t(
          null,
          l,
          x,
          c,
          f
        ) === !1)
          return !1;
        continue;
      }
      switch (s.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (t(
            s,
            l,
            x,
            c,
            f
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < s.geometries.length; n++)
            if (t(
              s.geometries[n],
              l,
              x,
              c,
              f
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    l++;
  }
}
function TL(r, t, e) {
  var n = e;
  return h2(
    r,
    function(i, s, o, a, u) {
      s === 0 && e === void 0 ? n = i : n = t(
        n,
        i,
        s,
        o,
        a,
        u
      );
    }
  ), n;
}
function Dy(r, t) {
  h2(r, function(e, n, i, s, o) {
    var a = e === null ? null : e.type;
    switch (a) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return t(
          Ur.feature.call(void 0, e, i, { bbox: s, id: o }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var u;
    switch (a) {
      case "MultiPoint":
        u = "Point";
        break;
      case "MultiLineString":
        u = "LineString";
        break;
      case "MultiPolygon":
        u = "Polygon";
        break;
    }
    for (var x = 0; x < e.coordinates.length; x++) {
      var c = e.coordinates[x], f = {
        type: u,
        coordinates: c
      };
      if (t(Ur.feature.call(void 0, f, i), n, x) === !1)
        return !1;
    }
  });
}
function DL(r, t, e) {
  var n = e;
  return Dy(
    r,
    function(i, s, o) {
      s === 0 && o === 0 && e === void 0 ? n = i : n = t(
        n,
        i,
        s,
        o
      );
    }
  ), n;
}
function aE(r, t) {
  Dy(r, function(e, n, i) {
    var s = 0;
    if (e.geometry) {
      var o = e.geometry.type;
      if (!(o === "Point" || o === "MultiPoint")) {
        var a, u = 0, x = 0, c = 0;
        if (Xl(
          e,
          function(f, l, h, p, y) {
            if (a === void 0 || n > u || p > x || y > c) {
              a = f, u = n, x = p, c = y, s = 0;
              return;
            }
            var v = Ur.lineString.call(
              void 0,
              [a, f],
              e.properties
            );
            if (t(
              v,
              n,
              i,
              y,
              s
            ) === !1)
              return !1;
            s++, a = f;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
function FL(r, t, e) {
  var n = e, i = !1;
  return aE(
    r,
    function(s, o, a, u, x) {
      i === !1 && e === void 0 ? n = s : n = t(
        n,
        s,
        o,
        a,
        u,
        x
      ), i = !0;
    }
  ), n;
}
function uE(r, t) {
  if (!r)
    throw new Error("geojson is required");
  Dy(r, function(e, n, i) {
    if (e.geometry !== null) {
      var s = e.geometry.type, o = e.geometry.coordinates;
      switch (s) {
        case "LineString":
          if (t(e, n, i, 0, 0) === !1)
            return !1;
          break;
        case "Polygon":
          for (var a = 0; a < o.length; a++)
            if (t(
              Ur.lineString.call(void 0, o[a], e.properties),
              n,
              i,
              a
            ) === !1)
              return !1;
          break;
      }
    }
  });
}
function kL(r, t, e) {
  var n = e;
  return uE(
    r,
    function(i, s, o, a) {
      s === 0 && e === void 0 ? n = i : n = t(
        n,
        i,
        s,
        o,
        a
      );
    }
  ), n;
}
function BL(r, t) {
  if (t = t || {}, !Ur.isObject.call(void 0, t))
    throw new Error("options is invalid");
  var e = t.featureIndex || 0, n = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, s = t.segmentIndex || 0, o = t.properties, a;
  switch (r.type) {
    case "FeatureCollection":
      e < 0 && (e = r.features.length + e), o = o || r.features[e].properties, a = r.features[e].geometry;
      break;
    case "Feature":
      o = o || r.properties, a = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      a = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (a === null)
    return null;
  var u = a.coordinates;
  switch (a.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      return s < 0 && (s = u.length + s - 1), Ur.lineString.call(
        void 0,
        [u[s], u[s + 1]],
        o,
        t
      );
    case "Polygon":
      return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), Ur.lineString.call(
        void 0,
        [
          u[i][s],
          u[i][s + 1]
        ],
        o,
        t
      );
    case "MultiLineString":
      return n < 0 && (n = u.length + n), s < 0 && (s = u[n].length + s - 1), Ur.lineString.call(
        void 0,
        [
          u[n][s],
          u[n][s + 1]
        ],
        o,
        t
      );
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), s < 0 && (s = u[n][i].length - s - 1), Ur.lineString.call(
        void 0,
        [
          u[n][i][s],
          u[n][i][s + 1]
        ],
        o,
        t
      );
  }
  throw new Error("geojson is invalid");
}
function GL(r, t) {
  if (t = t || {}, !Ur.isObject.call(void 0, t))
    throw new Error("options is invalid");
  var e = t.featureIndex || 0, n = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, s = t.coordIndex || 0, o = t.properties, a;
  switch (r.type) {
    case "FeatureCollection":
      e < 0 && (e = r.features.length + e), o = o || r.features[e].properties, a = r.features[e].geometry;
      break;
    case "Feature":
      o = o || r.properties, a = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      a = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (a === null)
    return null;
  var u = a.coordinates;
  switch (a.type) {
    case "Point":
      return Ur.point.call(void 0, u, o, t);
    case "MultiPoint":
      return n < 0 && (n = u.length + n), Ur.point.call(void 0, u[n], o, t);
    case "LineString":
      return s < 0 && (s = u.length + s), Ur.point.call(void 0, u[s], o, t);
    case "Polygon":
      return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s), Ur.point.call(void 0, u[i][s], o, t);
    case "MultiLineString":
      return n < 0 && (n = u.length + n), s < 0 && (s = u[n].length + s), Ur.point.call(void 0, u[n][s], o, t);
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), s < 0 && (s = u[n][i].length - s), Ur.point.call(
        void 0,
        u[n][i][s],
        o,
        t
      );
  }
  throw new Error("geojson is invalid");
}
cr.coordAll = AL;
cr.coordEach = Xl;
cr.coordReduce = NL;
cr.featureEach = oE;
cr.featureReduce = RL;
cr.findPoint = GL;
cr.findSegment = BL;
cr.flattenEach = Dy;
cr.flattenReduce = DL;
cr.geomEach = h2;
cr.geomReduce = TL;
cr.lineEach = uE;
cr.lineReduce = kL;
cr.propEach = sE;
cr.propReduce = OL;
cr.segmentEach = aE;
cr.segmentReduce = FL;
Object.defineProperty(Ay, "__esModule", { value: !0 });
var YL = cr;
function xE(r, t = {}) {
  if (r.bbox != null && t.recompute !== !0)
    return r.bbox;
  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return YL.coordEach.call(void 0, r, (n) => {
    e[0] > n[0] && (e[0] = n[0]), e[1] > n[1] && (e[1] = n[1]), e[2] < n[0] && (e[2] = n[0]), e[3] < n[1] && (e[3] = n[1]);
  }), e;
}
var XL = xE;
Ay.bbox = xE;
Ay.default = XL;
var uo = iL, cE = o2, fE = xr, Su = Ay.default, qL = fE.featureEach;
fE.coordEach;
cE.polygon;
var T5 = cE.featureCollection;
function lE(r) {
  var t = new uo(r);
  return t.insert = function(e) {
    if (e.type !== "Feature") throw new Error("invalid feature");
    return e.bbox = e.bbox ? e.bbox : Su(e), uo.prototype.insert.call(this, e);
  }, t.load = function(e) {
    var n = [];
    return Array.isArray(e) ? e.forEach(function(i) {
      if (i.type !== "Feature") throw new Error("invalid features");
      i.bbox = i.bbox ? i.bbox : Su(i), n.push(i);
    }) : qL(e, function(i) {
      if (i.type !== "Feature") throw new Error("invalid features");
      i.bbox = i.bbox ? i.bbox : Su(i), n.push(i);
    }), uo.prototype.load.call(this, n);
  }, t.remove = function(e, n) {
    if (e.type !== "Feature") throw new Error("invalid feature");
    return e.bbox = e.bbox ? e.bbox : Su(e), uo.prototype.remove.call(this, e, n);
  }, t.clear = function() {
    return uo.prototype.clear.call(this);
  }, t.search = function(e) {
    var n = uo.prototype.search.call(this, this.toBBox(e));
    return T5(n);
  }, t.collides = function(e) {
    return uo.prototype.collides.call(this, this.toBBox(e));
  }, t.all = function() {
    var e = uo.prototype.all.call(this);
    return T5(e);
  }, t.toJSON = function() {
    return uo.prototype.toJSON.call(this);
  }, t.fromJSON = function(e) {
    return uo.prototype.fromJSON.call(this, e);
  }, t.toBBox = function(e) {
    var n;
    if (e.bbox) n = e.bbox;
    else if (Array.isArray(e) && e.length === 4) n = e;
    else if (Array.isArray(e) && e.length === 6) n = [e[0], e[1], e[3], e[4]];
    else if (e.type === "Feature") n = Su(e);
    else if (e.type === "FeatureCollection") n = Su(e);
    else throw new Error("invalid geojson");
    return {
      minX: n[0],
      minY: n[1],
      maxX: n[2],
      maxY: n[3]
    };
  }, t;
}
s2.exports = lE;
s2.exports.default = lE;
var zL = s2.exports;
const Fy = /* @__PURE__ */ Ao(zL);
function wa(r, t) {
  var e = {}, n = [];
  if (r.type === "LineString" && (r = Tn(r)), t.type === "LineString" && (t = Tn(t)), r.type === "Feature" && t.type === "Feature" && r.geometry !== null && t.geometry !== null && r.geometry.type === "LineString" && t.geometry.type === "LineString" && r.geometry.coordinates.length === 2 && t.geometry.coordinates.length === 2) {
    var i = D5(r, t);
    return i && n.push(i), ht(n);
  }
  var s = Fy();
  return s.load(W0(t)), he(W0(r), function(o) {
    he(s.search(o), function(a) {
      var u = D5(o, a);
      if (u) {
        var x = gt(u).join(",");
        e[x] || (e[x] = !0, n.push(u));
      }
    });
  }), ht(n);
}
function D5(r, t) {
  var e = gt(r), n = gt(t);
  if (e.length !== 2)
    throw new Error("<intersects> line1 must only contain 2 coordinates");
  if (n.length !== 2)
    throw new Error("<intersects> line2 must only contain 2 coordinates");
  var i = e[0][0], s = e[0][1], o = e[1][0], a = e[1][1], u = n[0][0], x = n[0][1], c = n[1][0], f = n[1][1], l = (f - x) * (o - i) - (c - u) * (a - s), h = (c - u) * (s - x) - (f - x) * (i - u), p = (o - i) * (s - x) - (a - s) * (i - u);
  if (l === 0)
    return null;
  var y = h / l, v = p / l;
  if (y >= 0 && y <= 1 && v >= 0 && v <= 1) {
    var m = i + y * (o - i), d = s + y * (a - s);
    return Pt([m, d]);
  }
  return null;
}
function Ko(r, t, e) {
  e === void 0 && (e = {});
  var n = Pt([1 / 0, 1 / 0], {
    dist: 1 / 0
  }), i = 0;
  return sr(r, function(s) {
    for (var o = gt(s), a = 0; a < o.length - 1; a++) {
      var u = Pt(o[a]);
      u.properties.dist = Ie(t, u, e);
      var x = Pt(o[a + 1]);
      x.properties.dist = Ie(t, x, e);
      var c = Ie(u, x, e), f = Math.max(u.properties.dist, x.properties.dist), l = fa(u, x), h = Eo(t, f, l + 90, e), p = Eo(t, f, l - 90, e), y = wa(ge([
        h.geometry.coordinates,
        p.geometry.coordinates
      ]), ge([u.geometry.coordinates, x.geometry.coordinates])), v = null;
      y.features.length > 0 && (v = y.features[0], v.properties.dist = Ie(t, v, e), v.properties.location = i + Ie(u, v, e)), u.properties.dist < n.properties.dist && (n = u, n.properties.index = a, n.properties.location = i), x.properties.dist < n.properties.dist && (n = x, n.properties.index = a + 1, n.properties.location = i + c), v && v.properties.dist < n.properties.dist && (n = v, n.properties.index = a), i += c;
    }
  }), n;
}
function ky(r, t, e) {
  e === void 0 && (e = {});
  var n = Ae(r), i = Ae(t);
  i[0] += i[0] - n[0] > 180 ? -360 : n[0] - i[0] > 180 ? 360 : 0;
  var s = UL(n, i), o = z0(s, "meters", e.units);
  return o;
}
function UL(r, t, e) {
  e = e === void 0 ? Xn : Number(e);
  var n = e, i = r[1] * Math.PI / 180, s = t[1] * Math.PI / 180, o = s - i, a = Math.abs(t[0] - r[0]) * Math.PI / 180;
  a > Math.PI && (a -= 2 * Math.PI);
  var u = Math.log(Math.tan(s / 2 + Math.PI / 4) / Math.tan(i / 2 + Math.PI / 4)), x = Math.abs(u) > 1e-11 ? o / u : Math.cos(i), c = Math.sqrt(o * o + x * x * a * a), f = c * n;
  return f;
}
function hE(r, t, e) {
  if (e === void 0 && (e = {}), e.method || (e.method = "geodesic"), e.units || (e.units = "kilometers"), !r)
    throw new Error("pt is required");
  if (Array.isArray(r) ? r = Pt(r) : r.type === "Point" ? r = Tn(r) : il(r, "Point", "point"), !t)
    throw new Error("line is required");
  Array.isArray(t) ? t = ge(t) : t.type === "LineString" ? t = Tn(t) : il(t, "LineString", "line");
  var n = 1 / 0, i = r.geometry.coordinates;
  return Zo(t, function(s) {
    var o = s.geometry.coordinates[0], a = s.geometry.coordinates[1], u = VL(i, o, a, e);
    u < n && (n = u);
  }), z0(n, "degrees", e.units);
}
function VL(r, t, e, n) {
  var i = [e[0] - t[0], e[1] - t[1]], s = [r[0] - t[0], r[1] - t[1]], o = F5(s, i);
  if (o <= 0)
    return Tv(r, t, { method: n.method, units: "degrees" });
  var a = F5(i, i);
  if (a <= o)
    return Tv(r, e, { method: n.method, units: "degrees" });
  var u = o / a, x = [t[0] + u * i[0], t[1] + u * i[1]];
  return Tv(r, x, { method: n.method, units: "degrees" });
}
function F5(r, t) {
  return r[0] * t[0] + r[1] * t[1];
}
function Tv(r, t, e) {
  return e.method === "planar" ? ky(r, t, e) : Ie(r, t, e);
}
function WL(r, t, e) {
  e === void 0 && (e = {});
  var n = e.units, i = e.properties || {}, s = HL(r);
  if (!s.features.length)
    throw new Error("points must contain features");
  if (!t)
    throw new Error("line is required");
  if (oi(t) !== "LineString")
    throw new Error("line must be a LineString");
  var o = 1 / 0, a = null;
  return he(s, function(u) {
    var x = hE(u, t, { units: n });
    x < o && (o = x, a = u);
  }), a && (a.properties = Z_({ dist: o }, a.properties, i)), a;
}
function HL(r) {
  var t = [], e = r.geometry ? r.geometry.type : r.type;
  switch (e) {
    case "GeometryCollection":
      return Pi(r, function(n) {
        n.type === "Point" && t.push({ type: "Feature", properties: {}, geometry: n });
      }), { type: "FeatureCollection", features: t };
    case "FeatureCollection":
      return r.features = r.features.filter(function(n) {
        return n.geometry.type === "Point";
      }), r;
    default:
      throw new Error("points must be a Point Collection");
  }
}
function JL(r, t) {
  var e = Ae(r), n = ke(t), i = n.coordinates, s = i[0];
  if (s.length < 4)
    throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
  var o = t.properties || {}, a = o.a, u = o.b, x = o.c, c = e[0], f = e[1], l = s[0][0], h = s[0][1], p = a !== void 0 ? a : s[0][2], y = s[1][0], v = s[1][1], m = u !== void 0 ? u : s[1][2], d = s[2][0], g = s[2][1], _ = x !== void 0 ? x : s[2][2], b = (_ * (c - l) * (f - v) + p * (c - y) * (f - g) + m * (c - d) * (f - h) - m * (c - l) * (f - g) - _ * (c - y) * (f - h) - p * (c - d) * (f - v)) / ((c - l) * (f - v) + (c - y) * (f - g) + (c - d) * (f - h) - (c - l) * (f - g) - (c - y) * (f - h) - (c - d) * (f - v));
  return b;
}
function ZL(r) {
  var t, e, n = {
    type: "FeatureCollection",
    features: []
  };
  if (r.type === "Feature" ? e = r.geometry : e = r, e.type === "LineString")
    t = [e.coordinates];
  else if (e.type === "MultiLineString")
    t = e.coordinates;
  else if (e.type === "MultiPolygon")
    t = [].concat.apply([], e.coordinates);
  else if (e.type === "Polygon")
    t = e.coordinates;
  else
    throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
  return t.forEach(function(i) {
    t.forEach(function(s) {
      for (var o = 0; o < i.length - 1; o++)
        for (var a = o; a < s.length - 1; a++)
          if (!(i === s && (Math.abs(o - a) === 1 || // segments are first and last segment of lineString
          o === 0 && a === i.length - 2 && // lineString is closed
          i[o][0] === i[i.length - 1][0] && i[o][1] === i[i.length - 1][1]))) {
            var u = KL(i[o][0], i[o][1], i[o + 1][0], i[o + 1][1], s[a][0], s[a][1], s[a + 1][0], s[a + 1][1]);
            u && n.features.push(Pt([u[0], u[1]]));
          }
    });
  }), n;
}
function KL(r, t, e, n, i, s, o, a) {
  var u, x, c, f, l, h = {
    x: null,
    y: null,
    onLine1: !1,
    onLine2: !1
  };
  return u = (a - s) * (e - r) - (o - i) * (n - t), u === 0 ? h.x !== null && h.y !== null ? h : !1 : (x = t - s, c = r - i, f = (o - i) * x - (a - s) * c, l = (e - r) * x - (n - t) * c, x = f / u, c = l / u, h.x = r + x * (e - r), h.y = t + x * (n - t), x >= 0 && x <= 1 && (h.onLine1 = !0), c >= 0 && c <= 1 && (h.onLine2 = !0), h.onLine1 && h.onLine2 ? [h.x, h.y] : !1);
}
function k5(r) {
  for (var t = jL(r), e = Py(t), n = !1, i = 0; !n && i < t.features.length; ) {
    var s = t.features[i].geometry, o, a, u, x, c, f, l, h = !1;
    if (s.type === "Point")
      e.geometry.coordinates[0] === s.coordinates[0] && e.geometry.coordinates[1] === s.coordinates[1] && (n = !0);
    else if (s.type === "MultiPoint") {
      var p = !1;
      for (l = 0; !p && l < s.coordinates.length; )
        e.geometry.coordinates[0] === s.coordinates[l][0] && e.geometry.coordinates[1] === s.coordinates[l][1] && (n = !0, p = !0), l++;
    } else if (s.type === "LineString")
      for (l = 0; !h && l < s.coordinates.length - 1; )
        o = e.geometry.coordinates[0], a = e.geometry.coordinates[1], u = s.coordinates[l][0], x = s.coordinates[l][1], c = s.coordinates[l + 1][0], f = s.coordinates[l + 1][1], B5(o, a, u, x, c, f) && (h = !0, n = !0), l++;
    else if (s.type === "MultiLineString")
      for (var y = 0; y < s.coordinates.length; ) {
        h = !1, l = 0;
        for (var v = s.coordinates[y]; !h && l < v.length - 1; )
          o = e.geometry.coordinates[0], a = e.geometry.coordinates[1], u = v[l][0], x = v[l][1], c = v[l + 1][0], f = v[l + 1][1], B5(o, a, u, x, c, f) && (h = !0, n = !0), l++;
        y++;
      }
    else (s.type === "Polygon" || s.type === "MultiPolygon") && Fe(e, s) && (n = !0);
    i++;
  }
  if (n)
    return e;
  var m = ht([]);
  for (i = 0; i < t.features.length; i++)
    m.features = m.features.concat(
      Ly(t.features[i]).features
    );
  return Pt(Eg(e, m).geometry.coordinates);
}
function jL(r) {
  return r.type !== "FeatureCollection" ? r.type !== "Feature" ? ht([Tn(r)]) : ht([r]) : r;
}
function B5(r, t, e, n, i, s) {
  var o = Math.sqrt((i - e) * (i - e) + (s - n) * (s - n)), a = Math.sqrt((r - e) * (r - e) + (t - n) * (t - n)), u = Math.sqrt((i - r) * (i - r) + (s - t) * (s - t));
  return o === a + u;
}
var G5 = 6378137;
function p2(r) {
  return U_(r, function(t, e) {
    return t + QL(e);
  }, 0);
}
function QL(r) {
  var t = 0, e;
  switch (r.type) {
    case "Polygon":
      return Y5(r.coordinates);
    case "MultiPolygon":
      for (e = 0; e < r.coordinates.length; e++)
        t += Y5(r.coordinates[e]);
      return t;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function Y5(r) {
  var t = 0;
  if (r && r.length > 0) {
    t += Math.abs(X5(r[0]));
    for (var e = 1; e < r.length; e++)
      t -= Math.abs(X5(r[e]));
  }
  return t;
}
function X5(r) {
  var t, e, n, i, s, o, a, u = 0, x = r.length;
  if (x > 2) {
    for (a = 0; a < x; a++)
      a === x - 2 ? (i = x - 2, s = x - 1, o = 0) : a === x - 1 ? (i = x - 1, s = 0, o = 1) : (i = a, s = a + 1, o = a + 2), t = r[i], e = r[s], n = r[o], u += (Dv(n[0]) - Dv(t[0])) * Math.sin(Dv(e[1]));
    u = u * G5 * G5 / 2;
  }
  return u;
}
function Dv(r) {
  return r * Math.PI / 180;
}
function $L(r, t, e) {
  e === void 0 && (e = {});
  for (var n = ke(r), i = n.coordinates, s = 0, o = 0; o < i.length && !(t >= s && o === i.length - 1); o++)
    if (s >= t) {
      var a = t - s;
      if (a) {
        var u = fa(i[o], i[o - 1]) - 180, x = Eo(i[o], a, u, e);
        return x;
      } else
        return Pt(i[o]);
    } else
      s += Ie(i[o], i[o + 1], e);
  return Pt(i[i.length - 1]);
}
function zm(r, t) {
  return t === void 0 && (t = {}), V_(r, function(e, n) {
    var i = n.geometry.coordinates;
    return e + Ie(i[0], i[1], t);
  }, 0);
}
function tN(r, t, e) {
  var n = gt(e);
  if (oi(e) !== "LineString")
    throw new Error("line must be a LineString");
  var i = Ko(e, r), s = Ko(e, t), o;
  i.properties.index <= s.properties.index ? o = [i, s] : o = [s, i];
  for (var a = [o[0].geometry.coordinates], u = o[0].properties.index + 1; u < o[1].properties.index + 1; u++)
    a.push(n[u]);
  return a.push(o[1].geometry.coordinates), ge(a, e.properties);
}
function pE(r, t, e, n) {
  if (n = n || {}, !we(n)) throw new Error("options is invalid");
  var i, s = [];
  if (r.type === "Feature") i = r.geometry.coordinates;
  else if (r.type === "LineString") i = r.coordinates;
  else throw new Error("input must be a LineString Feature or Geometry");
  for (var o = i.length, a = 0, u, x, c, f = 0; f < i.length && !(t >= a && f === i.length - 1); f++) {
    if (a > t && s.length === 0) {
      if (u = t - a, !u)
        return s.push(i[f]), ge(s);
      x = fa(i[f], i[f - 1]) - 180, c = Eo(i[f], u, x, n), s.push(c.geometry.coordinates);
    }
    if (a >= e)
      return u = e - a, u ? (x = fa(i[f], i[f - 1]) - 180, c = Eo(i[f], u, x, n), s.push(c.geometry.coordinates), ge(s)) : (s.push(i[f]), ge(s));
    if (a >= t && s.push(i[f]), f === i.length - 1)
      return ge(s);
    a += Ie(i[f], i[f + 1], n);
  }
  if (a < t && i.length === o)
    throw new Error("Start position is beyond line");
  var l = i[i.length - 1];
  return ge([l, l]);
}
function bi(r, t, e) {
  e === void 0 && (e = {});
  for (var n = Ae(r), i = gt(t), s = 0; s < i.length - 1; s++) {
    var o = !1;
    if (e.ignoreEndVertices && (s === 0 && (o = "start"), s === i.length - 2 && (o = "end"), s === 0 && s + 1 === i.length - 1 && (o = "both")), eN(i[s], i[s + 1], n, o, typeof e.epsilon > "u" ? null : e.epsilon))
      return !0;
  }
  return !1;
}
function eN(r, t, e, n, i) {
  var s = e[0], o = e[1], a = r[0], u = r[1], x = t[0], c = t[1], f = e[0] - a, l = e[1] - u, h = x - a, p = c - u, y = f * p - l * h;
  if (i !== null) {
    if (Math.abs(y) > i)
      return !1;
  } else if (y !== 0)
    return !1;
  if (n) {
    if (n === "start")
      return Math.abs(h) >= Math.abs(p) ? h > 0 ? a < s && s <= x : x <= s && s < a : p > 0 ? u < o && o <= c : c <= o && o < u;
    if (n === "end")
      return Math.abs(h) >= Math.abs(p) ? h > 0 ? a <= s && s < x : x < s && s <= a : p > 0 ? u <= o && o < c : c < o && o <= u;
    if (n === "both")
      return Math.abs(h) >= Math.abs(p) ? h > 0 ? a < s && s < x : x < s && s < a : p > 0 ? u < o && o < c : c < o && o < u;
  } else return Math.abs(h) >= Math.abs(p) ? h > 0 ? a <= s && s <= x : x <= s && s <= a : p > 0 ? u <= o && o <= c : c <= o && o <= u;
  return !1;
}
function dE(r, t) {
  var e = ke(r), n = ke(t), i = e.type, s = n.type;
  switch (i) {
    case "Point":
      switch (s) {
        case "MultiPoint":
          return nN(e, n);
        case "LineString":
          return bi(e, n, { ignoreEndVertices: !0 });
        case "Polygon":
        case "MultiPolygon":
          return Fe(e, n, { ignoreBoundary: !0 });
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    case "MultiPoint":
      switch (s) {
        case "MultiPoint":
          return rN(e, n);
        case "LineString":
          return iN(e, n);
        case "Polygon":
        case "MultiPolygon":
          return sN(e, n);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    case "LineString":
      switch (s) {
        case "LineString":
          return oN(e, n);
        case "Polygon":
        case "MultiPolygon":
          return aN(e, n);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    case "Polygon":
      switch (s) {
        case "Polygon":
        case "MultiPolygon":
          return uN(e, n);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + i + " geometry not supported");
  }
}
function nN(r, t) {
  var e, n = !1;
  for (e = 0; e < t.coordinates.length; e++)
    if (yE(t.coordinates[e], r.coordinates)) {
      n = !0;
      break;
    }
  return n;
}
function rN(r, t) {
  for (var e = 0; e < r.coordinates.length; e++) {
    for (var n = !1, i = 0; i < t.coordinates.length; i++)
      yE(r.coordinates[e], t.coordinates[i]) && (n = !0);
    if (!n)
      return !1;
  }
  return !0;
}
function iN(r, t) {
  for (var e = !1, n = 0; n < r.coordinates.length; n++) {
    if (!bi(r.coordinates[n], t))
      return !1;
    e || (e = bi(r.coordinates[n], t, { ignoreEndVertices: !0 }));
  }
  return e;
}
function sN(r, t) {
  for (var e = !0, n = !1, i = 0; i < r.coordinates.length; i++) {
    if (n = Fe(r.coordinates[1], t), !n) {
      e = !1;
      break;
    }
    n = Fe(r.coordinates[1], t, {
      ignoreBoundary: !0
    });
  }
  return e && n;
}
function oN(r, t) {
  for (var e = 0; e < r.coordinates.length; e++)
    if (!bi(r.coordinates[e], t))
      return !1;
  return !0;
}
function aN(r, t) {
  var e = Cn(t), n = Cn(r);
  if (!gE(e, n))
    return !1;
  for (var i = !1, s = 0; s < r.coordinates.length - 1; s++) {
    if (!Fe(r.coordinates[s], t))
      return !1;
    if (i || (i = Fe(r.coordinates[s], t, { ignoreBoundary: !0 })), !i) {
      var o = xN(r.coordinates[s], r.coordinates[s + 1]);
      i = Fe(o, t, {
        ignoreBoundary: !0
      });
    }
  }
  return i;
}
function uN(r, t) {
  var e = Cn(r), n = Cn(t);
  if (!gE(n, e))
    return !1;
  for (var i = 0; i < r.coordinates[0].length; i++)
    if (!Fe(r.coordinates[0][i], t))
      return !1;
  return !0;
}
function gE(r, t) {
  return !(r[0] > t[0] || r[2] < t[2] || r[1] > t[1] || r[3] < t[3]);
}
function yE(r, t) {
  return r[0] === t[0] && r[1] === t[1];
}
function xN(r, t) {
  return [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2];
}
function vE(r, t, e) {
  e === void 0 && (e = {}), e.mask && !e.units && (e.units = "kilometers");
  for (var n = [], i = r[0], s = r[1], o = r[2], a = r[3], u = t / Ie([i, s], [o, s], e), x = u * (o - i), c = t / Ie([i, s], [i, a], e), f = c * (a - s), l = o - i, h = a - s, p = Math.floor(l / x), y = Math.floor(h / f), v = (l - p * x) / 2, m = (h - y * f) / 2, d = i + v; d <= o; ) {
    for (var g = s + m; g <= a; ) {
      var _ = Pt([d, g], e.properties);
      e.mask ? dE(_, e.mask) && n.push(_) : n.push(_), g += f;
    }
    d += x;
  }
  return ht(n);
}
function mE(r, t) {
  t === void 0 && (t = {});
  var e = t.precision, n = t.coordinates, i = t.mutate;
  if (e = e == null || isNaN(e) ? 6 : e, n = n == null || isNaN(n) ? 3 : n, !r)
    throw new Error("<geojson> is required");
  if (typeof e != "number")
    throw new Error("<precision> must be a number");
  if (typeof n != "number")
    throw new Error("<coordinates> must be a number");
  (i === !1 || i === void 0) && (r = JSON.parse(JSON.stringify(r)));
  var s = Math.pow(10, e);
  return hn(r, function(o) {
    cN(o, s, n);
  }), r;
}
function cN(r, t, e) {
  r.length > e && r.splice(e, r.length);
  for (var n = 0; n < r.length; n++)
    r[n] = Math.round(r[n] * t) / t;
  return r;
}
function Um(r) {
  if (!r) throw new Error("geojson is required");
  var t = [];
  return sr(r, function(e) {
    t.push(e);
  }), ht(t);
}
function fN(r, t, e) {
  if (e = e || {}, !we(e)) throw new Error("options is invalid");
  var n = e.units, i = e.reverse;
  if (!r) throw new Error("geojson is required");
  if (t <= 0)
    throw new Error("segmentLength must be greater than 0");
  var s = [];
  return sr(r, function(o) {
    i && (o.geometry.coordinates = o.geometry.coordinates.reverse()), lN(o, t, n, function(a) {
      s.push(a);
    });
  }), ht(s);
}
function lN(r, t, e, n) {
  var i = zm(r, { units: e });
  if (i <= t) return n(r);
  var s = i / t;
  Number.isInteger(s) || (s = Math.floor(s) + 1);
  for (var o = 0; o < s; o++) {
    var a = pE(
      r,
      t * o,
      t * (o + 1),
      { units: e }
    );
    n(a, o);
  }
}
var d2 = { exports: {} };
d2.exports = xl;
d2.exports.default = xl;
var hN = qw;
function xl(r, t) {
  if (!(this instanceof xl)) return new xl(r, t);
  this._maxEntries = Math.max(4, r || 9), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), t && this._initFormat(t), this.clear();
}
xl.prototype = {
  all: function() {
    return this._all(this.data, []);
  },
  search: function(r) {
    var t = this.data, e = [], n = this.toBBox;
    if (!Eh(r, t)) return e;
    for (var i = [], s, o, a, u; t; ) {
      for (s = 0, o = t.children.length; s < o; s++)
        a = t.children[s], u = t.leaf ? n(a) : a, Eh(r, u) && (t.leaf ? e.push(a) : kv(r, u) ? this._all(a, e) : i.push(a));
      t = i.pop();
    }
    return e;
  },
  collides: function(r) {
    var t = this.data, e = this.toBBox;
    if (!Eh(r, t)) return !1;
    for (var n = [], i, s, o, a; t; ) {
      for (i = 0, s = t.children.length; i < s; i++)
        if (o = t.children[i], a = t.leaf ? e(o) : o, Eh(r, a)) {
          if (t.leaf || kv(r, a)) return !0;
          n.push(o);
        }
      t = n.pop();
    }
    return !1;
  },
  load: function(r) {
    if (!(r && r.length)) return this;
    if (r.length < this._minEntries) {
      for (var t = 0, e = r.length; t < e; t++)
        this.insert(r[t]);
      return this;
    }
    var n = this._build(r.slice(), 0, r.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        var i = this.data;
        this.data = n, n = i;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  },
  insert: function(r) {
    return r && this._insert(r, this.data.height - 1), this;
  },
  clear: function() {
    return this.data = Tu([]), this;
  },
  remove: function(r, t) {
    if (!r) return this;
    for (var e = this.data, n = this.toBBox(r), i = [], s = [], o, a, u, x; e || i.length; ) {
      if (e || (e = i.pop(), a = i[i.length - 1], o = s.pop(), x = !0), e.leaf && (u = pN(r, e.children, t), u !== -1))
        return e.children.splice(u, 1), i.push(e), this._condense(i), this;
      !x && !e.leaf && kv(e, n) ? (i.push(e), s.push(o), o = 0, a = e, e = e.children[0]) : a ? (o++, e = a.children[o], x = !1) : e = null;
    }
    return this;
  },
  toBBox: function(r) {
    return r;
  },
  compareMinX: q5,
  compareMinY: z5,
  toJSON: function() {
    return this.data;
  },
  fromJSON: function(r) {
    return this.data = r, this;
  },
  _all: function(r, t) {
    for (var e = []; r; )
      r.leaf ? t.push.apply(t, r.children) : e.push.apply(e, r.children), r = e.pop();
    return t;
  },
  _build: function(r, t, e, n) {
    var i = e - t + 1, s = this._maxEntries, o;
    if (i <= s)
      return o = Tu(r.slice(t, e + 1)), Cu(o, this.toBBox), o;
    n || (n = Math.ceil(Math.log(i) / Math.log(s)), s = Math.ceil(i / Math.pow(s, n - 1))), o = Tu([]), o.leaf = !1, o.height = n;
    var a = Math.ceil(i / s), u = a * Math.ceil(Math.sqrt(s)), x, c, f, l;
    for (U5(r, t, e, u, this.compareMinX), x = t; x <= e; x += u)
      for (f = Math.min(x + u - 1, e), U5(r, x, f, a, this.compareMinY), c = x; c <= f; c += a)
        l = Math.min(c + a - 1, f), o.children.push(this._build(r, c, l, n - 1));
    return Cu(o, this.toBBox), o;
  },
  _chooseSubtree: function(r, t, e, n) {
    for (var i, s, o, a, u, x, c, f; n.push(t), !(t.leaf || n.length - 1 === e); ) {
      for (c = f = 1 / 0, i = 0, s = t.children.length; i < s; i++)
        o = t.children[i], u = Fv(o), x = dN(r, o) - u, x < f ? (f = x, c = u < c ? u : c, a = o) : x === f && u < c && (c = u, a = o);
      t = a || t.children[0];
    }
    return t;
  },
  _insert: function(r, t, e) {
    var n = this.toBBox, i = e ? r : n(r), s = [], o = this._chooseSubtree(i, this.data, t, s);
    for (o.children.push(r), Tc(o, i); t >= 0 && s[t].children.length > this._maxEntries; )
      this._split(s, t), t--;
    this._adjustParentBBoxes(i, s, t);
  },
  // split overflowed node into two
  _split: function(r, t) {
    var e = r[t], n = e.children.length, i = this._minEntries;
    this._chooseSplitAxis(e, i, n);
    var s = this._chooseSplitIndex(e, i, n), o = Tu(e.children.splice(s, e.children.length - s));
    o.height = e.height, o.leaf = e.leaf, Cu(e, this.toBBox), Cu(o, this.toBBox), t ? r[t - 1].children.push(o) : this._splitRoot(e, o);
  },
  _splitRoot: function(r, t) {
    this.data = Tu([r, t]), this.data.height = r.height + 1, this.data.leaf = !1, Cu(this.data, this.toBBox);
  },
  _chooseSplitIndex: function(r, t, e) {
    var n, i, s, o, a, u, x, c;
    for (u = x = 1 / 0, n = t; n <= e - t; n++)
      i = Ac(r, 0, n, this.toBBox), s = Ac(r, n, e, this.toBBox), o = gN(i, s), a = Fv(i) + Fv(s), o < u ? (u = o, c = n, x = a < x ? a : x) : o === u && a < x && (x = a, c = n);
    return c;
  },
  // sorts node children by the best axis for split
  _chooseSplitAxis: function(r, t, e) {
    var n = r.leaf ? this.compareMinX : q5, i = r.leaf ? this.compareMinY : z5, s = this._allDistMargin(r, t, e, n), o = this._allDistMargin(r, t, e, i);
    s < o && r.children.sort(n);
  },
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin: function(r, t, e, n) {
    r.children.sort(n);
    var i = this.toBBox, s = Ac(r, 0, t, i), o = Ac(r, e - t, e, i), a = wh(s) + wh(o), u, x;
    for (u = t; u < e - t; u++)
      x = r.children[u], Tc(s, r.leaf ? i(x) : x), a += wh(s);
    for (u = e - t - 1; u >= t; u--)
      x = r.children[u], Tc(o, r.leaf ? i(x) : x), a += wh(o);
    return a;
  },
  _adjustParentBBoxes: function(r, t, e) {
    for (var n = e; n >= 0; n--)
      Tc(t[n], r);
  },
  _condense: function(r) {
    for (var t = r.length - 1, e; t >= 0; t--)
      r[t].children.length === 0 ? t > 0 ? (e = r[t - 1].children, e.splice(e.indexOf(r[t]), 1)) : this.clear() : Cu(r[t], this.toBBox);
  },
  _initFormat: function(r) {
    var t = ["return a", " - b", ";"];
    this.compareMinX = new Function("a", "b", t.join(r[0])), this.compareMinY = new Function("a", "b", t.join(r[1])), this.toBBox = new Function(
      "a",
      "return {minX: a" + r[0] + ", minY: a" + r[1] + ", maxX: a" + r[2] + ", maxY: a" + r[3] + "};"
    );
  }
};
function pN(r, t, e) {
  if (!e) return t.indexOf(r);
  for (var n = 0; n < t.length; n++)
    if (e(r, t[n])) return n;
  return -1;
}
function Cu(r, t) {
  Ac(r, 0, r.children.length, t, r);
}
function Ac(r, t, e, n, i) {
  i || (i = Tu(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (var s = t, o; s < e; s++)
    o = r.children[s], Tc(i, r.leaf ? n(o) : o);
  return i;
}
function Tc(r, t) {
  return r.minX = Math.min(r.minX, t.minX), r.minY = Math.min(r.minY, t.minY), r.maxX = Math.max(r.maxX, t.maxX), r.maxY = Math.max(r.maxY, t.maxY), r;
}
function q5(r, t) {
  return r.minX - t.minX;
}
function z5(r, t) {
  return r.minY - t.minY;
}
function Fv(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function wh(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function dN(r, t) {
  return (Math.max(t.maxX, r.maxX) - Math.min(t.minX, r.minX)) * (Math.max(t.maxY, r.maxY) - Math.min(t.minY, r.minY));
}
function gN(r, t) {
  var e = Math.max(r.minX, t.minX), n = Math.max(r.minY, t.minY), i = Math.min(r.maxX, t.maxX), s = Math.min(r.maxY, t.maxY);
  return Math.max(0, i - e) * Math.max(0, s - n);
}
function kv(r, t) {
  return r.minX <= t.minX && r.minY <= t.minY && t.maxX <= r.maxX && t.maxY <= r.maxY;
}
function Eh(r, t) {
  return t.minX <= r.maxX && t.minY <= r.maxY && t.maxX >= r.minX && t.maxY >= r.minY;
}
function Tu(r) {
  return {
    children: r,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function U5(r, t, e, n, i) {
  for (var s = [t, e], o; s.length; )
    e = s.pop(), t = s.pop(), !(e - t <= n) && (o = t + Math.ceil((e - t) / n / 2) * n, hN(r, o, t, e, i), s.push(t, o, o, e));
}
var yN = d2.exports;
const _E = /* @__PURE__ */ Ao(yN);
function vN(r, t, e) {
  if (r.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  e === void 0 && (e = 1);
  var n = r.geometry.coordinates, i = [], s = {};
  if (e) {
    for (var o = [], a = 0; a < n.length; a++)
      for (var u = 0; u < n[a].length - 1; u++)
        o.push(v(a, u));
    var x = _E();
    x.load(o);
  }
  for (var c = 0; c < n.length; c++)
    for (var f = 0; f < n[c].length - 1; f++)
      if (e) {
        var l = x.search(v(c, f));
        l.forEach(function(m) {
          var d = m.ring, g = m.edge;
          y(c, f, d, g);
        });
      } else
        for (var h = 0; h < n.length; h++)
          for (var p = 0; p < n[h].length - 1; p++)
            y(c, f, h, p);
  return t || (i = {
    type: "Feature",
    geometry: { type: "MultiPoint", coordinates: i }
  }), i;
  function y(m, d, g, _) {
    var b = n[m][d], w = n[m][d + 1], E = n[g][_], S = n[g][_ + 1], I = mN(b, w, E, S);
    if (I !== null) {
      var L, M;
      if (w[0] !== b[0] ? L = (I[0] - b[0]) / (w[0] - b[0]) : L = (I[1] - b[1]) / (w[1] - b[1]), S[0] !== E[0] ? M = (I[0] - E[0]) / (S[0] - E[0]) : M = (I[1] - E[1]) / (S[1] - E[1]), !(L >= 1 || L <= 0 || M >= 1 || M <= 0)) {
        var N = I, P = !s[N];
        P && (s[N] = !0), t ? i.push(
          t(
            I,
            m,
            d,
            b,
            w,
            L,
            g,
            _,
            E,
            S,
            M,
            P
          )
        ) : i.push(I);
      }
    }
  }
  function v(m, d) {
    var g = n[m][d], _ = n[m][d + 1], b, w, E, S;
    return g[0] < _[0] ? (b = g[0], w = _[0]) : (b = _[0], w = g[0]), g[1] < _[1] ? (E = g[1], S = _[1]) : (E = _[1], S = g[1]), {
      minX: b,
      minY: E,
      maxX: w,
      maxY: S,
      ring: m,
      edge: d
    };
  }
}
function mN(r, t, e, n) {
  if (Dc(r, e) || Dc(r, n) || Dc(t, e) || Dc(n, e))
    return null;
  var i = r[0], s = r[1], o = t[0], a = t[1], u = e[0], x = e[1], c = n[0], f = n[1], l = (i - o) * (x - f) - (s - a) * (u - c);
  if (l === 0) return null;
  var h = ((i * a - s * o) * (u - c) - (i - o) * (u * f - x * c)) / l, p = ((i * a - s * o) * (x - f) - (s - a) * (u * f - x * c)) / l;
  return [h, p];
}
function Dc(r, t) {
  if (!r || !t || r.length !== t.length) return !1;
  for (var e = 0, n = r.length; e < n; e++)
    if (r[e] instanceof Array && t[e] instanceof Array) {
      if (!Dc(r[e], t[e])) return !1;
    } else if (r[e] !== t[e])
      return !1;
  return !0;
}
function _N(r) {
  if (r.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (r.geometry === void 0 || r.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (r.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");
  for (var t = r.geometry.coordinates.length, e = [], d = 0; d < t; d++) {
    var n = r.geometry.coordinates[d];
    Fc(n[0], n[n.length - 1]) || n.push(n[0]), e.push.apply(e, n.slice(0, n.length - 1));
  }
  if (!IN(e))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var i = e.length, s = vN(
    r,
    function($, B, _t, pe, Bn, on, jn, Gn, Ti, Cr, Qr, $r) {
      return [
        $,
        B,
        _t,
        pe,
        Bn,
        on,
        jn,
        Gn,
        Ti,
        Cr,
        Qr,
        $r
      ];
    }
  ), o = s.length;
  if (o == 0) {
    for (var E = [], d = 0; d < t; d++)
      E.push(
        Nt([r.geometry.coordinates[d]], {
          parent: -1,
          winding: bN(r.geometry.coordinates[d])
        })
      );
    var W = ht(E);
    return U(), q(), W;
  }
  for (var a = [], u = [], d = 0; d < t; d++) {
    a.push([]);
    for (var x = 0; x < r.geometry.coordinates[d].length - 1; x++)
      a[d].push([
        new V5(
          r.geometry.coordinates[d][zu(x + 1, r.geometry.coordinates[d].length - 1)],
          1,
          [d, x],
          [d, zu(x + 1, r.geometry.coordinates[d].length - 1)],
          void 0
        )
      ]), u.push(
        new W5(
          r.geometry.coordinates[d][x],
          [d, zu(x - 1, r.geometry.coordinates[d].length - 1)],
          [d, x],
          void 0,
          void 0,
          !1,
          !0
        )
      );
  }
  for (var d = 0; d < o; d++)
    a[s[d][1]][s[d][2]].push(
      new V5(
        s[d][0],
        s[d][5],
        [s[d][1], s[d][2]],
        [s[d][6], s[d][7]],
        void 0
      )
    ), s[d][11] && u.push(
      new W5(
        s[d][0],
        [s[d][1], s[d][2]],
        [s[d][6], s[d][7]],
        void 0,
        void 0,
        !0,
        !0
      )
    );
  for (var c = u.length, d = 0; d < a.length; d++)
    for (var x = 0; x < a[d].length; x++)
      a[d][x].sort(function(B, _t) {
        return B.param < _t.param ? -1 : 1;
      });
  for (var f = [], d = 0; d < c; d++)
    f.push({
      minX: u[d].coord[0],
      minY: u[d].coord[1],
      maxX: u[d].coord[0],
      maxY: u[d].coord[1],
      index: d
    });
  var l = _E();
  l.load(f);
  for (var d = 0; d < a.length; d++)
    for (var x = 0; x < a[d].length; x++)
      for (var h = 0; h < a[d][x].length; h++) {
        var p;
        h == a[d][x].length - 1 ? p = a[d][zu(x + 1, r.geometry.coordinates[d].length - 1)][0].coord : p = a[d][x][h + 1].coord;
        var y = l.search({
          minX: p[0],
          minY: p[1],
          maxX: p[0],
          maxY: p[1]
        })[0];
        a[d][x][h].nxtIsectAlongEdgeIn = y.index;
      }
  for (var d = 0; d < a.length; d++)
    for (var x = 0; x < a[d].length; x++)
      for (var h = 0; h < a[d][x].length; h++) {
        var p = a[d][x][h].coord, y = l.search({
          minX: p[0],
          minY: p[1],
          maxX: p[0],
          maxY: p[1]
        })[0], v = y.index;
        v < i ? u[v].nxtIsectAlongRingAndEdge2 = a[d][x][h].nxtIsectAlongEdgeIn : Fc(
          u[v].ringAndEdge1,
          a[d][x][h].ringAndEdgeIn
        ) ? u[v].nxtIsectAlongRingAndEdge1 = a[d][x][h].nxtIsectAlongEdgeIn : u[v].nxtIsectAlongRingAndEdge2 = a[d][x][h].nxtIsectAlongEdgeIn;
      }
  for (var m = [], d = 0, x = 0; x < t; x++) {
    for (var g = d, h = 0; h < r.geometry.coordinates[x].length - 1; h++)
      u[d].coord[0] < u[g].coord[0] && (g = d), d++;
    for (var _ = u[g].nxtIsectAlongRingAndEdge2, h = 0; h < u.length; h++)
      if (u[h].nxtIsectAlongRingAndEdge1 == g || u[h].nxtIsectAlongRingAndEdge2 == g) {
        var b = h;
        break;
      }
    var w = Yh(
      [
        u[b].coord,
        u[g].coord,
        u[_].coord
      ],
      !0
    ) ? 1 : -1;
    m.push({ isect: g, parent: -1, winding: w });
  }
  m.sort(function(tt, $) {
    return u[tt.isect].coord > u[$.isect].coord ? -1 : 1;
  });
  for (var E = []; m.length > 0; ) {
    var S = m.pop(), I = S.isect, L = S.parent, M = S.winding, N = E.length, P = [u[I].coord], O = I;
    if (u[I].ringAndEdge1Walkable)
      var k = u[I].ringAndEdge1, D = u[I].nxtIsectAlongRingAndEdge1;
    else
      var k = u[I].ringAndEdge2, D = u[I].nxtIsectAlongRingAndEdge2;
    for (; !Fc(u[I].coord, u[D].coord); ) {
      P.push(u[D].coord);
      for (var F = void 0, d = 0; d < m.length; d++)
        if (m[d].isect == D) {
          F = d;
          break;
        }
      if (F != null && m.splice(F, 1), Fc(k, u[D].ringAndEdge1)) {
        if (k = u[D].ringAndEdge2, u[D].ringAndEdge2Walkable = !1, u[D].ringAndEdge1Walkable) {
          var X = { isect: D };
          Yh(
            [
              u[O].coord,
              u[D].coord,
              u[u[D].nxtIsectAlongRingAndEdge2].coord
            ],
            M == 1
          ) ? (X.parent = L, X.winding = -M) : (X.parent = N, X.winding = M), m.push(X);
        }
        O = D, D = u[D].nxtIsectAlongRingAndEdge2;
      } else {
        if (k = u[D].ringAndEdge1, u[D].ringAndEdge1Walkable = !1, u[D].ringAndEdge2Walkable) {
          var X = { isect: D };
          Yh(
            [
              u[O].coord,
              u[D].coord,
              u[u[D].nxtIsectAlongRingAndEdge1].coord
            ],
            M == 1
          ) ? (X.parent = L, X.winding = -M) : (X.parent = N, X.winding = M), m.push(X);
        }
        O = D, D = u[D].nxtIsectAlongRingAndEdge1;
      }
    }
    P.push(u[D].coord), E.push(
      Nt([P], {
        index: N,
        parent: L,
        winding: M,
        netWinding: void 0
      })
    );
  }
  var W = ht(E);
  U(), q();
  function U() {
    for (var tt = [], $ = 0; $ < W.features.length; $++)
      W.features[$].properties.parent == -1 && tt.push($);
    if (tt.length > 1)
      for (var $ = 0; $ < tt.length; $++) {
        for (var B = -1, _t = 1 / 0, pe = 0; pe < W.features.length; pe++)
          tt[$] != pe && Fe(
            W.features[tt[$]].geometry.coordinates[0][0],
            W.features[pe],
            { ignoreBoundary: !0 }
          ) && p2(W.features[pe]) < _t && (B = pe);
        W.features[tt[$]].properties.parent = B;
      }
  }
  function q() {
    for (var tt = 0; tt < W.features.length; tt++)
      if (W.features[tt].properties.parent == -1) {
        var $ = W.features[tt].properties.winding;
        W.features[tt].properties.netWinding = $, V(tt, $);
      }
  }
  function V(tt, $) {
    for (var B = 0; B < W.features.length; B++)
      if (W.features[B].properties.parent == tt) {
        var _t = $ + W.features[B].properties.winding;
        W.features[B].properties.netWinding = _t, V(B, _t);
      }
  }
  return W;
}
var V5 = function(r, t, e, n, i) {
  this.coord = r, this.param = t, this.ringAndEdgeIn = e, this.ringAndEdgeOut = n, this.nxtIsectAlongEdgeIn = i;
}, W5 = function(r, t, e, n, i, s, o) {
  this.coord = r, this.ringAndEdge1 = t, this.ringAndEdge2 = e, this.nxtIsectAlongRingAndEdge1 = n, this.nxtIsectAlongRingAndEdge2 = i, this.ringAndEdge1Walkable = s, this.ringAndEdge2Walkable = o;
};
function Yh(r, t) {
  if (typeof t > "u" && (t = !0), r.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var e = (r[1][0] - r[0][0]) * (r[2][1] - r[0][1]) - (r[1][1] - r[0][1]) * (r[2][0] - r[0][0]);
  return e >= 0 == t;
}
function bN(r) {
  for (var t = 0, e = 0; e < r.length - 1; e++)
    r[e][0] < r[t][0] && (t = e);
  if (Yh(
    [
      r[zu(t - 1, r.length - 1)],
      r[t],
      r[zu(t + 1, r.length - 1)]
    ],
    !0
  ))
    var n = 1;
  else
    var n = -1;
  return n;
}
function Fc(r, t) {
  if (!r || !t || r.length != t.length) return !1;
  for (var e = 0, n = r.length; e < n; e++)
    if (r[e] instanceof Array && t[e] instanceof Array) {
      if (!Fc(r[e], t[e])) return !1;
    } else if (r[e] != t[e])
      return !1;
  return !0;
}
function zu(r, t) {
  return (r % t + t) % t;
}
function IN(r) {
  for (var t = {}, e = 1, n = 0, i = r.length; n < i; ++n) {
    if (Object.prototype.hasOwnProperty.call(t, r[n])) {
      e = 0;
      break;
    }
    t[r[n]] = 1;
  }
  return e;
}
function wN(r) {
  var t = [];
  return sr(r, function(e) {
    e.geometry.type === "Polygon" && he(_N(e), function(n) {
      t.push(Nt(n.geometry.coordinates, e.properties));
    });
  }), ht(t);
}
var H5 = Math.PI / 180, J5 = 180 / Math.PI, cl = function(r, t) {
  this.lon = r, this.lat = t, this.x = H5 * r, this.y = H5 * t;
};
cl.prototype.view = function() {
  return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
};
cl.prototype.antipode = function() {
  var r = -1 * this.lat, t = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
  return new cl(t, r);
};
var bE = function() {
  this.coords = [], this.length = 0;
};
bE.prototype.move_to = function(r) {
  this.length++, this.coords.push(r);
};
var g2 = function(r) {
  this.properties = r || {}, this.geometries = [];
};
g2.prototype.json = function() {
  if (this.geometries.length <= 0)
    return {
      geometry: { type: "LineString", coordinates: null },
      type: "Feature",
      properties: this.properties
    };
  if (this.geometries.length === 1)
    return {
      geometry: { type: "LineString", coordinates: this.geometries[0].coords },
      type: "Feature",
      properties: this.properties
    };
  for (var r = [], t = 0; t < this.geometries.length; t++)
    r.push(this.geometries[t].coords);
  return {
    geometry: { type: "MultiLineString", coordinates: r },
    type: "Feature",
    properties: this.properties
  };
};
g2.prototype.wkt = function() {
  for (var r = "", t = "LINESTRING(", e = function(s) {
    t += s[0] + " " + s[1] + ",";
  }, n = 0; n < this.geometries.length; n++) {
    if (this.geometries[n].coords.length === 0)
      return "LINESTRING(empty)";
    var i = this.geometries[n].coords;
    i.forEach(e), r += t.substring(0, t.length - 1) + ")";
  }
  return r;
};
var y2 = function(r, t, e) {
  if (!r || r.x === void 0 || r.y === void 0)
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  if (!t || t.x === void 0 || t.y === void 0)
    throw new Error(
      "GreatCircle constructor expects two args: start and end objects with x and y properties"
    );
  this.start = new cl(r.x, r.y), this.end = new cl(t.x, t.y), this.properties = e || {};
  var n = this.start.x - this.end.x, i = this.start.y - this.end.y, s = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(n / 2), 2);
  if (this.g = 2 * Math.asin(Math.sqrt(s)), this.g === Math.PI)
    throw new Error(
      "it appears " + r.view() + " and " + t.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
    );
  if (isNaN(this.g))
    throw new Error(
      "could not calculate great circle between " + r + " and " + t
    );
};
y2.prototype.interpolate = function(r) {
  var t = Math.sin((1 - r) * this.g) / Math.sin(this.g), e = Math.sin(r * this.g) / Math.sin(this.g), n = t * Math.cos(this.start.y) * Math.cos(this.start.x) + e * Math.cos(this.end.y) * Math.cos(this.end.x), i = t * Math.cos(this.start.y) * Math.sin(this.start.x) + e * Math.cos(this.end.y) * Math.sin(this.end.x), s = t * Math.sin(this.start.y) + e * Math.sin(this.end.y), o = J5 * Math.atan2(s, Math.sqrt(Math.pow(n, 2) + Math.pow(i, 2))), a = J5 * Math.atan2(i, n);
  return [a, o];
};
y2.prototype.Arc = function(r, t) {
  var e = [];
  if (!r || r <= 2)
    e.push([this.start.lon, this.start.lat]), e.push([this.end.lon, this.end.lat]);
  else
    for (var n = 1 / (r - 1), i = 0; i < r; ++i) {
      var s = n * i, o = this.interpolate(s);
      e.push(o);
    }
  for (var a = !1, u = 0, x = t && t.offset ? t.offset : 10, c = 180 - x, f = -180 + x, l = 360 - x, h = 1; h < e.length; ++h) {
    var p = e[h - 1][0], y = e[h][0], v = Math.abs(y - p);
    v > l && (y > c && p < f || p > c && y < f) ? a = !0 : v > u && (u = v);
  }
  var m = [];
  if (a && u < x) {
    var d = [];
    m.push(d);
    for (var g = 0; g < e.length; ++g) {
      var _ = parseFloat(e[g][0]);
      if (g > 0 && Math.abs(_ - e[g - 1][0]) > l) {
        var b = parseFloat(e[g - 1][0]), w = parseFloat(e[g - 1][1]), E = parseFloat(e[g][0]), S = parseFloat(e[g][1]);
        if (b > -180 && b < f && E === 180 && g + 1 < e.length && e[g - 1][0] > -180 && e[g - 1][0] < f) {
          d.push([-180, e[g][1]]), g++, d.push([e[g][0], e[g][1]]);
          continue;
        } else if (b > c && b < 180 && E === -180 && g + 1 < e.length && e[g - 1][0] > c && e[g - 1][0] < 180) {
          d.push([180, e[g][1]]), g++, d.push([e[g][0], e[g][1]]);
          continue;
        }
        if (b < f && E > c) {
          var I = b;
          b = E, E = I;
          var L = w;
          w = S, S = L;
        }
        if (b > c && E < f && (E += 360), b <= 180 && E >= 180 && b < E) {
          var M = (180 - b) / (E - b), N = M * S + (1 - M) * w;
          d.push([
            e[g - 1][0] > c ? 180 : -180,
            N
          ]), d = [], d.push([
            e[g - 1][0] > c ? -180 : 180,
            N
          ]), m.push(d);
        } else
          d = [], m.push(d);
        d.push([_, e[g][1]]);
      } else
        d.push([e[g][0], e[g][1]]);
    }
  } else {
    var P = [];
    m.push(P);
    for (var O = 0; O < e.length; ++O)
      P.push([e[O][0], e[O][1]]);
  }
  for (var k = new g2(this.properties), D = 0; D < m.length; ++D) {
    var F = new bE();
    k.geometries.push(F);
    for (var X = m[D], W = 0; W < X.length; ++W)
      F.move_to(X[W]);
  }
  return k;
};
function EN(r, t, e) {
  if (e = e || {}, typeof e != "object") throw new Error("options is invalid");
  var n = e.properties, i = e.npoints, s = e.offset;
  r = Ae(r), t = Ae(t), n = n || {}, i = i || 100, s = s || 10;
  var o = new y2(
    { x: r[0], y: r[1] },
    { x: t[0], y: t[1] },
    n
  ), a = o.Arc(i, { offset: s });
  return a.json();
}
function SN(r, t) {
  if (!r) throw new Error("line is required");
  if (!t) throw new Error("splitter is required");
  var e = oi(r), n = oi(t);
  if (e !== "LineString") throw new Error("line must be LineString");
  if (n === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (n === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var i = mE(t, { precision: 7 });
  switch (n) {
    case "Point":
      return Vm(r, i);
    case "MultiPoint":
      return Z5(r, i);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return Z5(r, wa(r, i));
  }
}
function Z5(r, t) {
  var e = [], n = Fy();
  return sr(t, function(i) {
    if (e.forEach(function(a, u) {
      a.id = u;
    }), !e.length)
      e = Vm(r, i).features, e.forEach(function(a) {
        a.bbox || (a.bbox = Uw(Cn(a)));
      }), n.load(ht(e));
    else {
      var s = n.search(i);
      if (s.features.length) {
        var o = IE(i, s);
        e = e.filter(function(a) {
          return a.id !== o.id;
        }), n.remove(o), he(Vm(o, i), function(a) {
          e.push(a), n.insert(a);
        });
      }
    }
  }), ht(e);
}
function Vm(r, t) {
  var e = [], n = gt(r)[0], i = gt(r)[r.geometry.coordinates.length - 1];
  if (Bv(n, Ae(t)) || Bv(i, Ae(t)))
    return ht([r]);
  var s = Fy(), o = W0(r);
  s.load(o);
  var a = s.search(t);
  if (!a.features.length) return ht([r]);
  var u = IE(t, a), x = [n], c = z_(
    o,
    function(f, l, h) {
      var p = gt(l)[1], y = Ae(t);
      return h === u.id ? (f.push(y), e.push(ge(f)), Bv(y, p) ? [y] : [y, p]) : (f.push(p), f);
    },
    x
  );
  return c.length > 1 && e.push(ge(c)), ht(e);
}
function IE(r, t) {
  if (!t.features.length) throw new Error("lines must contain features");
  if (t.features.length === 1) return t.features[0];
  var e, n = 1 / 0;
  return he(t, function(i) {
    var s = Ko(i, r), o = s.properties.dist;
    o < n && (e = i, n = o);
  }), e;
}
function Bv(r, t) {
  return r[0] === t[0] && r[1] === t[1];
}
function wE(r, t, e, n, i) {
  i === void 0 && (i = {});
  var s = i.steps || 64, o = K5(e), a = K5(n), u = !Array.isArray(r) && r.type === "Feature" ? r.properties : {};
  if (o === a)
    return ge(r2(r, t, i).geometry.coordinates[0], u);
  for (var x = o, c = o < a ? a : a + 360, f = x, l = [], h = 0; f < c; )
    l.push(Eo(r, t, f, i).geometry.coordinates), h++, f = x + h * 360 / s;
  return f > c && l.push(Eo(r, t, c, i).geometry.coordinates), ge(l, u);
}
function K5(r) {
  var t = r % 360;
  return t < 0 && (t += 360), t;
}
function fl(r, t) {
  t === void 0 && (t = {});
  var e = ke(r);
  switch (!t.properties && r.type === "Feature" && (t.properties = r.properties), e.type) {
    case "Polygon":
      return EE(e, t);
    case "MultiPolygon":
      return CN(e, t);
    default:
      throw new Error("invalid poly");
  }
}
function EE(r, t) {
  t === void 0 && (t = {});
  var e = ke(r), n = e.coordinates, i = t.properties ? t.properties : r.type === "Feature" ? r.properties : {};
  return SE(n, i);
}
function CN(r, t) {
  t === void 0 && (t = {});
  var e = ke(r), n = e.coordinates, i = t.properties ? t.properties : r.type === "Feature" ? r.properties : {}, s = [];
  return n.forEach(function(o) {
    s.push(SE(o, i));
  }), ht(s);
}
function SE(r, t) {
  return r.length > 1 ? c0(r, t) : ge(r[0], t);
}
function j5(r, t) {
  t === void 0 && (t = {});
  var e, n, i, s = t.properties, o = (e = t.autoComplete) !== null && e !== void 0 ? e : !0, a = (n = t.orderCoords) !== null && n !== void 0 ? n : !0, u = (i = t.mutate) !== null && i !== void 0 ? i : !1;
  switch (u || (r = br(r)), r.type) {
    case "FeatureCollection":
      var x = [];
      return r.features.forEach(function(c) {
        x.push(gt(Q5(c, {}, o, a)));
      }), Mi(x, s);
    default:
      return Q5(r, s, o, a);
  }
}
function Q5(r, t, e, n) {
  t = t || (r.type === "Feature" ? r.properties : {});
  var i = ke(r), s = i.coordinates, o = i.type;
  if (!s.length)
    throw new Error("line must contain coordinates");
  switch (o) {
    case "LineString":
      return e && (s = $5(s)), Nt([s], t);
    case "MultiLineString":
      var a = [], u = 0;
      return s.forEach(function(x) {
        if (e && (x = $5(x)), n) {
          var c = MN(Cn(ge(x)));
          c > u ? (a.unshift(x), u = c) : a.push(x);
        } else
          a.push(x);
      }), Nt(a, t);
    default:
      throw new Error("geometry type " + o + " is not supported");
  }
}
function $5(r) {
  var t = r[0], e = t[0], n = t[1], i = r[r.length - 1], s = i[0], o = i[1];
  return (e !== s || n !== o) && r.push(t), r;
}
function MN(r) {
  var t = r[0], e = r[1], n = r[2], i = r[3];
  return Math.abs(t - n) * Math.abs(e - i);
}
function PN(r, t, e) {
  var n = r.length, i = Uu(r[0], t), s = [], o, a, u, x, c;
  for (e || (e = []), o = 1; o < n; o++) {
    for (x = r[o - 1], c = r[o], a = u = Uu(c, t); ; )
      if (i | a) {
        if (i & a)
          break;
        i ? (x = Wm(x, c, i, t), i = Uu(x, t)) : (c = Wm(x, c, a, t), a = Uu(c, t));
      } else {
        s.push(x), a !== u ? (s.push(c), o < n - 1 && (e.push(s), s = [])) : o === n - 1 && s.push(c);
        break;
      }
    i = u;
  }
  return s.length && e.push(s), e;
}
function LN(r, t) {
  var e, n, i, s, o, a, u;
  for (n = 1; n <= 8; n *= 2) {
    for (e = [], i = r[r.length - 1], s = !(Uu(i, t) & n), o = 0; o < r.length; o++)
      a = r[o], u = !(Uu(a, t) & n), u !== s && e.push(Wm(i, a, n, t)), u && e.push(a), i = a, s = u;
    if (r = e, !r.length)
      break;
  }
  return e;
}
function Wm(r, t, e, n) {
  return e & 8 ? [r[0] + (t[0] - r[0]) * (n[3] - r[1]) / (t[1] - r[1]), n[3]] : e & 4 ? [r[0] + (t[0] - r[0]) * (n[1] - r[1]) / (t[1] - r[1]), n[1]] : e & 2 ? [n[2], r[1] + (t[1] - r[1]) * (n[2] - r[0]) / (t[0] - r[0])] : e & 1 ? [n[0], r[1] + (t[1] - r[1]) * (n[0] - r[0]) / (t[0] - r[0])] : null;
}
function Uu(r, t) {
  var e = 0;
  return r[0] < t[0] ? e |= 1 : r[0] > t[2] && (e |= 2), r[1] < t[1] ? e |= 4 : r[1] > t[3] && (e |= 8), e;
}
function NN(r, t) {
  var e = ke(r), n = e.type, i = r.type === "Feature" ? r.properties : {}, s = e.coordinates;
  switch (n) {
    case "LineString":
    case "MultiLineString": {
      var o = [];
      return n === "LineString" && (s = [s]), s.forEach(function(a) {
        PN(a, t, o);
      }), o.length === 1 ? ge(o[0], i) : c0(o, i);
    }
    case "Polygon":
      return Nt(tI(s, t), i);
    case "MultiPolygon":
      return Mi(s.map(function(a) {
        return tI(a, t);
      }), i);
    default:
      throw new Error("geometry " + n + " not supported");
  }
}
function tI(r, t) {
  for (var e = [], n = 0, i = r; n < i.length; n++) {
    var s = i[n], o = LN(s, t);
    o.length > 0 && ((o[0][0] !== o[o.length - 1][0] || o[0][1] !== o[o.length - 1][1]) && o.push(o[0]), o.length >= 4 && e.push(o));
  }
  return e;
}
var eI = Object.prototype.toString, CE = function(t) {
  var e = eI.call(t), n = e === "[object Arguments]";
  return n || (n = e !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && eI.call(t.callee) === "[object Function]"), n;
}, Gv, nI;
function ON() {
  if (nI) return Gv;
  nI = 1;
  var r;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, e = Object.prototype.toString, n = CE, i = Object.prototype.propertyIsEnumerable, s = !i.call({ toString: null }, "toString"), o = i.call(function() {
    }, "prototype"), a = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], u = function(l) {
      var h = l.constructor;
      return h && h.prototype === l;
    }, x = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, c = function() {
      if (typeof window > "u")
        return !1;
      for (var l in window)
        try {
          if (!x["$" + l] && t.call(window, l) && window[l] !== null && typeof window[l] == "object")
            try {
              u(window[l]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), f = function(l) {
      if (typeof window > "u" || !c)
        return u(l);
      try {
        return u(l);
      } catch {
        return !1;
      }
    };
    r = function(h) {
      var p = h !== null && typeof h == "object", y = e.call(h) === "[object Function]", v = n(h), m = p && e.call(h) === "[object String]", d = [];
      if (!p && !y && !v)
        throw new TypeError("Object.keys called on a non-object");
      var g = o && y;
      if (m && h.length > 0 && !t.call(h, 0))
        for (var _ = 0; _ < h.length; ++_)
          d.push(String(_));
      if (v && h.length > 0)
        for (var b = 0; b < h.length; ++b)
          d.push(String(b));
      else
        for (var w in h)
          !(g && w === "prototype") && t.call(h, w) && d.push(String(w));
      if (s)
        for (var E = f(h), S = 0; S < a.length; ++S)
          !(E && a[S] === "constructor") && t.call(h, a[S]) && d.push(a[S]);
      return d;
    };
  }
  return Gv = r, Gv;
}
var RN = Array.prototype.slice, AN = CE, rI = Object.keys, Xh = rI ? function(t) {
  return rI(t);
} : ON(), iI = Object.keys;
Xh.shim = function() {
  if (Object.keys) {
    var t = function() {
      var e = Object.keys(arguments);
      return e && e.length === arguments.length;
    }(1, 2);
    t || (Object.keys = function(n) {
      return AN(n) ? iI(RN.call(n)) : iI(n);
    });
  } else
    Object.keys = Xh;
  return Object.keys || Xh;
};
var ME = Xh, PE = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, e = Symbol("test"), n = Object(e);
  if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
    return !1;
  var i = 42;
  t[e] = i;
  for (var s in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var o = Object.getOwnPropertySymbols(t);
  if (o.length !== 1 || o[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var a = (
      /** @type {PropertyDescriptor} */
      Object.getOwnPropertyDescriptor(t, e)
    );
    if (a.value !== i || a.enumerable !== !0)
      return !1;
  }
  return !0;
}, TN = PE, v2 = function() {
  return TN() && !!Symbol.toStringTag;
}, DN = Error, FN = EvalError, kN = RangeError, BN = ReferenceError, LE = SyntaxError, ic = TypeError, GN = URIError, YN = Object.getOwnPropertyDescriptor, qh = YN;
if (qh)
  try {
    qh([], "length");
  } catch {
    qh = null;
  }
var ql = qh, zh = Object.defineProperty || !1;
if (zh)
  try {
    zh({}, "a", { value: 1 });
  } catch {
    zh = !1;
  }
var By = zh, Yv, sI;
function XN() {
  if (sI) return Yv;
  sI = 1;
  var r = typeof Symbol < "u" && Symbol, t = PE;
  return Yv = function() {
    return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Yv;
}
var qN = "Function.prototype.bind called on incompatible ", zN = Object.prototype.toString, UN = Math.max, VN = "[object Function]", oI = function(t, e) {
  for (var n = [], i = 0; i < t.length; i += 1)
    n[i] = t[i];
  for (var s = 0; s < e.length; s += 1)
    n[s + t.length] = e[s];
  return n;
}, WN = function(t, e) {
  for (var n = [], i = e, s = 0; i < t.length; i += 1, s += 1)
    n[s] = t[i];
  return n;
}, HN = function(r, t) {
  for (var e = "", n = 0; n < r.length; n += 1)
    e += r[n], n + 1 < r.length && (e += t);
  return e;
}, JN = function(t) {
  var e = this;
  if (typeof e != "function" || zN.apply(e) !== VN)
    throw new TypeError(qN + e);
  for (var n = WN(arguments, 1), i, s = function() {
    if (this instanceof i) {
      var c = e.apply(
        this,
        oI(n, arguments)
      );
      return Object(c) === c ? c : this;
    }
    return e.apply(
      t,
      oI(n, arguments)
    );
  }, o = UN(0, e.length - n.length), a = [], u = 0; u < o; u++)
    a[u] = "$" + u;
  if (i = Function("binder", "return function (" + HN(a, ",") + "){ return binder.apply(this,arguments); }")(s), e.prototype) {
    var x = function() {
    };
    x.prototype = e.prototype, i.prototype = new x(), x.prototype = null;
  }
  return i;
}, ZN = JN, zl = Function.prototype.bind || ZN, m2 = Function.prototype.call, _2 = Function.prototype.apply, KN = typeof Reflect < "u" && Reflect && Reflect.apply, jN = zl, QN = _2, $N = m2, tO = KN, NE = tO || jN.call($N, QN), eO = zl, nO = ic, rO = m2, iO = NE, OE = function(t) {
  if (t.length < 1 || typeof t[0] != "function")
    throw new nO("a function is required");
  return iO(eO, rO, t);
}, Xv, aI;
function sO() {
  if (aI) return Xv;
  aI = 1;
  var r = OE, t = ql, e = (
    /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype
  ), n = e && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, s = i.getPrototypeOf;
  return Xv = n && typeof n.get == "function" ? r([n.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(a) {
      return s(a == null ? a : i(a));
    }
  ) : !1, Xv;
}
var oO = Function.prototype.call, aO = Object.prototype.hasOwnProperty, uO = zl, RE = uO.call(oO, aO), le, xO = DN, cO = FN, fO = kN, lO = BN, Nx = LE, Qu = ic, hO = GN, AE = Function, qv = function(r) {
  try {
    return AE('"use strict"; return (' + r + ").constructor;")();
  } catch {
  }
}, ll = ql, pO = By, zv = function() {
  throw new Qu();
}, dO = ll ? function() {
  try {
    return arguments.callee, zv;
  } catch {
    try {
      return ll(arguments, "callee").get;
    } catch {
      return zv;
    }
  }
}() : zv, Mu = XN()(), gO = sO(), lr = typeof Reflect == "function" && Reflect.getPrototypeOf || Object.getPrototypeOf || gO, TE = _2, Ul = m2, Du = {}, yO = typeof Uint8Array > "u" || !lr ? le : lr(Uint8Array), L0 = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? le : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? le : ArrayBuffer,
  "%ArrayIteratorPrototype%": Mu && lr ? lr([][Symbol.iterator]()) : le,
  "%AsyncFromSyncIteratorPrototype%": le,
  "%AsyncFunction%": Du,
  "%AsyncGenerator%": Du,
  "%AsyncGeneratorFunction%": Du,
  "%AsyncIteratorPrototype%": Du,
  "%Atomics%": typeof Atomics > "u" ? le : Atomics,
  "%BigInt%": typeof BigInt > "u" ? le : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? le : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? le : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? le : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": xO,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": cO,
  "%Float32Array%": typeof Float32Array > "u" ? le : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? le : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? le : FinalizationRegistry,
  "%Function%": AE,
  "%GeneratorFunction%": Du,
  "%Int8Array%": typeof Int8Array > "u" ? le : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? le : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? le : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Mu && lr ? lr(lr([][Symbol.iterator]())) : le,
  "%JSON%": typeof JSON == "object" ? JSON : le,
  "%Map%": typeof Map > "u" ? le : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Mu || !lr ? le : lr((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%Object.getOwnPropertyDescriptor%": ll,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? le : Promise,
  "%Proxy%": typeof Proxy > "u" ? le : Proxy,
  "%RangeError%": fO,
  "%ReferenceError%": lO,
  "%Reflect%": typeof Reflect > "u" ? le : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? le : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Mu || !lr ? le : lr((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? le : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Mu && lr ? lr(""[Symbol.iterator]()) : le,
  "%Symbol%": Mu ? Symbol : le,
  "%SyntaxError%": Nx,
  "%ThrowTypeError%": dO,
  "%TypedArray%": yO,
  "%TypeError%": Qu,
  "%Uint8Array%": typeof Uint8Array > "u" ? le : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? le : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? le : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? le : Uint32Array,
  "%URIError%": hO,
  "%WeakMap%": typeof WeakMap > "u" ? le : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? le : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? le : WeakSet,
  "%Function.prototype.call%": Ul,
  "%Function.prototype.apply%": TE,
  "%Object.defineProperty%": pO
};
if (lr)
  try {
    null.error;
  } catch (r) {
    var vO = lr(lr(r));
    L0["%Error.prototype%"] = vO;
  }
var mO = function r(t) {
  var e;
  if (t === "%AsyncFunction%")
    e = qv("async function () {}");
  else if (t === "%GeneratorFunction%")
    e = qv("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    e = qv("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var n = r("%AsyncGeneratorFunction%");
    n && (e = n.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = r("%AsyncGenerator%");
    i && lr && (e = lr(i.prototype));
  }
  return L0[t] = e, e;
}, uI = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Vl = zl, Cg = RE, _O = Vl.call(Ul, Array.prototype.concat), bO = Vl.call(TE, Array.prototype.splice), xI = Vl.call(Ul, String.prototype.replace), Mg = Vl.call(Ul, String.prototype.slice), IO = Vl.call(Ul, RegExp.prototype.exec), wO = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, EO = /\\(\\)?/g, SO = function(t) {
  var e = Mg(t, 0, 1), n = Mg(t, -1);
  if (e === "%" && n !== "%")
    throw new Nx("invalid intrinsic syntax, expected closing `%`");
  if (n === "%" && e !== "%")
    throw new Nx("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return xI(t, wO, function(s, o, a, u) {
    i[i.length] = a ? xI(u, EO, "$1") : o || s;
  }), i;
}, CO = function(t, e) {
  var n = t, i;
  if (Cg(uI, n) && (i = uI[n], n = "%" + i[0] + "%"), Cg(L0, n)) {
    var s = L0[n];
    if (s === Du && (s = mO(n)), typeof s > "u" && !e)
      throw new Qu("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: n,
      value: s
    };
  }
  throw new Nx("intrinsic " + t + " does not exist!");
}, DE = function(t, e) {
  if (typeof t != "string" || t.length === 0)
    throw new Qu("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof e != "boolean")
    throw new Qu('"allowMissing" argument must be a boolean');
  if (IO(/^%?[^%]*%?$/, t) === null)
    throw new Nx("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n = SO(t), i = n.length > 0 ? n[0] : "", s = CO("%" + i + "%", e), o = s.name, a = s.value, u = !1, x = s.alias;
  x && (i = x[0], bO(n, _O([0, 1], x)));
  for (var c = 1, f = !0; c < n.length; c += 1) {
    var l = n[c], h = Mg(l, 0, 1), p = Mg(l, -1);
    if ((h === '"' || h === "'" || h === "`" || p === '"' || p === "'" || p === "`") && h !== p)
      throw new Nx("property names with quotes must have matching quotes");
    if ((l === "constructor" || !f) && (u = !0), i += "." + l, o = "%" + i + "%", Cg(L0, o))
      a = L0[o];
    else if (a != null) {
      if (!(l in a)) {
        if (!e)
          throw new Qu("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (ll && c + 1 >= n.length) {
        var y = ll(a, l);
        f = !!y, f && "get" in y && !("originalValue" in y.get) ? a = y.get : a = a[l];
      } else
        f = Cg(a, l), a = a[l];
      f && !u && (L0[o] = a);
    }
  }
  return a;
}, FE = { exports: {} }, cI = By, MO = LE, Pu = ic, fI = ql, b2 = function(t, e, n) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new Pu("`obj` must be an object or a function`");
  if (typeof e != "string" && typeof e != "symbol")
    throw new Pu("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new Pu("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new Pu("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new Pu("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new Pu("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, s = arguments.length > 4 ? arguments[4] : null, o = arguments.length > 5 ? arguments[5] : null, a = arguments.length > 6 ? arguments[6] : !1, u = !!fI && fI(t, e);
  if (cI)
    cI(t, e, {
      configurable: o === null && u ? u.configurable : !o,
      enumerable: i === null && u ? u.enumerable : !i,
      value: n,
      writable: s === null && u ? u.writable : !s
    });
  else if (a || !i && !s && !o)
    t[e] = n;
  else
    throw new MO("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, Hm = By, kE = function() {
  return !!Hm;
};
kE.hasArrayLengthDefineBug = function() {
  if (!Hm)
    return null;
  try {
    return Hm([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var I2 = kE, PO = DE, lI = b2, LO = I2(), hI = ql, pI = ic, NO = PO("%Math.floor%"), OO = function(t, e) {
  if (typeof t != "function")
    throw new pI("`fn` is not a function");
  if (typeof e != "number" || e < 0 || e > 4294967295 || NO(e) !== e)
    throw new pI("`length` must be a positive 32-bit integer");
  var n = arguments.length > 2 && !!arguments[2], i = !0, s = !0;
  if ("length" in t && hI) {
    var o = hI(t, "length");
    o && !o.configurable && (i = !1), o && !o.writable && (s = !1);
  }
  return (i || s || !n) && (LO ? lI(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    e,
    !0,
    !0
  ) : lI(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    e
  )), t;
}, RO = zl, AO = _2, TO = NE, DO = function() {
  return TO(RO, AO, arguments);
};
(function(r) {
  var t = OO, e = By, n = OE, i = DO;
  r.exports = function(o) {
    var a = n(arguments), u = o.length - (arguments.length - 1);
    return t(
      a,
      1 + (u > 0 ? u : 0),
      !0
    );
  }, e ? e(r.exports, "apply", { value: i }) : r.exports.apply = i;
})(FE);
var w2 = FE.exports, BE = DE, GE = w2, FO = GE(BE("String.prototype.indexOf")), YE = function(t, e) {
  var n = BE(t, !!e);
  return typeof n == "function" && FO(t, ".prototype.") > -1 ? GE(n) : n;
}, kO = v2(), BO = YE, Jm = BO("Object.prototype.toString"), Gy = function(t) {
  return kO && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : Jm(t) === "[object Arguments]";
}, XE = function(t) {
  return Gy(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && Jm(t) !== "[object Array]" && Jm(t.callee) === "[object Function]";
}, GO = function() {
  return Gy(arguments);
}();
Gy.isLegacyArguments = XE;
var YO = GO ? Gy : XE, XO = ME, qO = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", zO = Object.prototype.toString, UO = Array.prototype.concat, dI = b2, VO = function(r) {
  return typeof r == "function" && zO.call(r) === "[object Function]";
}, qE = I2(), WO = function(r, t, e, n) {
  if (t in r) {
    if (n === !0) {
      if (r[t] === e)
        return;
    } else if (!VO(n) || !n())
      return;
  }
  qE ? dI(r, t, e, !0) : dI(r, t, e);
}, zE = function(r, t) {
  var e = arguments.length > 2 ? arguments[2] : {}, n = XO(t);
  qO && (n = UO.call(n, Object.getOwnPropertySymbols(t)));
  for (var i = 0; i < n.length; i += 1)
    WO(r, n[i], t[n[i]], e[n[i]]);
};
zE.supportsDescriptors = !!qE;
var Wl = zE, gI = function(r) {
  return r !== r;
}, UE = function(t, e) {
  return t === 0 && e === 0 ? 1 / t === 1 / e : !!(t === e || gI(t) && gI(e));
}, HO = UE, VE = function() {
  return typeof Object.is == "function" ? Object.is : HO;
}, JO = VE, ZO = Wl, KO = function() {
  var t = JO();
  return ZO(Object, { is: t }, {
    is: function() {
      return Object.is !== t;
    }
  }), t;
}, jO = Wl, QO = w2, $O = UE, WE = VE, tR = KO, HE = QO(WE(), Object);
jO(HE, {
  getPolyfill: WE,
  implementation: $O,
  shim: tR
});
var eR = HE, yI = YE, nR = v2(), rR = RE, iR = ql, Zm;
if (nR) {
  var sR = yI("RegExp.prototype.exec"), vI = {}, Uv = function() {
    throw vI;
  }, mI = {
    toString: Uv,
    valueOf: Uv
  };
  typeof Symbol.toPrimitive == "symbol" && (mI[Symbol.toPrimitive] = Uv), Zm = function(t) {
    if (!t || typeof t != "object")
      return !1;
    var e = (
      /** @type {NonNullable<typeof gOPD>} */
      iR(
        /** @type {{ lastIndex?: unknown }} */
        t,
        "lastIndex"
      )
    ), n = e && rR(e, "value");
    if (!n)
      return !1;
    try {
      sR(
        t,
        /** @type {string} */
        /** @type {unknown} */
        mI
      );
    } catch (i) {
      return i === vI;
    }
  };
} else {
  var oR = yI("Object.prototype.toString"), aR = "[object RegExp]";
  Zm = function(t) {
    return !t || typeof t != "object" && typeof t != "function" ? !1 : oR(t) === aR;
  };
}
var uR = Zm, hl = function() {
  return typeof (function() {
  }).name == "string";
}, Wc = Object.getOwnPropertyDescriptor;
if (Wc)
  try {
    Wc([], "length");
  } catch {
    Wc = null;
  }
hl.functionsHaveConfigurableNames = function() {
  if (!hl() || !Wc)
    return !1;
  var t = Wc(function() {
  }, "name");
  return !!t && !!t.configurable;
};
var xR = Function.prototype.bind;
hl.boundFunctionsHaveNames = function() {
  return hl() && typeof xR == "function" && (function() {
  }).bind().name !== "";
};
var cR = hl, _I = b2, fR = I2(), lR = cR.functionsHaveConfigurableNames(), hR = ic, pR = function(t, e) {
  if (typeof t != "function")
    throw new hR("`fn` is not a function");
  var n = arguments.length > 2 && !!arguments[2];
  return (!n || lR) && (fR ? _I(
    /** @type {Parameters<define>[0]} */
    t,
    "name",
    e,
    !0,
    !0
  ) : _I(
    /** @type {Parameters<define>[0]} */
    t,
    "name",
    e
  )), t;
}, dR = pR, gR = ic, yR = Object, JE = dR(function() {
  if (this == null || this !== yR(this))
    throw new gR("RegExp.prototype.flags getter called on non-object");
  var t = "";
  return this.hasIndices && (t += "d"), this.global && (t += "g"), this.ignoreCase && (t += "i"), this.multiline && (t += "m"), this.dotAll && (t += "s"), this.unicode && (t += "u"), this.unicodeSets && (t += "v"), this.sticky && (t += "y"), t;
}, "get flags", !0), vR = JE, mR = Wl.supportsDescriptors, _R = Object.getOwnPropertyDescriptor, ZE = function() {
  if (mR && /a/mig.flags === "gim") {
    var t = _R(RegExp.prototype, "flags");
    if (t && typeof t.get == "function" && "dotAll" in RegExp.prototype && "hasIndices" in RegExp.prototype) {
      var e = "", n = {};
      if (Object.defineProperty(n, "hasIndices", {
        get: function() {
          e += "d";
        }
      }), Object.defineProperty(n, "sticky", {
        get: function() {
          e += "y";
        }
      }), t.get.call(n), e === "dy")
        return t.get;
    }
  }
  return vR;
}, bR = Wl.supportsDescriptors, IR = ZE, wR = Object.getOwnPropertyDescriptor, ER = Object.defineProperty, SR = TypeError, bI = Object.getPrototypeOf, CR = /a/, MR = function() {
  if (!bR || !bI)
    throw new SR("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  var t = IR(), e = bI(CR), n = wR(e, "flags");
  return (!n || n.get !== t) && ER(e, "flags", {
    configurable: !0,
    enumerable: !1,
    get: t
  }), t;
}, PR = Wl, LR = w2, NR = JE, KE = ZE, OR = MR, jE = LR(KE());
PR(jE, {
  getPolyfill: KE,
  implementation: NR,
  shim: OR
});
var RR = jE, AR = Date.prototype.getDay, TR = function(t) {
  try {
    return AR.call(t), !0;
  } catch {
    return !1;
  }
}, DR = Object.prototype.toString, FR = "[object Date]", kR = v2(), BR = function(t) {
  return typeof t != "object" || t === null ? !1 : kR ? TR(t) : DR.call(t) === FR;
}, II = ME, wI = YO, EI = eR, SI = uR, CI = RR, MI = BR, PI = Date.prototype.getTime;
function QE(r, t, e) {
  var n = e || {};
  return (n.strict ? EI(r, t) : r === t) ? !0 : !r || !t || typeof r != "object" && typeof t != "object" ? n.strict ? EI(r, t) : r == t : GR(r, t, n);
}
function LI(r) {
  return r == null;
}
function NI(r) {
  return !(!r || typeof r != "object" || typeof r.length != "number" || typeof r.copy != "function" || typeof r.slice != "function" || r.length > 0 && typeof r[0] != "number");
}
function GR(r, t, e) {
  var n, i;
  if (typeof r != typeof t || LI(r) || LI(t) || r.prototype !== t.prototype || wI(r) !== wI(t))
    return !1;
  var s = SI(r), o = SI(t);
  if (s !== o)
    return !1;
  if (s || o)
    return r.source === t.source && CI(r) === CI(t);
  if (MI(r) && MI(t))
    return PI.call(r) === PI.call(t);
  var a = NI(r), u = NI(t);
  if (a !== u)
    return !1;
  if (a || u) {
    if (r.length !== t.length)
      return !1;
    for (n = 0; n < r.length; n++)
      if (r[n] !== t[n])
        return !1;
    return !0;
  }
  if (typeof r != typeof t)
    return !1;
  try {
    var x = II(r), c = II(t);
  } catch {
    return !1;
  }
  if (x.length !== c.length)
    return !1;
  for (x.sort(), c.sort(), n = x.length - 1; n >= 0; n--)
    if (x[n] != c[n])
      return !1;
  for (n = x.length - 1; n >= 0; n--)
    if (i = x[n], !QE(r[i], t[i], e))
      return !1;
  return !0;
}
var $E = QE;
const kc = /* @__PURE__ */ Ao($E);
function tS(r, t, e) {
  if (e === void 0 && (e = {}), e = e || {}, !we(e))
    throw new Error("options is invalid");
  var n = e.tolerance || 0, i = [], s = Fy(), o = W0(r);
  s.load(o);
  var a;
  return Zo(t, function(u) {
    var x = !1;
    u && (he(s.search(u), function(c) {
      if (x === !1) {
        var f = gt(u).sort(), l = gt(c).sort();
        kc(f, l) || (n === 0 ? bi(f[0], c) && bi(f[1], c) : Ko(c, f[0]).properties.dist <= n && Ko(c, f[1]).properties.dist <= n) ? (x = !0, a ? a = Vv(a, u) : a = u) : (n === 0 ? bi(l[0], u) && bi(l[1], u) : Ko(u, l[0]).properties.dist <= n && Ko(u, l[1]).properties.dist <= n) && (a ? a = Vv(a, c) : a = c);
      }
    }), x === !1 && a && (i.push(a), a = void 0));
  }), a && i.push(a), ht(i);
}
function Vv(r, t) {
  var e = gt(t), n = gt(r), i = n[0], s = n[n.length - 1], o = r.geometry.coordinates;
  return kc(e[0], i) ? o.unshift(e[1]) : kc(e[0], s) ? o.push(e[1]) : kc(e[1], i) ? o.unshift(e[0]) : kc(e[1], s) && o.push(e[0]), r;
}
function YR(r, t, e, n, i) {
  if (i = i || {}, !we(i)) throw new Error("options is invalid");
  var s = i.properties;
  if (!r) throw new Error("center is required");
  if (e == null)
    throw new Error("bearing1 is required");
  if (n == null)
    throw new Error("bearing2 is required");
  if (!t) throw new Error("radius is required");
  if (typeof i != "object") throw new Error("options must be an object");
  if (OI(e) === OI(n))
    return r2(r, t, i);
  var o = gt(r), a = wE(r, t, e, n, i), u = [[o]];
  return hn(a, function(x) {
    u[0].push(x);
  }), u[0].push(o), Nt(u, s);
}
function OI(r) {
  var t = r % 360;
  return t < 0 && (t += 360), t;
}
function H0(r, t, e) {
  e === void 0 && (e = {});
  var n;
  e.final ? n = RI(Ae(t), Ae(r)) : n = RI(Ae(r), Ae(t));
  var i = n > 180 ? -(360 - n) : n;
  return i;
}
function RI(r, t) {
  var e = Un(r[1]), n = Un(t[1]), i = Un(t[0] - r[0]);
  i > Math.PI && (i -= 2 * Math.PI), i < -Math.PI && (i += 2 * Math.PI);
  var s = Math.log(Math.tan(n / 2 + Math.PI / 4) / Math.tan(e / 2 + Math.PI / 4)), o = Math.atan2(i, s);
  return (Za(o) + 360) % 360;
}
function Ox(r, t, e, n) {
  n === void 0 && (n = {});
  var i = t < 0, s = z0(Math.abs(t), n.units, "meters");
  i && (s = -Math.abs(s));
  var o = Ae(r), a = XR(o, s, e);
  return a[0] += a[0] - o[0] > 180 ? -360 : o[0] - a[0] > 180 ? 360 : 0, Pt(a, n.properties);
}
function XR(r, t, e, n) {
  n = n === void 0 ? Xn : Number(n);
  var i = t / n, s = r[0] * Math.PI / 180, o = Un(r[1]), a = Un(e), u = i * Math.cos(a), x = o + u;
  Math.abs(x) > Math.PI / 2 && (x = x > 0 ? Math.PI - x : -Math.PI - x);
  var c = Math.log(Math.tan(x / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)), f = Math.abs(c) > 1e-11 ? u / c : Math.cos(o), l = i * Math.sin(a) / f, h = s + l;
  return [
    (h * 180 / Math.PI + 540) % 360 - 180,
    x * 180 / Math.PI
  ];
}
function qR(r, t) {
  var e = gt(r), n = gt(t), i, s, o, a, u = Cn(t), x = 0, c = null;
  e[0] > u[0] && e[0] < u[2] && e[1] > u[1] && e[1] < u[3] && (c = Eg(r, Ly(t)), x = c.properties.featureIndex);
  var f = oi(t);
  switch (f) {
    case "Polygon":
      i = n[0][x], s = n[0][0], c !== null && c.geometry.coordinates[1] < e[1] && (s = n[0][x]), a = pl(
        n[0][0],
        n[0][n[0].length - 1],
        e
      );
      var l = AI(
        n[0],
        e,
        a,
        o,
        i,
        s
      );
      i = l[0], s = l[1];
      break;
    case "MultiPolygon":
      for (var h = 0, p = 0, y = 0, v = 0; v < n[0].length; v++) {
        h = v;
        for (var m = !1, d = 0; d < n[0][v].length; d++) {
          if (p = d, y === x) {
            m = !0;
            break;
          }
          y++;
        }
        if (m) break;
      }
      i = n[0][h][p], s = n[0][h][p], a = pl(
        n[0][0][0],
        n[0][0][n[0][0].length - 1],
        e
      ), n.forEach(function(g) {
        var _ = AI(
          g[0],
          e,
          a,
          o,
          i,
          s
        );
        i = _[0], s = _[1];
      });
      break;
  }
  return ht([Pt(i), Pt(s)]);
}
function AI(r, t, e, n, i, s) {
  for (var o = 0; o < r.length; o++) {
    var a = r[o], u = r[o + 1];
    o === r.length - 1 && (u = r[0]), n = pl(a, u, t), e <= 0 && n > 0 ? UR(t, a, i) || (i = a) : e > 0 && n <= 0 && (zR(t, a, s) || (s = a)), e = n;
  }
  return [i, s];
}
function zR(r, t, e) {
  return pl(r, t, e) > 0;
}
function UR(r, t, e) {
  return pl(r, t, e) < 0;
}
function pl(r, t, e) {
  return (t[0] - r[0]) * (e[1] - r[1]) - (e[0] - r[0]) * (t[1] - r[1]);
}
function Pg(r) {
  for (var t = gt(r), e = 0, n = 1, i, s; n < t.length; )
    i = s || t[0], s = t[n], e += (s[0] - i[0]) * (s[1] + i[1]), n++;
  return e > 0;
}
function VR(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.reverse || !1, n = t.mutate || !1;
  if (!r) throw new Error("<geojson> is required");
  if (typeof e != "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof n != "boolean")
    throw new Error("<mutate> must be a boolean");
  n === !1 && (r = br(r));
  var i = [];
  switch (r.type) {
    case "GeometryCollection":
      return Pi(r, function(s) {
        Uh(s, e);
      }), r;
    case "FeatureCollection":
      return he(r, function(s) {
        he(Uh(s, e), function(o) {
          i.push(o);
        });
      }), ht(i);
  }
  return Uh(r, e);
}
function Uh(r, t) {
  var e = r.type === "Feature" ? r.geometry.type : r.type;
  switch (e) {
    case "GeometryCollection":
      return Pi(r, function(n) {
        Uh(n, t);
      }), r;
    case "LineString":
      return TI(gt(r), t), r;
    case "Polygon":
      return DI(gt(r), t), r;
    case "MultiLineString":
      return gt(r).forEach(function(n) {
        TI(n, t);
      }), r;
    case "MultiPolygon":
      return gt(r).forEach(function(n) {
        DI(n, t);
      }), r;
    case "Point":
    case "MultiPoint":
      return r;
  }
}
function TI(r, t) {
  Pg(r) === t && r.reverse();
}
function DI(r, t) {
  Pg(r[0]) !== t && r[0].reverse();
  for (var e = 1; e < r.length; e++)
    Pg(r[e]) === t && r[e].reverse();
}
function WR(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.zProperty || "elevation", n = t.flip, i = t.flags;
  Ia(r, "Point", "input must contain Points");
  for (var s = HR(r, n), o = [], a = 0; a < s.length; a++) {
    for (var u = s[a], x = [], c = 0; c < u.length; c++) {
      var f = u[c];
      f.properties[e] ? x.push(f.properties[e]) : x.push(0), i === !0 && (f.properties.matrixPosition = [a, c]);
    }
    o.push(x);
  }
  return o;
}
function HR(r, t) {
  var e = {};
  he(r, function(s) {
    var o = gt(s)[1];
    e[o] || (e[o] = []), e[o].push(s);
  });
  var n = Object.keys(e).map(function(s) {
    var o = e[s], a = o.sort(function(u, x) {
      return gt(u)[0] - gt(x)[0];
    });
    return a;
  }), i = n.sort(function(s, o) {
    return t ? gt(s[0])[1] - gt(o[0])[1] : gt(o[0])[1] - gt(s[0])[1];
  });
  return i;
}
/*!
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */
var FI = {
  successCallback: null,
  verbose: !1,
  polygons: !1
}, _0 = {};
function JR(r, t, e, n) {
  n = n || {};
  for (var i = Object.keys(FI), s = 0; s < i.length; s++) {
    var o = i[s], a = n[o];
    a = typeof a < "u" && a !== null ? a : FI[o], _0[o] = a;
  }
  _0.verbose && console.log(
    "MarchingSquaresJS-isoBands: computing isobands for [" + t + ":" + (t + e) + "]"
  );
  var u = MA(r, t, e), x;
  return _0.polygons ? (_0.verbose && console.log(
    "MarchingSquaresJS-isoBands: returning single polygons for each grid cell"
  ), x = AA(u)) : (_0.verbose && console.log(
    "MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"
  ), x = PA(u)), typeof _0.successCallback == "function" && _0.successCallback(x), x;
}
var Rr = 64, ps = 16, er = 4, pr = 1, At = [], Tt = [], Dt = [], Ft = [], kt = [], Bt = [], Gt = [], Yt = [], Xt = [], qt = [], zt = [], Ut = [], Vt = [], Wt = [], Ht = [], Jt = [], Zt = [], Kt = [], jt = [], Qt = [], $t = [], te = [], ee = [], ne = [];
Gt[85] = qt[85] = -1;
Yt[85] = zt[85] = 0;
Xt[85] = Ut[85] = 1;
jt[85] = te[85] = 1;
Qt[85] = ee[85] = 0;
$t[85] = ne[85] = 1;
At[85] = Ft[85] = 0;
Tt[85] = kt[85] = -1;
Dt[85] = Ht[85] = 0;
Jt[85] = Vt[85] = 0;
Zt[85] = Wt[85] = 1;
Bt[85] = Kt[85] = 1;
te[1] = te[169] = 0;
ee[1] = ee[169] = -1;
ne[1] = ne[169] = 0;
Vt[1] = Vt[169] = -1;
Wt[1] = Wt[169] = 0;
Ht[1] = Ht[169] = 0;
qt[4] = qt[166] = 0;
zt[4] = zt[166] = -1;
Ut[4] = Ut[166] = 1;
Jt[4] = Jt[166] = 1;
Zt[4] = Zt[166] = 0;
Kt[4] = Kt[166] = 0;
Gt[16] = Gt[154] = 0;
Yt[16] = Yt[154] = 1;
Xt[16] = Xt[154] = 1;
Ft[16] = Ft[154] = 1;
kt[16] = kt[154] = 0;
Bt[16] = Bt[154] = 1;
jt[64] = jt[106] = 0;
Qt[64] = Qt[106] = 1;
$t[64] = $t[106] = 0;
At[64] = At[106] = -1;
Tt[64] = Tt[106] = 0;
Dt[64] = Dt[106] = 1;
jt[2] = jt[168] = 0;
Qt[2] = Qt[168] = -1;
$t[2] = $t[168] = 1;
te[2] = te[168] = 0;
ee[2] = ee[168] = -1;
ne[2] = ne[168] = 0;
Vt[2] = Vt[168] = -1;
Wt[2] = Wt[168] = 0;
Ht[2] = Ht[168] = 0;
Jt[2] = Jt[168] = -1;
Zt[2] = Zt[168] = 0;
Kt[2] = Kt[168] = 1;
Gt[8] = Gt[162] = 0;
Yt[8] = Yt[162] = -1;
Xt[8] = Xt[162] = 0;
qt[8] = qt[162] = 0;
zt[8] = zt[162] = -1;
Ut[8] = Ut[162] = 1;
Vt[8] = Vt[162] = 1;
Wt[8] = Wt[162] = 0;
Ht[8] = Ht[162] = 1;
Jt[8] = Jt[162] = 1;
Zt[8] = Zt[162] = 0;
Kt[8] = Kt[162] = 0;
Gt[32] = Gt[138] = 0;
Yt[32] = Yt[138] = 1;
Xt[32] = Xt[138] = 1;
qt[32] = qt[138] = 0;
zt[32] = zt[138] = 1;
Ut[32] = Ut[138] = 0;
At[32] = At[138] = 1;
Tt[32] = Tt[138] = 0;
Dt[32] = Dt[138] = 0;
Ft[32] = Ft[138] = 1;
kt[32] = kt[138] = 0;
Bt[32] = Bt[138] = 1;
te[128] = te[42] = 0;
ee[128] = ee[42] = 1;
ne[128] = ne[42] = 1;
jt[128] = jt[42] = 0;
Qt[128] = Qt[42] = 1;
$t[128] = $t[42] = 0;
At[128] = At[42] = -1;
Tt[128] = Tt[42] = 0;
Dt[128] = Dt[42] = 1;
Ft[128] = Ft[42] = -1;
kt[128] = kt[42] = 0;
Bt[128] = Bt[42] = 0;
qt[5] = qt[165] = -1;
zt[5] = zt[165] = 0;
Ut[5] = Ut[165] = 0;
te[5] = te[165] = 1;
ee[5] = ee[165] = 0;
ne[5] = ne[165] = 0;
Jt[20] = Jt[150] = 0;
Zt[20] = Zt[150] = 1;
Kt[20] = Kt[150] = 1;
Ft[20] = Ft[150] = 0;
kt[20] = kt[150] = -1;
Bt[20] = Bt[150] = 1;
Gt[80] = Gt[90] = -1;
Yt[80] = Yt[90] = 0;
Xt[80] = Xt[90] = 1;
jt[80] = jt[90] = 1;
Qt[80] = Qt[90] = 0;
$t[80] = $t[90] = 1;
Vt[65] = Vt[105] = 0;
Wt[65] = Wt[105] = 1;
Ht[65] = Ht[105] = 0;
At[65] = At[105] = 0;
Tt[65] = Tt[105] = -1;
Dt[65] = Dt[105] = 0;
Gt[160] = Gt[10] = -1;
Yt[160] = Yt[10] = 0;
Xt[160] = Xt[10] = 1;
qt[160] = qt[10] = -1;
zt[160] = zt[10] = 0;
Ut[160] = Ut[10] = 0;
te[160] = te[10] = 1;
ee[160] = ee[10] = 0;
ne[160] = ne[10] = 0;
jt[160] = jt[10] = 1;
Qt[160] = Qt[10] = 0;
$t[160] = $t[10] = 1;
Jt[130] = Jt[40] = 0;
Zt[130] = Zt[40] = 1;
Kt[130] = Kt[40] = 1;
Vt[130] = Vt[40] = 0;
Wt[130] = Wt[40] = 1;
Ht[130] = Ht[40] = 0;
At[130] = At[40] = 0;
Tt[130] = Tt[40] = -1;
Dt[130] = Dt[40] = 0;
Ft[130] = Ft[40] = 0;
kt[130] = kt[40] = -1;
Bt[130] = Bt[40] = 1;
qt[37] = qt[133] = 0;
zt[37] = zt[133] = 1;
Ut[37] = Ut[133] = 1;
te[37] = te[133] = 0;
ee[37] = ee[133] = 1;
ne[37] = ne[133] = 0;
At[37] = At[133] = -1;
Tt[37] = Tt[133] = 0;
Dt[37] = Dt[133] = 0;
Ft[37] = Ft[133] = 1;
kt[37] = kt[133] = 0;
Bt[37] = Bt[133] = 0;
Jt[148] = Jt[22] = -1;
Zt[148] = Zt[22] = 0;
Kt[148] = Kt[22] = 0;
te[148] = te[22] = 0;
ee[148] = ee[22] = -1;
ne[148] = ne[22] = 1;
jt[148] = jt[22] = 0;
Qt[148] = Qt[22] = 1;
$t[148] = $t[22] = 1;
Ft[148] = Ft[22] = -1;
kt[148] = kt[22] = 0;
Bt[148] = Bt[22] = 1;
Gt[82] = Gt[88] = 0;
Yt[82] = Yt[88] = -1;
Xt[82] = Xt[88] = 1;
Jt[82] = Jt[88] = 1;
Zt[82] = Zt[88] = 0;
Kt[82] = Kt[88] = 1;
Vt[82] = Vt[88] = -1;
Wt[82] = Wt[88] = 0;
Ht[82] = Ht[88] = 1;
jt[82] = jt[88] = 0;
Qt[82] = Qt[88] = -1;
$t[82] = $t[88] = 0;
Gt[73] = Gt[97] = 0;
Yt[73] = Yt[97] = 1;
Xt[73] = Xt[97] = 0;
qt[73] = qt[97] = 0;
zt[73] = zt[97] = -1;
Ut[73] = Ut[97] = 0;
Vt[73] = Vt[97] = 1;
Wt[73] = Wt[97] = 0;
Ht[73] = Ht[97] = 0;
At[73] = At[97] = 1;
Tt[73] = Tt[97] = 0;
Dt[73] = Dt[97] = 1;
Gt[145] = Gt[25] = 0;
Yt[145] = Yt[25] = -1;
Xt[145] = Xt[25] = 0;
Vt[145] = Vt[25] = 1;
Wt[145] = Wt[25] = 0;
Ht[145] = Ht[25] = 1;
te[145] = te[25] = 0;
ee[145] = ee[25] = 1;
ne[145] = ne[25] = 1;
Ft[145] = Ft[25] = -1;
kt[145] = kt[25] = 0;
Bt[145] = Bt[25] = 0;
qt[70] = qt[100] = 0;
zt[70] = zt[100] = 1;
Ut[70] = Ut[100] = 0;
Jt[70] = Jt[100] = -1;
Zt[70] = Zt[100] = 0;
Kt[70] = Kt[100] = 1;
jt[70] = jt[100] = 0;
Qt[70] = Qt[100] = -1;
$t[70] = $t[100] = 1;
At[70] = At[100] = 1;
Tt[70] = Tt[100] = 0;
Dt[70] = Dt[100] = 0;
qt[101] = qt[69] = 0;
zt[101] = zt[69] = 1;
Ut[101] = Ut[69] = 0;
At[101] = At[69] = 1;
Tt[101] = Tt[69] = 0;
Dt[101] = Dt[69] = 0;
te[149] = te[21] = 0;
ee[149] = ee[21] = 1;
ne[149] = ne[21] = 1;
Ft[149] = Ft[21] = -1;
kt[149] = kt[21] = 0;
Bt[149] = Bt[21] = 0;
Jt[86] = Jt[84] = -1;
Zt[86] = Zt[84] = 0;
Kt[86] = Kt[84] = 1;
jt[86] = jt[84] = 0;
Qt[86] = Qt[84] = -1;
$t[86] = $t[84] = 1;
Gt[89] = Gt[81] = 0;
Yt[89] = Yt[81] = -1;
Xt[89] = Xt[81] = 0;
Vt[89] = Vt[81] = 1;
Wt[89] = Wt[81] = 0;
Ht[89] = Ht[81] = 1;
Gt[96] = Gt[74] = 0;
Yt[96] = Yt[74] = 1;
Xt[96] = Xt[74] = 0;
qt[96] = qt[74] = -1;
zt[96] = zt[74] = 0;
Ut[96] = Ut[74] = 1;
jt[96] = jt[74] = 1;
Qt[96] = Qt[74] = 0;
$t[96] = $t[74] = 0;
At[96] = At[74] = 1;
Tt[96] = Tt[74] = 0;
Dt[96] = Dt[74] = 1;
Gt[24] = Gt[146] = 0;
Yt[24] = Yt[146] = -1;
Xt[24] = Xt[146] = 1;
Jt[24] = Jt[146] = 1;
Zt[24] = Zt[146] = 0;
Kt[24] = Kt[146] = 1;
Vt[24] = Vt[146] = 0;
Wt[24] = Wt[146] = 1;
Ht[24] = Ht[146] = 1;
Ft[24] = Ft[146] = 0;
kt[24] = kt[146] = -1;
Bt[24] = Bt[146] = 0;
qt[6] = qt[164] = -1;
zt[6] = zt[164] = 0;
Ut[6] = Ut[164] = 1;
Jt[6] = Jt[164] = -1;
Zt[6] = Zt[164] = 0;
Kt[6] = Kt[164] = 0;
te[6] = te[164] = 0;
ee[6] = ee[164] = -1;
ne[6] = ne[164] = 1;
jt[6] = jt[164] = 1;
Qt[6] = Qt[164] = 0;
$t[6] = $t[164] = 0;
Vt[129] = Vt[41] = 0;
Wt[129] = Wt[41] = 1;
Ht[129] = Ht[41] = 1;
te[129] = te[41] = 0;
ee[129] = ee[41] = 1;
ne[129] = ne[41] = 0;
At[129] = At[41] = -1;
Tt[129] = Tt[41] = 0;
Dt[129] = Dt[41] = 0;
Ft[129] = Ft[41] = 0;
kt[129] = kt[41] = -1;
Bt[129] = Bt[41] = 0;
Jt[66] = Jt[104] = 0;
Zt[66] = Zt[104] = 1;
Kt[66] = Kt[104] = 0;
Vt[66] = Vt[104] = -1;
Wt[66] = Wt[104] = 0;
Ht[66] = Ht[104] = 1;
jt[66] = jt[104] = 0;
Qt[66] = Qt[104] = -1;
$t[66] = $t[104] = 0;
At[66] = At[104] = 0;
Tt[66] = Tt[104] = -1;
Dt[66] = Dt[104] = 1;
Gt[144] = Gt[26] = -1;
Yt[144] = Yt[26] = 0;
Xt[144] = Xt[26] = 0;
te[144] = te[26] = 1;
ee[144] = ee[26] = 0;
ne[144] = ne[26] = 1;
jt[144] = jt[26] = 0;
Qt[144] = Qt[26] = 1;
$t[144] = $t[26] = 1;
Ft[144] = Ft[26] = -1;
kt[144] = kt[26] = 0;
Bt[144] = Bt[26] = 1;
qt[36] = qt[134] = 0;
zt[36] = zt[134] = 1;
Ut[36] = Ut[134] = 1;
Jt[36] = Jt[134] = 0;
Zt[36] = Zt[134] = 1;
Kt[36] = Kt[134] = 0;
At[36] = At[134] = 0;
Tt[36] = Tt[134] = -1;
Dt[36] = Dt[134] = 1;
Ft[36] = Ft[134] = 1;
kt[36] = kt[134] = 0;
Bt[36] = Bt[134] = 0;
Gt[9] = Gt[161] = -1;
Yt[9] = Yt[161] = 0;
Xt[9] = Xt[161] = 0;
qt[9] = qt[161] = 0;
zt[9] = zt[161] = -1;
Ut[9] = Ut[161] = 0;
Vt[9] = Vt[161] = 1;
Wt[9] = Wt[161] = 0;
Ht[9] = Ht[161] = 0;
te[9] = te[161] = 1;
ee[9] = ee[161] = 0;
ne[9] = ne[161] = 1;
Gt[136] = 0;
Yt[136] = 1;
Xt[136] = 1;
qt[136] = 0;
zt[136] = 1;
Ut[136] = 0;
Jt[136] = -1;
Zt[136] = 0;
Kt[136] = 1;
Vt[136] = -1;
Wt[136] = 0;
Ht[136] = 0;
te[136] = 0;
ee[136] = -1;
ne[136] = 0;
jt[136] = 0;
Qt[136] = -1;
$t[136] = 1;
At[136] = 1;
Tt[136] = 0;
Dt[136] = 0;
Ft[136] = 1;
kt[136] = 0;
Bt[136] = 1;
Gt[34] = 0;
Yt[34] = -1;
Xt[34] = 0;
qt[34] = 0;
zt[34] = -1;
Ut[34] = 1;
Jt[34] = 1;
Zt[34] = 0;
Kt[34] = 0;
Vt[34] = 1;
Wt[34] = 0;
Ht[34] = 1;
te[34] = 0;
ee[34] = 1;
ne[34] = 1;
jt[34] = 0;
Qt[34] = 1;
$t[34] = 0;
At[34] = -1;
Tt[34] = 0;
Dt[34] = 1;
Ft[34] = -1;
kt[34] = 0;
Bt[34] = 0;
Gt[35] = 0;
Yt[35] = 1;
Xt[35] = 1;
qt[35] = 0;
zt[35] = -1;
Ut[35] = 1;
Jt[35] = 1;
Zt[35] = 0;
Kt[35] = 0;
Vt[35] = -1;
Wt[35] = 0;
Ht[35] = 0;
te[35] = 0;
ee[35] = -1;
ne[35] = 0;
jt[35] = 0;
Qt[35] = 1;
$t[35] = 0;
At[35] = -1;
Tt[35] = 0;
Dt[35] = 1;
Ft[35] = 1;
kt[35] = 0;
Bt[35] = 1;
Gt[153] = 0;
Yt[153] = 1;
Xt[153] = 1;
Vt[153] = -1;
Wt[153] = 0;
Ht[153] = 0;
te[153] = 0;
ee[153] = -1;
ne[153] = 0;
Ft[153] = 1;
kt[153] = 0;
Bt[153] = 1;
qt[102] = 0;
zt[102] = -1;
Ut[102] = 1;
Jt[102] = 1;
Zt[102] = 0;
Kt[102] = 0;
jt[102] = 0;
Qt[102] = 1;
$t[102] = 0;
At[102] = -1;
Tt[102] = 0;
Dt[102] = 1;
Gt[155] = 0;
Yt[155] = -1;
Xt[155] = 0;
Vt[155] = 1;
Wt[155] = 0;
Ht[155] = 1;
te[155] = 0;
ee[155] = 1;
ne[155] = 1;
Ft[155] = -1;
kt[155] = 0;
Bt[155] = 0;
qt[103] = 0;
zt[103] = 1;
Ut[103] = 0;
Jt[103] = -1;
Zt[103] = 0;
Kt[103] = 1;
jt[103] = 0;
Qt[103] = -1;
$t[103] = 1;
At[103] = 1;
Tt[103] = 0;
Dt[103] = 0;
Gt[152] = 0;
Yt[152] = 1;
Xt[152] = 1;
Jt[152] = -1;
Zt[152] = 0;
Kt[152] = 1;
Vt[152] = -1;
Wt[152] = 0;
Ht[152] = 0;
te[152] = 0;
ee[152] = -1;
ne[152] = 0;
jt[152] = 0;
Qt[152] = -1;
$t[152] = 1;
Ft[152] = 1;
kt[152] = 0;
Bt[152] = 1;
Gt[156] = 0;
Yt[156] = -1;
Xt[156] = 1;
Jt[156] = 1;
Zt[156] = 0;
Kt[156] = 1;
Vt[156] = -1;
Wt[156] = 0;
Ht[156] = 0;
te[156] = 0;
ee[156] = -1;
ne[156] = 0;
jt[156] = 0;
Qt[156] = 1;
$t[156] = 1;
Ft[156] = -1;
kt[156] = 0;
Bt[156] = 1;
Gt[137] = 0;
Yt[137] = 1;
Xt[137] = 1;
qt[137] = 0;
zt[137] = 1;
Ut[137] = 0;
Vt[137] = -1;
Wt[137] = 0;
Ht[137] = 0;
te[137] = 0;
ee[137] = -1;
ne[137] = 0;
At[137] = 1;
Tt[137] = 0;
Dt[137] = 0;
Ft[137] = 1;
kt[137] = 0;
Bt[137] = 1;
Gt[139] = 0;
Yt[139] = 1;
Xt[139] = 1;
qt[139] = 0;
zt[139] = -1;
Ut[139] = 0;
Vt[139] = 1;
Wt[139] = 0;
Ht[139] = 0;
te[139] = 0;
ee[139] = 1;
ne[139] = 0;
At[139] = -1;
Tt[139] = 0;
Dt[139] = 0;
Ft[139] = 1;
kt[139] = 0;
Bt[139] = 1;
Gt[98] = 0;
Yt[98] = -1;
Xt[98] = 0;
qt[98] = 0;
zt[98] = -1;
Ut[98] = 1;
Jt[98] = 1;
Zt[98] = 0;
Kt[98] = 0;
Vt[98] = 1;
Wt[98] = 0;
Ht[98] = 1;
jt[98] = 0;
Qt[98] = 1;
$t[98] = 0;
At[98] = -1;
Tt[98] = 0;
Dt[98] = 1;
Gt[99] = 0;
Yt[99] = 1;
Xt[99] = 0;
qt[99] = 0;
zt[99] = -1;
Ut[99] = 1;
Jt[99] = 1;
Zt[99] = 0;
Kt[99] = 0;
Vt[99] = -1;
Wt[99] = 0;
Ht[99] = 1;
jt[99] = 0;
Qt[99] = -1;
$t[99] = 0;
At[99] = 1;
Tt[99] = 0;
Dt[99] = 1;
qt[38] = 0;
zt[38] = -1;
Ut[38] = 1;
Jt[38] = 1;
Zt[38] = 0;
Kt[38] = 0;
te[38] = 0;
ee[38] = 1;
ne[38] = 1;
jt[38] = 0;
Qt[38] = 1;
$t[38] = 0;
At[38] = -1;
Tt[38] = 0;
Dt[38] = 1;
Ft[38] = -1;
kt[38] = 0;
Bt[38] = 0;
qt[39] = 0;
zt[39] = 1;
Ut[39] = 1;
Jt[39] = -1;
Zt[39] = 0;
Kt[39] = 0;
te[39] = 0;
ee[39] = -1;
ne[39] = 1;
jt[39] = 0;
Qt[39] = 1;
$t[39] = 0;
At[39] = -1;
Tt[39] = 0;
Dt[39] = 1;
Ft[39] = 1;
kt[39] = 0;
Bt[39] = 0;
var E2 = function(r) {
  return [
    [r.bottomleft, 0],
    [0, 0],
    [0, r.leftbottom]
  ];
}, S2 = function(r) {
  return [
    [1, r.rightbottom],
    [1, 0],
    [r.bottomright, 0]
  ];
}, C2 = function(r) {
  return [
    [r.topright, 1],
    [1, 1],
    [1, r.righttop]
  ];
}, M2 = function(r) {
  return [
    [0, r.lefttop],
    [0, 1],
    [r.topleft, 1]
  ];
}, P2 = function(r) {
  return [
    [r.bottomright, 0],
    [r.bottomleft, 0],
    [0, r.leftbottom],
    [0, r.lefttop]
  ];
}, L2 = function(r) {
  return [
    [r.bottomright, 0],
    [r.bottomleft, 0],
    [1, r.righttop],
    [1, r.rightbottom]
  ];
}, N2 = function(r) {
  return [
    [1, r.righttop],
    [1, r.rightbottom],
    [r.topleft, 1],
    [r.topright, 1]
  ];
}, O2 = function(r) {
  return [
    [0, r.leftbottom],
    [0, r.lefttop],
    [r.topleft, 1],
    [r.topright, 1]
  ];
}, ZR = function(r) {
  return [
    [0, 0],
    [0, r.leftbottom],
    [1, r.rightbottom],
    [1, 0]
  ];
}, KR = function(r) {
  return [
    [1, 0],
    [r.bottomright, 0],
    [r.topright, 1],
    [1, 1]
  ];
}, jR = function(r) {
  return [
    [1, 1],
    [1, r.righttop],
    [0, r.lefttop],
    [0, 1]
  ];
}, QR = function(r) {
  return [
    [r.bottomleft, 0],
    [0, 0],
    [0, 1],
    [r.topleft, 1]
  ];
}, $R = function(r) {
  return [
    [1, r.righttop],
    [1, r.rightbottom],
    [0, r.leftbottom],
    [0, r.lefttop]
  ];
}, tA = function(r) {
  return [
    [r.topleft, 1],
    [r.topright, 1],
    [r.bottomright, 0],
    [r.bottomleft, 0]
  ];
}, eA = function() {
  return [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0]
  ];
}, nA = function(r) {
  return [
    [1, r.rightbottom],
    [1, 0],
    [0, 0],
    [0, 1],
    [r.topleft, 1]
  ];
}, rA = function(r) {
  return [
    [r.topright, 1],
    [1, 1],
    [1, 0],
    [0, 0],
    [0, r.leftbottom]
  ];
}, iA = function(r) {
  return [
    [1, 0],
    [r.bottomright, 0],
    [0, r.lefttop],
    [0, 1],
    [1, 1]
  ];
}, sA = function(r) {
  return [
    [1, 1],
    [1, r.righttop],
    [r.bottomleft, 0],
    [0, 0],
    [0, 1]
  ];
}, oA = function(r) {
  return [
    [1, r.righttop],
    [1, r.rightbottom],
    [0, r.lefttop],
    [0, 1],
    [r.topleft, 1]
  ];
}, aA = function(r) {
  return [
    [1, 1],
    [1, r.righttop],
    [r.bottomright, 0],
    [r.bottomleft, 0],
    [r.topright, 1]
  ];
}, uA = function(r) {
  return [
    [1, r.rightbottom],
    [1, 0],
    [r.bottomright, 0],
    [0, r.leftbottom],
    [0, r.lefttop]
  ];
}, xA = function(r) {
  return [
    [r.topright, 1],
    [r.bottomleft, 0],
    [0, 0],
    [0, r.leftbottom],
    [r.topleft, 1]
  ];
}, cA = function(r) {
  return [
    [r.bottomright, 0],
    [r.bottomleft, 0],
    [0, r.lefttop],
    [0, 1],
    [r.topleft, 1]
  ];
}, fA = function(r) {
  return [
    [1, 1],
    [1, r.righttop],
    [0, r.leftbottom],
    [0, r.lefttop],
    [r.topright, 1]
  ];
}, lA = function(r) {
  return [
    [1, r.rightbottom],
    [1, 0],
    [r.bottomright, 0],
    [r.topleft, 1],
    [r.topright, 1]
  ];
}, hA = function(r) {
  return [
    [1, r.righttop],
    [1, r.rightbottom],
    [r.bottomleft, 0],
    [0, 0],
    [0, r.leftbottom]
  ];
}, pA = function(r) {
  return [
    [1, r.rightbottom],
    [1, 0],
    [0, 0],
    [0, r.leftbottom],
    [r.topleft, 1],
    [r.topright, 1]
  ];
}, dA = function(r) {
  return [
    [1, 1],
    [1, 0],
    [r.bottomright, 0],
    [0, r.leftbottom],
    [0, r.lefttop],
    [r.topright, 1]
  ];
}, gA = function(r) {
  return [
    [1, 1],
    [1, r.righttop],
    [r.bottomright, 0],
    [r.bottomleft, 0],
    [0, r.lefttop],
    [0, 1]
  ];
}, yA = function(r) {
  return [
    [1, r.righttop],
    [1, r.rightbottom],
    [r.bottomleft, 0],
    [0, 0],
    [0, 1],
    [r.topleft, 1]
  ];
}, vA = function(r) {
  return [
    [1, 1],
    [1, r.righttop],
    [r.bottomleft, 0],
    [0, 0],
    [0, r.leftbottom],
    [r.topright, 1]
  ];
}, mA = function(r) {
  return [
    [1, r.rightbottom],
    [1, 0],
    [r.bottomright, 0],
    [0, r.lefttop],
    [0, 1],
    [r.topleft, 1]
  ];
}, _A = function(r) {
  return [
    [1, r.righttop],
    [1, r.rightbottom],
    [r.bottomright, 0],
    [r.bottomleft, 0],
    [0, r.leftbottom],
    [0, r.lefttop],
    [r.topleft, 1],
    [r.topright, 1]
  ];
}, bA = function(r) {
  return [
    [1, 1],
    [1, r.righttop],
    [r.bottomleft, 0],
    [0, 0],
    [0, r.leftbottom],
    [r.topright, 1]
  ];
}, IA = function(r) {
  return [
    [1, r.rightbottom],
    [1, 0],
    [r.bottomright, 0],
    [0, r.lefttop],
    [0, 1],
    [r.topleft, 1]
  ];
}, wA = function(r) {
  return [
    [1, 1],
    [1, r.righttop],
    [r.bottomright, 0],
    [r.bottomleft, 0],
    [0, r.leftbottom],
    [0, r.lefttop],
    [r.topright, 1]
  ];
}, EA = function(r) {
  return [
    [1, r.righttop],
    [1, r.rightbottom],
    [r.bottomleft, 0],
    [0, 0],
    [0, r.leftbottom],
    [r.topleft, 1],
    [r.topright, 1]
  ];
}, SA = function(r) {
  return [
    [1, r.righttop],
    [1, r.rightbottom],
    [r.bottomright, 0],
    [r.bottomleft, 0],
    [0, r.lefttop],
    [0, 1],
    [r.topleft, 1]
  ];
}, CA = function(r) {
  return [
    [1, r.rightbottom],
    [1, 0],
    [r.bottomright, 0],
    [0, r.leftbottom],
    [0, r.lefttop],
    [r.topleft, 1],
    [r.topright, 1]
  ];
}, Q = [], j = [], ut = [], ot = [], dt = [], lt = [], re = [], ie = [];
ot[1] = dt[1] = 18;
ot[169] = dt[169] = 18;
ut[4] = j[4] = 12;
ut[166] = j[166] = 12;
Q[16] = ie[16] = 4;
Q[154] = ie[154] = 4;
lt[64] = re[64] = 22;
lt[106] = re[106] = 22;
ut[2] = lt[2] = 17;
ot[2] = dt[2] = 18;
ut[168] = lt[168] = 17;
ot[168] = dt[168] = 18;
Q[8] = ot[8] = 9;
j[8] = ut[8] = 12;
Q[162] = ot[162] = 9;
j[162] = ut[162] = 12;
Q[32] = ie[32] = 4;
j[32] = re[32] = 1;
Q[138] = ie[138] = 4;
j[138] = re[138] = 1;
dt[128] = ie[128] = 21;
lt[128] = re[128] = 22;
dt[42] = ie[42] = 21;
lt[42] = re[42] = 22;
j[5] = dt[5] = 14;
j[165] = dt[165] = 14;
ut[20] = ie[20] = 6;
ut[150] = ie[150] = 6;
Q[80] = lt[80] = 11;
Q[90] = lt[90] = 11;
ot[65] = re[65] = 3;
ot[105] = re[105] = 3;
Q[160] = lt[160] = 11;
j[160] = dt[160] = 14;
Q[10] = lt[10] = 11;
j[10] = dt[10] = 14;
ut[130] = ie[130] = 6;
ot[130] = re[130] = 3;
ut[40] = ie[40] = 6;
ot[40] = re[40] = 3;
j[101] = re[101] = 1;
j[69] = re[69] = 1;
dt[149] = ie[149] = 21;
dt[21] = ie[21] = 21;
ut[86] = lt[86] = 17;
ut[84] = lt[84] = 17;
Q[89] = ot[89] = 9;
Q[81] = ot[81] = 9;
Q[96] = re[96] = 0;
j[96] = lt[96] = 15;
Q[74] = re[74] = 0;
j[74] = lt[74] = 15;
Q[24] = ut[24] = 8;
ot[24] = ie[24] = 7;
Q[146] = ut[146] = 8;
ot[146] = ie[146] = 7;
j[6] = lt[6] = 15;
ut[6] = dt[6] = 16;
j[164] = lt[164] = 15;
ut[164] = dt[164] = 16;
ot[129] = ie[129] = 7;
dt[129] = re[129] = 20;
ot[41] = ie[41] = 7;
dt[41] = re[41] = 20;
ut[66] = re[66] = 2;
ot[66] = lt[66] = 19;
ut[104] = re[104] = 2;
ot[104] = lt[104] = 19;
Q[144] = dt[144] = 10;
lt[144] = ie[144] = 23;
Q[26] = dt[26] = 10;
lt[26] = ie[26] = 23;
j[36] = ie[36] = 5;
ut[36] = re[36] = 2;
j[134] = ie[134] = 5;
ut[134] = re[134] = 2;
Q[9] = dt[9] = 10;
j[9] = ot[9] = 13;
Q[161] = dt[161] = 10;
j[161] = ot[161] = 13;
j[37] = ie[37] = 5;
dt[37] = re[37] = 20;
j[133] = ie[133] = 5;
dt[133] = re[133] = 20;
ut[148] = dt[148] = 16;
lt[148] = ie[148] = 23;
ut[22] = dt[22] = 16;
lt[22] = ie[22] = 23;
Q[82] = ut[82] = 8;
ot[82] = lt[82] = 19;
Q[88] = ut[88] = 8;
ot[88] = lt[88] = 19;
Q[73] = re[73] = 0;
j[73] = ot[73] = 13;
Q[97] = re[97] = 0;
j[97] = ot[97] = 13;
Q[145] = ot[145] = 9;
dt[145] = ie[145] = 21;
Q[25] = ot[25] = 9;
dt[25] = ie[25] = 21;
j[70] = re[70] = 1;
ut[70] = lt[70] = 17;
j[100] = re[100] = 1;
ut[100] = lt[100] = 17;
Q[34] = ot[34] = 9;
j[34] = ut[34] = 12;
dt[34] = ie[34] = 21;
lt[34] = re[34] = 22;
Q[136] = ie[136] = 4;
j[136] = re[136] = 1;
ut[136] = lt[136] = 17;
ot[136] = dt[136] = 18;
Q[35] = ie[35] = 4;
j[35] = ut[35] = 12;
ot[35] = dt[35] = 18;
lt[35] = re[35] = 22;
Q[153] = ie[153] = 4;
ot[153] = dt[153] = 18;
j[102] = ut[102] = 12;
lt[102] = re[102] = 22;
Q[155] = ot[155] = 9;
dt[155] = ie[155] = 23;
j[103] = re[103] = 1;
ut[103] = lt[103] = 17;
Q[152] = ie[152] = 4;
ut[152] = lt[152] = 17;
ot[152] = dt[152] = 18;
Q[156] = ut[156] = 8;
ot[156] = dt[156] = 18;
lt[156] = ie[156] = 23;
Q[137] = ie[137] = 4;
j[137] = re[137] = 1;
ot[137] = dt[137] = 18;
Q[139] = ie[139] = 4;
j[139] = ot[139] = 13;
dt[139] = re[139] = 20;
Q[98] = ot[98] = 9;
j[98] = ut[98] = 12;
lt[98] = re[98] = 22;
Q[99] = re[99] = 0;
j[99] = ut[99] = 12;
ot[99] = lt[99] = 19;
j[38] = ut[38] = 12;
dt[38] = ie[38] = 21;
lt[38] = re[38] = 22;
j[39] = ie[39] = 5;
ut[39] = dt[39] = 16;
lt[39] = re[39] = 22;
var K = [];
K[1] = K[169] = E2;
K[4] = K[166] = S2;
K[16] = K[154] = C2;
K[64] = K[106] = M2;
K[168] = K[2] = P2;
K[162] = K[8] = L2;
K[138] = K[32] = N2;
K[42] = K[128] = O2;
K[5] = K[165] = ZR;
K[20] = K[150] = KR;
K[80] = K[90] = jR;
K[65] = K[105] = QR;
K[160] = K[10] = $R;
K[130] = K[40] = tA;
K[85] = eA;
K[101] = K[69] = nA;
K[149] = K[21] = rA;
K[86] = K[84] = iA;
K[89] = K[81] = sA;
K[96] = K[74] = oA;
K[24] = K[146] = aA;
K[6] = K[164] = uA;
K[129] = K[41] = xA;
K[66] = K[104] = cA;
K[144] = K[26] = fA;
K[36] = K[134] = lA;
K[9] = K[161] = hA;
K[37] = K[133] = pA;
K[148] = K[22] = dA;
K[82] = K[88] = gA;
K[73] = K[97] = yA;
K[145] = K[25] = vA;
K[70] = K[100] = mA;
K[34] = function(r) {
  return [O2(r), L2(r)];
};
K[35] = _A;
K[136] = function(r) {
  return [N2(r), P2(r)];
};
K[153] = function(r) {
  return [C2(r), E2(r)];
};
K[102] = function(r) {
  return [S2(r), M2(r)];
};
K[155] = bA;
K[103] = IA;
K[152] = function(r) {
  return [C2(r), P2(r)];
};
K[156] = wA;
K[137] = function(r) {
  return [N2(r), E2(r)];
};
K[139] = EA;
K[98] = function(r) {
  return [L2(r), M2(r)];
};
K[99] = SA;
K[38] = function(r) {
  return [S2(r), O2(r)];
};
K[39] = CA;
function C(r, t, e) {
  return (r - t) / (e - t);
}
function Wv(r) {
  return r.constructor.toString().indexOf("Array") > -1;
}
function MA(r, t, e) {
  for (var n = r.length - 1, i = r[0].length - 1, s = { rows: n, cols: i, cells: [] }, o = t + Math.abs(e), a = 0; a < n; ++a) {
    s.cells[a] = [];
    for (var u = 0; u < i; ++u) {
      var x = 0, c = r[a + 1][u], f = r[a + 1][u + 1], l = r[a][u + 1], h = r[a][u];
      if (!(isNaN(c) || isNaN(f) || isNaN(l) || isNaN(h))) {
        x |= c < t ? 0 : c > o ? 128 : 64, x |= f < t ? 0 : f > o ? 32 : 16, x |= l < t ? 0 : l > o ? 8 : 4, x |= h < t ? 0 : h > o ? 2 : 1;
        var p = +x, y = 0;
        if (x === 17 || x === 18 || x === 33 || x === 34 || x === 38 || x === 68 || x === 72 || x === 98 || x === 102 || x === 132 || x === 136 || x === 137 || x === 152 || x === 153) {
          var v = (c + f + l + h) / 4;
          y = v > o ? 2 : v < t ? 0 : 1, x === 34 ? y === 1 ? x = 35 : y === 0 && (x = 136) : x === 136 ? y === 1 ? (x = 35, y = 4) : y === 0 && (x = 34) : x === 17 ? y === 1 ? (x = 155, y = 4) : y === 0 && (x = 153) : x === 68 ? y === 1 ? (x = 103, y = 4) : y === 0 && (x = 102) : x === 153 ? y === 1 && (x = 155) : x === 102 ? y === 1 && (x = 103) : x === 152 ? y < 2 && (x = 156, y = 1) : x === 137 ? y < 2 && (x = 139, y = 1) : x === 98 ? y < 2 && (x = 99, y = 1) : x === 38 ? y < 2 && (x = 39, y = 1) : x === 18 ? y > 0 ? (x = 156, y = 4) : x = 152 : x === 33 ? y > 0 ? (x = 139, y = 4) : x = 137 : x === 72 ? y > 0 ? (x = 99, y = 4) : x = 98 : x === 132 && (y > 0 ? (x = 39, y = 4) : x = 38);
        }
        if (x != 0 && x != 170) {
          var m, d, g, _, b, w, E, S;
          m = d = g = _ = b = w = E = S = 0.5;
          var I = [];
          x === 1 ? (g = 1 - C(t, l, h), S = 1 - C(t, c, h), I.push(ot[x])) : x === 169 ? (g = C(o, h, l), S = C(o, h, c), I.push(ot[x])) : x === 4 ? (w = 1 - C(t, f, l), _ = C(t, h, l), I.push(j[x])) : x === 166 ? (w = C(o, l, f), _ = 1 - C(o, l, h), I.push(j[x])) : x === 16 ? (b = C(t, l, f), d = C(t, c, f), I.push(Q[x])) : x === 154 ? (b = 1 - C(o, f, l), d = 1 - C(o, f, c), I.push(Q[x])) : x === 64 ? (E = C(t, h, c), m = 1 - C(t, f, c), I.push(lt[x])) : x === 106 ? (E = 1 - C(o, c, h), m = C(o, c, f), I.push(lt[x])) : x === 168 ? (_ = C(o, h, l), g = C(t, h, l), S = C(t, h, c), E = C(o, h, c), I.push(ut[x]), I.push(ot[x])) : x === 2 ? (_ = 1 - C(t, l, h), g = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), I.push(ut[x]), I.push(ot[x])) : x === 162 ? (b = C(o, l, f), w = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), I.push(ut[x]), I.push(ot[x])) : x === 8 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), I.push(Q[x]), I.push(j[x])) : x === 138 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), m = 1 - C(o, f, c), d = 1 - C(t, f, c), I.push(Q[x]), I.push(j[x])) : x === 32 ? (b = C(o, l, f), w = C(t, l, f), m = C(t, c, f), d = C(o, c, f), I.push(Q[x]), I.push(j[x])) : x === 42 ? (S = 1 - C(o, c, h), E = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f), I.push(dt[x]), I.push(lt[x])) : x === 128 && (S = C(t, h, c), E = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c), I.push(dt[x]), I.push(lt[x])), x === 5 ? (w = 1 - C(t, f, l), S = 1 - C(t, c, h), I.push(j[x])) : x === 165 ? (w = C(o, l, f), S = C(o, h, c), I.push(j[x])) : x === 20 ? (_ = C(t, h, l), d = C(t, c, f), I.push(ut[x])) : x === 150 ? (_ = 1 - C(o, l, h), d = 1 - C(o, f, c), I.push(ut[x])) : x === 80 ? (b = C(t, l, f), E = C(t, h, c), I.push(Q[x])) : x === 90 ? (b = 1 - C(o, f, l), E = 1 - C(o, c, h), I.push(Q[x])) : x === 65 ? (g = 1 - C(t, l, h), m = 1 - C(t, f, c), I.push(ot[x])) : x === 105 ? (g = C(o, h, l), m = C(o, c, f), I.push(ot[x])) : x === 160 ? (b = C(o, l, f), w = C(t, l, f), S = C(t, h, c), E = C(o, h, c), I.push(Q[x]), I.push(j[x])) : x === 10 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), S = 1 - C(o, c, h), E = 1 - C(t, c, h), I.push(Q[x]), I.push(j[x])) : x === 130 ? (_ = 1 - C(t, l, h), g = 1 - C(o, l, h), m = 1 - C(o, f, c), d = 1 - C(t, f, c), I.push(ut[x]), I.push(ot[x])) : x === 40 ? (_ = C(o, h, l), g = C(t, h, l), m = C(t, c, f), d = C(o, c, f), I.push(ut[x]), I.push(ot[x])) : x === 101 ? (w = C(o, l, f), m = C(o, c, f), I.push(j[x])) : x === 69 ? (w = 1 - C(t, f, l), m = 1 - C(t, f, c), I.push(j[x])) : x === 149 ? (S = C(o, h, c), d = 1 - C(o, f, c), I.push(dt[x])) : x === 21 ? (S = 1 - C(t, c, h), d = C(t, c, f), I.push(dt[x])) : x === 86 ? (_ = 1 - C(o, l, h), E = 1 - C(o, c, h), I.push(ut[x])) : x === 84 ? (_ = C(t, h, l), E = C(t, h, c), I.push(ut[x])) : x === 89 ? (b = 1 - C(o, f, l), g = C(o, h, l), I.push(ot[x])) : x === 81 ? (b = C(t, l, f), g = 1 - C(t, l, h), I.push(ot[x])) : x === 96 ? (b = C(o, l, f), w = C(t, l, f), E = C(t, h, c), m = C(o, c, f), I.push(Q[x]), I.push(j[x])) : x === 74 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), E = 1 - C(o, c, h), m = 1 - C(t, f, c), I.push(Q[x]), I.push(j[x])) : x === 24 ? (b = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), d = C(t, c, f), I.push(Q[x]), I.push(ot[x])) : x === 146 ? (b = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), d = 1 - C(o, f, c), I.push(Q[x]), I.push(ot[x])) : x === 6 ? (w = 1 - C(t, f, l), _ = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), I.push(j[x]), I.push(ut[x])) : x === 164 ? (w = C(o, l, f), _ = C(t, h, l), S = C(t, h, c), E = C(o, h, c), I.push(j[x]), I.push(ut[x])) : x === 129 ? (g = 1 - C(t, l, h), S = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c), I.push(ot[x]), I.push(dt[x])) : x === 41 ? (g = C(o, h, l), S = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f), I.push(ot[x]), I.push(dt[x])) : x === 66 ? (_ = 1 - C(t, l, h), g = 1 - C(o, l, h), E = 1 - C(o, c, h), m = 1 - C(t, f, c), I.push(ut[x]), I.push(ot[x])) : x === 104 ? (_ = C(o, h, l), g = C(t, h, l), E = C(t, h, c), m = C(o, c, f), I.push(ot[x]), I.push(re[x])) : x === 144 ? (b = C(t, l, f), S = C(t, h, c), E = C(o, h, c), d = 1 - C(o, f, c), I.push(Q[x]), I.push(lt[x])) : x === 26 ? (b = 1 - C(o, f, l), S = 1 - C(o, c, h), E = 1 - C(t, c, h), d = C(t, c, f), I.push(Q[x]), I.push(lt[x])) : x === 36 ? (w = C(o, l, f), _ = C(t, h, l), m = C(t, c, f), d = C(o, c, f), I.push(j[x]), I.push(ut[x])) : x === 134 ? (w = 1 - C(t, f, l), _ = 1 - C(o, l, h), m = 1 - C(o, f, c), d = 1 - C(t, f, c), I.push(j[x]), I.push(ut[x])) : x === 9 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), g = C(o, h, l), S = 1 - C(t, c, h), I.push(Q[x]), I.push(j[x])) : x === 161 ? (b = C(o, l, f), w = C(t, l, f), g = 1 - C(t, l, h), S = C(o, h, c), I.push(Q[x]), I.push(j[x])) : x === 37 ? (w = C(o, l, f), S = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f), I.push(j[x]), I.push(dt[x])) : x === 133 ? (w = 1 - C(t, f, l), S = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c), I.push(j[x]), I.push(dt[x])) : x === 148 ? (_ = C(t, h, l), S = C(t, h, c), E = C(o, h, c), d = 1 - C(o, f, c), I.push(ut[x]), I.push(lt[x])) : x === 22 ? (_ = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), d = C(t, c, f), I.push(ut[x]), I.push(lt[x])) : x === 82 ? (b = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), E = 1 - C(o, c, h), I.push(Q[x]), I.push(ot[x])) : x === 88 ? (b = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), E = C(t, h, c), I.push(Q[x]), I.push(ot[x])) : x === 73 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), g = C(o, h, l), m = 1 - C(t, f, c), I.push(Q[x]), I.push(j[x])) : x === 97 ? (b = C(o, l, f), w = C(t, l, f), g = 1 - C(t, l, h), m = C(o, c, f), I.push(Q[x]), I.push(j[x])) : x === 145 ? (b = C(t, l, f), g = 1 - C(t, l, h), S = C(o, h, c), d = 1 - C(o, f, c), I.push(Q[x]), I.push(dt[x])) : x === 25 ? (b = 1 - C(o, f, l), g = C(o, h, l), S = 1 - C(t, c, h), d = C(t, c, f), I.push(Q[x]), I.push(dt[x])) : x === 70 ? (w = 1 - C(t, f, l), _ = 1 - C(o, l, h), E = 1 - C(o, c, h), m = 1 - C(t, f, c), I.push(j[x]), I.push(ut[x])) : x === 100 ? (w = C(o, l, f), _ = C(t, h, l), E = C(t, h, c), m = C(o, c, f), I.push(j[x]), I.push(ut[x])) : x === 34 ? (y === 0 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), S = C(t, h, c), E = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c)) : (b = C(o, l, f), w = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f)), I.push(Q[x]), I.push(j[x]), I.push(dt[x]), I.push(lt[x])) : x === 35 ? (y === 4 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), S = C(t, h, c), E = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c)) : (b = C(o, l, f), w = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f)), I.push(Q[x]), I.push(j[x]), I.push(ot[x]), I.push(lt[x])) : x === 136 ? (y === 0 ? (b = C(o, l, f), w = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f)) : (b = 1 - C(t, f, l), w = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), S = C(t, h, c), E = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c)), I.push(Q[x]), I.push(j[x]), I.push(dt[x]), I.push(lt[x])) : x === 153 ? (y === 0 ? (b = C(t, l, f), g = 1 - C(t, l, h), S = 1 - C(t, c, h), d = C(t, c, f)) : (b = 1 - C(o, f, l), g = C(o, h, l), S = C(o, h, c), d = 1 - C(o, f, c)), I.push(Q[x]), I.push(ot[x])) : x === 102 ? (y === 0 ? (w = 1 - C(t, f, l), _ = C(t, h, l), E = C(t, h, c), m = 1 - C(t, f, c)) : (w = C(o, l, f), _ = 1 - C(o, l, h), E = 1 - C(o, c, h), m = C(o, c, f)), I.push(j[x]), I.push(lt[x])) : x === 155 ? (y === 4 ? (b = C(t, l, f), g = 1 - C(t, l, h), S = 1 - C(t, c, h), d = C(t, c, f)) : (b = 1 - C(o, f, l), g = C(o, h, l), S = C(o, h, c), d = 1 - C(o, f, c)), I.push(Q[x]), I.push(dt[x])) : x === 103 ? (y === 4 ? (w = 1 - C(t, f, l), _ = C(t, h, l), E = C(t, h, c), m = 1 - C(t, f, c)) : (w = C(o, l, f), _ = 1 - C(o, l, h), E = 1 - C(o, c, h), m = C(o, c, f)), I.push(j[x]), I.push(ut[x])) : x === 152 ? (y === 0 ? (b = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), d = C(t, c, f)) : (b = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), S = C(t, h, c), E = C(o, h, c), d = 1 - C(o, f, c)), I.push(Q[x]), I.push(ut[x]), I.push(ot[x])) : x === 156 ? (y === 4 ? (b = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), d = C(t, c, f)) : (b = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), S = C(t, h, c), E = C(o, h, c), d = 1 - C(o, f, c)), I.push(Q[x]), I.push(ot[x]), I.push(lt[x])) : x === 137 ? (y === 0 ? (b = C(o, l, f), w = C(t, l, f), g = 1 - C(t, l, h), S = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f)) : (b = 1 - C(t, f, l), w = 1 - C(o, f, l), g = C(o, h, l), S = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c)), I.push(Q[x]), I.push(j[x]), I.push(ot[x])) : x === 139 ? (y === 4 ? (b = C(o, l, f), w = C(t, l, f), g = 1 - C(t, l, h), S = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f)) : (b = 1 - C(t, f, l), w = 1 - C(o, f, l), g = C(o, h, l), S = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c)), I.push(Q[x]), I.push(j[x]), I.push(dt[x])) : x === 98 ? (y === 0 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), E = C(t, h, c), m = 1 - C(t, f, c)) : (b = C(o, l, f), w = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), E = 1 - C(o, c, h), m = C(o, c, f)), I.push(Q[x]), I.push(j[x]), I.push(lt[x])) : x === 99 ? (y === 4 ? (b = 1 - C(t, f, l), w = 1 - C(o, f, l), _ = C(o, h, l), g = C(t, h, l), E = C(t, h, c), m = 1 - C(t, f, c)) : (b = C(o, l, f), w = C(t, l, f), _ = 1 - C(t, l, h), g = 1 - C(o, l, h), E = 1 - C(o, c, h), m = C(o, c, f)), I.push(Q[x]), I.push(j[x]), I.push(ot[x])) : x === 38 ? (y === 0 ? (w = 1 - C(t, f, l), _ = C(t, h, l), S = C(t, h, c), E = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c)) : (w = C(o, l, f), _ = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f)), I.push(j[x]), I.push(dt[x]), I.push(lt[x])) : x === 39 ? (y === 4 ? (w = 1 - C(t, f, l), _ = C(t, h, l), S = C(t, h, c), E = C(o, h, c), m = 1 - C(o, f, c), d = 1 - C(t, f, c)) : (w = C(o, l, f), _ = 1 - C(o, l, h), S = 1 - C(o, c, h), E = 1 - C(t, c, h), m = C(t, c, f), d = C(o, c, f)), I.push(j[x]), I.push(ut[x]), I.push(lt[x])) : x === 85 && (b = 1, w = 0, _ = 1, g = 0, S = 0, E = 1, m = 0, d = 1), (m < 0 || m > 1 || d < 0 || d > 1 || b < 0 || b > 1 || _ < 0 || _ > 1 || S < 0 || S > 1 || E < 0 || E > 1) && console.log(
            "MarchingSquaresJS-isoBands: " + x + " " + p + " " + c + "," + f + "," + l + "," + h + " " + y + " " + m + " " + d + " " + b + " " + w + " " + _ + " " + g + " " + S + " " + E
          ), s.cells[a][u] = {
            cval: x,
            cval_real: p,
            flipped: y,
            topleft: m,
            topright: d,
            righttop: b,
            rightbottom: w,
            bottomright: _,
            bottomleft: g,
            leftbottom: S,
            lefttop: E,
            edges: I
          };
        }
      }
    }
  }
  return s;
}
function PA(r) {
  for (var t = [], e = r.rows, n = r.cols, i = [], s = 0; s < e; s++)
    for (var o = 0; o < n; o++)
      if (typeof r.cells[s][o] < "u" && r.cells[s][o].edges.length > 0) {
        var a = r.cells[s][o], u = OA(a), x = null, c = o, f = s;
        u !== null && i.push([u.p[0] + c, u.p[1] + f]);
        do {
          if (x = RA(r.cells[f][c], u.x, u.y, u.o), x !== null)
            i.push([x.p[0] + c, x.p[1] + f]), c += x.x, f += x.y, u = x;
          else
            break;
          if (f < 0 || f >= e || c < 0 || c >= n || typeof r.cells[f][c] > "u") {
            c -= x.x, f -= x.y;
            var l = LA(
              r,
              c,
              f,
              x.x,
              x.y,
              x.o
            );
            if (l !== null)
              l.path.forEach(function(h) {
                i.push(h);
              }), c = l.i, f = l.j, u = l;
            else
              break;
          }
        } while (typeof r.cells[f][c] < "u" && r.cells[f][c].edges.length > 0);
        t.push(i), i = [], r.cells[s][o].edges.length > 0 && o--;
      }
  return t;
}
function LA(r, t, e, n, i, s) {
  for (var o = r.cells[e][t], a = o.cval_real, u = t + n, x = e + i, c = [], f = !1; !f; ) {
    if (typeof r.cells[x] > "u" || typeof r.cells[x][u] > "u")
      if (x -= i, u -= n, o = r.cells[x][u], a = o.cval_real, i === -1)
        if (s === 0)
          if (a & pr)
            c.push([u, x]), n = -1, i = 0, s = 0;
          else if (a & er)
            c.push([u + 1, x]), n = 1, i = 0, s = 0;
          else {
            c.push([u + o.bottomright, x]), n = 0, i = 1, s = 1, f = !0;
            break;
          }
        else if (a & pr)
          c.push([u, x]), n = -1, i = 0, s = 0;
        else if (a & er) {
          c.push([u + o.bottomright, x]), n = 0, i = 1, s = 1, f = !0;
          break;
        } else {
          c.push([u + o.bottomleft, x]), n = 0, i = 1, s = 0, f = !0;
          break;
        }
      else if (i === 1)
        if (s === 0)
          if (a & ps)
            c.push([u + 1, x + 1]), n = 1, i = 0, s = 1;
          else if (a & Rr) {
            c.push([u + o.topleft, x + 1]), n = 0, i = -1, s = 0, f = !0;
            break;
          } else {
            c.push([u + o.topright, x + 1]), n = 0, i = -1, s = 1, f = !0;
            break;
          }
        else a & ps ? (c.push([u + 1, x + 1]), n = 1, i = 0, s = 1) : (c.push([u + 1, x + 1]), n = 1, i = 0, s = 1);
      else if (n === -1)
        if (s === 0)
          if (a & Rr)
            c.push([u, x + 1]), n = 0, i = 1, s = 0;
          else if (a & pr) {
            c.push([u, x + o.leftbottom]), n = 1, i = 0, s = 0, f = !0;
            break;
          } else {
            c.push([u, x + o.lefttop]), n = 1, i = 0, s = 1, f = !0;
            break;
          }
        else if (a & Rr)
          c.push([u, x + 1]), n = 0, i = 1, s = 0;
        else {
          console.log("MarchingSquaresJS-isoBands: wtf");
          break;
        }
      else if (n === 1)
        if (s === 0)
          if (a & er)
            c.push([u + 1, x]), n = 0, i = -1, s = 1;
          else {
            c.push([u + 1, x + o.rightbottom]), n = -1, i = 0, s = 0, f = !0;
            break;
          }
        else if (a & er)
          c.push([u + 1, x]), n = 0, i = -1, s = 1;
        else if (a & ps) {
          c.push([u + 1, x + o.righttop]), n = -1, i = 0, s = 1;
          break;
        } else {
          c.push([u + 1, x + o.rightbottom]), n = -1, i = 0, s = 0, f = !0;
          break;
        }
      else {
        console.log("MarchingSquaresJS-isoBands: we came from nowhere!");
        break;
      }
    else if (o = r.cells[x][u], a = o.cval_real, n === -1)
      if (s === 0)
        if (typeof r.cells[x - 1] < "u" && typeof r.cells[x - 1][u] < "u")
          n = 0, i = -1, s = 1;
        else if (a & pr)
          c.push([u, x]);
        else {
          c.push([u + o.bottomright, x]), n = 0, i = 1, s = 1, f = !0;
          break;
        }
      else if (a & Rr)
        console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!");
      else {
        console.log(
          "MarchingSquaresJS-isoBands: found entry from top at " + u + "," + x
        );
        break;
      }
    else if (n === 1)
      if (s === 0) {
        console.log("MarchingSquaresJS-isoBands: wtf");
        break;
      } else if (typeof r.cells[x + 1] < "u" && typeof r.cells[x + 1][u] < "u")
        n = 0, i = 1, s = 0;
      else if (a & ps)
        c.push([u + 1, x + 1]), n = 1, i = 0, s = 1;
      else {
        c.push([u + o.topleft, x + 1]), n = 0, i = -1, s = 0, f = !0;
        break;
      }
    else if (i === -1)
      if (s === 1)
        if (typeof r.cells[x][u + 1] < "u")
          n = 1, i = 0, s = 1;
        else if (a & er)
          c.push([u + 1, x]), n = 0, i = -1, s = 1;
        else {
          c.push([u + 1, x + o.righttop]), n = -1, i = 0, s = 1, f = !0;
          break;
        }
      else {
        console.log("MarchingSquaresJS-isoBands: wtf");
        break;
      }
    else if (i === 1)
      if (s === 0)
        if (typeof r.cells[x][u - 1] < "u")
          n = -1, i = 0, s = 0;
        else if (a & Rr)
          c.push([u, x + 1]), n = 0, i = 1, s = 0;
        else {
          c.push([u, x + o.leftbottom]), n = 1, i = 0, s = 0, f = !0;
          break;
        }
      else {
        console.log("MarchingSquaresJS-isoBands: wtf");
        break;
      }
    else {
      console.log("MarchingSquaresJS-isoBands: where did we came from???");
      break;
    }
    if (u += n, x += i, u === t && x === e)
      break;
  }
  return { path: c, i: u, j: x, x: n, y: i, o: s };
}
function NA(r, t) {
  delete r.edges[t];
  for (var e = t + 1; e < r.edges.length; e++)
    r.edges[e - 1] = r.edges[e];
  r.edges.pop();
}
function OA(r) {
  if (r.edges.length > 0) {
    var t = r.edges[r.edges.length - 1], e = r.cval_real;
    switch (t) {
      case 0:
        return e & ps ? { p: [1, r.righttop], x: -1, y: 0, o: 1 } : { p: [r.topleft, 1], x: 0, y: -1, o: 0 };
      case 1:
        return e & er ? { p: [r.topleft, 1], x: 0, y: -1, o: 0 } : { p: [1, r.rightbottom], x: -1, y: 0, o: 0 };
      case 2:
        return e & er ? { p: [r.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [r.topleft, 1], x: 0, y: -1, o: 0 };
      case 3:
        return e & pr ? { p: [r.topleft, 1], x: 0, y: -1, o: 0 } : { p: [r.bottomleft, 0], x: 0, y: 1, o: 0 };
      case 4:
        return e & ps ? { p: [1, r.righttop], x: -1, y: 0, o: 1 } : { p: [r.topright, 1], x: 0, y: -1, o: 1 };
      case 5:
        return e & er ? { p: [r.topright, 1], x: 0, y: -1, o: 1 } : { p: [1, r.rightbottom], x: -1, y: 0, o: 0 };
      case 6:
        return e & er ? { p: [r.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [r.topright, 1], x: 0, y: -1, o: 1 };
      case 7:
        return e & pr ? { p: [r.topright, 1], x: 0, y: -1, o: 1 } : { p: [r.bottomleft, 0], x: 0, y: 1, o: 0 };
      case 8:
        return e & er ? { p: [r.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [1, r.righttop], x: -1, y: 0, o: 1 };
      case 9:
        return e & pr ? { p: [1, r.righttop], x: -1, y: 0, o: 1 } : { p: [r.bottomleft, 0], x: 0, y: 1, o: 0 };
      case 10:
        return e & pr ? { p: [0, r.leftbottom], x: 1, y: 0, o: 0 } : { p: [1, r.righttop], x: -1, y: 0, o: 1 };
      case 11:
        return e & Rr ? { p: [1, r.righttop], x: -1, y: 0, o: 1 } : { p: [0, r.lefttop], x: 1, y: 0, o: 1 };
      case 12:
        return e & er ? { p: [r.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [1, r.rightbottom], x: -1, y: 0, o: 0 };
      case 13:
        return e & pr ? { p: [1, r.rightbottom], x: -1, y: 0, o: 0 } : { p: [r.bottomleft, 0], x: 0, y: 1, o: 0 };
      case 14:
        return e & pr ? { p: [0, r.leftbottom], x: 1, y: 0, o: 0 } : { p: [1, r.rightbottom], x: -1, y: 0, o: 0 };
      case 15:
        return e & Rr ? { p: [1, r.rightbottom], x: -1, y: 0, o: 0 } : { p: [0, r.lefttop], x: 1, y: 0, o: 1 };
      case 16:
        return e & er ? { p: [r.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [0, r.leftbottom], x: 1, y: 0, o: 0 };
      case 17:
        return e & Rr ? { p: [r.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [0, r.lefttop], x: 1, y: 0, o: 1 };
      case 18:
        return e & pr ? { p: [0, r.leftbottom], x: 1, y: 0, o: 0 } : { p: [r.bottomleft, 0], x: 0, y: 1, o: 0 };
      case 19:
        return e & Rr ? { p: [r.bottomleft, 0], x: 0, y: 1, o: 0 } : { p: [0, r.lefttop], x: 1, y: 0, o: 1 };
      case 20:
        return e & Rr ? { p: [r.topleft, 1], x: 0, y: -1, o: 0 } : { p: [0, r.leftbottom], x: 1, y: 0, o: 0 };
      case 21:
        return e & ps ? { p: [0, r.leftbottom], x: 1, y: 0, o: 0 } : { p: [r.topright, 1], x: 0, y: -1, o: 1 };
      case 22:
        return e & Rr ? { p: [r.topleft, 1], x: 0, y: -1, o: 0 } : { p: [0, r.lefttop], x: 1, y: 0, o: 1 };
      case 23:
        return e & ps ? { p: [0, r.lefttop], x: 1, y: 0, o: 1 } : { p: [r.topright, 1], x: 0, y: -1, o: 1 };
      default:
        console.log("MarchingSquaresJS-isoBands: edge index out of range!"), console.log(r);
        break;
    }
  }
  return null;
}
function RA(r, t, e, n) {
  var i, s, o, a, u = r.cval, x;
  switch (t) {
    case -1:
      switch (n) {
        case 0:
          i = j[u], o = qt[u], a = zt[u], x = Ut[u];
          break;
        default:
          i = Q[u], o = Gt[u], a = Yt[u], x = Xt[u];
          break;
      }
      break;
    case 1:
      switch (n) {
        case 0:
          i = dt[u], o = te[u], a = ee[u], x = ne[u];
          break;
        default:
          i = lt[u], o = jt[u], a = Qt[u], x = $t[u];
          break;
      }
      break;
    default:
      switch (e) {
        case -1:
          switch (n) {
            case 0:
              i = re[u], o = At[u], a = Tt[u], x = Dt[u];
              break;
            default:
              i = ie[u], o = Ft[u], a = kt[u], x = Bt[u];
              break;
          }
          break;
        case 1:
          switch (n) {
            case 0:
              i = ot[u], o = Vt[u], a = Wt[u], x = Ht[u];
              break;
            default:
              i = ut[u], o = Jt[u], a = Zt[u], x = Kt[u];
              break;
          }
          break;
      }
      break;
  }
  if (s = r.edges.indexOf(i), typeof r.edges[s] < "u")
    NA(r, s);
  else
    return null;
  switch (u = r.cval_real, i) {
    case 0:
      u & ps ? (t = r.topleft, e = 1) : (t = 1, e = r.righttop);
      break;
    case 1:
      u & er ? (t = 1, e = r.rightbottom) : (t = r.topleft, e = 1);
      break;
    case 2:
      u & er ? (t = r.topleft, e = 1) : (t = r.bottomright, e = 0);
      break;
    case 3:
      u & pr ? (t = r.bottomleft, e = 0) : (t = r.topleft, e = 1);
      break;
    case 4:
      u & ps ? (t = r.topright, e = 1) : (t = 1, e = r.righttop);
      break;
    case 5:
      u & er ? (t = 1, e = r.rightbottom) : (t = r.topright, e = 1);
      break;
    case 6:
      u & er ? (t = r.topright, e = 1) : (t = r.bottomright, e = 0);
      break;
    case 7:
      u & pr ? (t = r.bottomleft, e = 0) : (t = r.topright, e = 1);
      break;
    case 8:
      u & er ? (t = 1, e = r.righttop) : (t = r.bottomright, e = 0);
      break;
    case 9:
      u & pr ? (t = r.bottomleft, e = 0) : (t = 1, e = r.righttop);
      break;
    case 10:
      u & pr ? (t = 1, e = r.righttop) : (t = 0, e = r.leftbottom);
      break;
    case 11:
      u & Rr ? (t = 0, e = r.lefttop) : (t = 1, e = r.righttop);
      break;
    case 12:
      u & er ? (t = 1, e = r.rightbottom) : (t = r.bottomright, e = 0);
      break;
    case 13:
      u & pr ? (t = r.bottomleft, e = 0) : (t = 1, e = r.rightbottom);
      break;
    case 14:
      u & pr ? (t = 1, e = r.rightbottom) : (t = 0, e = r.leftbottom);
      break;
    case 15:
      u & Rr ? (t = 0, e = r.lefttop) : (t = 1, e = r.rightbottom);
      break;
    case 16:
      u & er ? (t = 0, e = r.leftbottom) : (t = r.bottomright, e = 0);
      break;
    case 17:
      u & Rr ? (t = 0, e = r.lefttop) : (t = r.bottomright, e = 0);
      break;
    case 18:
      u & pr ? (t = r.bottomleft, e = 0) : (t = 0, e = r.leftbottom);
      break;
    case 19:
      u & Rr ? (t = 0, e = r.lefttop) : (t = r.bottomleft, e = 0);
      break;
    case 20:
      u & Rr ? (t = 0, e = r.leftbottom) : (t = r.topleft, e = 1);
      break;
    case 21:
      u & ps ? (t = r.topright, e = 1) : (t = 0, e = r.leftbottom);
      break;
    case 22:
      u & Rr ? (t = 0, e = r.lefttop) : (t = r.topleft, e = 1);
      break;
    case 23:
      u & ps ? (t = r.topright, e = 1) : (t = 0, e = r.lefttop);
      break;
    default:
      return console.log("MarchingSquaresJS-isoBands: edge index out of range!"), console.log(r), null;
  }
  return (typeof t > "u" || typeof e > "u" || typeof o > "u" || typeof a > "u" || typeof x > "u") && (console.log("MarchingSquaresJS-isoBands: undefined value!"), console.log(r), console.log(t + " " + e + " " + o + " " + a + " " + x)), { p: [t, e], x: o, y: a, o: x };
}
function AA(r) {
  var t = [], e = 0;
  return r.cells.forEach(function(n, i) {
    n.forEach(function(s, o) {
      if (typeof s < "u") {
        var a = K[s.cval](s);
        typeof a == "object" && Wv(a) ? typeof a[0] == "object" && Wv(a[0]) ? typeof a[0][0] == "object" && Wv(a[0][0]) ? a.forEach(function(u) {
          u.forEach(function(x) {
            x[0] += o, x[1] += i;
          }), t[e++] = u;
        }) : (a.forEach(function(u) {
          u[0] += o, u[1] += i;
        }), t[e++] = a) : console.log(
          "MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates"
        ) : console.log(
          "MarchingSquaresJS-isoBands: bandcell polygon with null coordinates"
        );
      }
    });
  }), t;
}
function TA(r, t, e) {
  if (e = e || {}, !we(e)) throw new Error("options is invalid");
  var n = e.zProperty || "elevation", i = e.commonProperties || {}, s = e.breaksProperties || [];
  if (Ia(r, "Point", "Input must contain Points"), !t) throw new Error("breaks is required");
  if (!Array.isArray(t)) throw new Error("breaks is not an Array");
  if (!we(i))
    throw new Error("commonProperties is not an Object");
  if (!Array.isArray(s))
    throw new Error("breaksProperties is not an Array");
  var o = WR(r, { zProperty: n, flip: !0 }), a = DA(o, t, n);
  a = FA(a, o, r);
  var u = a.map(function(x, c) {
    if (s[c] && !we(s[c]))
      throw new Error("Each mappedProperty is required to be an Object");
    var f = Z_(
      {},
      i,
      s[c]
    );
    f[n] = x[n];
    var l = Mi(x.groupedRings, f);
    return l;
  });
  return ht(u);
}
function DA(r, t, e) {
  for (var n = [], i = 1; i < t.length; i++) {
    var s = +t[i - 1], o = +t[i], a = JR(r, s, o - s), u = kA(a), x = BA(u), c = {};
    c.groupedRings = x, c[e] = s + "-" + o, n.push(c);
  }
  return n;
}
function FA(r, t, e) {
  var n = Cn(e), i = n[2] - n[0], s = n[3] - n[1], o = n[0], a = n[1], u = t[0].length - 1, x = t.length - 1, c = i / u, f = s / x, l = function(h) {
    h[0] = h[0] * c + o, h[1] = h[1] * f + a;
  };
  return r.forEach(function(h) {
    h.groupedRings.forEach(function(p) {
      p.forEach(function(y) {
        y.forEach(l);
      });
    });
  }), r;
}
function kA(r) {
  var t = [], e = [];
  r.forEach(function(i) {
    var s = p2(Nt([i]));
    e.push(s), t.push({ ring: i, area: s });
  }), e.sort(function(i, s) {
    return s - i;
  });
  var n = [];
  return e.forEach(function(i) {
    for (var s = 0; s < t.length; s++)
      if (t[s].area === i) {
        n.push(t[s].ring), t.splice(s, 1);
        break;
      }
  }), n;
}
function BA(r) {
  for (var t = r.map(function(u) {
    return { lrCoordinates: u, grouped: !1 };
  }), e = []; !YA(t); )
    for (var n = 0; n < t.length; n++)
      if (!t[n].grouped) {
        var i = [];
        i.push(t[n].lrCoordinates), t[n].grouped = !0;
        for (var s = Nt([t[n].lrCoordinates]), o = n + 1; o < t.length; o++)
          if (!t[o].grouped) {
            var a = Nt([t[o].lrCoordinates]);
            GA(a, s) && (i.push(t[o].lrCoordinates), t[o].grouped = !0);
          }
        e.push(i);
      }
  return e;
}
function GA(r, t) {
  for (var e = Ly(r), n = 0; n < e.features.length; n++)
    if (!Fe(e.features[n], t))
      return !1;
  return !0;
}
function YA(r) {
  for (var t = 0; t < r.length; t++)
    if (r[t].grouped === !1)
      return !1;
  return !0;
}
function eS(r, t, e) {
  if (e = e || {}, !we(e)) throw new Error("options is invalid");
  var n = e.pivot, i = e.mutate;
  if (!r) throw new Error("geojson is required");
  if (t == null || isNaN(t))
    throw new Error("angle is required");
  return t === 0 || (n || (n = Ka(r)), (i === !1 || i === void 0) && (r = br(r)), hn(r, function(s) {
    var o = H0(n, s), a = o + t, u = ky(n, s), x = gt(Ox(n, u, a));
    s[0] = x[0], s[1] = x[1];
  })), r;
}
function nS(r, t, e) {
  if (e = e || {}, !we(e)) throw new Error("options is invalid");
  var n = e.origin, i = e.mutate;
  if (!r) throw new Error("geojson required");
  if (typeof t != "number" || t === 0)
    throw new Error("invalid factor");
  var s = Array.isArray(n) || typeof n == "object";
  return i !== !0 && (r = br(r)), r.type === "FeatureCollection" && !s ? (he(r, function(o, a) {
    r.features[a] = kI(o, t, n);
  }), r) : kI(r, t, n);
}
function kI(r, t, e) {
  var n = oi(r) === "Point";
  return e = XA(r, e), t === 1 || n || hn(r, function(i) {
    var s = ky(e, i), o = H0(e, i), a = s * t, u = gt(Ox(e, a, o));
    i[0] = u[0], i[1] = u[1], i.length === 3 && (i[2] *= t);
  }), r;
}
function XA(r, t) {
  if (t == null && (t = "centroid"), Array.isArray(t) || typeof t == "object")
    return Ae(t);
  var e = r.bbox ? r.bbox : Cn(r), n = e[0], i = e[1], s = e[2], o = e[3];
  switch (t) {
    case "sw":
    case "southwest":
    case "westsouth":
    case "bottomleft":
      return Pt([n, i]);
    case "se":
    case "southeast":
    case "eastsouth":
    case "bottomright":
      return Pt([s, i]);
    case "nw":
    case "northwest":
    case "westnorth":
    case "topleft":
      return Pt([n, o]);
    case "ne":
    case "northeast":
    case "eastnorth":
    case "topright":
      return Pt([s, o]);
    case "center":
      return Py(r);
    case void 0:
    case null:
    case "centroid":
      return Ka(r);
    default:
      throw new Error("invalid origin");
  }
}
function qA(r, t, e, n) {
  if (n = n || {}, !we(n)) throw new Error("options is invalid");
  var i = n.units, s = n.zTranslation, o = n.mutate;
  if (!r) throw new Error("geojson is required");
  if (t == null || isNaN(t))
    throw new Error("distance is required");
  if (s && typeof s != "number" && isNaN(s))
    throw new Error("zTranslation is not a number");
  if (s = s !== void 0 ? s : 0, t === 0 && s === 0) return r;
  if (e == null || isNaN(e))
    throw new Error("direction is required");
  return t < 0 && (t = -t, e = e + 180), (o === !1 || o === void 0) && (r = br(r)), hn(r, function(a) {
    var u = gt(
      Ox(a, t, e, { units: i })
    );
    a[0] = u[0], a[1] = u[1], s && a.length === 3 && (a[2] += s);
  }), r;
}
function Lg(r) {
  var t = r[0], e = r[1];
  return [e[0] - t[0], e[1] - t[1]];
}
function Km(r, t) {
  return r[0] * t[1] - t[0] * r[1];
}
function zA(r, t) {
  return [r[0] + t[0], r[1] + t[1]];
}
function UA(r, t) {
  return [r[0] - t[0], r[1] - t[1]];
}
function VA(r, t) {
  return [r * t[0], r * t[1]];
}
function WA(r, t) {
  var e = r[0], n = Lg(r), i = t[0], s = Lg(t), o = Km(n, s), a = UA(i, e), u = Km(a, s), x = u / o, c = zA(e, VA(x, n));
  return c;
}
function HA(r, t) {
  var e = Lg(r), n = Lg(t);
  return Km(e, n) === 0;
}
function JA(r, t) {
  return HA(r, t) ? !1 : WA(r, t);
}
function rS(r, t, e) {
  if (e = e || {}, !we(e)) throw new Error("options is invalid");
  var n = e.units;
  if (!r) throw new Error("geojson is required");
  if (t == null || isNaN(t))
    throw new Error("distance is required");
  var i = oi(r), s = r.properties;
  switch (i) {
    case "LineString":
      return BI(r, t, n);
    case "MultiLineString":
      var o = [];
      return sr(r, function(a) {
        o.push(
          BI(a, t, n).geometry.coordinates
        );
      }), c0(o, s);
    default:
      throw new Error("geometry " + i + " is not supported");
  }
}
function BI(r, t, e) {
  var n = [], i = wg(t, e), s = gt(r), o = [];
  return s.forEach(function(a, u) {
    if (u !== s.length - 1) {
      var x = ZA(
        a,
        s[u + 1],
        i
      );
      if (n.push(x), u > 0) {
        var c = n[u - 1], f = JA(x, c);
        f !== !1 && (c[1] = f, x[0] = f), o.push(c[0]), u === s.length - 2 && (o.push(x[0]), o.push(x[1]));
      }
      s.length === 2 && (o.push(x[0]), o.push(x[1]));
    }
  }), ge(o, r.properties);
}
function ZA(r, t, e) {
  var n = Math.sqrt(
    (r[0] - t[0]) * (r[0] - t[0]) + (r[1] - t[1]) * (r[1] - t[1])
  ), i = r[0] + e * (t[1] - r[1]) / n, s = t[0] + e * (t[1] - r[1]) / n, o = r[1] + e * (r[0] - t[0]) / n, a = t[1] + e * (r[0] - t[0]) / n;
  return [
    [i, o],
    [s, a]
  ];
}
function KA(r) {
  return (r > 0) - (r < 0) || +r;
}
function R2(r, t, e) {
  var n = t[0] - r[0], i = t[1] - r[1], s = e[0] - t[0], o = e[1] - t[1];
  return KA(n * o - s * i);
}
function jA(r, t) {
  var e = r.geometry.coordinates[0].map(function(o) {
    return o[0];
  }), n = r.geometry.coordinates[0].map(function(o) {
    return o[1];
  }), i = t.geometry.coordinates[0].map(function(o) {
    return o[0];
  }), s = t.geometry.coordinates[0].map(function(o) {
    return o[1];
  });
  return Math.max.apply(null, e) === Math.max.apply(null, i) && Math.max.apply(null, n) === Math.max.apply(null, s) && Math.min.apply(null, e) === Math.min.apply(null, i) && Math.min.apply(null, n) === Math.min.apply(null, s);
}
function GI(r, t) {
  return t.geometry.coordinates[0].every(function(e) {
    return Fe(Pt(e), r);
  });
}
function QA(r, t) {
  return r[0] === t[0] && r[1] === t[1];
}
var YI = (
  /** @class */
  function() {
    function r(t) {
      this.id = r.buildId(t), this.coordinates = t, this.innerEdges = [], this.outerEdges = [], this.outerEdgesSorted = !1;
    }
    return r.buildId = function(t) {
      return t.join(",");
    }, r.prototype.removeInnerEdge = function(t) {
      this.innerEdges = this.innerEdges.filter(function(e) {
        return e.from.id !== t.from.id;
      });
    }, r.prototype.removeOuterEdge = function(t) {
      this.outerEdges = this.outerEdges.filter(function(e) {
        return e.to.id !== t.to.id;
      });
    }, r.prototype.addOuterEdge = function(t) {
      this.outerEdges.push(t), this.outerEdgesSorted = !1;
    }, r.prototype.sortOuterEdges = function() {
      var t = this;
      this.outerEdgesSorted || (this.outerEdges.sort(function(e, n) {
        var i = e.to, s = n.to;
        if (i.coordinates[0] - t.coordinates[0] >= 0 && s.coordinates[0] - t.coordinates[0] < 0)
          return 1;
        if (i.coordinates[0] - t.coordinates[0] < 0 && s.coordinates[0] - t.coordinates[0] >= 0)
          return -1;
        if (i.coordinates[0] - t.coordinates[0] === 0 && s.coordinates[0] - t.coordinates[0] === 0)
          return i.coordinates[1] - t.coordinates[1] >= 0 || s.coordinates[1] - t.coordinates[1] >= 0 ? i.coordinates[1] - s.coordinates[1] : s.coordinates[1] - i.coordinates[1];
        var o = R2(t.coordinates, i.coordinates, s.coordinates);
        if (o < 0)
          return 1;
        if (o > 0)
          return -1;
        var a = Math.pow(i.coordinates[0] - t.coordinates[0], 2) + Math.pow(i.coordinates[1] - t.coordinates[1], 2), u = Math.pow(s.coordinates[0] - t.coordinates[0], 2) + Math.pow(s.coordinates[1] - t.coordinates[1], 2);
        return a - u;
      }), this.outerEdgesSorted = !0);
    }, r.prototype.getOuterEdges = function() {
      return this.sortOuterEdges(), this.outerEdges;
    }, r.prototype.getOuterEdge = function(t) {
      return this.sortOuterEdges(), this.outerEdges[t];
    }, r.prototype.addInnerEdge = function(t) {
      this.innerEdges.push(t);
    }, r;
  }()
), $A = (
  /** @class */
  function() {
    function r(t, e) {
      this.from = t, this.to = e, this.next = void 0, this.label = void 0, this.symetric = void 0, this.ring = void 0, this.from.addOuterEdge(this), this.to.addInnerEdge(this);
    }
    return r.prototype.getSymetric = function() {
      return this.symetric || (this.symetric = new r(this.to, this.from), this.symetric.symetric = this), this.symetric;
    }, r.prototype.deleteEdge = function() {
      this.from.removeOuterEdge(this), this.to.removeInnerEdge(this);
    }, r.prototype.isEqual = function(t) {
      return this.from.id === t.from.id && this.to.id === t.to.id;
    }, r.prototype.toString = function() {
      return "Edge { " + this.from.id + " -> " + this.to.id + " }";
    }, r.prototype.toLineString = function() {
      return ge([this.from.coordinates, this.to.coordinates]);
    }, r.prototype.compareTo = function(t) {
      return R2(t.from.coordinates, t.to.coordinates, this.to.coordinates);
    }, r;
  }()
), iS = (
  /** @class */
  function() {
    function r() {
      this.edges = [], this.polygon = void 0, this.envelope = void 0;
    }
    return r.prototype.push = function(t) {
      this.edges.push(t), this.polygon = this.envelope = void 0;
    }, r.prototype.get = function(t) {
      return this.edges[t];
    }, Object.defineProperty(r.prototype, "length", {
      /**
       * Getter of length property.
       *
       * @memberof EdgeRing
       * @returns {number} - Length of the edge ring.
       */
      get: function() {
        return this.edges.length;
      },
      enumerable: !0,
      configurable: !0
    }), r.prototype.forEach = function(t) {
      this.edges.forEach(t);
    }, r.prototype.map = function(t) {
      return this.edges.map(t);
    }, r.prototype.some = function(t) {
      return this.edges.some(t);
    }, r.prototype.isValid = function() {
      return !0;
    }, r.prototype.isHole = function() {
      var t = this, e = this.edges.reduce(function(o, a, u) {
        return a.from.coordinates[1] > t.edges[o].from.coordinates[1] && (o = u), o;
      }, 0), n = (e === 0 ? this.length : e) - 1, i = (e + 1) % this.length, s = R2(this.edges[n].from.coordinates, this.edges[e].from.coordinates, this.edges[i].from.coordinates);
      return s === 0 ? this.edges[n].from.coordinates[0] > this.edges[i].from.coordinates[0] : s > 0;
    }, r.prototype.toMultiPoint = function() {
      return Gl(this.edges.map(function(t) {
        return t.from.coordinates;
      }));
    }, r.prototype.toPolygon = function() {
      if (this.polygon)
        return this.polygon;
      var t = this.edges.map(function(e) {
        return e.from.coordinates;
      });
      return t.push(this.edges[0].from.coordinates), this.polygon = Nt([t]);
    }, r.prototype.getEnvelope = function() {
      return this.envelope ? this.envelope : this.envelope = zw(this.toPolygon());
    }, r.findEdgeRingContaining = function(t, e) {
      var n = t.getEnvelope(), i, s;
      return e.forEach(function(o) {
        var a = o.getEnvelope();
        if (s && (i = s.getEnvelope()), !jA(a, n) && GI(a, n)) {
          for (var u = t.map(function(p) {
            return p.from.coordinates;
          }), x = void 0, c = function(p) {
            o.some(function(y) {
              return QA(p, y.from.coordinates);
            }) || (x = p);
          }, f = 0, l = u; f < l.length; f++) {
            var h = l[f];
            c(h);
          }
          x && o.inside(Pt(x)) && (!s || GI(i, a)) && (s = o);
        }
      }), s;
    }, r.prototype.inside = function(t) {
      return Fe(t, this.toPolygon());
    }, r;
  }()
);
function tT(r) {
  if (!r)
    throw new Error("No geojson passed");
  if (r.type !== "FeatureCollection" && r.type !== "GeometryCollection" && r.type !== "MultiLineString" && r.type !== "LineString" && r.type !== "Feature")
    throw new Error("Invalid input type '" + r.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
}
var eT = (
  /** @class */
  function() {
    function r() {
      this.edges = [], this.nodes = {};
    }
    return r.fromGeoJson = function(t) {
      tT(t);
      var e = new r();
      return sr(t, function(n) {
        il(n, "LineString", "Graph::fromGeoJson"), X_(n, function(i, s) {
          if (i) {
            var o = e.getNode(i), a = e.getNode(s);
            e.addEdge(o, a);
          }
          return s;
        });
      }), e;
    }, r.prototype.getNode = function(t) {
      var e = YI.buildId(t), n = this.nodes[e];
      return n || (n = this.nodes[e] = new YI(t)), n;
    }, r.prototype.addEdge = function(t, e) {
      var n = new $A(t, e), i = n.getSymetric();
      this.edges.push(n), this.edges.push(i);
    }, r.prototype.deleteDangles = function() {
      var t = this;
      Object.keys(this.nodes).map(function(e) {
        return t.nodes[e];
      }).forEach(function(e) {
        return t._removeIfDangle(e);
      });
    }, r.prototype._removeIfDangle = function(t) {
      var e = this;
      if (t.innerEdges.length <= 1) {
        var n = t.getOuterEdges().map(function(i) {
          return i.to;
        });
        this.removeNode(t), n.forEach(function(i) {
          return e._removeIfDangle(i);
        });
      }
    }, r.prototype.deleteCutEdges = function() {
      var t = this;
      this._computeNextCWEdges(), this._findLabeledEdgeRings(), this.edges.forEach(function(e) {
        e.label === e.symetric.label && (t.removeEdge(e.symetric), t.removeEdge(e));
      });
    }, r.prototype._computeNextCWEdges = function(t) {
      var e = this;
      typeof t > "u" ? Object.keys(this.nodes).forEach(function(n) {
        return e._computeNextCWEdges(e.nodes[n]);
      }) : t.getOuterEdges().forEach(function(n, i) {
        t.getOuterEdge((i === 0 ? t.getOuterEdges().length : i) - 1).symetric.next = n;
      });
    }, r.prototype._computeNextCCWEdges = function(t, e) {
      for (var n = t.getOuterEdges(), i, s, o = n.length - 1; o >= 0; --o) {
        var a = n[o], u = a.symetric, x = void 0, c = void 0;
        a.label === e && (x = a), u.label === e && (c = u), !(!x || !c) && (c && (s = c), x && (s && (s.next = x, s = void 0), i || (i = x)));
      }
      s && (s.next = i);
    }, r.prototype._findLabeledEdgeRings = function() {
      var t = [], e = 0;
      return this.edges.forEach(function(n) {
        if (!(n.label >= 0)) {
          t.push(n);
          var i = n;
          do
            i.label = e, i = i.next;
          while (!n.isEqual(i));
          e++;
        }
      }), t;
    }, r.prototype.getEdgeRings = function() {
      var t = this;
      this._computeNextCWEdges(), this.edges.forEach(function(n) {
        n.label = void 0;
      }), this._findLabeledEdgeRings().forEach(function(n) {
        t._findIntersectionNodes(n).forEach(function(i) {
          t._computeNextCCWEdges(i, n.label);
        });
      });
      var e = [];
      return this.edges.forEach(function(n) {
        n.ring || e.push(t._findEdgeRing(n));
      }), e;
    }, r.prototype._findIntersectionNodes = function(t) {
      var e = [], n = t, i = function() {
        var s = 0;
        n.from.getOuterEdges().forEach(function(o) {
          o.label === t.label && ++s;
        }), s > 1 && e.push(n.from), n = n.next;
      };
      do
        i();
      while (!t.isEqual(n));
      return e;
    }, r.prototype._findEdgeRing = function(t) {
      var e = t, n = new iS();
      do
        n.push(e), e.ring = n, e = e.next;
      while (!t.isEqual(e));
      return n;
    }, r.prototype.removeNode = function(t) {
      var e = this;
      t.getOuterEdges().forEach(function(n) {
        return e.removeEdge(n);
      }), t.innerEdges.forEach(function(n) {
        return e.removeEdge(n);
      }), delete this.nodes[t.id];
    }, r.prototype.removeEdge = function(t) {
      this.edges = this.edges.filter(function(e) {
        return !e.isEqual(t);
      }), t.deleteEdge();
    }, r;
  }()
);
function nT(r) {
  var t = eT.fromGeoJson(r);
  t.deleteDangles(), t.deleteCutEdges();
  var e = [], n = [];
  return t.getEdgeRings().filter(function(i) {
    return i.isValid();
  }).forEach(function(i) {
    i.isHole() ? e.push(i) : n.push(i);
  }), e.forEach(function(i) {
    iS.findEdgeRingContaining(i, n) && n.push(i);
  }), ht(n.map(function(i) {
    return i.toPolygon();
  }));
}
function sS(r, t) {
  var e = !0;
  return sr(r, function(n) {
    sr(t, function(i) {
      if (e === !1)
        return !1;
      e = rT(n.geometry, i.geometry);
    });
  }), e;
}
function rT(r, t) {
  switch (r.type) {
    case "Point":
      switch (t.type) {
        case "Point":
          return !aT(r.coordinates, t.coordinates);
        case "LineString":
          return !XI(t, r);
        case "Polygon":
          return !Fe(r, t);
      }
      break;
    case "LineString":
      switch (t.type) {
        case "Point":
          return !XI(r, t);
        case "LineString":
          return !iT(r, t);
        case "Polygon":
          return !qI(t, r);
      }
      break;
    case "Polygon":
      switch (t.type) {
        case "Point":
          return !Fe(t, r);
        case "LineString":
          return !qI(r, t);
        case "Polygon":
          return !sT(t, r);
      }
  }
  return !1;
}
function XI(r, t) {
  for (var e = 0; e < r.coordinates.length - 1; e++)
    if (oT(r.coordinates[e], r.coordinates[e + 1], t.coordinates))
      return !0;
  return !1;
}
function iT(r, t) {
  var e = wa(r, t);
  return e.features.length > 0;
}
function qI(r, t) {
  for (var e = 0, n = t.coordinates; e < n.length; e++) {
    var i = n[e];
    if (Fe(i, r))
      return !0;
  }
  var s = wa(t, fl(r));
  return s.features.length > 0;
}
function sT(r, t) {
  for (var e = 0, n = r.coordinates[0]; e < n.length; e++) {
    var i = n[e];
    if (Fe(i, t))
      return !0;
  }
  for (var s = 0, o = t.coordinates[0]; s < o.length; s++) {
    var a = o[s];
    if (Fe(a, r))
      return !0;
  }
  var u = wa(fl(r), fl(t));
  return u.features.length > 0;
}
function oT(r, t, e) {
  var n = e[0] - r[0], i = e[1] - r[1], s = t[0] - r[0], o = t[1] - r[1], a = n * o - i * s;
  return a !== 0 ? !1 : Math.abs(s) >= Math.abs(o) ? s > 0 ? r[0] <= e[0] && e[0] <= t[0] : t[0] <= e[0] && e[0] <= r[0] : o > 0 ? r[1] <= e[1] && e[1] <= t[1] : t[1] <= e[1] && e[1] <= r[1];
}
function aT(r, t) {
  return r[0] === t[0] && r[1] === t[1];
}
function uT(r, t) {
  var e = ke(r), n = ke(t), i = e.type, s = n.type, o = e.coordinates, a = n.coordinates;
  switch (i) {
    case "Point":
      switch (s) {
        case "Point":
          return A2(o, a);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    case "MultiPoint":
      switch (s) {
        case "Point":
          return xT(e, n);
        case "MultiPoint":
          return cT(e, n);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    case "LineString":
      switch (s) {
        case "Point":
          return bi(n, e, { ignoreEndVertices: !0 });
        case "LineString":
          return hT(e, n);
        case "MultiPoint":
          return fT(e, n);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    case "Polygon":
      switch (s) {
        case "Point":
          return Fe(n, e, { ignoreBoundary: !0 });
        case "LineString":
          return pT(e, n);
        case "Polygon":
          return dT(e, n);
        case "MultiPoint":
          return lT(e, n);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + i + " geometry not supported");
  }
}
function xT(r, t) {
  var e, n = !1;
  for (e = 0; e < r.coordinates.length; e++)
    if (A2(r.coordinates[e], t.coordinates)) {
      n = !0;
      break;
    }
  return n;
}
function cT(r, t) {
  for (var e = 0, n = t.coordinates; e < n.length; e++) {
    for (var i = n[e], s = !1, o = 0, a = r.coordinates; o < a.length; o++) {
      var u = a[o];
      if (A2(i, u)) {
        s = !0;
        break;
      }
    }
    if (!s)
      return !1;
  }
  return !0;
}
function fT(r, t) {
  for (var e = !1, n = 0, i = t.coordinates; n < i.length; n++) {
    var s = i[n];
    if (bi(s, r, { ignoreEndVertices: !0 }) && (e = !0), !bi(s, r))
      return !1;
  }
  return !!e;
}
function lT(r, t) {
  for (var e = 0, n = t.coordinates; e < n.length; e++) {
    var i = n[e];
    if (!Fe(i, r, { ignoreBoundary: !0 }))
      return !1;
  }
  return !0;
}
function hT(r, t) {
  for (var e = !1, n = 0, i = t.coordinates; n < i.length; n++) {
    var s = i[n];
    if (bi({ type: "Point", coordinates: s }, r, {
      ignoreEndVertices: !0
    }) && (e = !0), !bi({ type: "Point", coordinates: s }, r, {
      ignoreEndVertices: !1
    }))
      return !1;
  }
  return e;
}
function pT(r, t) {
  var e = !1, n = 0, i = Cn(r), s = Cn(t);
  if (!oS(i, s))
    return !1;
  for (n; n < t.coordinates.length - 1; n++) {
    var o = gT(t.coordinates[n], t.coordinates[n + 1]);
    if (Fe({ type: "Point", coordinates: o }, r, {
      ignoreBoundary: !0
    })) {
      e = !0;
      break;
    }
  }
  return e;
}
function dT(r, t) {
  if (r.type === "Feature" && r.geometry === null || t.type === "Feature" && t.geometry === null)
    return !1;
  var e = Cn(r), n = Cn(t);
  if (!oS(e, n))
    return !1;
  for (var i = ke(t).coordinates, s = 0, o = i; s < o.length; s++)
    for (var a = o[s], u = 0, x = a; u < x.length; u++) {
      var c = x[u];
      if (!Fe(c, r))
        return !1;
    }
  return !0;
}
function oS(r, t) {
  return !(r[0] > t[0] || r[2] < t[2] || r[1] > t[1] || r[3] < t[3]);
}
function A2(r, t) {
  return r[0] === t[0] && r[1] === t[1];
}
function gT(r, t) {
  return [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2];
}
function yT(r, t) {
  var e = ke(r), n = ke(t), i = e.type, s = n.type;
  switch (i) {
    case "MultiPoint":
      switch (s) {
        case "LineString":
          return zI(e, n);
        case "Polygon":
          return VI(e, n);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    case "LineString":
      switch (s) {
        case "MultiPoint":
          return zI(n, e);
        case "LineString":
          return vT(e, n);
        case "Polygon":
          return UI(e, n);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    case "Polygon":
      switch (s) {
        case "MultiPoint":
          return VI(n, e);
        case "LineString":
          return UI(n, e);
        default:
          throw new Error("feature2 " + s + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + i + " geometry not supported");
  }
}
function zI(r, t) {
  for (var e = !1, n = !1, i = r.coordinates.length, s = 0; s < i && !e && !n; ) {
    for (var o = 0; o < t.coordinates.length - 1; o++) {
      var a = !0;
      (o === 0 || o === t.coordinates.length - 2) && (a = !1), aS(t.coordinates[o], t.coordinates[o + 1], r.coordinates[s], a) ? e = !0 : n = !0;
    }
    s++;
  }
  return e && n;
}
function vT(r, t) {
  var e = wa(r, t);
  if (e.features.length > 0)
    for (var n = 0; n < r.coordinates.length - 1; n++)
      for (var i = 0; i < t.coordinates.length - 1; i++) {
        var s = !0;
        if ((i === 0 || i === t.coordinates.length - 2) && (s = !1), aS(r.coordinates[n], r.coordinates[n + 1], t.coordinates[i], s))
          return !0;
      }
  return !1;
}
function UI(r, t) {
  var e = EE(t), n = wa(r, e);
  return n.features.length > 0;
}
function VI(r, t) {
  for (var e = !1, n = !1, i = r.coordinates.length, s = 0; s < i && (!e || !n); s++)
    Fe(Pt(r.coordinates[s]), t) ? e = !0 : n = !0;
  return n && e;
}
function aS(r, t, e, n) {
  var i = e[0] - r[0], s = e[1] - r[1], o = t[0] - r[0], a = t[1] - r[1], u = i * a - s * o;
  return u !== 0 ? !1 : n ? Math.abs(o) >= Math.abs(a) ? o > 0 ? r[0] <= e[0] && e[0] <= t[0] : t[0] <= e[0] && e[0] <= r[0] : a > 0 ? r[1] <= e[1] && e[1] <= t[1] : t[1] <= e[1] && e[1] <= r[1] : Math.abs(o) >= Math.abs(a) ? o > 0 ? r[0] < e[0] && e[0] < t[0] : t[0] < e[0] && e[0] < r[0] : a > 0 ? r[1] < e[1] && e[1] < t[1] : t[1] < e[1] && e[1] < r[1];
}
var mT = $E, To = function(r) {
  this.precision = r && r.precision ? r.precision : 17, this.direction = r && r.direction ? r.direction : !1, this.pseudoNode = r && r.pseudoNode ? r.pseudoNode : !1, this.objectComparator = r && r.objectComparator ? r.objectComparator : _T;
};
To.prototype.compare = function(r, t) {
  if (r.type !== t.type || !uS(r, t)) return !1;
  switch (r.type) {
    case "Point":
      return this.compareCoord(r.coordinates, t.coordinates);
    case "LineString":
      return this.compareLine(r.coordinates, t.coordinates, 0, !1);
    case "Polygon":
      return this.comparePolygon(r, t);
    case "Feature":
      return this.compareFeature(r, t);
    default:
      if (r.type.indexOf("Multi") === 0) {
        var e = this, n = WI(r), i = WI(t);
        return n.every(function(s) {
          return this.some(function(o) {
            return e.compare(s, o);
          });
        }, i);
      }
  }
  return !1;
};
function WI(r) {
  return r.coordinates.map(function(t) {
    return {
      type: r.type.replace("Multi", ""),
      coordinates: t
    };
  });
}
function uS(r, t) {
  return r.hasOwnProperty("coordinates") ? r.coordinates.length === t.coordinates.length : r.length === t.length;
}
To.prototype.compareCoord = function(r, t) {
  if (r.length !== t.length)
    return !1;
  for (var e = 0; e < r.length; e++)
    if (r[e].toFixed(this.precision) !== t[e].toFixed(this.precision))
      return !1;
  return !0;
};
To.prototype.compareLine = function(r, t, e, n) {
  if (!uS(r, t)) return !1;
  var i = this.pseudoNode ? r : this.removePseudo(r), s = this.pseudoNode ? t : this.removePseudo(t);
  if (!(n && !this.compareCoord(i[0], s[0]) && (s = this.fixStartIndex(s, i), !s))) {
    var o = this.compareCoord(i[e], s[e]);
    return this.direction || o ? this.comparePath(i, s) : this.compareCoord(i[e], s[s.length - (1 + e)]) ? this.comparePath(i.slice().reverse(), s) : !1;
  }
};
To.prototype.fixStartIndex = function(r, t) {
  for (var e, n = -1, i = 0; i < r.length; i++)
    if (this.compareCoord(r[i], t[0])) {
      n = i;
      break;
    }
  return n >= 0 && (e = [].concat(
    r.slice(n, r.length),
    r.slice(1, n + 1)
  )), e;
};
To.prototype.comparePath = function(r, t) {
  var e = this;
  return r.every(function(n, i) {
    return e.compareCoord(n, this[i]);
  }, t);
};
To.prototype.comparePolygon = function(r, t) {
  if (this.compareLine(r.coordinates[0], t.coordinates[0], 1, !0)) {
    var e = r.coordinates.slice(1, r.coordinates.length), n = t.coordinates.slice(1, t.coordinates.length), i = this;
    return e.every(function(s) {
      return this.some(function(o) {
        return i.compareLine(s, o, 1, !0);
      });
    }, n);
  } else
    return !1;
};
To.prototype.compareFeature = function(r, t) {
  return r.id !== t.id || !this.objectComparator(r.properties, t.properties) || !this.compareBBox(r, t) ? !1 : this.compare(r.geometry, t.geometry);
};
To.prototype.compareBBox = function(r, t) {
  return !!(!r.bbox && !t.bbox || r.bbox && t.bbox && this.compareCoord(r.bbox, t.bbox));
};
To.prototype.removePseudo = function(r) {
  return r;
};
function _T(r, t) {
  return mT(r, t, { strict: !0 });
}
var bT = To;
const xS = /* @__PURE__ */ Ao(bT);
function IT(r, t) {
  var e = ke(r), n = ke(t), i = e.type, s = n.type;
  if (i === "MultiPoint" && s !== "MultiPoint" || (i === "LineString" || i === "MultiLineString") && s !== "LineString" && s !== "MultiLineString" || (i === "Polygon" || i === "MultiPolygon") && s !== "Polygon" && s !== "MultiPolygon")
    throw new Error("features must be of the same type");
  if (i === "Point")
    throw new Error("Point geometry not supported");
  var o = new xS({ precision: 6 });
  if (o.compare(r, t))
    return !1;
  var a = 0;
  switch (i) {
    case "MultiPoint":
      for (var u = 0; u < e.coordinates.length; u++)
        for (var x = 0; x < n.coordinates.length; x++) {
          var c = e.coordinates[u], f = n.coordinates[x];
          if (c[0] === f[0] && c[1] === f[1])
            return !0;
        }
      return !1;
    case "LineString":
    case "MultiLineString":
      Zo(r, function(l) {
        Zo(t, function(h) {
          tS(l, h).features.length && a++;
        });
      });
      break;
    case "Polygon":
    case "MultiPolygon":
      Zo(r, function(l) {
        Zo(t, function(h) {
          wa(l, h).features.length && a++;
        });
      });
      break;
  }
  return a > 0;
}
function wT(r, t) {
  var e = ke(r).type, n = ke(t).type;
  if (e !== n)
    return !1;
  var i = new xS({ precision: 6 });
  return i.compare(U0(r), U0(t));
}
function cS(r, t) {
  var e = !1;
  return sr(r, function(n) {
    sr(t, function(i) {
      if (e === !0)
        return !0;
      e = !sS(n.geometry, i.geometry);
    });
  }), e;
}
var fS = { exports: {} }, Hv = { exports: {} }, HI;
function ET() {
  return HI || (HI = 1, function(r) {
    function t(e, n, i, s) {
      this.dataset = [], this.epsilon = 1, this.minPts = 2, this.distance = this._euclideanDistance, this.clusters = [], this.noise = [], this._visited = [], this._assigned = [], this._datasetLength = 0, this._init(e, n, i, s);
    }
    t.prototype.run = function(e, n, i, s) {
      this._init(e, n, i, s);
      for (var o = 0; o < this._datasetLength; o++)
        if (this._visited[o] !== 1) {
          this._visited[o] = 1;
          var a = this._regionQuery(o);
          if (a.length < this.minPts)
            this.noise.push(o);
          else {
            var u = this.clusters.length;
            this.clusters.push([]), this._addToCluster(o, u), this._expandCluster(u, a);
          }
        }
      return this.clusters;
    }, t.prototype._init = function(e, n, i, s) {
      if (e) {
        if (!(e instanceof Array))
          throw Error("Dataset must be of type array, " + typeof e + " given");
        this.dataset = e, this.clusters = [], this.noise = [], this._datasetLength = e.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength);
      }
      n && (this.epsilon = n), i && (this.minPts = i), s && (this.distance = s);
    }, t.prototype._expandCluster = function(e, n) {
      for (var i = 0; i < n.length; i++) {
        var s = n[i];
        if (this._visited[s] !== 1) {
          this._visited[s] = 1;
          var o = this._regionQuery(s);
          o.length >= this.minPts && (n = this._mergeArrays(n, o));
        }
        this._assigned[s] !== 1 && this._addToCluster(s, e);
      }
    }, t.prototype._addToCluster = function(e, n) {
      this.clusters[n].push(e), this._assigned[e] = 1;
    }, t.prototype._regionQuery = function(e) {
      for (var n = [], i = 0; i < this._datasetLength; i++) {
        var s = this.distance(this.dataset[e], this.dataset[i]);
        s < this.epsilon && n.push(i);
      }
      return n;
    }, t.prototype._mergeArrays = function(e, n) {
      for (var i = n.length, s = 0; s < i; s++) {
        var o = n[s];
        e.indexOf(o) < 0 && e.push(o);
      }
      return e;
    }, t.prototype._euclideanDistance = function(e, n) {
      for (var i = 0, s = Math.min(e.length, n.length); s--; )
        i += (e[s] - n[s]) * (e[s] - n[s]);
      return Math.sqrt(i);
    }, r.exports && (r.exports = t);
  }(Hv)), Hv.exports;
}
var Jv = { exports: {} }, JI;
function ST() {
  return JI || (JI = 1, function(r) {
    function t(e, n, i) {
      this.k = 3, this.dataset = [], this.assignments = [], this.centroids = [], this.init(e, n, i);
    }
    t.prototype.init = function(e, n, i) {
      this.assignments = [], this.centroids = [], typeof e < "u" && (this.dataset = e), typeof n < "u" && (this.k = n), typeof i < "u" && (this.distance = i);
    }, t.prototype.run = function(e, n) {
      this.init(e, n);
      for (var i = this.dataset.length, s = 0; s < this.k; s++)
        this.centroids[s] = this.randomCentroid();
      for (var o = !0; o; ) {
        o = this.assign();
        for (var a = 0; a < this.k; a++) {
          for (var u = new Array(l), x = 0, c = 0; c < l; c++)
            u[c] = 0;
          for (var f = 0; f < i; f++) {
            var l = this.dataset[f].length;
            if (a === this.assignments[f]) {
              for (var c = 0; c < l; c++)
                u[c] += this.dataset[f][c];
              x++;
            }
          }
          if (x > 0) {
            for (var c = 0; c < l; c++)
              u[c] /= x;
            this.centroids[a] = u;
          } else
            this.centroids[a] = this.randomCentroid(), o = !0;
        }
      }
      return this.getClusters();
    }, t.prototype.randomCentroid = function() {
      var e = this.dataset.length - 1, n, i;
      do
        i = Math.round(Math.random() * e), n = this.dataset[i];
      while (this.centroids.indexOf(n) >= 0);
      return n;
    }, t.prototype.assign = function() {
      for (var e = !1, n = this.dataset.length, i, s = 0; s < n; s++)
        i = this.argmin(this.dataset[s], this.centroids, this.distance), i != this.assignments[s] && (this.assignments[s] = i, e = !0);
      return e;
    }, t.prototype.getClusters = function() {
      for (var e = new Array(this.k), n, i = 0; i < this.assignments.length; i++)
        n = this.assignments[i], typeof e[n] > "u" && (e[n] = []), e[n].push(i);
      return e;
    }, t.prototype.argmin = function(e, n, i) {
      for (var s = Number.MAX_VALUE, o = 0, a = n.length, u, x = 0; x < a; x++)
        u = i(e, n[x]), u < s && (s = u, o = x);
      return o;
    }, t.prototype.distance = function(e, n) {
      for (var i = 0, s = Math.min(e.length, n.length); s--; ) {
        var o = e[s] - n[s];
        i += o * o;
      }
      return Math.sqrt(i);
    }, r.exports && (r.exports = t);
  }(Jv)), Jv.exports;
}
var Zv = { exports: {} }, Kv = { exports: {} }, ZI;
function lS() {
  return ZI || (ZI = 1, function(r) {
    function t(e, n, i) {
      this._queue = [], this._priorities = [], this._sorting = "desc", this._init(e, n, i);
    }
    t.prototype.insert = function(e, n) {
      for (var i = this._queue.length, s = i; s--; ) {
        var o = this._priorities[s];
        this._sorting === "desc" ? n > o && (i = s) : n < o && (i = s);
      }
      this._insertAt(e, n, i);
    }, t.prototype.remove = function(e) {
      for (var n = this._queue.length; n--; ) {
        var i = this._queue[n];
        if (e === i) {
          this._queue.splice(n, 1), this._priorities.splice(n, 1);
          break;
        }
      }
    }, t.prototype.forEach = function(e) {
      this._queue.forEach(e);
    }, t.prototype.getElements = function() {
      return this._queue;
    }, t.prototype.getElementPriority = function(e) {
      return this._priorities[e];
    }, t.prototype.getPriorities = function() {
      return this._priorities;
    }, t.prototype.getElementsWithPriorities = function() {
      for (var e = [], n = 0, i = this._queue.length; n < i; n++)
        e.push([this._queue[n], this._priorities[n]]);
      return e;
    }, t.prototype._init = function(e, n, i) {
      if (e && n) {
        if (this._queue = [], this._priorities = [], e.length !== n.length)
          throw new Error("Arrays must have the same length");
        for (var s = 0; s < e.length; s++)
          this.insert(e[s], n[s]);
      }
      i && (this._sorting = i);
    }, t.prototype._insertAt = function(e, n, i) {
      this._queue.length === i ? (this._queue.push(e), this._priorities.push(n)) : (this._queue.splice(i, 0, e), this._priorities.splice(i, 0, n));
    }, r.exports && (r.exports = t);
  }(Kv)), Kv.exports;
}
var KI;
function CT() {
  return KI || (KI = 1, function(r) {
    if (r.exports)
      var t = lS();
    function e(n, i, s, o) {
      this.epsilon = 1, this.minPts = 1, this.distance = this._euclideanDistance, this._reachability = [], this._processed = [], this._coreDistance = 0, this._orderedList = [], this._init(n, i, s, o);
    }
    e.prototype.run = function(n, i, s, o) {
      this._init(n, i, s, o);
      for (var a = 0, u = this.dataset.length; a < u; a++)
        if (this._processed[a] !== 1) {
          this._processed[a] = 1, this.clusters.push([a]);
          var x = this.clusters.length - 1;
          this._orderedList.push(a);
          var c = new t(null, null, "asc"), f = this._regionQuery(a);
          this._distanceToCore(a) !== void 0 && (this._updateQueue(a, f, c), this._expandCluster(x, c));
        }
      return this.clusters;
    }, e.prototype.getReachabilityPlot = function() {
      for (var n = [], i = 0, s = this._orderedList.length; i < s; i++) {
        var o = this._orderedList[i], a = this._reachability[o];
        n.push([o, a]);
      }
      return n;
    }, e.prototype._init = function(n, i, s, o) {
      if (n) {
        if (!(n instanceof Array))
          throw Error("Dataset must be of type array, " + typeof n + " given");
        this.dataset = n, this.clusters = [], this._reachability = new Array(this.dataset.length), this._processed = new Array(this.dataset.length), this._coreDistance = 0, this._orderedList = [];
      }
      i && (this.epsilon = i), s && (this.minPts = s), o && (this.distance = o);
    }, e.prototype._updateQueue = function(n, i, s) {
      var o = this;
      this._coreDistance = this._distanceToCore(n), i.forEach(function(a) {
        if (o._processed[a] === void 0) {
          var u = o.distance(o.dataset[n], o.dataset[a]), x = Math.max(o._coreDistance, u);
          o._reachability[a] === void 0 ? (o._reachability[a] = x, s.insert(a, x)) : x < o._reachability[a] && (o._reachability[a] = x, s.remove(a), s.insert(a, x));
        }
      });
    }, e.prototype._expandCluster = function(n, i) {
      for (var s = i.getElements(), o = 0, a = s.length; o < a; o++) {
        var u = s[o];
        if (this._processed[u] === void 0) {
          var x = this._regionQuery(u);
          this._processed[u] = 1, this.clusters[n].push(u), this._orderedList.push(u), this._distanceToCore(u) !== void 0 && (this._updateQueue(u, x, i), this._expandCluster(n, i));
        }
      }
    }, e.prototype._distanceToCore = function(n) {
      for (var i = this.epsilon, s = 0; s < i; s++) {
        var o = this._regionQuery(n, s);
        if (o.length >= this.minPts)
          return s;
      }
    }, e.prototype._regionQuery = function(n, i) {
      i = i || this.epsilon;
      for (var s = [], o = 0, a = this.dataset.length; o < a; o++)
        this.distance(this.dataset[n], this.dataset[o]) < i && s.push(o);
      return s;
    }, e.prototype._euclideanDistance = function(n, i) {
      for (var s = 0, o = Math.min(n.length, i.length); o--; )
        s += (n[o] - i[o]) * (n[o] - i[o]);
      return Math.sqrt(s);
    }, r.exports && (r.exports = e);
  }(Zv)), Zv.exports;
}
(function(r) {
  r.exports && (r.exports = {
    DBSCAN: ET(),
    KMEANS: ST(),
    OPTICS: CT(),
    PriorityQueue: lS()
  });
})(fS);
var MT = fS.exports;
const PT = /* @__PURE__ */ Ao(MT);
function LT(r, t, e) {
  e === void 0 && (e = {}), e.mutate !== !0 && (r = br(r)), e.minPoints = e.minPoints || 3;
  var n = new PT.DBSCAN(), i = n.run(Lx(r), z0(t, e.units), e.minPoints, Ie), s = -1;
  return i.forEach(function(o) {
    s++, o.forEach(function(a) {
      var u = r.features[a];
      u.properties || (u.properties = {}), u.properties.cluster = s, u.properties.dbscan = "core";
    });
  }), n.noise.forEach(function(o) {
    var a = r.features[o];
    a.properties || (a.properties = {}), a.properties.cluster ? a.properties.dbscan = "edge" : a.properties.dbscan = "noise";
  }), r;
}
var hS = {
  /**
   * Euclidean distance
   */
  eudist: function(t, e, n) {
    for (var i = t.length, s = 0, o = 0; o < i; o++) {
      var a = (t[o] || 0) - (e[o] || 0);
      s += a * a;
    }
    return n ? Math.sqrt(s) : s;
  },
  mandist: function(t, e, n) {
    for (var i = t.length, s = 0, o = 0; o < i; o++)
      s += Math.abs((t[o] || 0) - (e[o] || 0));
    return n ? Math.sqrt(s) : s;
  },
  /**
   * Unidimensional distance
   */
  dist: function(t, e, n) {
    var i = Math.abs(t - e);
    return n ? i : i * i;
  }
}, pS = hS, NT = pS.eudist, OT = pS.dist, RT = {
  kmrand: function(t, e) {
    for (var n = {}, i = [], s = e << 2, o = t.length, a = t[0].length > 0; i.length < e && s-- > 0; ) {
      var u = t[Math.floor(Math.random() * o)], x = a ? u.join("_") : "" + u;
      n[x] || (n[x] = !0, i.push(u));
    }
    if (i.length < e) throw new Error("Error initializating clusters");
    return i;
  },
  /**
   * K-means++ initial centroid selection
   */
  kmpp: function(t, e) {
    var n = t[0].length ? NT : OT, i = [], s = t.length, o = t[0].length > 0, a = t[Math.floor(Math.random() * s)];
    for (o ? a.join("_") : "" + a, i.push(a); i.length < e; ) {
      for (var u = [], x = i.length, c = 0, f = [], l = 0; l < s; l++) {
        for (var h = 1 / 0, p = 0; p < x; p++) {
          var y = n(t[l], i[p]);
          y <= h && (h = y);
        }
        u[l] = h;
      }
      for (var v = 0; v < s; v++)
        c += u[v];
      for (var m = 0; m < s; m++)
        f[m] = { i: m, v: t[m], pr: u[m] / c, cs: 0 };
      f.sort(function(b, w) {
        return b.pr - w.pr;
      }), f[0].cs = f[0].pr;
      for (var d = 1; d < s; d++)
        f[d].cs = f[d - 1].cs + f[d].pr;
      for (var g = Math.random(), _ = 0; _ < s - 1 && f[_++].cs < g; )
        ;
      i.push(f[_ - 1].v);
    }
    return i;
  }
}, T2 = hS, dS = RT, AT = T2.eudist;
T2.mandist;
T2.dist;
var TT = dS.kmrand, DT = dS.kmpp, jI = 1e4;
function QI(r, t, e) {
  e = e || [];
  for (var n = 0; n < r; n++)
    e[n] = t;
  return e;
}
function FT(r, t, e, n) {
  var i = [], s = [], o = [], a = [], u = !1, x = n || jI, c = r.length, f = r[0].length, l = f > 0, h = [];
  if (e)
    e == "kmrand" ? i = TT(r, t) : e == "kmpp" ? i = DT(r, t) : i = e;
  else for (var p = {}; i.length < t; ) {
    var y = Math.floor(Math.random() * c);
    p[y] || (p[y] = !0, i.push(r[y]));
  }
  do {
    QI(t, 0, h);
    for (var v = 0; v < c; v++) {
      for (var m = 1 / 0, d = 0, g = 0; g < t; g++) {
        var a = l ? AT(r[v], i[g]) : Math.abs(r[v] - i[g]);
        a <= m && (m = a, d = g);
      }
      o[v] = d, h[d]++;
    }
    for (var _ = [], s = [], b = 0; b < t; b++)
      _[b] = l ? QI(f, 0, _[b]) : 0, s[b] = i[b];
    if (l) {
      for (var w = 0; w < t; w++)
        i[w] = [];
      for (var E = 0; E < c; E++)
        for (var S = o[E], I = _[S], L = r[E], M = 0; M < f; M++)
          I[M] += L[M];
      u = !0;
      for (var N = 0; N < t; N++) {
        for (var P = i[N], O = _[N], k = s[N], D = h[N], F = 0; F < f; F++)
          P[F] = O[F] / D || 0;
        if (u) {
          for (var X = 0; X < f; X++)
            if (k[X] != P[X]) {
              u = !1;
              break;
            }
        }
      }
    } else {
      for (var W = 0; W < c; W++) {
        var U = o[W];
        _[U] += r[W];
      }
      for (var q = 0; q < t; q++)
        i[q] = _[q] / h[q] || 0;
      u = !0;
      for (var V = 0; V < t; V++)
        if (s[V] != i[V]) {
          u = !1;
          break;
        }
    }
    u = u || --x <= 0;
  } while (!u);
  return {
    it: jI - x,
    k: t,
    idxs: o,
    centroids: i
  };
}
var kT = FT;
const BT = /* @__PURE__ */ Ao(kT);
function GT(r, t) {
  t === void 0 && (t = {});
  var e = r.features.length;
  t.numberOfClusters = t.numberOfClusters || Math.round(Math.sqrt(e / 2)), t.numberOfClusters > e && (t.numberOfClusters = e), t.mutate !== !0 && (r = br(r));
  var n = Lx(r), i = n.slice(0, t.numberOfClusters), s = BT(n, t.numberOfClusters, i), o = {};
  return s.centroids.forEach(function(a, u) {
    o[u] = a;
  }), he(r, function(a, u) {
    var x = s.idxs[u];
    a.properties.cluster = x, a.properties.centroid = o[x];
  }), r;
}
function YT(r, t) {
  if (!r)
    throw new Error("line1 is required");
  if (!t)
    throw new Error("line2 is required");
  var e = $I(r, "line1");
  if (e !== "LineString")
    throw new Error("line1 must be a LineString");
  var n = $I(t, "line2");
  if (n !== "LineString")
    throw new Error("line2 must be a LineString");
  for (var i = W0(U0(r)).features, s = W0(U0(t)).features, o = 0; o < i.length; o++) {
    var a = i[o].geometry.coordinates;
    if (!s[o])
      break;
    var u = s[o].geometry.coordinates;
    if (!XT(a, u))
      return !1;
  }
  return !0;
}
function XT(r, t) {
  var e = q0(H0(r[0], r[1])), n = q0(H0(t[0], t[1]));
  return e === n;
}
function $I(r, t) {
  if (r.geometry && r.geometry.type)
    return r.geometry.type;
  if (r.type)
    return r.type;
  throw new Error("Invalid GeoJSON object for " + t);
}
function t3(r) {
  for (var t = r, e = []; t.parent; )
    e.unshift(t), t = t.parent;
  return e;
}
function qT() {
  return new gS(function(r) {
    return r.f;
  });
}
var Yy = {
  /**
   * Perform an A* Search on a graph given a start and end node.
   *
   * @private
   * @memberof astar
   * @param {Graph} graph Graph
   * @param {GridNode} start Start
   * @param {GridNode} end End
   * @param {Object} [options] Options
   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
   * @returns {Object} Search
   */
  search: function(r, t, e, n) {
    r.cleanDirty(), n = n || {};
    var i = n.heuristic || Yy.heuristics.manhattan, s = n.closest || !1, o = qT(), a = t;
    for (t.h = i(t, e), o.push(t); o.size() > 0; ) {
      var u = o.pop();
      if (u === e)
        return t3(u);
      u.closed = !0;
      for (var x = r.neighbors(u), c = 0, f = x.length; c < f; ++c) {
        var l = x[c];
        if (!(l.closed || l.isWall())) {
          var h = u.g + l.getCost(u), p = l.visited;
          (!p || h < l.g) && (l.visited = !0, l.parent = u, l.h = l.h || i(l, e), l.g = h, l.f = l.g + l.h, r.markDirty(l), s && (l.h < a.h || l.h === a.h && l.g < a.g) && (a = l), p ? o.rescoreElement(l) : o.push(l));
        }
      }
    }
    return s ? t3(a) : [];
  },
  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
  heuristics: {
    manhattan: function(r, t) {
      var e = Math.abs(t.x - r.x), n = Math.abs(t.y - r.y);
      return e + n;
    },
    diagonal: function(r, t) {
      var e = 1, n = Math.sqrt(2), i = Math.abs(t.x - r.x), s = Math.abs(t.y - r.y);
      return e * (i + s) + (n - 2 * e) * Math.min(i, s);
    }
  },
  cleanNode: function(r) {
    r.f = 0, r.g = 0, r.h = 0, r.visited = !1, r.closed = !1, r.parent = null;
  }
};
function sc(r, t) {
  t = t || {}, this.nodes = [], this.diagonal = !!t.diagonal, this.grid = [];
  for (var e = 0; e < r.length; e++) {
    this.grid[e] = [];
    for (var n = 0, i = r[e]; n < i.length; n++) {
      var s = new Xy(e, n, i[n]);
      this.grid[e][n] = s, this.nodes.push(s);
    }
  }
  this.init();
}
sc.prototype.init = function() {
  this.dirtyNodes = [];
  for (var r = 0; r < this.nodes.length; r++)
    Yy.cleanNode(this.nodes[r]);
};
sc.prototype.cleanDirty = function() {
  for (var r = 0; r < this.dirtyNodes.length; r++)
    Yy.cleanNode(this.dirtyNodes[r]);
  this.dirtyNodes = [];
};
sc.prototype.markDirty = function(r) {
  this.dirtyNodes.push(r);
};
sc.prototype.neighbors = function(r) {
  var t = [], e = r.x, n = r.y, i = this.grid;
  return i[e - 1] && i[e - 1][n] && t.push(i[e - 1][n]), i[e + 1] && i[e + 1][n] && t.push(i[e + 1][n]), i[e] && i[e][n - 1] && t.push(i[e][n - 1]), i[e] && i[e][n + 1] && t.push(i[e][n + 1]), this.diagonal && (i[e - 1] && i[e - 1][n - 1] && t.push(i[e - 1][n - 1]), i[e + 1] && i[e + 1][n - 1] && t.push(i[e + 1][n - 1]), i[e - 1] && i[e - 1][n + 1] && t.push(i[e - 1][n + 1]), i[e + 1] && i[e + 1][n + 1] && t.push(i[e + 1][n + 1])), t;
};
sc.prototype.toString = function() {
  for (var r = [], t = this.grid, e, n, i, s, o = 0, a = t.length; o < a; o++) {
    for (e = [], n = t[o], i = 0, s = n.length; i < s; i++)
      e.push(n[i].weight);
    r.push(e.join(" "));
  }
  return r.join(`
`);
};
function Xy(r, t, e) {
  this.x = r, this.y = t, this.weight = e;
}
Xy.prototype.toString = function() {
  return "[" + this.x + " " + this.y + "]";
};
Xy.prototype.getCost = function(r) {
  return r && r.x !== this.x && r.y !== this.y ? this.weight * 1.41421 : this.weight;
};
Xy.prototype.isWall = function() {
  return this.weight === 0;
};
function gS(r) {
  this.content = [], this.scoreFunction = r;
}
gS.prototype = {
  push: function(r) {
    this.content.push(r), this.sinkDown(this.content.length - 1);
  },
  pop: function() {
    var r = this.content[0], t = this.content.pop();
    return this.content.length > 0 && (this.content[0] = t, this.bubbleUp(0)), r;
  },
  remove: function(r) {
    var t = this.content.indexOf(r), e = this.content.pop();
    t !== this.content.length - 1 && (this.content[t] = e, this.scoreFunction(e) < this.scoreFunction(r) ? this.sinkDown(t) : this.bubbleUp(t));
  },
  size: function() {
    return this.content.length;
  },
  rescoreElement: function(r) {
    this.sinkDown(this.content.indexOf(r));
  },
  sinkDown: function(r) {
    for (var t = this.content[r]; r > 0; ) {
      var e = (r + 1 >> 1) - 1, n = this.content[e];
      if (this.scoreFunction(t) < this.scoreFunction(n))
        this.content[e] = t, this.content[r] = n, r = e;
      else
        break;
    }
  },
  bubbleUp: function(r) {
    for (var t = this.content.length, e = this.content[r], n = this.scoreFunction(e); ; ) {
      var i = r + 1 << 1, s = i - 1, o = null, a;
      if (s < t) {
        var u = this.content[s];
        a = this.scoreFunction(u), a < n && (o = s);
      }
      if (i < t) {
        var x = this.content[i], c = this.scoreFunction(x);
        c < (o === null ? n : a) && (o = i);
      }
      if (o !== null)
        this.content[r] = this.content[o], this.content[o] = e, r = o;
      else
        break;
    }
  }
};
function zT(r, t, e) {
  if (e = e || {}, !we(e)) throw new Error("options is invalid");
  var n = e.resolution, i = e.minDistance, s = e.obstacles || ht([]);
  if (!r) throw new Error("start is required");
  if (!t) throw new Error("end is required");
  if (n && !Wn(n) || n <= 0)
    throw new Error("options.resolution must be a number, greater than 0");
  if (i)
    throw new Error("options.minDistance is not yet implemented");
  var o = Ae(r), a = Ae(t);
  switch (r = Pt(o), t = Pt(a), oi(s)) {
    case "FeatureCollection":
      if (s.features.length === 0)
        return ge([o, a]);
      break;
    case "Polygon":
      s = ht([Tn(ke(s))]);
      break;
    default:
      throw new Error("invalid obstacles");
  }
  var u = s;
  u.features.push(r), u.features.push(t);
  var x = Cn(nS(n2(Cn(u)), 1.15));
  if (!n) {
    var c = Ie([x[0], x[1]], [x[2], x[1]], e);
    n = c / 100;
  }
  u.features.pop(), u.features.pop();
  for (var f = x[0], l = x[1], h = x[2], p = x[3], y = n / Ie([f, l], [h, l], e), v = y * (h - f), m = n / Ie([f, l], [f, p], e), d = m * (p - l), g = h - f, _ = p - l, b = Math.floor(g / v), w = Math.floor(_ / d), E = (g - b * v) / 2, S = (_ - w * d) / 2, I = [], L = [], M = [], N = [], P = 1 / 0, O = 1 / 0, k = p - S, D = 0; k >= l; ) {
    for (var F = [], X = [], W = f + E, U = 0; W <= h; ) {
      var q = Pt([W, k]), V = UT(q, s);
      F.push(V ? 0 : 1), X.push(W + "|" + k);
      var tt = Ie(q, r);
      !V && tt < P && (P = tt, M = { x: U, y: D });
      var $ = Ie(q, t);
      !V && $ < O && (O = $, N = { x: U, y: D }), W += v, U++;
    }
    L.push(F), I.push(X), k -= d, D++;
  }
  var B = new sc(L, { diagonal: !0 }), _t = B.grid[M.y][M.x], pe = B.grid[N.y][N.x], Bn = Yy.search(B, _t, pe), on = [o];
  return Bn.forEach(function(jn) {
    var Gn = I[jn.x][jn.y].split("|");
    on.push([+Gn[0], +Gn[1]]);
  }), on.push(a), U0(ge(on));
}
function UT(r, t) {
  for (var e = 0; e < t.features.length; e++)
    if (Fe(r, t.features[e]))
      return !0;
  return !1;
}
function e3(r) {
  return function() {
    return r;
  };
}
function VT(r) {
  return r[0];
}
function WT(r) {
  return r[1];
}
function Ng() {
  this._ = null;
}
function qy(r) {
  r.U = // parent node
  r.C = // color - true for red, false for black
  r.L = // left node
  r.R = // right node
  r.P = // previous node
  r.N = null;
}
Ng.prototype = {
  constructor: Ng,
  insert: function(r, t) {
    var e, n, i;
    if (r) {
      if (t.P = r, t.N = r.N, r.N && (r.N.P = t), r.N = t, r.R) {
        for (r = r.R; r.L; ) r = r.L;
        r.L = t;
      } else
        r.R = t;
      e = r;
    } else this._ ? (r = n3(this._), t.P = null, t.N = r, r.P = r.L = t, e = r) : (t.P = t.N = null, this._ = t, e = null);
    for (t.L = t.R = null, t.U = e, t.C = !0, r = t; e && e.C; )
      n = e.U, e === n.L ? (i = n.R, i && i.C ? (e.C = i.C = !1, n.C = !0, r = n) : (r === e.R && (mc(this, e), r = e, e = r.U), e.C = !1, n.C = !0, _c(this, n))) : (i = n.L, i && i.C ? (e.C = i.C = !1, n.C = !0, r = n) : (r === e.L && (_c(this, e), r = e, e = r.U), e.C = !1, n.C = !0, mc(this, n))), e = r.U;
    this._.C = !1;
  },
  remove: function(r) {
    r.N && (r.N.P = r.P), r.P && (r.P.N = r.N), r.N = r.P = null;
    var t = r.U, e, n = r.L, i = r.R, s, o;
    if (n ? i ? s = n3(i) : s = n : s = i, t ? t.L === r ? t.L = s : t.R = s : this._ = s, n && i ? (o = s.C, s.C = r.C, s.L = n, n.U = s, s !== i ? (t = s.U, s.U = r.U, r = s.R, t.L = r, s.R = i, i.U = s) : (s.U = t, t = s, r = s.R)) : (o = r.C, r = s), r && (r.U = t), !o) {
      if (r && r.C) {
        r.C = !1;
        return;
      }
      do {
        if (r === this._) break;
        if (r === t.L) {
          if (e = t.R, e.C && (e.C = !1, t.C = !0, mc(this, t), e = t.R), e.L && e.L.C || e.R && e.R.C) {
            (!e.R || !e.R.C) && (e.L.C = !1, e.C = !0, _c(this, e), e = t.R), e.C = t.C, t.C = e.R.C = !1, mc(this, t), r = this._;
            break;
          }
        } else if (e = t.L, e.C && (e.C = !1, t.C = !0, _c(this, t), e = t.L), e.L && e.L.C || e.R && e.R.C) {
          (!e.L || !e.L.C) && (e.R.C = !1, e.C = !0, mc(this, e), e = t.L), e.C = t.C, t.C = e.L.C = !1, _c(this, t), r = this._;
          break;
        }
        e.C = !0, r = t, t = t.U;
      } while (!r.C);
      r && (r.C = !1);
    }
  }
};
function mc(r, t) {
  var e = t, n = t.R, i = e.U;
  i ? i.L === e ? i.L = n : i.R = n : r._ = n, n.U = i, e.U = n, e.R = n.L, e.R && (e.R.U = e), n.L = e;
}
function _c(r, t) {
  var e = t, n = t.L, i = e.U;
  i ? i.L === e ? i.L = n : i.R = n : r._ = n, n.U = i, e.U = n, e.L = n.R, e.L && (e.L.U = e), n.R = e;
}
function n3(r) {
  for (; r.L; ) r = r.L;
  return r;
}
function Bc(r, t, e, n) {
  var i = [null, null], s = qr.push(i) - 1;
  return i.left = r, i.right = t, e && Og(i, r, t, e), n && Og(i, t, r, n), Xi[r.index].halfedges.push(s), Xi[t.index].halfedges.push(s), i;
}
function bc(r, t, e) {
  var n = [t, e];
  return n.left = r, n;
}
function Og(r, t, e, n) {
  !r[0] && !r[1] ? (r[0] = n, r.left = t, r.right = e) : r.left === e ? r[1] = n : r[0] = n;
}
function HT(r, t, e, n, i) {
  var s = r[0], o = r[1], a = s[0], u = s[1], x = o[0], c = o[1], f = 0, l = 1, h = x - a, p = c - u, y;
  if (y = t - a, !(!h && y > 0)) {
    if (y /= h, h < 0) {
      if (y < f) return;
      y < l && (l = y);
    } else if (h > 0) {
      if (y > l) return;
      y > f && (f = y);
    }
    if (y = n - a, !(!h && y < 0)) {
      if (y /= h, h < 0) {
        if (y > l) return;
        y > f && (f = y);
      } else if (h > 0) {
        if (y < f) return;
        y < l && (l = y);
      }
      if (y = e - u, !(!p && y > 0)) {
        if (y /= p, p < 0) {
          if (y < f) return;
          y < l && (l = y);
        } else if (p > 0) {
          if (y > l) return;
          y > f && (f = y);
        }
        if (y = i - u, !(!p && y < 0)) {
          if (y /= p, p < 0) {
            if (y > l) return;
            y > f && (f = y);
          } else if (p > 0) {
            if (y < f) return;
            y < l && (l = y);
          }
          return !(f > 0) && !(l < 1) || (f > 0 && (r[0] = [a + f * h, u + f * p]), l < 1 && (r[1] = [a + l * h, u + l * p])), !0;
        }
      }
    }
  }
}
function JT(r, t, e, n, i) {
  var s = r[1];
  if (s) return !0;
  var o = r[0], a = r.left, u = r.right, x = a[0], c = a[1], f = u[0], l = u[1], h = (x + f) / 2, p = (c + l) / 2, y, v;
  if (l === c) {
    if (h < t || h >= n) return;
    if (x > f) {
      if (!o) o = [h, e];
      else if (o[1] >= i) return;
      s = [h, i];
    } else {
      if (!o) o = [h, i];
      else if (o[1] < e) return;
      s = [h, e];
    }
  } else if (y = (x - f) / (l - c), v = p - y * h, y < -1 || y > 1)
    if (x > f) {
      if (!o) o = [(e - v) / y, e];
      else if (o[1] >= i) return;
      s = [(i - v) / y, i];
    } else {
      if (!o) o = [(i - v) / y, i];
      else if (o[1] < e) return;
      s = [(e - v) / y, e];
    }
  else if (c < l) {
    if (!o) o = [t, y * t + v];
    else if (o[0] >= n) return;
    s = [n, y * n + v];
  } else {
    if (!o) o = [n, y * n + v];
    else if (o[0] < t) return;
    s = [t, y * t + v];
  }
  return r[0] = o, r[1] = s, !0;
}
function ZT(r, t, e, n) {
  for (var i = qr.length, s; i--; )
    (!JT(s = qr[i], r, t, e, n) || !HT(s, r, t, e, n) || !(Math.abs(s[0][0] - s[1][0]) > Xe || Math.abs(s[0][1] - s[1][1]) > Xe)) && delete qr[i];
}
function KT(r) {
  return Xi[r.index] = {
    site: r,
    halfedges: []
  };
}
function jT(r, t) {
  var e = r.site, n = t.left, i = t.right;
  return e === i && (i = n, n = e), i ? Math.atan2(i[1] - n[1], i[0] - n[0]) : (e === n ? (n = t[1], i = t[0]) : (n = t[0], i = t[1]), Math.atan2(n[0] - i[0], i[1] - n[1]));
}
function yS(r, t) {
  return t[+(t.left !== r.site)];
}
function QT(r, t) {
  return t[+(t.left === r.site)];
}
function $T() {
  for (var r = 0, t = Xi.length, e, n, i, s; r < t; ++r)
    if ((e = Xi[r]) && (s = (n = e.halfedges).length)) {
      var o = new Array(s), a = new Array(s);
      for (i = 0; i < s; ++i) o[i] = i, a[i] = jT(e, qr[n[i]]);
      for (o.sort(function(u, x) {
        return a[x] - a[u];
      }), i = 0; i < s; ++i) a[i] = n[o[i]];
      for (i = 0; i < s; ++i) n[i] = a[i];
    }
}
function tD(r, t, e, n) {
  var i = Xi.length, s, o, a, u, x, c, f, l, h, p, y, v, m = !0;
  for (s = 0; s < i; ++s)
    if (o = Xi[s]) {
      for (a = o.site, x = o.halfedges, u = x.length; u--; )
        qr[x[u]] || x.splice(u, 1);
      for (u = 0, c = x.length; u < c; )
        p = QT(o, qr[x[u]]), y = p[0], v = p[1], f = yS(o, qr[x[++u % c]]), l = f[0], h = f[1], (Math.abs(y - l) > Xe || Math.abs(v - h) > Xe) && (x.splice(u, 0, qr.push(bc(
          a,
          p,
          Math.abs(y - r) < Xe && n - v > Xe ? [r, Math.abs(l - r) < Xe ? h : n] : Math.abs(v - n) < Xe && e - y > Xe ? [Math.abs(h - n) < Xe ? l : e, n] : Math.abs(y - e) < Xe && v - t > Xe ? [e, Math.abs(l - e) < Xe ? h : t] : Math.abs(v - t) < Xe && y - r > Xe ? [Math.abs(h - t) < Xe ? l : r, t] : null
        )) - 1), ++c);
      c && (m = !1);
    }
  if (m) {
    var d, g, _, b = 1 / 0;
    for (s = 0, m = null; s < i; ++s)
      (o = Xi[s]) && (a = o.site, d = a[0] - r, g = a[1] - t, _ = d * d + g * g, _ < b && (b = _, m = o));
    if (m) {
      var w = [r, t], E = [r, n], S = [e, n], I = [e, t];
      m.halfedges.push(
        qr.push(bc(a = m.site, w, E)) - 1,
        qr.push(bc(a, E, S)) - 1,
        qr.push(bc(a, S, I)) - 1,
        qr.push(bc(a, I, w)) - 1
      );
    }
  }
  for (s = 0; s < i; ++s)
    (o = Xi[s]) && (o.halfedges.length || delete Xi[s]);
}
var vS = [], D2;
function eD() {
  qy(this), this.x = this.y = this.arc = this.site = this.cy = null;
}
function Vu(r) {
  var t = r.P, e = r.N;
  if (!(!t || !e)) {
    var n = t.site, i = r.site, s = e.site;
    if (n !== s) {
      var o = i[0], a = i[1], u = n[0] - o, x = n[1] - a, c = s[0] - o, f = s[1] - a, l = 2 * (u * f - x * c);
      if (!(l >= -oD)) {
        var h = u * u + x * x, p = c * c + f * f, y = (f * h - x * p) / l, v = (u * p - c * h) / l, m = vS.pop() || new eD();
        m.arc = r, m.site = i, m.x = y + o, m.y = (m.cy = v + a) + Math.sqrt(y * y + v * v), r.circle = m;
        for (var d = null, g = dl._; g; )
          if (m.y < g.y || m.y === g.y && m.x <= g.x)
            if (g.L) g = g.L;
            else {
              d = g.P;
              break;
            }
          else if (g.R) g = g.R;
          else {
            d = g;
            break;
          }
        dl.insert(d, m), d || (D2 = m);
      }
    }
  }
}
function $u(r) {
  var t = r.circle;
  t && (t.P || (D2 = t.N), dl.remove(t), vS.push(t), qy(t), r.circle = null);
}
var mS = [];
function nD() {
  qy(this), this.edge = this.site = this.circle = null;
}
function r3(r) {
  var t = mS.pop() || new nD();
  return t.site = r, t;
}
function jv(r) {
  $u(r), tx.remove(r), mS.push(r), qy(r);
}
function rD(r) {
  var t = r.circle, e = t.x, n = t.cy, i = [e, n], s = r.P, o = r.N, a = [r];
  jv(r);
  for (var u = s; u.circle && Math.abs(e - u.circle.x) < Xe && Math.abs(n - u.circle.cy) < Xe; )
    s = u.P, a.unshift(u), jv(u), u = s;
  a.unshift(u), $u(u);
  for (var x = o; x.circle && Math.abs(e - x.circle.x) < Xe && Math.abs(n - x.circle.cy) < Xe; )
    o = x.N, a.push(x), jv(x), x = o;
  a.push(x), $u(x);
  var c = a.length, f;
  for (f = 1; f < c; ++f)
    x = a[f], u = a[f - 1], Og(x.edge, u.site, x.site, i);
  u = a[0], x = a[c - 1], x.edge = Bc(u.site, x.site, null, i), Vu(u), Vu(x);
}
function iD(r) {
  for (var t = r[0], e = r[1], n, i, s, o, a = tx._; a; )
    if (s = _S(a, e) - t, s > Xe) a = a.L;
    else if (o = t - sD(a, e), o > Xe) {
      if (!a.R) {
        n = a;
        break;
      }
      a = a.R;
    } else {
      s > -Xe ? (n = a.P, i = a) : o > -Xe ? (n = a, i = a.N) : n = i = a;
      break;
    }
  KT(r);
  var u = r3(r);
  if (tx.insert(n, u), !(!n && !i)) {
    if (n === i) {
      $u(n), i = r3(n.site), tx.insert(u, i), u.edge = i.edge = Bc(n.site, u.site), Vu(n), Vu(i);
      return;
    }
    if (!i) {
      u.edge = Bc(n.site, u.site);
      return;
    }
    $u(n), $u(i);
    var x = n.site, c = x[0], f = x[1], l = r[0] - c, h = r[1] - f, p = i.site, y = p[0] - c, v = p[1] - f, m = 2 * (l * v - h * y), d = l * l + h * h, g = y * y + v * v, _ = [(v * d - h * g) / m + c, (l * g - y * d) / m + f];
    Og(i.edge, x, p, _), u.edge = Bc(x, r, null, _), i.edge = Bc(r, p, null, _), Vu(n), Vu(i);
  }
}
function _S(r, t) {
  var e = r.site, n = e[0], i = e[1], s = i - t;
  if (!s) return n;
  var o = r.P;
  if (!o) return -1 / 0;
  e = o.site;
  var a = e[0], u = e[1], x = u - t;
  if (!x) return a;
  var c = a - n, f = 1 / s - 1 / x, l = c / x;
  return f ? (-l + Math.sqrt(l * l - 2 * f * (c * c / (-2 * x) - u + x / 2 + i - s / 2))) / f + n : (n + a) / 2;
}
function sD(r, t) {
  var e = r.N;
  if (e) return _S(e, t);
  var n = r.site;
  return n[1] === t ? n[0] : 1 / 0;
}
var Xe = 1e-6, oD = 1e-12, tx, Xi, dl, qr;
function aD(r, t, e) {
  return (r[0] - e[0]) * (t[1] - r[1]) - (r[0] - t[0]) * (e[1] - r[1]);
}
function uD(r, t) {
  return t[1] - r[1] || t[0] - r[0];
}
function jm(r, t) {
  var e = r.sort(uD).pop(), n, i, s;
  for (qr = [], Xi = new Array(r.length), tx = new Ng(), dl = new Ng(); ; )
    if (s = D2, e && (!s || e[1] < s.y || e[1] === s.y && e[0] < s.x))
      (e[0] !== n || e[1] !== i) && (iD(e), n = e[0], i = e[1]), e = r.pop();
    else if (s)
      rD(s.arc);
    else
      break;
  if ($T(), t) {
    var o = +t[0][0], a = +t[0][1], u = +t[1][0], x = +t[1][1];
    ZT(o, a, u, x), tD(o, a, u, x);
  }
  this.edges = qr, this.cells = Xi, tx = dl = qr = Xi = null;
}
jm.prototype = {
  constructor: jm,
  polygons: function() {
    var r = this.edges;
    return this.cells.map(function(t) {
      var e = t.halfedges.map(function(n) {
        return yS(t, r[n]);
      });
      return e.data = t.site.data, e;
    });
  },
  triangles: function() {
    var r = [], t = this.edges;
    return this.cells.forEach(function(e, n) {
      if (a = (s = e.halfedges).length)
        for (var i = e.site, s, o = -1, a, u, x = t[s[a - 1]], c = x.left === i ? x.right : x.left; ++o < a; )
          u = c, x = t[s[o]], c = x.left === i ? x.right : x.left, u && c && n < u.index && n < c.index && aD(i, u, c) < 0 && r.push([i.data, u.data, c.data]);
    }), r;
  },
  links: function() {
    return this.edges.filter(function(r) {
      return r.right;
    }).map(function(r) {
      return {
        source: r.left.data,
        target: r.right.data
      };
    });
  },
  find: function(r, t, e) {
    for (var n = this, i, s = n._found || 0, o = n.cells.length, a; !(a = n.cells[s]); ) if (++s >= o) return null;
    var u = r - a.site[0], x = t - a.site[1], c = u * u + x * x;
    do
      a = n.cells[i = s], s = null, a.halfedges.forEach(function(f) {
        var l = n.edges[f], h = l.left;
        if (!((h === a.site || !h) && !(h = l.right))) {
          var p = r - h[0], y = t - h[1], v = p * p + y * y;
          v < c && (c = v, s = h.index);
        }
      });
    while (s !== null);
    return n._found = i, e == null || c <= e * e ? a.site : null;
  }
};
function xD() {
  var r = VT, t = WT, e = null;
  function n(i) {
    return new jm(i.map(function(s, o) {
      var a = [Math.round(r(s, o, i) / Xe) * Xe, Math.round(t(s, o, i) / Xe) * Xe];
      return a.index = o, a.data = s, a;
    }), e);
  }
  return n.polygons = function(i) {
    return n(i).polygons();
  }, n.links = function(i) {
    return n(i).links();
  }, n.triangles = function(i) {
    return n(i).triangles();
  }, n.x = function(i) {
    return arguments.length ? (r = typeof i == "function" ? i : e3(+i), n) : r;
  }, n.y = function(i) {
    return arguments.length ? (t = typeof i == "function" ? i : e3(+i), n) : t;
  }, n.extent = function(i) {
    return arguments.length ? (e = i == null ? null : [[+i[0][0], +i[0][1]], [+i[1][0], +i[1][1]]], n) : e && [[e[0][0], e[0][1]], [e[1][0], e[1][1]]];
  }, n.size = function(i) {
    return arguments.length ? (e = i == null ? null : [[0, 0], [+i[0], +i[1]]], n) : e && [e[1][0] - e[0][0], e[1][1] - e[0][1]];
  }, n;
}
function cD(r) {
  return r = r.slice(), r.push(r[0]), Nt([r]);
}
function fD(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.bbox || [-180, -85, 180, 85];
  if (!r) throw new Error("points is required");
  if (!Array.isArray(e)) throw new Error("bbox is invalid");
  return Ia(r, "Point", "points"), ht(
    xD().x(function(n) {
      return n.geometry.coordinates[0];
    }).y(function(n) {
      return n.geometry.coordinates[1];
    }).extent([
      [e[0], e[1]],
      [e[2], e[3]]
    ]).polygons(r.features).map(cD)
  );
}
function bS(r, t, e, n) {
  n = n || {};
  var i = n.steps || 64, s = n.units || "kilometers", o = n.angle || 0, a = n.pivot || r, u = n.properties || r.properties || {};
  if (!r) throw new Error("center is required");
  if (!t) throw new Error("xSemiAxis is required");
  if (!e) throw new Error("ySemiAxis is required");
  if (!we(n)) throw new Error("options must be an object");
  if (!Wn(i)) throw new Error("steps must be a number");
  if (!Wn(o)) throw new Error("angle must be a number");
  var x = Ae(r);
  if (s === "degrees")
    var c = Un(o);
  else
    t = Ox(r, t, 90, { units: s }), e = Ox(r, e, 0, { units: s }), t = Ae(t)[0] - x[0], e = Ae(e)[1] - x[1];
  for (var f = [], l = 0; l < i; l += 1) {
    var h = l * -360 / i, p = t * e / Math.sqrt(
      Math.pow(e, 2) + Math.pow(t, 2) * Math.pow(i3(h), 2)
    ), y = t * e / Math.sqrt(
      Math.pow(t, 2) + Math.pow(e, 2) / Math.pow(i3(h), 2)
    );
    if (h < -90 && h >= -270 && (p = -p), h < -180 && h >= -360 && (y = -y), s === "degrees") {
      var v = p * Math.cos(c) + y * Math.sin(c), m = y * Math.cos(c) - p * Math.sin(c);
      p = v, y = m;
    }
    f.push([p + x[0], y + x[1]]);
  }
  return f.push(f[0]), s === "degrees" ? Nt([f], u) : eS(Nt([f], u), o, {
    pivot: a
  });
}
function i3(r) {
  var t = r * Math.PI / 180;
  return Math.tan(t);
}
function F2(r, t) {
  t === void 0 && (t = {});
  var e = 0, n = 0, i = 0;
  return Pi(r, function(s, o, a) {
    var u = t.weight ? a == null ? void 0 : a[t.weight] : void 0;
    if (u = u ?? 1, !Wn(u))
      throw new Error("weight value must be a number for feature index " + o);
    u = Number(u), u > 0 && hn(s, function(x) {
      e += x[0] * u, n += x[1] * u, i += u;
    });
  }), Pt([e / i, n / i], t.properties, t);
}
function lD(r, t) {
  if (t === void 0 && (t = {}), t = t || {}, !we(t))
    throw new Error("options is invalid");
  var e = t.counter || 10;
  if (!Wn(e))
    throw new Error("counter must be a number");
  var n = t.weight, i = F2(r, { weight: t.weight }), s = ht([]);
  he(r, function(a) {
    var u;
    s.features.push(Ka(a, {
      properties: { weight: (u = a.properties) === null || u === void 0 ? void 0 : u[n] }
    }));
  });
  var o = {
    tolerance: t.tolerance,
    medianCandidates: []
  };
  return IS(i.geometry.coordinates, [0, 0], s, o, e);
}
function IS(r, t, e, n, i) {
  var s = n.tolerance || 1e-3, o = 0, a = 0, u = 0, x = 0;
  if (he(e, function(l) {
    var h, p = (h = l.properties) === null || h === void 0 ? void 0 : h.weight, y = p ?? 1;
    if (y = Number(y), !Wn(y))
      throw new Error("weight value must be a number");
    if (y > 0) {
      x += 1;
      var v = y * Ie(l, r);
      v === 0 && (v = 1);
      var m = y / v;
      o += l.geometry.coordinates[0] * m, a += l.geometry.coordinates[1] * m, u += m;
    }
  }), x < 1)
    throw new Error("no features to measure");
  var c = o / u, f = a / u;
  return x === 1 || i === 0 || Math.abs(c - t[0]) < s && Math.abs(f - t[1]) < s ? Pt([c, f], {
    medianCandidates: n.medianCandidates
  }) : (n.medianCandidates.push([c, f]), IS([c, f], r, e, n, i - 1));
}
function hD(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.steps || 64, n = t.weight, i = t.properties || {};
  if (!Wn(e)) throw new Error("steps must be a number");
  if (!we(i)) throw new Error("properties must be a number");
  var s = Lx(r).length, o = F2(r, { weight: n }), a = 0, u = 0, x = 0;
  he(r, function(E) {
    var S = E.properties[n] || 1, I = s3(gt(E), gt(o));
    a += Math.pow(I.x, 2) * S, u += Math.pow(I.y, 2) * S, x += I.x * I.y * S;
  });
  var c = a - u, f = Math.sqrt(Math.pow(c, 2) + 4 * Math.pow(x, 2)), l = 2 * x, h = Math.atan((c + f) / l), p = h * 180 / Math.PI, y = 0, v = 0, m = 0;
  he(r, function(E) {
    var S = E.properties[n] || 1, I = s3(gt(E), gt(o));
    y += Math.pow(
      I.x * Math.cos(h) - I.y * Math.sin(h),
      2
    ) * S, v += Math.pow(
      I.x * Math.sin(h) + I.y * Math.cos(h),
      2
    ) * S, m += S;
  });
  var d = Math.sqrt(2 * y / m), g = Math.sqrt(2 * v / m), _ = bS(o, d, g, {
    units: "degrees",
    angle: p,
    steps: e,
    properties: i
  }), b = Dm(
    r,
    ht([_])
  ), w = {
    meanCenterCoordinates: gt(o),
    semiMajorAxis: d,
    semiMinorAxis: g,
    numberOfFeatures: s,
    angle: p,
    percentageWithinEllipse: 100 * Lx(b).length / s
  };
  return _.properties.standardDeviationalEllipse = w, _;
}
function s3(r, t) {
  return {
    x: r[0] - t[0],
    y: r[1] - t[1]
  };
}
function pD(r, t, e, n) {
  if (n === void 0 && (n = {}), !we(n))
    throw new Error("options is invalid");
  if (!r)
    throw new Error("startPoint is required");
  if (!t)
    throw new Error("midPoint is required");
  if (!e)
    throw new Error("endPoint is required");
  var i = r, s = t, o = e, a = q0(n.mercator !== !0 ? fa(i, s) : H0(i, s)), u = q0(n.mercator !== !0 ? fa(o, s) : H0(o, s)), x = Math.abs(a - u);
  return n.explementary === !0 ? 360 - x : x;
}
function dD(r, t) {
  var e = [], n = t.iterations || 1;
  if (!r) throw new Error("inputPolys is required");
  return Pi(r, function(i, s, o) {
    var a, u, x;
    switch (i.type) {
      case "Polygon":
        a = [[]];
        for (var c = 0; c < n; c++)
          x = [[]], u = i, c > 0 && (u = Nt(a).geometry), gD(u, x), a = x.slice(0);
        e.push(Nt(a, o));
        break;
      case "MultiPolygon":
        a = [[[]]];
        for (var f = 0; f < n; f++)
          x = [[[]]], u = i, f > 0 && (u = Mi(a).geometry), yD(u, x), a = x.slice(0);
        e.push(Mi(a, o));
        break;
      default:
        throw new Error("geometry is invalid, must be Polygon or MultiPolygon");
    }
  }), ht(e);
}
function gD(r, t) {
  var e = 0, n = 0;
  hn(
    r,
    function(i, s, o, a, u) {
      u > e && (e = u, n = s, t.push([]));
      var x = s - n, c = r.coordinates[u][x + 1], f = i[0], l = i[1], h = c[0], p = c[1];
      t[u].push([
        0.75 * f + 0.25 * h,
        0.75 * l + 0.25 * p
      ]), t[u].push([
        0.25 * f + 0.75 * h,
        0.25 * l + 0.75 * p
      ]);
    },
    !0
  ), t.forEach(function(i) {
    i.push(i[0]);
  });
}
function yD(r, t) {
  var e = 0, n = 0, i = 0;
  hn(
    r,
    function(s, o, a, u, x) {
      u > i && (i = u, n = o, t.push([[]])), x > e && (e = x, n = o, t[u].push([]));
      var c = o - n, f = r.coordinates[u][x][c + 1], l = s[0], h = s[1], p = f[0], y = f[1];
      t[u][x].push([
        0.75 * l + 0.25 * p,
        0.75 * h + 0.25 * y
      ]), t[u][x].push([
        0.25 * l + 0.75 * p,
        0.25 * h + 0.75 * y
      ]);
    },
    !0
  ), t.forEach(function(s) {
    s.forEach(function(o) {
      o.push(o[0]);
    });
  });
}
function vD(r, t, e) {
  e === void 0 && (e = 2);
  var n = Ae(r), i = Ae(t), s = n[0] - i[0], o = n[1] - i[1];
  return e === 1 ? Math.abs(s) + Math.abs(o) : Math.pow(Math.pow(s, e) + Math.pow(o, e), 1 / e);
}
function wS(r, t) {
  t = t || {};
  var e = t.threshold || 1e4, n = t.p || 2, i = t.binary || !1, s = t.alpha || -1, o = t.standardization || !1, a = [];
  he(r, function(h) {
    a.push(Ka(h));
  });
  for (var u = [], x = 0; x < a.length; x++)
    u[x] = [];
  for (var x = 0; x < a.length; x++)
    for (var c = x; c < a.length; c++) {
      x === c && (u[x][c] = 0);
      var f = vD(a[x], a[c], n);
      u[x][c] = f, u[c][x] = f;
    }
  for (var x = 0; x < a.length; x++)
    for (var c = 0; c < a.length; c++) {
      var f = u[x][c];
      f !== 0 && (i ? f <= e ? u[x][c] = 1 : u[x][c] = 0 : f <= e ? u[x][c] = Math.pow(f, s) : u[x][c] = 0);
    }
  if (o)
    for (var x = 0; x < a.length; x++)
      for (var l = u[x].reduce(function(p, y) {
        return p + y;
      }, 0), c = 0; c < a.length; c++)
        u[x][c] = u[x][c] / l;
  return u;
}
function mD(r, t) {
  var e = t.inputField, n = t.threshold || 1e5, i = t.p || 2, s = t.binary || !1, o = t.alpha || -1, a = t.standardization || !0, u = wS(r, {
    alpha: o,
    binary: s,
    p: i,
    standardization: a,
    threshold: n
  }), x = [];
  he(r, function(M) {
    var N = M.properties || {};
    x.push(N[e]);
  });
  for (var c = ES(x), f = _D(x), l = 0, h = 0, p = 0, y = 0, v = u.length, m = 0; m < v; m++) {
    for (var d = 0, g = 0; g < v; g++)
      l += u[m][g] * (x[m] - c) * (x[g] - c), h += u[m][g], p += Math.pow(u[m][g] + u[g][m], 2), d += u[m][g] + u[g][m];
    y += Math.pow(d, 2);
  }
  p = 0.5 * p;
  var _ = l / h / f, b = -1 / (v - 1), w = v * v * p - v * y + 3 * (h * h), E = (v - 1) * (v + 1) * (h * h), S = w / E - b * b, I = Math.sqrt(S), L = (_ - b) / I;
  return {
    expectedMoranIndex: b,
    moranIndex: _,
    stdNorm: I,
    zNorm: L
  };
}
function ES(r) {
  for (var t = 0, e = 0, n = r; e < n.length; e++) {
    var i = n[e];
    t += i;
  }
  return t / r.length;
}
function _D(r) {
  for (var t = ES(r), e = 0, n = 0, i = r; n < i.length; n++) {
    var s = i[n];
    e += Math.pow(s - t, 2);
  }
  return e / r.length;
}
function SS(r, t) {
  return t === void 0 && (t = {}), MS(r, "mercator", t);
}
function CS(r, t) {
  return t === void 0 && (t = {}), MS(r, "wgs84", t);
}
function MS(r, t, e) {
  e === void 0 && (e = {}), e = e || {};
  var n = e.mutate;
  if (!r)
    throw new Error("geojson is required");
  return Array.isArray(r) && Wn(r[0]) ? r = t === "mercator" ? o3(r) : a3(r) : (n !== !0 && (r = br(r)), hn(r, function(i) {
    var s = t === "mercator" ? o3(i) : a3(i);
    i[0] = s[0], i[1] = s[1];
  })), r;
}
function o3(r) {
  var t = Math.PI / 180, e = 6378137, n = 20037508342789244e-9, i = Math.abs(r[0]) <= 180 ? r[0] : r[0] - bD(r[0]) * 360, s = [
    e * i * t,
    e * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * r[1] * t))
  ];
  return s[0] > n && (s[0] = n), s[0] < -n && (s[0] = -n), s[1] > n && (s[1] = n), s[1] < -n && (s[1] = -n), s;
}
function a3(r) {
  var t = 180 / Math.PI, e = 6378137;
  return [
    r[0] * t / e,
    (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-r[1] / e))) * t
  ];
}
function bD(r) {
  return r < 0 ? -1 : r > 0 ? 1 : 0;
}
const ID = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  toMercator: SS,
  toWgs84: CS
}, Symbol.toStringTag, { value: "Module" }));
var wD = function() {
  for (var r = 0, t = 0, e = arguments.length; t < e; t++) r += arguments[t].length;
  for (var n = Array(r), i = 0, t = 0; t < e; t++)
    for (var s = arguments[t], o = 0, a = s.length; o < a; o++, i++)
      n[i] = s[o];
  return n;
};
function Hl(r) {
  return Array.isArray(r) ? u3(r) : r && r.bbox ? u3(r.bbox) : [SD(), CD()];
}
function PS(r, t) {
  t === void 0 && (t = {}), r == null && (r = 1);
  for (var e = [], n = 0; n < r; n++)
    e.push(Pt(Hl(t.bbox)));
  return ht(e);
}
function LS(r, t) {
  t === void 0 && (t = {}), r == null && (r = 1), (!Wn(t.num_vertices) || t.num_vertices === void 0) && (t.num_vertices = 10), (!Wn(t.max_radial_length) || t.max_radial_length === void 0) && (t.max_radial_length = 10);
  for (var e = [], n = function(s) {
    var o = [], a = wD(Array(t.num_vertices + 1)).map(Math.random);
    a.forEach(function(u, x, c) {
      c[x] = x > 0 ? u + c[x - 1] : u;
    }), a.forEach(function(u) {
      u = u * 2 * Math.PI / a[a.length - 1];
      var x = Math.random();
      o.push([
        x * (t.max_radial_length || 10) * Math.sin(u),
        x * (t.max_radial_length || 10) * Math.cos(u)
      ]);
    }), o[o.length - 1] = o[0], o = o.map(ED(Hl(t.bbox))), e.push(Nt([o]));
  }, i = 0; i < r; i++)
    n();
  return ht(e);
}
function NS(r, t) {
  if (t === void 0 && (t = {}), t = t || {}, !we(t))
    throw new Error("options is invalid");
  var e = t.bbox, n = t.num_vertices, i = t.max_length, s = t.max_rotation;
  r == null && (r = 1), (!Wn(n) || n === void 0 || n < 2) && (n = 10), (!Wn(i) || i === void 0) && (i = 1e-4), (!Wn(s) || s === void 0) && (s = Math.PI / 8);
  for (var o = [], a = 0; a < r; a++) {
    for (var u = Hl(e), x = [u], c = 0; c < n - 1; c++) {
      var f = c === 0 ? Math.random() * 2 * Math.PI : Math.tan((x[c][1] - x[c - 1][1]) / (x[c][0] - x[c - 1][0])), l = f + (Math.random() - 0.5) * s * 2, h = Math.random() * i;
      x.push([
        x[c][0] + h * Math.cos(l),
        x[c][1] + h * Math.sin(l)
      ]);
    }
    o.push(ge(x));
  }
  return ht(o);
}
function ED(r) {
  return function(t) {
    return [t[0] + r[0], t[1] + r[1]];
  };
}
function OS() {
  return Math.random() - 0.5;
}
function SD() {
  return OS() * 360;
}
function CD() {
  return OS() * 180;
}
function u3(r) {
  return [
    Math.random() * (r[2] - r[0]) + r[0],
    Math.random() * (r[3] - r[1]) + r[1]
  ];
}
const MD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  randomLineString: NS,
  randomPoint: PS,
  randomPolygon: LS,
  randomPosition: Hl
}, Symbol.toStringTag, { value: "Module" }));
function RS(r, t) {
  if (!r)
    throw new Error("geojson is required");
  if (r.type !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (t == null)
    throw new Error("filter is required");
  var e = [];
  return he(r, function(n) {
    zy(n.properties, t) && e.push(n);
  }), ht(e);
}
function k2(r, t, e) {
  if (!r)
    throw new Error("geojson is required");
  if (r.type !== "FeatureCollection")
    throw new Error("geojson must be a FeatureCollection");
  if (t == null)
    throw new Error("property is required");
  for (var n = B2(r, t), i = Object.keys(n), s = 0; s < i.length; s++) {
    for (var o = i[s], a = n[o], u = [], x = 0; x < a.length; x++)
      u.push(r.features[a[x]]);
    e(ht(u), o, s);
  }
}
function AS(r, t, e, n) {
  var i = n;
  return k2(r, t, function(s, o, a) {
    a === 0 && n === void 0 ? i = s : i = e(i, s, o, a);
  }), i;
}
function B2(r, t) {
  var e = {};
  return he(r, function(n, i) {
    var s = n.properties || {};
    if (Object.prototype.hasOwnProperty.call(s, String(t))) {
      var o = s[t];
      Object.prototype.hasOwnProperty.call(e, o) ? e[o].push(i) : e[o] = [i];
    }
  }), e;
}
function zy(r, t) {
  if (r === void 0)
    return !1;
  var e = typeof t;
  if (e === "number" || e === "string")
    return Object.prototype.hasOwnProperty.call(r, t);
  if (Array.isArray(t)) {
    for (var n = 0; n < t.length; n++)
      if (!zy(r, t[n]))
        return !1;
    return !0;
  } else
    return G2(r, t);
}
function G2(r, t) {
  for (var e = Object.keys(t), n = 0; n < e.length; n++) {
    var i = e[n];
    if (r[i] !== t[i])
      return !1;
  }
  return !0;
}
function TS(r, t) {
  if (!t)
    return {};
  if (!t.length)
    return {};
  for (var e = {}, n = 0; n < t.length; n++) {
    var i = t[n];
    Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
  }
  return e;
}
const PD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyFilter: zy,
  clusterEach: k2,
  clusterReduce: AS,
  createBins: B2,
  filterProperties: TS,
  getCluster: RS,
  propertiesContainsFilter: G2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function LD(r, t) {
  var e = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(x) {
    return function(c) {
      return u([x, c]);
    };
  }
  function u(x) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; e; ) try {
      if (n = 1, i && (s = x[0] & 2 ? i.return : x[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, x[1])).done) return s;
      switch (i = 0, s && (x = [x[0] & 2, s.value]), x[0]) {
        case 0:
        case 1:
          s = x;
          break;
        case 4:
          return e.label++, { value: x[1], done: !1 };
        case 5:
          e.label++, i = x[1], x = [0];
          continue;
        case 7:
          x = e.ops.pop(), e.trys.pop();
          continue;
        default:
          if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (x[0] === 6 || x[0] === 2)) {
            e = 0;
            continue;
          }
          if (x[0] === 3 && (!s || x[1] > s[0] && x[1] < s[3])) {
            e.label = x[1];
            break;
          }
          if (x[0] === 6 && e.label < s[1]) {
            e.label = s[1], s = x;
            break;
          }
          if (s && e.label < s[2]) {
            e.label = s[2], e.ops.push(x);
            break;
          }
          s[2] && e.ops.pop(), e.trys.pop();
          continue;
      }
      x = t.call(r, e);
    } catch (c) {
      x = [6, c], i = 0;
    } finally {
      n = s = 0;
    }
    if (x[0] & 5) throw x[1];
    return { value: x[0] ? x[1] : void 0, done: !0 };
  }
}
var ja = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t, e) {
      this.next = null, this.key = t, this.data = e, this.left = null, this.right = null;
    }
    return r;
  }()
);
function ND(r, t) {
  return r > t ? 1 : r < t ? -1 : 0;
}
function Ta(r, t, e) {
  for (var n = new ja(null, null), i = n, s = n; ; ) {
    var o = e(r, t.key);
    if (o < 0) {
      if (t.left === null)
        break;
      if (e(r, t.left.key) < 0) {
        var a = t.left;
        if (t.left = a.right, a.right = t, t = a, t.left === null)
          break;
      }
      s.left = t, s = t, t = t.left;
    } else if (o > 0) {
      if (t.right === null)
        break;
      if (e(r, t.right.key) > 0) {
        var a = t.right;
        if (t.right = a.left, a.left = t, t = a, t.right === null)
          break;
      }
      i.right = t, i = t, t = t.right;
    } else
      break;
  }
  return i.right = t.left, s.left = t.right, t.left = n.right, t.right = n.left, t;
}
function Qv(r, t, e, n) {
  var i = new ja(r, t);
  if (e === null)
    return i.left = i.right = null, i;
  e = Ta(r, e, n);
  var s = n(r, e.key);
  return s < 0 ? (i.left = e.left, i.right = e, e.left = null) : s >= 0 && (i.right = e.right, i.left = e, e.right = null), i;
}
function x3(r, t, e) {
  var n = null, i = null;
  if (t) {
    t = Ta(r, t, e);
    var s = e(t.key, r);
    s === 0 ? (n = t.left, i = t.right) : s < 0 ? (i = t.right, t.right = null, n = t) : (n = t.left, t.left = null, i = t);
  }
  return { left: n, right: i };
}
function OD(r, t, e) {
  return t === null ? r : (r === null || (t = Ta(r.key, t, e), t.left = r), t);
}
function Qm(r, t, e, n, i) {
  if (r) {
    n("" + t + (e ? "└── " : "├── ") + i(r) + `
`);
    var s = t + (e ? "    " : "│   ");
    r.left && Qm(r.left, s, !1, n, i), r.right && Qm(r.right, s, !0, n, i);
  }
}
var Y2 = (
  /** @class */
  function() {
    function r(t) {
      t === void 0 && (t = ND), this._root = null, this._size = 0, this._comparator = t;
    }
    return r.prototype.insert = function(t, e) {
      return this._size++, this._root = Qv(t, e, this._root, this._comparator);
    }, r.prototype.add = function(t, e) {
      var n = new ja(t, e);
      this._root === null && (n.left = n.right = null, this._size++, this._root = n);
      var i = this._comparator, s = Ta(t, this._root, i), o = i(t, s.key);
      return o === 0 ? this._root = s : (o < 0 ? (n.left = s.left, n.right = s, s.left = null) : o > 0 && (n.right = s.right, n.left = s, s.right = null), this._size++, this._root = n), this._root;
    }, r.prototype.remove = function(t) {
      this._root = this._remove(t, this._root, this._comparator);
    }, r.prototype._remove = function(t, e, n) {
      var i;
      if (e === null)
        return null;
      e = Ta(t, e, n);
      var s = n(t, e.key);
      return s === 0 ? (e.left === null ? i = e.right : (i = Ta(t, e.left, n), i.right = e.right), this._size--, i) : e;
    }, r.prototype.pop = function() {
      var t = this._root;
      if (t) {
        for (; t.left; )
          t = t.left;
        return this._root = Ta(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), { key: t.key, data: t.data };
      }
      return null;
    }, r.prototype.findStatic = function(t) {
      for (var e = this._root, n = this._comparator; e; ) {
        var i = n(t, e.key);
        if (i === 0)
          return e;
        i < 0 ? e = e.left : e = e.right;
      }
      return null;
    }, r.prototype.find = function(t) {
      return this._root && (this._root = Ta(t, this._root, this._comparator), this._comparator(t, this._root.key) !== 0) ? null : this._root;
    }, r.prototype.contains = function(t) {
      for (var e = this._root, n = this._comparator; e; ) {
        var i = n(t, e.key);
        if (i === 0)
          return !0;
        i < 0 ? e = e.left : e = e.right;
      }
      return !1;
    }, r.prototype.forEach = function(t, e) {
      for (var n = this._root, i = [], s = !1; !s; )
        n !== null ? (i.push(n), n = n.left) : i.length !== 0 ? (n = i.pop(), t.call(e, n), n = n.right) : s = !0;
      return this;
    }, r.prototype.range = function(t, e, n, i) {
      for (var s = [], o = this._comparator, a = this._root, u; s.length !== 0 || a; )
        if (a)
          s.push(a), a = a.left;
        else {
          if (a = s.pop(), u = o(a.key, e), u > 0)
            break;
          if (o(a.key, t) >= 0 && n.call(i, a))
            return this;
          a = a.right;
        }
      return this;
    }, r.prototype.keys = function() {
      var t = [];
      return this.forEach(function(e) {
        var n = e.key;
        return t.push(n);
      }), t;
    }, r.prototype.values = function() {
      var t = [];
      return this.forEach(function(e) {
        var n = e.data;
        return t.push(n);
      }), t;
    }, r.prototype.min = function() {
      return this._root ? this.minNode(this._root).key : null;
    }, r.prototype.max = function() {
      return this._root ? this.maxNode(this._root).key : null;
    }, r.prototype.minNode = function(t) {
      if (t === void 0 && (t = this._root), t)
        for (; t.left; )
          t = t.left;
      return t;
    }, r.prototype.maxNode = function(t) {
      if (t === void 0 && (t = this._root), t)
        for (; t.right; )
          t = t.right;
      return t;
    }, r.prototype.at = function(t) {
      for (var e = this._root, n = !1, i = 0, s = []; !n; )
        if (e)
          s.push(e), e = e.left;
        else if (s.length > 0) {
          if (e = s.pop(), i === t)
            return e;
          i++, e = e.right;
        } else
          n = !0;
      return null;
    }, r.prototype.next = function(t) {
      var e = this._root, n = null;
      if (t.right) {
        for (n = t.right; n.left; )
          n = n.left;
        return n;
      }
      for (var i = this._comparator; e; ) {
        var s = i(t.key, e.key);
        if (s === 0)
          break;
        s < 0 ? (n = e, e = e.left) : e = e.right;
      }
      return n;
    }, r.prototype.prev = function(t) {
      var e = this._root, n = null;
      if (t.left !== null) {
        for (n = t.left; n.right; )
          n = n.right;
        return n;
      }
      for (var i = this._comparator; e; ) {
        var s = i(t.key, e.key);
        if (s === 0)
          break;
        s < 0 ? e = e.left : (n = e, e = e.right);
      }
      return n;
    }, r.prototype.clear = function() {
      return this._root = null, this._size = 0, this;
    }, r.prototype.toList = function() {
      return AD(this._root);
    }, r.prototype.load = function(t, e, n) {
      e === void 0 && (e = []), n === void 0 && (n = !1);
      var i = t.length, s = this._comparator;
      if (n && e_(t, e, 0, i - 1, s), this._root === null)
        this._root = $m(t, e, 0, i), this._size = i;
      else {
        var o = TD(this.toList(), RD(t, e), s);
        i = this._size + i, this._root = t_({ head: o }, 0, i);
      }
      return this;
    }, r.prototype.isEmpty = function() {
      return this._root === null;
    }, Object.defineProperty(r.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(r.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: !0,
      configurable: !0
    }), r.prototype.toString = function(t) {
      t === void 0 && (t = function(n) {
        return String(n.key);
      });
      var e = [];
      return Qm(this._root, "", !0, function(n) {
        return e.push(n);
      }, t), e.join("");
    }, r.prototype.update = function(t, e, n) {
      var i = this._comparator, s = x3(t, this._root, i), o = s.left, a = s.right;
      i(t, e) < 0 ? a = Qv(e, n, a, i) : o = Qv(e, n, o, i), this._root = OD(o, a, i);
    }, r.prototype.split = function(t) {
      return x3(t, this._root, this._comparator);
    }, r.prototype[Symbol.iterator] = function() {
      var t, e, n;
      return LD(this, function(i) {
        switch (i.label) {
          case 0:
            t = this._root, e = [], n = !1, i.label = 1;
          case 1:
            return n ? [3, 6] : t === null ? [3, 2] : (e.push(t), t = t.left, [3, 5]);
          case 2:
            return e.length === 0 ? [3, 4] : (t = e.pop(), [4, t]);
          case 3:
            return i.sent(), t = t.right, [3, 5];
          case 4:
            n = !0, i.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    }, r;
  }()
);
function $m(r, t, e, n) {
  var i = n - e;
  if (i > 0) {
    var s = e + Math.floor(i / 2), o = r[s], a = t[s], u = new ja(o, a);
    return u.left = $m(r, t, e, s), u.right = $m(r, t, s + 1, n), u;
  }
  return null;
}
function RD(r, t) {
  for (var e = new ja(null, null), n = e, i = 0; i < r.length; i++)
    n = n.next = new ja(r[i], t[i]);
  return n.next = null, e.next;
}
function AD(r) {
  for (var t = r, e = [], n = !1, i = new ja(null, null), s = i; !n; )
    t ? (e.push(t), t = t.left) : e.length > 0 ? (t = s = s.next = e.pop(), t = t.right) : n = !0;
  return s.next = null, i.next;
}
function t_(r, t, e) {
  var n = e - t;
  if (n > 0) {
    var i = t + Math.floor(n / 2), s = t_(r, t, i), o = r.head;
    return o.left = s, r.head = r.head.next, o.right = t_(r, i + 1, e), o;
  }
  return null;
}
function TD(r, t, e) {
  for (var n = new ja(null, null), i = n, s = r, o = t; s !== null && o !== null; )
    e(s.key, o.key) < 0 ? (i.next = s, s = s.next) : (i.next = o, o = o.next), i = i.next;
  return s !== null ? i.next = s : o !== null && (i.next = o), n.next;
}
function e_(r, t, e, n, i) {
  if (!(e >= n)) {
    for (var s = r[e + n >> 1], o = e - 1, a = n + 1; ; ) {
      do
        o++;
      while (i(r[o], s) < 0);
      do
        a--;
      while (i(r[a], s) > 0);
      if (o >= a)
        break;
      var u = r[o];
      r[o] = r[a], r[a] = u, u = t[o], t[o] = t[a], t[a] = u;
    }
    e_(r, t, e, a, i), e_(r, t, a + 1, n, i);
  }
}
const ra = 11102230246251565e-32, Yr = 134217729, DD = (3 + 8 * ra) * ra;
function $v(r, t, e, n, i) {
  let s, o, a, u, x = t[0], c = n[0], f = 0, l = 0;
  c > x == c > -x ? (s = x, x = t[++f]) : (s = c, c = n[++l]);
  let h = 0;
  if (f < r && l < e)
    for (c > x == c > -x ? (o = x + s, a = s - (o - x), x = t[++f]) : (o = c + s, a = s - (o - c), c = n[++l]), s = o, a !== 0 && (i[h++] = a); f < r && l < e; )
      c > x == c > -x ? (o = s + x, u = o - s, a = s - (o - u) + (x - u), x = t[++f]) : (o = s + c, u = o - s, a = s - (o - u) + (c - u), c = n[++l]), s = o, a !== 0 && (i[h++] = a);
  for (; f < r; )
    o = s + x, u = o - s, a = s - (o - u) + (x - u), x = t[++f], s = o, a !== 0 && (i[h++] = a);
  for (; l < e; )
    o = s + c, u = o - s, a = s - (o - u) + (c - u), c = n[++l], s = o, a !== 0 && (i[h++] = a);
  return (s !== 0 || h === 0) && (i[h++] = s), h;
}
function FD(r, t) {
  let e = t[0];
  for (let n = 1; n < r; n++) e += t[n];
  return e;
}
function Jl(r) {
  return new Float64Array(r);
}
const kD = (3 + 16 * ra) * ra, BD = (2 + 12 * ra) * ra, GD = (9 + 64 * ra) * ra * ra, Lu = Jl(4), c3 = Jl(8), f3 = Jl(12), l3 = Jl(16), ei = Jl(4);
function YD(r, t, e, n, i, s, o) {
  let a, u, x, c, f, l, h, p, y, v, m, d, g, _, b, w, E, S;
  const I = r - i, L = e - i, M = t - s, N = n - s;
  _ = I * N, l = Yr * I, h = l - (l - I), p = I - h, l = Yr * N, y = l - (l - N), v = N - y, b = p * v - (_ - h * y - p * y - h * v), w = M * L, l = Yr * M, h = l - (l - M), p = M - h, l = Yr * L, y = l - (l - L), v = L - y, E = p * v - (w - h * y - p * y - h * v), m = b - E, f = b - m, Lu[0] = b - (m + f) + (f - E), d = _ + m, f = d - _, g = _ - (d - f) + (m - f), m = g - w, f = g - m, Lu[1] = g - (m + f) + (f - w), S = d + m, f = S - d, Lu[2] = d - (S - f) + (m - f), Lu[3] = S;
  let P = FD(4, Lu), O = BD * o;
  if (P >= O || -P >= O || (f = r - I, a = r - (I + f) + (f - i), f = e - L, x = e - (L + f) + (f - i), f = t - M, u = t - (M + f) + (f - s), f = n - N, c = n - (N + f) + (f - s), a === 0 && u === 0 && x === 0 && c === 0) || (O = GD * o + DD * Math.abs(P), P += I * c + N * a - (M * x + L * u), P >= O || -P >= O)) return P;
  _ = a * N, l = Yr * a, h = l - (l - a), p = a - h, l = Yr * N, y = l - (l - N), v = N - y, b = p * v - (_ - h * y - p * y - h * v), w = u * L, l = Yr * u, h = l - (l - u), p = u - h, l = Yr * L, y = l - (l - L), v = L - y, E = p * v - (w - h * y - p * y - h * v), m = b - E, f = b - m, ei[0] = b - (m + f) + (f - E), d = _ + m, f = d - _, g = _ - (d - f) + (m - f), m = g - w, f = g - m, ei[1] = g - (m + f) + (f - w), S = d + m, f = S - d, ei[2] = d - (S - f) + (m - f), ei[3] = S;
  const k = $v(4, Lu, 4, ei, c3);
  _ = I * c, l = Yr * I, h = l - (l - I), p = I - h, l = Yr * c, y = l - (l - c), v = c - y, b = p * v - (_ - h * y - p * y - h * v), w = M * x, l = Yr * M, h = l - (l - M), p = M - h, l = Yr * x, y = l - (l - x), v = x - y, E = p * v - (w - h * y - p * y - h * v), m = b - E, f = b - m, ei[0] = b - (m + f) + (f - E), d = _ + m, f = d - _, g = _ - (d - f) + (m - f), m = g - w, f = g - m, ei[1] = g - (m + f) + (f - w), S = d + m, f = S - d, ei[2] = d - (S - f) + (m - f), ei[3] = S;
  const D = $v(k, c3, 4, ei, f3);
  _ = a * c, l = Yr * a, h = l - (l - a), p = a - h, l = Yr * c, y = l - (l - c), v = c - y, b = p * v - (_ - h * y - p * y - h * v), w = u * x, l = Yr * u, h = l - (l - u), p = u - h, l = Yr * x, y = l - (l - x), v = x - y, E = p * v - (w - h * y - p * y - h * v), m = b - E, f = b - m, ei[0] = b - (m + f) + (f - E), d = _ + m, f = d - _, g = _ - (d - f) + (m - f), m = g - w, f = g - m, ei[1] = g - (m + f) + (f - w), S = d + m, f = S - d, ei[2] = d - (S - f) + (m - f), ei[3] = S;
  const F = $v(D, f3, 4, ei, l3);
  return l3[F - 1];
}
function XD(r, t, e, n, i, s) {
  const o = (t - s) * (e - i), a = (r - i) * (n - s), u = o - a, x = Math.abs(o + a);
  return Math.abs(u) >= kD * x ? u : -YD(r, t, e, n, i, s, x);
}
const Ic = (r, t) => r.ll.x <= t.x && t.x <= r.ur.x && r.ll.y <= t.y && t.y <= r.ur.y, n_ = (r, t) => {
  if (t.ur.x < r.ll.x || r.ur.x < t.ll.x || t.ur.y < r.ll.y || r.ur.y < t.ll.y) return null;
  const e = r.ll.x < t.ll.x ? t.ll.x : r.ll.x, n = r.ur.x < t.ur.x ? r.ur.x : t.ur.x, i = r.ll.y < t.ll.y ? t.ll.y : r.ll.y, s = r.ur.y < t.ur.y ? r.ur.y : t.ur.y;
  return {
    ll: {
      x: e,
      y: i
    },
    ur: {
      x: n,
      y: s
    }
  };
};
let Ba = Number.EPSILON;
Ba === void 0 && (Ba = Math.pow(2, -52));
const qD = Ba * Ba, h3 = (r, t) => {
  if (-Ba < r && r < Ba && -Ba < t && t < Ba)
    return 0;
  const e = r - t;
  return e * e < qD * r * t ? 0 : r < t ? -1 : 1;
};
class zD {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new p3(), this.yRounder = new p3();
  }
  round(t, e) {
    return {
      x: this.xRounder.round(t),
      y: this.yRounder.round(e)
    };
  }
}
class p3 {
  constructor() {
    this.tree = new Y2(), this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(t) {
    const e = this.tree.add(t), n = this.tree.prev(e);
    if (n !== null && h3(e.key, n.key) === 0)
      return this.tree.remove(t), n.key;
    const i = this.tree.next(e);
    return i !== null && h3(e.key, i.key) === 0 ? (this.tree.remove(t), i.key) : t;
  }
}
const gl = new zD(), Vh = (r, t) => r.x * t.y - r.y * t.x, DS = (r, t) => r.x * t.x + r.y * t.y, d3 = (r, t, e) => {
  const n = XD(r.x, r.y, t.x, t.y, e.x, e.y);
  return n > 0 ? -1 : n < 0 ? 1 : 0;
}, Rg = (r) => Math.sqrt(DS(r, r)), UD = (r, t, e) => {
  const n = {
    x: t.x - r.x,
    y: t.y - r.y
  }, i = {
    x: e.x - r.x,
    y: e.y - r.y
  };
  return Vh(i, n) / Rg(i) / Rg(n);
}, VD = (r, t, e) => {
  const n = {
    x: t.x - r.x,
    y: t.y - r.y
  }, i = {
    x: e.x - r.x,
    y: e.y - r.y
  };
  return DS(i, n) / Rg(i) / Rg(n);
}, g3 = (r, t, e) => t.y === 0 ? null : {
  x: r.x + t.x / t.y * (e - r.y),
  y: e
}, y3 = (r, t, e) => t.x === 0 ? null : {
  x: e,
  y: r.y + t.y / t.x * (e - r.x)
}, WD = (r, t, e, n) => {
  if (t.x === 0) return y3(e, n, r.x);
  if (n.x === 0) return y3(r, t, e.x);
  if (t.y === 0) return g3(e, n, r.y);
  if (n.y === 0) return g3(r, t, e.y);
  const i = Vh(t, n);
  if (i == 0) return null;
  const s = {
    x: e.x - r.x,
    y: e.y - r.y
  }, o = Vh(s, t) / i, a = Vh(s, n) / i, u = r.x + a * t.x, x = e.x + o * n.x, c = r.y + a * t.y, f = e.y + o * n.y, l = (u + x) / 2, h = (c + f) / 2;
  return {
    x: l,
    y: h
  };
};
class fs {
  // for ordering sweep events in the sweep event queue
  static compare(t, e) {
    const n = fs.comparePoints(t.point, e.point);
    return n !== 0 ? n : (t.point !== e.point && t.link(e), t.isLeft !== e.isLeft ? t.isLeft ? 1 : -1 : qa.compare(t.segment, e.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(t, e) {
    return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(t, e) {
    t.events === void 0 ? t.events = [this] : t.events.push(this), this.point = t, this.isLeft = e;
  }
  link(t) {
    if (t.point === this.point)
      throw new Error("Tried to link already linked events");
    const e = t.point.events;
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      this.point.events.push(s), s.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const t = this.point.events.length;
    for (let e = 0; e < t; e++) {
      const n = this.point.events[e];
      if (n.segment.consumedBy === void 0)
        for (let i = e + 1; i < t; i++) {
          const s = this.point.events[i];
          s.consumedBy === void 0 && n.otherSE.point.events === s.otherSE.point.events && n.segment.consume(s.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const t = [];
    for (let e = 0, n = this.point.events.length; e < n; e++) {
      const i = this.point.events[e];
      i !== this && !i.segment.ringOut && i.segment.isInResult() && t.push(i);
    }
    return t;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(t) {
    const e = /* @__PURE__ */ new Map(), n = (i) => {
      const s = i.otherSE;
      e.set(i, {
        sine: UD(this.point, t.point, s.point),
        cosine: VD(this.point, t.point, s.point)
      });
    };
    return (i, s) => {
      e.has(i) || n(i), e.has(s) || n(s);
      const {
        sine: o,
        cosine: a
      } = e.get(i), {
        sine: u,
        cosine: x
      } = e.get(s);
      return o >= 0 && u >= 0 ? a < x ? 1 : a > x ? -1 : 0 : o < 0 && u < 0 ? a < x ? -1 : a > x ? 1 : 0 : u < o ? -1 : u > o ? 1 : 0;
    };
  }
}
let HD = 0;
class qa {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(t, e) {
    const n = t.leftSE.point.x, i = e.leftSE.point.x, s = t.rightSE.point.x, o = e.rightSE.point.x;
    if (o < n) return 1;
    if (s < i) return -1;
    const a = t.leftSE.point.y, u = e.leftSE.point.y, x = t.rightSE.point.y, c = e.rightSE.point.y;
    if (n < i) {
      if (u < a && u < x) return 1;
      if (u > a && u > x) return -1;
      const f = t.comparePoint(e.leftSE.point);
      if (f < 0) return 1;
      if (f > 0) return -1;
      const l = e.comparePoint(t.rightSE.point);
      return l !== 0 ? l : -1;
    }
    if (n > i) {
      if (a < u && a < c) return -1;
      if (a > u && a > c) return 1;
      const f = e.comparePoint(t.leftSE.point);
      if (f !== 0) return f;
      const l = t.comparePoint(e.rightSE.point);
      return l < 0 ? 1 : l > 0 ? -1 : 1;
    }
    if (a < u) return -1;
    if (a > u) return 1;
    if (s < o) {
      const f = e.comparePoint(t.rightSE.point);
      if (f !== 0) return f;
    }
    if (s > o) {
      const f = t.comparePoint(e.rightSE.point);
      if (f < 0) return 1;
      if (f > 0) return -1;
    }
    if (s !== o) {
      const f = x - a, l = s - n, h = c - u, p = o - i;
      if (f > l && h < p) return 1;
      if (f < l && h > p) return -1;
    }
    return s > o ? 1 : s < o || x < c ? -1 : x > c ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(t, e, n, i) {
    this.id = ++HD, this.leftSE = t, t.segment = this, t.otherSE = e, this.rightSE = e, e.segment = this, e.otherSE = t, this.rings = n, this.windings = i;
  }
  static fromRing(t, e, n) {
    let i, s, o;
    const a = fs.comparePoints(t, e);
    if (a < 0)
      i = t, s = e, o = 1;
    else if (a > 0)
      i = e, s = t, o = -1;
    else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);
    const u = new fs(i, !0), x = new fs(s, !1);
    return new qa(u, x, [n], [o]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(t) {
    this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const t = this.leftSE.point.y, e = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: t < e ? t : e
      },
      ur: {
        x: this.rightSE.point.x,
        y: t > e ? t : e
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(t) {
    return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(t) {
    if (this.isAnEndpoint(t)) return 0;
    const e = this.leftSE.point, n = this.rightSE.point, i = this.vector();
    if (e.x === n.x)
      return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;
    const s = (t.y - e.y) / i.y, o = e.x + s * i.x;
    if (t.x === o) return 0;
    const a = (t.x - e.x) / i.x, u = e.y + a * i.y;
    return t.y === u ? 0 : t.y < u ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(t) {
    const e = this.bbox(), n = t.bbox(), i = n_(e, n);
    if (i === null) return null;
    const s = this.leftSE.point, o = this.rightSE.point, a = t.leftSE.point, u = t.rightSE.point, x = Ic(e, a) && this.comparePoint(a) === 0, c = Ic(n, s) && t.comparePoint(s) === 0, f = Ic(e, u) && this.comparePoint(u) === 0, l = Ic(n, o) && t.comparePoint(o) === 0;
    if (c && x)
      return l && !f ? o : !l && f ? u : null;
    if (c)
      return f && s.x === u.x && s.y === u.y ? null : s;
    if (x)
      return l && o.x === a.x && o.y === a.y ? null : a;
    if (l && f) return null;
    if (l) return o;
    if (f) return u;
    const h = WD(s, this.vector(), a, t.vector());
    return h === null || !Ic(i, h) ? null : gl.round(h.x, h.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(t) {
    const e = [], n = t.events !== void 0, i = new fs(t, !0), s = new fs(t, !1), o = this.rightSE;
    this.replaceRightSE(s), e.push(s), e.push(i);
    const a = new qa(i, o, this.rings.slice(), this.windings.slice());
    return fs.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), fs.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), n && (i.checkForConsuming(), s.checkForConsuming()), e;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const t = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let e = 0, n = this.windings.length; e < n; e++)
      this.windings[e] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(t) {
    let e = this, n = t;
    for (; e.consumedBy; ) e = e.consumedBy;
    for (; n.consumedBy; ) n = n.consumedBy;
    const i = qa.compare(e, n);
    if (i !== 0) {
      if (i > 0) {
        const s = e;
        e = n, n = s;
      }
      if (e.prev === n) {
        const s = e;
        e = n, n = s;
      }
      for (let s = 0, o = n.rings.length; s < o; s++) {
        const a = n.rings[s], u = n.windings[s], x = e.rings.indexOf(a);
        x === -1 ? (e.rings.push(a), e.windings.push(u)) : e.windings[x] += u;
      }
      n.rings = null, n.windings = null, n.consumedBy = e, n.leftSE.consumedBy = e.leftSE, n.rightSE.consumedBy = e.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev) this._beforeState = {
      rings: [],
      windings: [],
      multiPolys: []
    };
    else {
      const t = this.prev.consumedBy || this.prev;
      this._beforeState = t.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const t = this.beforeState();
    this._afterState = {
      rings: t.rings.slice(0),
      windings: t.windings.slice(0),
      multiPolys: []
    };
    const e = this._afterState.rings, n = this._afterState.windings, i = this._afterState.multiPolys;
    for (let a = 0, u = this.rings.length; a < u; a++) {
      const x = this.rings[a], c = this.windings[a], f = e.indexOf(x);
      f === -1 ? (e.push(x), n.push(c)) : n[f] += c;
    }
    const s = [], o = [];
    for (let a = 0, u = e.length; a < u; a++) {
      if (n[a] === 0) continue;
      const x = e[a], c = x.poly;
      if (o.indexOf(c) === -1)
        if (x.isExterior) s.push(c);
        else {
          o.indexOf(c) === -1 && o.push(c);
          const f = s.indexOf(x.poly);
          f !== -1 && s.splice(f, 1);
        }
    }
    for (let a = 0, u = s.length; a < u; a++) {
      const x = s[a].multiPoly;
      i.indexOf(x) === -1 && i.push(x);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const t = this.beforeState().multiPolys, e = this.afterState().multiPolys;
    switch (Us.type) {
      case "union": {
        const n = t.length === 0, i = e.length === 0;
        this._isInResult = n !== i;
        break;
      }
      case "intersection": {
        let n, i;
        t.length < e.length ? (n = t.length, i = e.length) : (n = e.length, i = t.length), this._isInResult = i === Us.numMultiPolys && n < i;
        break;
      }
      case "xor": {
        const n = Math.abs(t.length - e.length);
        this._isInResult = n % 2 === 1;
        break;
      }
      case "difference": {
        const n = (i) => i.length === 1 && i[0].isSubject;
        this._isInResult = n(t) !== n(e);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${Us.type}`);
    }
    return this._isInResult;
  }
}
class v3 {
  constructor(t, e, n) {
    if (!Array.isArray(t) || t.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = e, this.isExterior = n, this.segments = [], typeof t[0][0] != "number" || typeof t[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const i = gl.round(t[0][0], t[0][1]);
    this.bbox = {
      ll: {
        x: i.x,
        y: i.y
      },
      ur: {
        x: i.x,
        y: i.y
      }
    };
    let s = i;
    for (let o = 1, a = t.length; o < a; o++) {
      if (typeof t[o][0] != "number" || typeof t[o][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      let u = gl.round(t[o][0], t[o][1]);
      u.x === s.x && u.y === s.y || (this.segments.push(qa.fromRing(s, u, this)), u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x), u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y), u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x), u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y), s = u);
    }
    (i.x !== s.x || i.y !== s.y) && this.segments.push(qa.fromRing(s, i, this));
  }
  getSweepEvents() {
    const t = [];
    for (let e = 0, n = this.segments.length; e < n; e++) {
      const i = this.segments[e];
      t.push(i.leftSE), t.push(i.rightSE);
    }
    return t;
  }
}
class JD {
  constructor(t, e) {
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new v3(t[0], this, !0), this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    }, this.interiorRings = [];
    for (let n = 1, i = t.length; n < i; n++) {
      const s = new v3(t[n], this, !1);
      s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.interiorRings.push(s);
    }
    this.multiPoly = e;
  }
  getSweepEvents() {
    const t = this.exteriorRing.getSweepEvents();
    for (let e = 0, n = this.interiorRings.length; e < n; e++) {
      const i = this.interiorRings[e].getSweepEvents();
      for (let s = 0, o = i.length; s < o; s++)
        t.push(i[s]);
    }
    return t;
  }
}
class m3 {
  constructor(t, e) {
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof t[0][0][0] == "number" && (t = [t]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let n = 0, i = t.length; n < i; n++) {
      const s = new JD(t[n], this);
      s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.polys.push(s);
    }
    this.isSubject = e;
  }
  getSweepEvents() {
    const t = [];
    for (let e = 0, n = this.polys.length; e < n; e++) {
      const i = this.polys[e].getSweepEvents();
      for (let s = 0, o = i.length; s < o; s++)
        t.push(i[s]);
    }
    return t;
  }
}
class Ag {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(t) {
    const e = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      if (!s.isInResult() || s.ringOut) continue;
      let o = null, a = s.leftSE, u = s.rightSE;
      const x = [a], c = a.point, f = [];
      for (; o = a, a = u, x.push(a), a.point !== c; )
        for (; ; ) {
          const l = a.getAvailableLinkedEvents();
          if (l.length === 0) {
            const y = x[0].point, v = x[x.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${y.x}, ${y.y}]. Last matching segment found ends at [${v.x}, ${v.y}].`);
          }
          if (l.length === 1) {
            u = l[0].otherSE;
            break;
          }
          let h = null;
          for (let y = 0, v = f.length; y < v; y++)
            if (f[y].point === a.point) {
              h = y;
              break;
            }
          if (h !== null) {
            const y = f.splice(h)[0], v = x.splice(y.index);
            v.unshift(v[0].otherSE), e.push(new Ag(v.reverse()));
            continue;
          }
          f.push({
            index: x.length,
            point: a.point
          });
          const p = a.getLeftmostComparator(o);
          u = l.sort(p)[0].otherSE;
          break;
        }
      e.push(new Ag(x));
    }
    return e;
  }
  constructor(t) {
    this.events = t;
    for (let e = 0, n = t.length; e < n; e++)
      t[e].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let t = this.events[0].point;
    const e = [t];
    for (let x = 1, c = this.events.length - 1; x < c; x++) {
      const f = this.events[x].point, l = this.events[x + 1].point;
      d3(f, t, l) !== 0 && (e.push(f), t = f);
    }
    if (e.length === 1) return null;
    const n = e[0], i = e[1];
    d3(n, t, i) === 0 && e.shift(), e.push(e[0]);
    const s = this.isExteriorRing() ? 1 : -1, o = this.isExteriorRing() ? 0 : e.length - 1, a = this.isExteriorRing() ? e.length : -1, u = [];
    for (let x = o; x != a; x += s) u.push([e[x].x, e[x].y]);
    return u;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const t = this.enclosingRing();
      this._isExteriorRing = t ? !t.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let t = this.events[0];
    for (let i = 1, s = this.events.length; i < s; i++) {
      const o = this.events[i];
      fs.compare(t, o) > 0 && (t = o);
    }
    let e = t.segment.prevInResult(), n = e ? e.prevInResult() : null;
    for (; ; ) {
      if (!e) return null;
      if (!n) return e.ringOut;
      if (n.ringOut !== e.ringOut)
        return n.ringOut.enclosingRing() !== e.ringOut ? e.ringOut : e.ringOut.enclosingRing();
      e = n.prevInResult(), n = e ? e.prevInResult() : null;
    }
  }
}
class _3 {
  constructor(t) {
    this.exteriorRing = t, t.poly = this, this.interiorRings = [];
  }
  addInterior(t) {
    this.interiorRings.push(t), t.poly = this;
  }
  getGeom() {
    const t = [this.exteriorRing.getGeom()];
    if (t[0] === null) return null;
    for (let e = 0, n = this.interiorRings.length; e < n; e++) {
      const i = this.interiorRings[e].getGeom();
      i !== null && t.push(i);
    }
    return t;
  }
}
class ZD {
  constructor(t) {
    this.rings = t, this.polys = this._composePolys(t);
  }
  getGeom() {
    const t = [];
    for (let e = 0, n = this.polys.length; e < n; e++) {
      const i = this.polys[e].getGeom();
      i !== null && t.push(i);
    }
    return t;
  }
  _composePolys(t) {
    const e = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      if (!s.poly)
        if (s.isExteriorRing()) e.push(new _3(s));
        else {
          const o = s.enclosingRing();
          o.poly || e.push(new _3(o)), o.poly.addInterior(s);
        }
    }
    return e;
  }
}
class KD {
  constructor(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : qa.compare;
    this.queue = t, this.tree = new Y2(e), this.segments = [];
  }
  process(t) {
    const e = t.segment, n = [];
    if (t.consumedBy)
      return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), n;
    const i = t.isLeft ? this.tree.add(e) : this.tree.find(e);
    if (!i) throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);
    let s = i, o = i, a, u;
    for (; a === void 0; )
      s = this.tree.prev(s), s === null ? a = null : s.key.consumedBy === void 0 && (a = s.key);
    for (; u === void 0; )
      o = this.tree.next(o), o === null ? u = null : o.key.consumedBy === void 0 && (u = o.key);
    if (t.isLeft) {
      let x = null;
      if (a) {
        const f = a.getIntersection(e);
        if (f !== null && (e.isAnEndpoint(f) || (x = f), !a.isAnEndpoint(f))) {
          const l = this._splitSafely(a, f);
          for (let h = 0, p = l.length; h < p; h++)
            n.push(l[h]);
        }
      }
      let c = null;
      if (u) {
        const f = u.getIntersection(e);
        if (f !== null && (e.isAnEndpoint(f) || (c = f), !u.isAnEndpoint(f))) {
          const l = this._splitSafely(u, f);
          for (let h = 0, p = l.length; h < p; h++)
            n.push(l[h]);
        }
      }
      if (x !== null || c !== null) {
        let f = null;
        x === null ? f = c : c === null ? f = x : f = fs.comparePoints(x, c) <= 0 ? x : c, this.queue.remove(e.rightSE), n.push(e.rightSE);
        const l = e.split(f);
        for (let h = 0, p = l.length; h < p; h++)
          n.push(l[h]);
      }
      n.length > 0 ? (this.tree.remove(e), n.push(t)) : (this.segments.push(e), e.prev = a);
    } else {
      if (a && u) {
        const x = a.getIntersection(u);
        if (x !== null) {
          if (!a.isAnEndpoint(x)) {
            const c = this._splitSafely(a, x);
            for (let f = 0, l = c.length; f < l; f++)
              n.push(c[f]);
          }
          if (!u.isAnEndpoint(x)) {
            const c = this._splitSafely(u, x);
            for (let f = 0, l = c.length; f < l; f++)
              n.push(c[f]);
          }
        }
      }
      this.tree.remove(e);
    }
    return n;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(t, e) {
    this.tree.remove(t);
    const n = t.rightSE;
    this.queue.remove(n);
    const i = t.split(e);
    return i.push(n), t.consumedBy === void 0 && this.tree.add(t), i;
  }
}
const b3 = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, jD = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
class QD {
  run(t, e, n) {
    Us.type = t, gl.reset();
    const i = [new m3(e, !0)];
    for (let f = 0, l = n.length; f < l; f++)
      i.push(new m3(n[f], !1));
    if (Us.numMultiPolys = i.length, Us.type === "difference") {
      const f = i[0];
      let l = 1;
      for (; l < i.length; )
        n_(i[l].bbox, f.bbox) !== null ? l++ : i.splice(l, 1);
    }
    if (Us.type === "intersection")
      for (let f = 0, l = i.length; f < l; f++) {
        const h = i[f];
        for (let p = f + 1, y = i.length; p < y; p++)
          if (n_(h.bbox, i[p].bbox) === null) return [];
      }
    const s = new Y2(fs.compare);
    for (let f = 0, l = i.length; f < l; f++) {
      const h = i[f].getSweepEvents();
      for (let p = 0, y = h.length; p < y; p++)
        if (s.insert(h[p]), s.size > b3)
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
    }
    const o = new KD(s);
    let a = s.size, u = s.pop();
    for (; u; ) {
      const f = u.key;
      if (s.size === a) {
        const h = f.segment;
        throw new Error(`Unable to pop() ${f.isLeft ? "left" : "right"} SweepEvent [${f.point.x}, ${f.point.y}] from segment #${h.id} [${h.leftSE.point.x}, ${h.leftSE.point.y}] -> [${h.rightSE.point.x}, ${h.rightSE.point.y}] from queue.`);
      }
      if (s.size > b3)
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      if (o.segments.length > jD)
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      const l = o.process(f);
      for (let h = 0, p = l.length; h < p; h++) {
        const y = l[h];
        y.consumedBy === void 0 && s.insert(y);
      }
      a = s.size, u = s.pop();
    }
    gl.reset();
    const x = Ag.factory(o.segments);
    return new ZD(x).getGeom();
  }
}
const Us = new QD(), $D = function(r) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    e[n - 1] = arguments[n];
  return Us.run("union", r, e);
}, tF = function(r) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    e[n - 1] = arguments[n];
  return Us.run("intersection", r, e);
}, eF = function(r) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    e[n - 1] = arguments[n];
  return Us.run("xor", r, e);
}, nF = function(r) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    e[n - 1] = arguments[n];
  return Us.run("difference", r, e);
};
var ia = {
  union: $D,
  intersection: tF,
  xor: eF,
  difference: nF
};
function rF(r, t) {
  var e = ke(r), n = ke(t), i = r.properties || {}, s = ia.difference(
    e.coordinates,
    n.coordinates
  );
  return s.length === 0 ? null : s.length === 1 ? Nt(s[0], i) : Mi(s, i);
}
"fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", {
  configurable: !0,
  value: function(t) {
    if (this === void 0 || this === null)
      throw new TypeError(this + " is not an object");
    var e = Object(this), n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0, i = 1 in arguments && parseInt(Number(arguments[1]), 10) || 0;
    i = i < 0 ? Math.max(n + i, 0) : Math.min(i, n);
    var s = 2 in arguments && arguments[2] !== void 0 ? parseInt(Number(arguments[2]), 10) || 0 : n;
    for (s = s < 0 ? Math.max(n + arguments[2], 0) : Math.min(s, n); i < s; )
      e[i] = t, ++i;
    return e;
  },
  writable: !0
});
Number.isFinite = Number.isFinite || function(r) {
  return typeof r == "number" && isFinite(r);
};
Number.isInteger = Number.isInteger || function(r) {
  return typeof r == "number" && isFinite(r) && Math.floor(r) === r;
};
Number.parseFloat = Number.parseFloat || parseFloat;
Number.isNaN = Number.isNaN || function(r) {
  return r !== r;
};
Math.trunc = Math.trunc || function(r) {
  return r < 0 ? Math.ceil(r) : Math.floor(r);
};
var J0 = function() {
};
J0.prototype.interfaces_ = function() {
  return [];
};
J0.prototype.getClass = function() {
  return J0;
};
J0.prototype.equalsWithTolerance = function(t, e, n) {
  return Math.abs(t - e) <= n;
};
var ze = function(r) {
  function t(e) {
    r.call(this, e), this.name = "IllegalArgumentException", this.message = e, this.stack = new r().stack;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t;
}(Error), yt = function() {
}, FS = { MAX_VALUE: { configurable: !0 } };
yt.isNaN = function(t) {
  return Number.isNaN(t);
};
yt.doubleToLongBits = function(t) {
  return t;
};
yt.longBitsToDouble = function(t) {
  return t;
};
yt.isInfinite = function(t) {
  return !Number.isFinite(t);
};
FS.MAX_VALUE.get = function() {
  return Number.MAX_VALUE;
};
Object.defineProperties(yt, FS);
var Ri = function() {
}, Uy = function() {
}, Rx = function() {
};
function Ai() {
}
var R = function r() {
  if (this.x = null, this.y = null, this.z = null, arguments.length === 0)
    this.x = 0, this.y = 0, this.z = r.NULL_ORDINATE;
  else if (arguments.length === 1) {
    var t = arguments[0];
    this.x = t.x, this.y = t.y, this.z = t.z;
  } else arguments.length === 2 ? (this.x = arguments[0], this.y = arguments[1], this.z = r.NULL_ORDINATE) : arguments.length === 3 && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
}, fu = { DimensionalComparator: { configurable: !0 }, serialVersionUID: { configurable: !0 }, NULL_ORDINATE: { configurable: !0 }, X: { configurable: !0 }, Y: { configurable: !0 }, Z: { configurable: !0 } };
R.prototype.setOrdinate = function(t, e) {
  switch (t) {
    case R.X:
      this.x = e;
      break;
    case R.Y:
      this.y = e;
      break;
    case R.Z:
      this.z = e;
      break;
    default:
      throw new ze("Invalid ordinate index: " + t);
  }
};
R.prototype.equals2D = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return !(this.x !== t.x || this.y !== t.y);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    return !(!J0.equalsWithTolerance(this.x, e.x, n) || !J0.equalsWithTolerance(this.y, e.y, n));
  }
};
R.prototype.getOrdinate = function(t) {
  switch (t) {
    case R.X:
      return this.x;
    case R.Y:
      return this.y;
    case R.Z:
      return this.z;
  }
  throw new ze("Invalid ordinate index: " + t);
};
R.prototype.equals3D = function(t) {
  return this.x === t.x && this.y === t.y && (this.z === t.z || yt.isNaN(this.z)) && yt.isNaN(t.z);
};
R.prototype.equals = function(t) {
  return t instanceof R ? this.equals2D(t) : !1;
};
R.prototype.equalInZ = function(t, e) {
  return J0.equalsWithTolerance(this.z, t.z, e);
};
R.prototype.compareTo = function(t) {
  var e = t;
  return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;
};
R.prototype.clone = function() {
};
R.prototype.copy = function() {
  return new R(this);
};
R.prototype.toString = function() {
  return "(" + this.x + ", " + this.y + ", " + this.z + ")";
};
R.prototype.distance3D = function(t) {
  var e = this.x - t.x, n = this.y - t.y, i = this.z - t.z;
  return Math.sqrt(e * e + n * n + i * i);
};
R.prototype.distance = function(t) {
  var e = this.x - t.x, n = this.y - t.y;
  return Math.sqrt(e * e + n * n);
};
R.prototype.hashCode = function() {
  var t = 17;
  return t = 37 * t + R.hashCode(this.x), t = 37 * t + R.hashCode(this.y), t;
};
R.prototype.setCoordinate = function(t) {
  this.x = t.x, this.y = t.y, this.z = t.z;
};
R.prototype.interfaces_ = function() {
  return [Ri, Uy, Ai];
};
R.prototype.getClass = function() {
  return R;
};
R.hashCode = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = yt.doubleToLongBits(t);
    return Math.trunc((e ^ e) >>> 32);
  }
};
fu.DimensionalComparator.get = function() {
  return jo;
};
fu.serialVersionUID.get = function() {
  return 6683108902428367e3;
};
fu.NULL_ORDINATE.get = function() {
  return yt.NaN;
};
fu.X.get = function() {
  return 0;
};
fu.Y.get = function() {
  return 1;
};
fu.Z.get = function() {
  return 2;
};
Object.defineProperties(R, fu);
var jo = function(t) {
  if (this._dimensionsToTest = 2, arguments.length !== 0) {
    if (arguments.length === 1) {
      var e = arguments[0];
      if (e !== 2 && e !== 3)
        throw new ze("only 2 or 3 dimensions may be specified");
      this._dimensionsToTest = e;
    }
  }
};
jo.prototype.compare = function(t, e) {
  var n = t, i = e, s = jo.compare(n.x, i.x);
  if (s !== 0)
    return s;
  var o = jo.compare(n.y, i.y);
  if (o !== 0)
    return o;
  if (this._dimensionsToTest <= 2)
    return 0;
  var a = jo.compare(n.z, i.z);
  return a;
};
jo.prototype.interfaces_ = function() {
  return [Rx];
};
jo.prototype.getClass = function() {
  return jo;
};
jo.compare = function(t, e) {
  return t < e ? -1 : t > e ? 1 : yt.isNaN(t) ? yt.isNaN(e) ? 0 : -1 : yt.isNaN(e) ? 1 : 0;
};
var Ax = function() {
};
Ax.prototype.create = function() {
};
Ax.prototype.interfaces_ = function() {
  return [];
};
Ax.prototype.getClass = function() {
  return Ax;
};
var A = function() {
}, Zl = { INTERIOR: { configurable: !0 }, BOUNDARY: { configurable: !0 }, EXTERIOR: { configurable: !0 }, NONE: { configurable: !0 } };
A.prototype.interfaces_ = function() {
  return [];
};
A.prototype.getClass = function() {
  return A;
};
A.toLocationSymbol = function(t) {
  switch (t) {
    case A.EXTERIOR:
      return "e";
    case A.BOUNDARY:
      return "b";
    case A.INTERIOR:
      return "i";
    case A.NONE:
      return "-";
  }
  throw new ze("Unknown location value: " + t);
};
Zl.INTERIOR.get = function() {
  return 0;
};
Zl.BOUNDARY.get = function() {
  return 1;
};
Zl.EXTERIOR.get = function() {
  return 2;
};
Zl.NONE.get = function() {
  return -1;
};
Object.defineProperties(A, Zl);
var ct = function(r, t) {
  return r.interfaces_ && r.interfaces_().indexOf(t) > -1;
}, ai = function() {
}, kS = { LOG_10: { configurable: !0 } };
ai.prototype.interfaces_ = function() {
  return [];
};
ai.prototype.getClass = function() {
  return ai;
};
ai.log10 = function(t) {
  var e = Math.log(t);
  return yt.isInfinite(e) || yt.isNaN(e) ? e : e / ai.LOG_10;
};
ai.min = function(t, e, n, i) {
  var s = t;
  return e < s && (s = e), n < s && (s = n), i < s && (s = i), s;
};
ai.clamp = function() {
  if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
    var t = arguments[0], e = arguments[1], n = arguments[2];
    return t < e ? e : t > n ? n : t;
  } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
    var i = arguments[0], s = arguments[1], o = arguments[2];
    return i < s ? s : i > o ? o : i;
  }
};
ai.wrap = function(t, e) {
  return t < 0 ? e - -t % e : t % e;
};
ai.max = function() {
  if (arguments.length === 3) {
    var t = arguments[0], e = arguments[1], n = arguments[2], i = t;
    return e > i && (i = e), n > i && (i = n), i;
  } else if (arguments.length === 4) {
    var s = arguments[0], o = arguments[1], a = arguments[2], u = arguments[3], x = s;
    return o > x && (x = o), a > x && (x = a), u > x && (x = u), x;
  }
};
ai.average = function(t, e) {
  return (t + e) / 2;
};
kS.LOG_10.get = function() {
  return Math.log(10);
};
Object.defineProperties(ai, kS);
var As = function(t) {
  this.str = t;
};
As.prototype.append = function(t) {
  this.str += t;
};
As.prototype.setCharAt = function(t, e) {
  this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);
};
As.prototype.toString = function(t) {
  return this.str;
};
var ws = function(t) {
  this.value = t;
};
ws.prototype.intValue = function() {
  return this.value;
};
ws.prototype.compareTo = function(t) {
  return this.value < t ? -1 : this.value > t ? 1 : 0;
};
ws.isNaN = function(t) {
  return Number.isNaN(t);
};
var yl = function() {
};
yl.isWhitespace = function(t) {
  return t <= 32 && t >= 0 || t === 127;
};
yl.toUpperCase = function(t) {
  return t.toUpperCase();
};
var T = function r() {
  if (this._hi = 0, this._lo = 0, arguments.length === 0)
    this.init(0);
  else if (arguments.length === 1) {
    if (typeof arguments[0] == "number") {
      var t = arguments[0];
      this.init(t);
    } else if (arguments[0] instanceof r) {
      var e = arguments[0];
      this.init(e);
    } else if (typeof arguments[0] == "string") {
      var n = arguments[0];
      r.call(this, r.parse(n));
    }
  } else if (arguments.length === 2) {
    var i = arguments[0], s = arguments[1];
    this.init(i, s);
  }
}, Qi = { PI: { configurable: !0 }, TWO_PI: { configurable: !0 }, PI_2: { configurable: !0 }, E: { configurable: !0 }, NaN: { configurable: !0 }, EPS: { configurable: !0 }, SPLIT: { configurable: !0 }, MAX_PRINT_DIGITS: { configurable: !0 }, TEN: { configurable: !0 }, ONE: { configurable: !0 }, SCI_NOT_EXPONENT_CHAR: { configurable: !0 }, SCI_NOT_ZERO: { configurable: !0 } };
T.prototype.le = function(t) {
  return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo;
};
T.prototype.extractSignificantDigits = function(t, e) {
  var n = this.abs(), i = T.magnitude(n._hi), s = T.TEN.pow(i);
  n = n.divide(s), n.gt(T.TEN) ? (n = n.divide(T.TEN), i += 1) : n.lt(T.ONE) && (n = n.multiply(T.TEN), i -= 1);
  for (var o = i + 1, a = new As(), u = T.MAX_PRINT_DIGITS - 1, x = 0; x <= u; x++) {
    t && x === o && a.append(".");
    var c = Math.trunc(n._hi);
    if (c < 0)
      break;
    var f = !1, l = 0;
    c > 9 ? (f = !0, l = "9") : l = "0" + c, a.append(l), n = n.subtract(T.valueOf(c)).multiply(T.TEN), f && n.selfAdd(T.TEN);
    var h = !0, p = T.magnitude(n._hi);
    if (p < 0 && Math.abs(p) >= u - x && (h = !1), !h)
      break;
  }
  return e[0] = i, a.toString();
};
T.prototype.sqr = function() {
  return this.multiply(this);
};
T.prototype.doubleValue = function() {
  return this._hi + this._lo;
};
T.prototype.subtract = function() {
  if (arguments[0] instanceof T) {
    var t = arguments[0];
    return this.add(t.negate());
  } else if (typeof arguments[0] == "number") {
    var e = arguments[0];
    return this.add(-e);
  }
};
T.prototype.equals = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return this._hi === t._hi && this._lo === t._lo;
  }
};
T.prototype.isZero = function() {
  return this._hi === 0 && this._lo === 0;
};
T.prototype.selfSubtract = function() {
  if (arguments[0] instanceof T) {
    var t = arguments[0];
    return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo);
  } else if (typeof arguments[0] == "number") {
    var e = arguments[0];
    return this.isNaN() ? this : this.selfAdd(-e, 0);
  }
};
T.prototype.getSpecialNumberString = function() {
  return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
};
T.prototype.min = function(t) {
  return this.le(t) ? this : t;
};
T.prototype.selfDivide = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof T) {
      var t = arguments[0];
      return this.selfDivide(t._hi, t._lo);
    } else if (typeof arguments[0] == "number") {
      var e = arguments[0];
      return this.selfDivide(e, 0);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], s = null, o = null, a = null, u = null, x = null, c = null, f = null, l = null;
    return x = this._hi / n, c = T.SPLIT * x, s = c - x, l = T.SPLIT * n, s = c - s, o = x - s, a = l - n, f = x * n, a = l - a, u = n - a, l = s * a - f + s * u + o * a + o * u, c = (this._hi - f - l + this._lo - x * i) / n, l = x + c, this._hi = l, this._lo = x - l + c, this;
  }
};
T.prototype.dump = function() {
  return "DD<" + this._hi + ", " + this._lo + ">";
};
T.prototype.divide = function() {
  if (arguments[0] instanceof T) {
    var t = arguments[0], e = null, n = null, i = null, s = null, o = null, a = null, u = null, x = null;
    o = this._hi / t._hi, a = T.SPLIT * o, e = a - o, x = T.SPLIT * t._hi, e = a - e, n = o - e, i = x - t._hi, u = o * t._hi, i = x - i, s = t._hi - i, x = e * i - u + e * s + n * i + n * s, a = (this._hi - u - x + this._lo - o * t._lo) / t._hi, x = o + a;
    var c = x, f = o - x + a;
    return new T(c, f);
  } else if (typeof arguments[0] == "number") {
    var l = arguments[0];
    return yt.isNaN(l) ? T.createNaN() : T.copy(this).selfDivide(l, 0);
  }
};
T.prototype.ge = function(t) {
  return (this._hi > t._hi || this._hi === t._hi) && this._lo >= t._lo;
};
T.prototype.pow = function(t) {
  if (t === 0)
    return T.valueOf(1);
  var e = new T(this), n = T.valueOf(1), i = Math.abs(t);
  if (i > 1)
    for (; i > 0; )
      i % 2 === 1 && n.selfMultiply(e), i /= 2, i > 0 && (e = e.sqr());
  else
    n = e;
  return t < 0 ? n.reciprocal() : n;
};
T.prototype.ceil = function() {
  if (this.isNaN())
    return T.NaN;
  var t = Math.ceil(this._hi), e = 0;
  return t === this._hi && (e = Math.ceil(this._lo)), new T(t, e);
};
T.prototype.compareTo = function(t) {
  var e = t;
  return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0;
};
T.prototype.rint = function() {
  if (this.isNaN())
    return this;
  var t = this.add(0.5);
  return t.floor();
};
T.prototype.setValue = function() {
  if (arguments[0] instanceof T) {
    var t = arguments[0];
    return this.init(t), this;
  } else if (typeof arguments[0] == "number") {
    var e = arguments[0];
    return this.init(e), this;
  }
};
T.prototype.max = function(t) {
  return this.ge(t) ? this : t;
};
T.prototype.sqrt = function() {
  if (this.isZero())
    return T.valueOf(0);
  if (this.isNegative())
    return T.NaN;
  var t = 1 / Math.sqrt(this._hi), e = this._hi * t, n = T.valueOf(e), i = this.subtract(n.sqr()), s = i._hi * (t * 0.5);
  return n.add(s);
};
T.prototype.selfAdd = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof T) {
      var t = arguments[0];
      return this.selfAdd(t._hi, t._lo);
    } else if (typeof arguments[0] == "number") {
      var e = arguments[0], n = null, i = null, s = null, o = null, a = null, u = null;
      return s = this._hi + e, a = s - this._hi, o = s - a, o = e - a + (this._hi - o), u = o + this._lo, n = s + u, i = u + (s - n), this._hi = n + i, this._lo = i + (n - this._hi), this;
    }
  } else if (arguments.length === 2) {
    var x = arguments[0], c = arguments[1], f = null, l = null, h = null, p = null, y = null, v = null, m = null, d = null;
    y = this._hi + x, h = this._lo + c, m = y - this._hi, d = h - this._lo, v = y - m, p = h - d, v = x - m + (this._hi - v), p = c - d + (this._lo - p), m = v + h, f = y + m, l = m + (y - f), m = p + l;
    var g = f + m, _ = m + (f - g);
    return this._hi = g, this._lo = _, this;
  }
};
T.prototype.selfMultiply = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof T) {
      var t = arguments[0];
      return this.selfMultiply(t._hi, t._lo);
    } else if (typeof arguments[0] == "number") {
      var e = arguments[0];
      return this.selfMultiply(e, 0);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], s = null, o = null, a = null, u = null, x = null, c = null;
    x = T.SPLIT * this._hi, s = x - this._hi, c = T.SPLIT * n, s = x - s, o = this._hi - s, a = c - n, x = this._hi * n, a = c - a, u = n - a, c = s * a - x + s * u + o * a + o * u + (this._hi * i + this._lo * n);
    var f = x + c;
    s = x - f;
    var l = c + s;
    return this._hi = f, this._lo = l, this;
  }
};
T.prototype.selfSqr = function() {
  return this.selfMultiply(this);
};
T.prototype.floor = function() {
  if (this.isNaN())
    return T.NaN;
  var t = Math.floor(this._hi), e = 0;
  return t === this._hi && (e = Math.floor(this._lo)), new T(t, e);
};
T.prototype.negate = function() {
  return this.isNaN() ? this : new T(-this._hi, -this._lo);
};
T.prototype.clone = function() {
};
T.prototype.multiply = function() {
  if (arguments[0] instanceof T) {
    var t = arguments[0];
    return t.isNaN() ? T.createNaN() : T.copy(this).selfMultiply(t);
  } else if (typeof arguments[0] == "number") {
    var e = arguments[0];
    return yt.isNaN(e) ? T.createNaN() : T.copy(this).selfMultiply(e, 0);
  }
};
T.prototype.isNaN = function() {
  return yt.isNaN(this._hi);
};
T.prototype.intValue = function() {
  return Math.trunc(this._hi);
};
T.prototype.toString = function() {
  var t = T.magnitude(this._hi);
  return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation();
};
T.prototype.toStandardNotation = function() {
  var t = this.getSpecialNumberString();
  if (t !== null)
    return t;
  var e = new Array(1).fill(null), n = this.extractSignificantDigits(!0, e), i = e[0] + 1, s = n;
  if (n.charAt(0) === ".")
    s = "0" + n;
  else if (i < 0)
    s = "0." + T.stringOfChar("0", -i) + n;
  else if (n.indexOf(".") === -1) {
    var o = i - n.length, a = T.stringOfChar("0", o);
    s = n + a + ".0";
  }
  return this.isNegative() ? "-" + s : s;
};
T.prototype.reciprocal = function() {
  var t = null, e = null, n = null, i = null, s = null, o = null, a = null, u = null;
  s = 1 / this._hi, o = T.SPLIT * s, t = o - s, u = T.SPLIT * this._hi, t = o - t, e = s - t, n = u - this._hi, a = s * this._hi, n = u - n, i = this._hi - n, u = t * n - a + t * i + e * n + e * i, o = (1 - a - u - s * this._lo) / this._hi;
  var x = s + o, c = s - x + o;
  return new T(x, c);
};
T.prototype.toSciNotation = function() {
  if (this.isZero())
    return T.SCI_NOT_ZERO;
  var t = this.getSpecialNumberString();
  if (t !== null)
    return t;
  var e = new Array(1).fill(null), n = this.extractSignificantDigits(!1, e), i = T.SCI_NOT_EXPONENT_CHAR + e[0];
  if (n.charAt(0) === "0")
    throw new Error("Found leading zero: " + n);
  var s = "";
  n.length > 1 && (s = n.substring(1));
  var o = n.charAt(0) + "." + s;
  return this.isNegative() ? "-" + o + i : o + i;
};
T.prototype.abs = function() {
  return this.isNaN() ? T.NaN : this.isNegative() ? this.negate() : new T(this);
};
T.prototype.isPositive = function() {
  return (this._hi > 0 || this._hi === 0) && this._lo > 0;
};
T.prototype.lt = function(t) {
  return (this._hi < t._hi || this._hi === t._hi) && this._lo < t._lo;
};
T.prototype.add = function() {
  if (arguments[0] instanceof T) {
    var t = arguments[0];
    return T.copy(this).selfAdd(t);
  } else if (typeof arguments[0] == "number") {
    var e = arguments[0];
    return T.copy(this).selfAdd(e);
  }
};
T.prototype.init = function() {
  if (arguments.length === 1) {
    if (typeof arguments[0] == "number") {
      var t = arguments[0];
      this._hi = t, this._lo = 0;
    } else if (arguments[0] instanceof T) {
      var e = arguments[0];
      this._hi = e._hi, this._lo = e._lo;
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this._hi = n, this._lo = i;
  }
};
T.prototype.gt = function(t) {
  return (this._hi > t._hi || this._hi === t._hi) && this._lo > t._lo;
};
T.prototype.isNegative = function() {
  return (this._hi < 0 || this._hi === 0) && this._lo < 0;
};
T.prototype.trunc = function() {
  return this.isNaN() ? T.NaN : this.isPositive() ? this.floor() : this.ceil();
};
T.prototype.signum = function() {
  return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
};
T.prototype.interfaces_ = function() {
  return [Ai, Ri, Uy];
};
T.prototype.getClass = function() {
  return T;
};
T.sqr = function(t) {
  return T.valueOf(t).selfMultiply(t);
};
T.valueOf = function() {
  if (typeof arguments[0] == "string") {
    var t = arguments[0];
    return T.parse(t);
  } else if (typeof arguments[0] == "number") {
    var e = arguments[0];
    return new T(e);
  }
};
T.sqrt = function(t) {
  return T.valueOf(t).sqrt();
};
T.parse = function(t) {
  for (var e = 0, n = t.length; yl.isWhitespace(t.charAt(e)); )
    e++;
  var i = !1;
  if (e < n) {
    var s = t.charAt(e);
    (s === "-" || s === "+") && (e++, s === "-" && (i = !0));
  }
  for (var o = new T(), a = 0, u = 0, x = 0; !(e >= n); ) {
    var c = t.charAt(e);
    if (e++, yl.isDigit(c)) {
      var f = c - "0";
      o.selfMultiply(T.TEN), o.selfAdd(f), a++;
      continue;
    }
    if (c === ".") {
      u = a;
      continue;
    }
    if (c === "e" || c === "E") {
      var l = t.substring(e);
      try {
        x = ws.parseInt(l);
      } catch (m) {
        throw m instanceof Error ? new Error("Invalid exponent " + l + " in string " + t) : m;
      } finally {
      }
      break;
    }
    throw new Error("Unexpected character '" + c + "' at position " + e + " in string " + t);
  }
  var h = o, p = a - u - x;
  if (p === 0)
    h = o;
  else if (p > 0) {
    var y = T.TEN.pow(p);
    h = o.divide(y);
  } else if (p < 0) {
    var v = T.TEN.pow(-p);
    h = o.multiply(v);
  }
  return i ? h.negate() : h;
};
T.createNaN = function() {
  return new T(yt.NaN, yt.NaN);
};
T.copy = function(t) {
  return new T(t);
};
T.magnitude = function(t) {
  var e = Math.abs(t), n = Math.log(e) / Math.log(10), i = Math.trunc(Math.floor(n)), s = Math.pow(10, i);
  return s * 10 <= e && (i += 1), i;
};
T.stringOfChar = function(t, e) {
  for (var n = new As(), i = 0; i < e; i++)
    n.append(t);
  return n.toString();
};
Qi.PI.get = function() {
  return new T(3.141592653589793, 12246467991473532e-32);
};
Qi.TWO_PI.get = function() {
  return new T(6.283185307179586, 24492935982947064e-32);
};
Qi.PI_2.get = function() {
  return new T(1.5707963267948966, 6123233995736766e-32);
};
Qi.E.get = function() {
  return new T(2.718281828459045, 14456468917292502e-32);
};
Qi.NaN.get = function() {
  return new T(yt.NaN, yt.NaN);
};
Qi.EPS.get = function() {
  return 123259516440783e-46;
};
Qi.SPLIT.get = function() {
  return 134217729;
};
Qi.MAX_PRINT_DIGITS.get = function() {
  return 32;
};
Qi.TEN.get = function() {
  return T.valueOf(10);
};
Qi.ONE.get = function() {
  return T.valueOf(1);
};
Qi.SCI_NOT_EXPONENT_CHAR.get = function() {
  return "E";
};
Qi.SCI_NOT_ZERO.get = function() {
  return "0.0E0";
};
Object.defineProperties(T, Qi);
var Ar = function() {
}, BS = { DP_SAFE_EPSILON: { configurable: !0 } };
Ar.prototype.interfaces_ = function() {
  return [];
};
Ar.prototype.getClass = function() {
  return Ar;
};
Ar.orientationIndex = function(t, e, n) {
  var i = Ar.orientationIndexFilter(t, e, n);
  if (i <= 1)
    return i;
  var s = T.valueOf(e.x).selfAdd(-t.x), o = T.valueOf(e.y).selfAdd(-t.y), a = T.valueOf(n.x).selfAdd(-e.x), u = T.valueOf(n.y).selfAdd(-e.y);
  return s.selfMultiply(u).selfSubtract(o.selfMultiply(a)).signum();
};
Ar.signOfDet2x2 = function(t, e, n, i) {
  var s = t.multiply(i).selfSubtract(e.multiply(n));
  return s.signum();
};
Ar.intersection = function(t, e, n, i) {
  var s = T.valueOf(i.y).selfSubtract(n.y).selfMultiply(T.valueOf(e.x).selfSubtract(t.x)), o = T.valueOf(i.x).selfSubtract(n.x).selfMultiply(T.valueOf(e.y).selfSubtract(t.y)), a = s.subtract(o), u = T.valueOf(i.x).selfSubtract(n.x).selfMultiply(T.valueOf(t.y).selfSubtract(n.y)), x = T.valueOf(i.y).selfSubtract(n.y).selfMultiply(T.valueOf(t.x).selfSubtract(n.x)), c = u.subtract(x), f = c.selfDivide(a).doubleValue(), l = T.valueOf(t.x).selfAdd(T.valueOf(e.x).selfSubtract(t.x).selfMultiply(f)).doubleValue(), h = T.valueOf(e.x).selfSubtract(t.x).selfMultiply(T.valueOf(t.y).selfSubtract(n.y)), p = T.valueOf(e.y).selfSubtract(t.y).selfMultiply(T.valueOf(t.x).selfSubtract(n.x)), y = h.subtract(p), v = y.selfDivide(a).doubleValue(), m = T.valueOf(n.y).selfAdd(T.valueOf(i.y).selfSubtract(n.y).selfMultiply(v)).doubleValue();
  return new R(l, m);
};
Ar.orientationIndexFilter = function(t, e, n) {
  var i = null, s = (t.x - n.x) * (e.y - n.y), o = (t.y - n.y) * (e.x - n.x), a = s - o;
  if (s > 0) {
    if (o <= 0)
      return Ar.signum(a);
    i = s + o;
  } else if (s < 0) {
    if (o >= 0)
      return Ar.signum(a);
    i = -s - o;
  } else
    return Ar.signum(a);
  var u = Ar.DP_SAFE_EPSILON * i;
  return a >= u || -a >= u ? Ar.signum(a) : 2;
};
Ar.signum = function(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
};
BS.DP_SAFE_EPSILON.get = function() {
  return 1e-15;
};
Object.defineProperties(Ar, BS);
var Rt = function() {
}, Kl = { X: { configurable: !0 }, Y: { configurable: !0 }, Z: { configurable: !0 }, M: { configurable: !0 } };
Kl.X.get = function() {
  return 0;
};
Kl.Y.get = function() {
  return 1;
};
Kl.Z.get = function() {
  return 2;
};
Kl.M.get = function() {
  return 3;
};
Rt.prototype.setOrdinate = function(t, e, n) {
};
Rt.prototype.size = function() {
};
Rt.prototype.getOrdinate = function(t, e) {
};
Rt.prototype.getCoordinate = function() {
};
Rt.prototype.getCoordinateCopy = function(t) {
};
Rt.prototype.getDimension = function() {
};
Rt.prototype.getX = function(t) {
};
Rt.prototype.clone = function() {
};
Rt.prototype.expandEnvelope = function(t) {
};
Rt.prototype.copy = function() {
};
Rt.prototype.getY = function(t) {
};
Rt.prototype.toCoordinateArray = function() {
};
Rt.prototype.interfaces_ = function() {
  return [Uy];
};
Rt.prototype.getClass = function() {
  return Rt;
};
Object.defineProperties(Rt, Kl);
var GS = function() {
}, oc = function(r) {
  function t() {
    r.call(this, "Projective point not representable on the Cartesian plane.");
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(GS), Hn = function() {
};
Hn.arraycopy = function(t, e, n, i, s) {
  for (var o = 0, a = e; a < e + s; a++)
    n[i + o] = t[a], o++;
};
Hn.getProperty = function(t) {
  return {
    "line.separator": `
`
  }[t];
};
var qi = function r() {
  if (this.x = null, this.y = null, this.w = null, arguments.length === 0)
    this.x = 0, this.y = 0, this.w = 1;
  else if (arguments.length === 1) {
    var t = arguments[0];
    this.x = t.x, this.y = t.y, this.w = 1;
  } else if (arguments.length === 2) {
    if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
      var e = arguments[0], n = arguments[1];
      this.x = e, this.y = n, this.w = 1;
    } else if (arguments[0] instanceof r && arguments[1] instanceof r) {
      var i = arguments[0], s = arguments[1];
      this.x = i.y * s.w - s.y * i.w, this.y = s.x * i.w - i.x * s.w, this.w = i.x * s.y - s.x * i.y;
    } else if (arguments[0] instanceof R && arguments[1] instanceof R) {
      var o = arguments[0], a = arguments[1];
      this.x = o.y - a.y, this.y = a.x - o.x, this.w = o.x * a.y - a.x * o.y;
    }
  } else if (arguments.length === 3) {
    var u = arguments[0], x = arguments[1], c = arguments[2];
    this.x = u, this.y = x, this.w = c;
  } else if (arguments.length === 4) {
    var f = arguments[0], l = arguments[1], h = arguments[2], p = arguments[3], y = f.y - l.y, v = l.x - f.x, m = f.x * l.y - l.x * f.y, d = h.y - p.y, g = p.x - h.x, _ = h.x * p.y - p.x * h.y;
    this.x = v * _ - g * m, this.y = d * m - y * _, this.w = y * g - d * v;
  }
};
qi.prototype.getY = function() {
  var t = this.y / this.w;
  if (yt.isNaN(t) || yt.isInfinite(t))
    throw new oc();
  return t;
};
qi.prototype.getX = function() {
  var t = this.x / this.w;
  if (yt.isNaN(t) || yt.isInfinite(t))
    throw new oc();
  return t;
};
qi.prototype.getCoordinate = function() {
  var t = new R();
  return t.x = this.getX(), t.y = this.getY(), t;
};
qi.prototype.interfaces_ = function() {
  return [];
};
qi.prototype.getClass = function() {
  return qi;
};
qi.intersection = function(t, e, n, i) {
  var s = t.y - e.y, o = e.x - t.x, a = t.x * e.y - e.x * t.y, u = n.y - i.y, x = i.x - n.x, c = n.x * i.y - i.x * n.y, f = o * c - x * a, l = u * a - s * c, h = s * x - u * o, p = f / h, y = l / h;
  if (yt.isNaN(p) || yt.isInfinite(p) || yt.isNaN(y) || yt.isInfinite(y))
    throw new oc();
  return new R(p, y);
};
var nt = function r() {
  if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0)
    this.init();
  else if (arguments.length === 1) {
    if (arguments[0] instanceof R) {
      var t = arguments[0];
      this.init(t.x, t.x, t.y, t.y);
    } else if (arguments[0] instanceof r) {
      var e = arguments[0];
      this.init(e);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this.init(n.x, i.x, n.y, i.y);
  } else if (arguments.length === 4) {
    var s = arguments[0], o = arguments[1], a = arguments[2], u = arguments[3];
    this.init(s, o, a, u);
  }
}, YS = { serialVersionUID: { configurable: !0 } };
nt.prototype.getArea = function() {
  return this.getWidth() * this.getHeight();
};
nt.prototype.equals = function(t) {
  if (!(t instanceof nt))
    return !1;
  var e = t;
  return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY();
};
nt.prototype.intersection = function(t) {
  if (this.isNull() || t.isNull() || !this.intersects(t))
    return new nt();
  var e = this._minx > t._minx ? this._minx : t._minx, n = this._miny > t._miny ? this._miny : t._miny, i = this._maxx < t._maxx ? this._maxx : t._maxx, s = this._maxy < t._maxy ? this._maxy : t._maxy;
  return new nt(e, i, n, s);
};
nt.prototype.isNull = function() {
  return this._maxx < this._minx;
};
nt.prototype.getMaxX = function() {
  return this._maxx;
};
nt.prototype.covers = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof R) {
      var t = arguments[0];
      return this.covers(t.x, t.y);
    } else if (arguments[0] instanceof nt) {
      var e = arguments[0];
      return this.isNull() || e.isNull() ? !1 : e.getMinX() >= this._minx && e.getMaxX() <= this._maxx && e.getMinY() >= this._miny && e.getMaxY() <= this._maxy;
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return this.isNull() ? !1 : n >= this._minx && n <= this._maxx && i >= this._miny && i <= this._maxy;
  }
};
nt.prototype.intersects = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof nt) {
      var t = arguments[0];
      return this.isNull() || t.isNull() ? !1 : !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny);
    } else if (arguments[0] instanceof R) {
      var e = arguments[0];
      return this.intersects(e.x, e.y);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return this.isNull() ? !1 : !(n > this._maxx || n < this._minx || i > this._maxy || i < this._miny);
  }
};
nt.prototype.getMinY = function() {
  return this._miny;
};
nt.prototype.getMinX = function() {
  return this._minx;
};
nt.prototype.expandToInclude = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof R) {
      var t = arguments[0];
      this.expandToInclude(t.x, t.y);
    } else if (arguments[0] instanceof nt) {
      var e = arguments[0];
      if (e.isNull())
        return null;
      this.isNull() ? (this._minx = e.getMinX(), this._maxx = e.getMaxX(), this._miny = e.getMinY(), this._maxy = e.getMaxY()) : (e._minx < this._minx && (this._minx = e._minx), e._maxx > this._maxx && (this._maxx = e._maxx), e._miny < this._miny && (this._miny = e._miny), e._maxy > this._maxy && (this._maxy = e._maxy));
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this.isNull() ? (this._minx = n, this._maxx = n, this._miny = i, this._maxy = i) : (n < this._minx && (this._minx = n), n > this._maxx && (this._maxx = n), i < this._miny && (this._miny = i), i > this._maxy && (this._maxy = i));
  }
};
nt.prototype.minExtent = function() {
  if (this.isNull())
    return 0;
  var t = this.getWidth(), e = this.getHeight();
  return t < e ? t : e;
};
nt.prototype.getWidth = function() {
  return this.isNull() ? 0 : this._maxx - this._minx;
};
nt.prototype.compareTo = function(t) {
  var e = t;
  return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0;
};
nt.prototype.translate = function(t, e) {
  if (this.isNull())
    return null;
  this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);
};
nt.prototype.toString = function() {
  return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
};
nt.prototype.setToNull = function() {
  this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
};
nt.prototype.getHeight = function() {
  return this.isNull() ? 0 : this._maxy - this._miny;
};
nt.prototype.maxExtent = function() {
  if (this.isNull())
    return 0;
  var t = this.getWidth(), e = this.getHeight();
  return t > e ? t : e;
};
nt.prototype.expandBy = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.expandBy(t, t);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    if (this.isNull())
      return null;
    this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
  }
};
nt.prototype.contains = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof nt) {
      var t = arguments[0];
      return this.covers(t);
    } else if (arguments[0] instanceof R) {
      var e = arguments[0];
      return this.covers(e);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return this.covers(n, i);
  }
};
nt.prototype.centre = function() {
  return this.isNull() ? null : new R((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
};
nt.prototype.init = function() {
  if (arguments.length === 0)
    this.setToNull();
  else if (arguments.length === 1) {
    if (arguments[0] instanceof R) {
      var t = arguments[0];
      this.init(t.x, t.x, t.y, t.y);
    } else if (arguments[0] instanceof nt) {
      var e = arguments[0];
      this._minx = e._minx, this._maxx = e._maxx, this._miny = e._miny, this._maxy = e._maxy;
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this.init(n.x, i.x, n.y, i.y);
  } else if (arguments.length === 4) {
    var s = arguments[0], o = arguments[1], a = arguments[2], u = arguments[3];
    s < o ? (this._minx = s, this._maxx = o) : (this._minx = o, this._maxx = s), a < u ? (this._miny = a, this._maxy = u) : (this._miny = u, this._maxy = a);
  }
};
nt.prototype.getMaxY = function() {
  return this._maxy;
};
nt.prototype.distance = function(t) {
  if (this.intersects(t))
    return 0;
  var e = 0;
  this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);
  var n = 0;
  return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), e === 0 ? n : n === 0 ? e : Math.sqrt(e * e + n * n);
};
nt.prototype.hashCode = function() {
  var t = 17;
  return t = 37 * t + R.hashCode(this._minx), t = 37 * t + R.hashCode(this._maxx), t = 37 * t + R.hashCode(this._miny), t = 37 * t + R.hashCode(this._maxy), t;
};
nt.prototype.interfaces_ = function() {
  return [Ri, Ai];
};
nt.prototype.getClass = function() {
  return nt;
};
nt.intersects = function() {
  if (arguments.length === 3) {
    var t = arguments[0], e = arguments[1], n = arguments[2];
    return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y);
  } else if (arguments.length === 4) {
    var i = arguments[0], s = arguments[1], o = arguments[2], a = arguments[3], u = Math.min(o.x, a.x), x = Math.max(o.x, a.x), c = Math.min(i.x, s.x), f = Math.max(i.x, s.x);
    return !(c > x || f < u || (u = Math.min(o.y, a.y), x = Math.max(o.y, a.y), c = Math.min(i.y, s.y), f = Math.max(i.y, s.y), c > x) || f < u);
  }
};
YS.serialVersionUID.get = function() {
  return 5873921885273102e3;
};
Object.defineProperties(nt, YS);
var os = {
  typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
  emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
  spaces: /\s+/,
  parenComma: /\)\s*,\s*\(/,
  doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
  // can't use {2} here
  trimParens: /^\s*\(?(.*?)\)?\s*$/
}, Vy = function(t) {
  this.geometryFactory = t || new St();
};
Vy.prototype.read = function(t) {
  var e, n, i;
  t = t.replace(/[\n\r]/g, " ");
  var s = os.typeStr.exec(t);
  if (t.search("EMPTY") !== -1 && (s = os.emptyTypeStr.exec(t), s[2] = void 0), s && (n = s[1].toLowerCase(), i = s[2], Wu[n] && (e = Wu[n].apply(this, [i]))), e === void 0)
    throw new Error("Could not parse WKT " + t);
  return e;
};
Vy.prototype.write = function(t) {
  return this.extractGeometry(t);
};
Vy.prototype.extractGeometry = function(t) {
  var e = t.getGeometryType().toLowerCase();
  if (!fo[e])
    return null;
  var n = e.toUpperCase(), i;
  return t.isEmpty() ? i = n + " EMPTY" : i = n + "(" + fo[e].apply(this, [t]) + ")", i;
};
var fo = {
  coordinate: function(t) {
    return t.x + " " + t.y;
  },
  /**
   * Return a space delimited string of point coordinates.
   *
   * @param {Point}
   *          point
   * @return {String} A string of coordinates representing the point.
   */
  point: function(t) {
    return fo.coordinate.call(this, t._coordinates._coordinates[0]);
  },
  /**
   * Return a comma delimited string of point coordinates from a multipoint.
   *
   * @param {MultiPoint}
   *          multipoint
   * @return {String} A string of point coordinate strings representing the
   *         multipoint.
   */
  multipoint: function(t) {
    for (var e = this, n = [], i = 0, s = t._geometries.length; i < s; ++i)
      n.push("(" + fo.point.apply(e, [t._geometries[i]]) + ")");
    return n.join(",");
  },
  /**
   * Return a comma delimited string of point coordinates from a line.
   *
   * @param {LineString} linestring
   * @return {String} A string of point coordinate strings representing the linestring.
   */
  linestring: function(t) {
    for (var e = this, n = [], i = 0, s = t._points._coordinates.length; i < s; ++i)
      n.push(fo.coordinate.apply(e, [t._points._coordinates[i]]));
    return n.join(",");
  },
  linearring: function(t) {
    for (var e = this, n = [], i = 0, s = t._points._coordinates.length; i < s; ++i)
      n.push(fo.coordinate.apply(e, [t._points._coordinates[i]]));
    return n.join(",");
  },
  /**
   * Return a comma delimited string of linestring strings from a
   * multilinestring.
   *
   * @param {MultiLineString} multilinestring
   * @return {String} A string of of linestring strings representing the multilinestring.
   */
  multilinestring: function(t) {
    for (var e = this, n = [], i = 0, s = t._geometries.length; i < s; ++i)
      n.push("(" + fo.linestring.apply(e, [t._geometries[i]]) + ")");
    return n.join(",");
  },
  /**
   * Return a comma delimited string of linear ring arrays from a polygon.
   *
   * @param {Polygon} polygon
   * @return {String} An array of linear ring arrays representing the polygon.
   */
  polygon: function(t) {
    var e = this, n = [];
    n.push("(" + fo.linestring.apply(this, [t._shell]) + ")");
    for (var i = 0, s = t._holes.length; i < s; ++i)
      n.push("(" + fo.linestring.apply(e, [t._holes[i]]) + ")");
    return n.join(",");
  },
  /**
   * Return an array of polygon arrays from a multipolygon.
   *
   * @param {MultiPolygon} multipolygon
   * @return {String} An array of polygon arrays representing the multipolygon.
   */
  multipolygon: function(t) {
    for (var e = this, n = [], i = 0, s = t._geometries.length; i < s; ++i)
      n.push("(" + fo.polygon.apply(e, [t._geometries[i]]) + ")");
    return n.join(",");
  },
  /**
   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
   * geometrycollection.
   *
   * @param {GeometryCollection} collection
   * @return {String} internal WKT representation of the collection.
   */
  geometrycollection: function(t) {
    for (var e = this, n = [], i = 0, s = t._geometries.length; i < s; ++i)
      n.push(e.extractGeometry(t._geometries[i]));
    return n.join(",");
  }
}, Wu = {
  /**
   * Return point geometry given a point WKT fragment.
   *
   * @param {String} str A WKT fragment representing the point.
   * @return {Point} A point geometry.
   * @private
   */
  point: function(t) {
    if (t === void 0)
      return this.geometryFactory.createPoint();
    var e = t.trim().split(os.spaces);
    return this.geometryFactory.createPoint(new R(
      Number.parseFloat(e[0]),
      Number.parseFloat(e[1])
    ));
  },
  /**
   * Return a multipoint geometry given a multipoint WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipoint.
   * @return {Point} A multipoint feature.
   * @private
   */
  multipoint: function(t) {
    var e = this;
    if (t === void 0)
      return this.geometryFactory.createMultiPoint();
    for (var n, i = t.trim().split(","), s = [], o = 0, a = i.length; o < a; ++o)
      n = i[o].replace(os.trimParens, "$1"), s.push(Wu.point.apply(e, [n]));
    return this.geometryFactory.createMultiPoint(s);
  },
  /**
   * Return a linestring geometry given a linestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linestring.
   * @return {LineString} A linestring geometry.
   * @private
   */
  linestring: function(t) {
    if (t === void 0)
      return this.geometryFactory.createLineString();
    for (var e = t.trim().split(","), n = [], i, s = 0, o = e.length; s < o; ++s)
      i = e[s].trim().split(os.spaces), n.push(new R(Number.parseFloat(i[0]), Number.parseFloat(i[1])));
    return this.geometryFactory.createLineString(n);
  },
  /**
   * Return a linearring geometry given a linearring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linearring.
   * @return {LinearRing} A linearring geometry.
   * @private
   */
  linearring: function(t) {
    if (t === void 0)
      return this.geometryFactory.createLinearRing();
    for (var e = t.trim().split(","), n = [], i, s = 0, o = e.length; s < o; ++s)
      i = e[s].trim().split(os.spaces), n.push(new R(Number.parseFloat(i[0]), Number.parseFloat(i[1])));
    return this.geometryFactory.createLinearRing(n);
  },
  /**
   * Return a multilinestring geometry given a multilinestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multilinestring.
   * @return {MultiLineString} A multilinestring geometry.
   * @private
   */
  multilinestring: function(t) {
    var e = this;
    if (t === void 0)
      return this.geometryFactory.createMultiLineString();
    for (var n, i = t.trim().split(os.parenComma), s = [], o = 0, a = i.length; o < a; ++o)
      n = i[o].replace(os.trimParens, "$1"), s.push(Wu.linestring.apply(e, [n]));
    return this.geometryFactory.createMultiLineString(s);
  },
  /**
   * Return a polygon geometry given a polygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the polygon.
   * @return {Polygon} A polygon geometry.
   * @private
   */
  polygon: function(t) {
    var e = this;
    if (t === void 0)
      return this.geometryFactory.createPolygon();
    for (var n, i, s, o = t.trim().split(os.parenComma), a, u = [], x = 0, c = o.length; x < c; ++x)
      n = o[x].replace(os.trimParens, "$1"), i = Wu.linestring.apply(e, [n]), s = e.geometryFactory.createLinearRing(i._points), x === 0 ? a = s : u.push(s);
    return this.geometryFactory.createPolygon(a, u);
  },
  /**
   * Return a multipolygon geometry given a multipolygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipolygon.
   * @return {MultiPolygon} A multipolygon geometry.
   * @private
   */
  multipolygon: function(t) {
    var e = this;
    if (t === void 0)
      return this.geometryFactory.createMultiPolygon();
    for (var n, i = t.trim().split(os.doubleParenComma), s = [], o = 0, a = i.length; o < a; ++o)
      n = i[o].replace(os.trimParens, "$1"), s.push(Wu.polygon.apply(e, [n]));
    return this.geometryFactory.createMultiPolygon(s);
  },
  /**
   * Return a geometrycollection given a geometrycollection WKT fragment.
   *
   * @param {String} str A WKT fragment representing the geometrycollection.
   * @return {GeometryCollection}
   * @private
   */
  geometrycollection: function(t) {
    var e = this;
    if (t === void 0)
      return this.geometryFactory.createGeometryCollection();
    t = t.replace(/,\s*([A-Za-z])/g, "|$1");
    for (var n = t.trim().split("|"), i = [], s = 0, o = n.length; s < o; ++s)
      i.push(e.read(n[s]));
    return this.geometryFactory.createGeometryCollection(i);
  }
}, Vi = function(t) {
  this.parser = new Vy(t);
};
Vi.prototype.write = function(t) {
  return this.parser.write(t);
};
Vi.toLineString = function(t, e) {
  if (arguments.length !== 2)
    throw new Error("Not implemented");
  return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )";
};
var So = function(r) {
  function t(e) {
    r.call(this, e), this.name = "RuntimeException", this.message = e, this.stack = new r().stack;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t;
}(Error), Tg = function(r) {
  function t() {
    if (r.call(this), arguments.length === 0)
      r.call(this);
    else if (arguments.length === 1) {
      var e = arguments[0];
      r.call(this, e);
    }
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(So), mt = function() {
};
mt.prototype.interfaces_ = function() {
  return [];
};
mt.prototype.getClass = function() {
  return mt;
};
mt.shouldNeverReachHere = function() {
  if (arguments.length === 0)
    mt.shouldNeverReachHere(null);
  else if (arguments.length === 1) {
    var t = arguments[0];
    throw new Tg("Should never reach here" + (t !== null ? ": " + t : ""));
  }
};
mt.isTrue = function() {
  var t, e;
  if (arguments.length === 1)
    t = arguments[0], mt.isTrue(t, null);
  else if (arguments.length === 2 && (t = arguments[0], e = arguments[1], !t))
    throw e === null ? new Tg() : new Tg(e);
};
mt.equals = function() {
  var t, e, n;
  if (arguments.length === 2)
    t = arguments[0], e = arguments[1], mt.equals(t, e, null);
  else if (arguments.length === 3 && (t = arguments[0], e = arguments[1], n = arguments[2], !e.equals(t)))
    throw new Tg("Expected " + t + " but encountered " + e + (n !== null ? ": " + n : ""));
};
var He = function() {
  this._result = null, this._inputLines = Array(2).fill().map(function() {
    return Array(2);
  }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new R(), this._intPt[1] = new R(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
}, lu = { DONT_INTERSECT: { configurable: !0 }, DO_INTERSECT: { configurable: !0 }, COLLINEAR: { configurable: !0 }, NO_INTERSECTION: { configurable: !0 }, POINT_INTERSECTION: { configurable: !0 }, COLLINEAR_INTERSECTION: { configurable: !0 } };
He.prototype.getIndexAlongSegment = function(t, e) {
  return this.computeIntLineIndex(), this._intLineIndex[t][e];
};
He.prototype.getTopologySummary = function() {
  var t = new As();
  return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString();
};
He.prototype.computeIntersection = function(t, e, n, i) {
  this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = i, this._result = this.computeIntersect(t, e, n, i);
};
He.prototype.getIntersectionNum = function() {
  return this._result;
};
He.prototype.computeIntLineIndex = function() {
  if (arguments.length === 0)
    this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map(function() {
      return Array(2);
    }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
  else if (arguments.length === 1) {
    var t = arguments[0], e = this.getEdgeDistance(t, 0), n = this.getEdgeDistance(t, 1);
    e > n ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0);
  }
};
He.prototype.isProper = function() {
  return this.hasIntersection() && this._isProper;
};
He.prototype.setPrecisionModel = function(t) {
  this._precisionModel = t;
};
He.prototype.isInteriorIntersection = function() {
  var t = this;
  if (arguments.length === 0)
    return !!(this.isInteriorIntersection(0) || this.isInteriorIntersection(1));
  if (arguments.length === 1) {
    for (var e = arguments[0], n = 0; n < this._result; n++)
      if (!(t._intPt[n].equals2D(t._inputLines[e][0]) || t._intPt[n].equals2D(t._inputLines[e][1])))
        return !0;
    return !1;
  }
};
He.prototype.getIntersection = function(t) {
  return this._intPt[t];
};
He.prototype.isEndPoint = function() {
  return this.hasIntersection() && !this._isProper;
};
He.prototype.hasIntersection = function() {
  return this._result !== He.NO_INTERSECTION;
};
He.prototype.getEdgeDistance = function(t, e) {
  var n = He.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1]);
  return n;
};
He.prototype.isCollinear = function() {
  return this._result === He.COLLINEAR_INTERSECTION;
};
He.prototype.toString = function() {
  return Vi.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Vi.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
};
He.prototype.getEndpoint = function(t, e) {
  return this._inputLines[t][e];
};
He.prototype.isIntersection = function(t) {
  for (var e = this, n = 0; n < this._result; n++)
    if (e._intPt[n].equals2D(t))
      return !0;
  return !1;
};
He.prototype.getIntersectionAlongSegment = function(t, e) {
  return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]];
};
He.prototype.interfaces_ = function() {
  return [];
};
He.prototype.getClass = function() {
  return He;
};
He.computeEdgeDistance = function(t, e, n) {
  var i = Math.abs(n.x - e.x), s = Math.abs(n.y - e.y), o = -1;
  if (t.equals(e))
    o = 0;
  else if (t.equals(n))
    i > s ? o = i : o = s;
  else {
    var a = Math.abs(t.x - e.x), u = Math.abs(t.y - e.y);
    i > s ? o = a : o = u, o === 0 && !t.equals(e) && (o = Math.max(a, u));
  }
  return mt.isTrue(!(o === 0 && !t.equals(e)), "Bad distance calculation"), o;
};
He.nonRobustComputeEdgeDistance = function(t, e, n) {
  var i = t.x - e.x, s = t.y - e.y, o = Math.sqrt(i * i + s * s);
  return mt.isTrue(!(o === 0 && !t.equals(e)), "Invalid distance calculation"), o;
};
lu.DONT_INTERSECT.get = function() {
  return 0;
};
lu.DO_INTERSECT.get = function() {
  return 1;
};
lu.COLLINEAR.get = function() {
  return 2;
};
lu.NO_INTERSECTION.get = function() {
  return 0;
};
lu.POINT_INTERSECTION.get = function() {
  return 1;
};
lu.COLLINEAR_INTERSECTION.get = function() {
  return 2;
};
Object.defineProperties(He, lu);
var l0 = function(r) {
  function t() {
    r.apply(this, arguments);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.isInSegmentEnvelopes = function(n) {
    var i = new nt(this._inputLines[0][0], this._inputLines[0][1]), s = new nt(this._inputLines[1][0], this._inputLines[1][1]);
    return i.contains(n) && s.contains(n);
  }, t.prototype.computeIntersection = function() {
    if (arguments.length === 3) {
      var n = arguments[0], i = arguments[1], s = arguments[2];
      if (this._isProper = !1, nt.intersects(i, s, n) && Z.orientationIndex(i, s, n) === 0 && Z.orientationIndex(s, i, n) === 0)
        return this._isProper = !0, (n.equals(i) || n.equals(s)) && (this._isProper = !1), this._result = r.POINT_INTERSECTION, null;
      this._result = r.NO_INTERSECTION;
    } else
      return r.prototype.computeIntersection.apply(this, arguments);
  }, t.prototype.normalizeToMinimum = function(n, i, s, o, a) {
    a.x = this.smallestInAbsValue(n.x, i.x, s.x, o.x), a.y = this.smallestInAbsValue(n.y, i.y, s.y, o.y), n.x -= a.x, n.y -= a.y, i.x -= a.x, i.y -= a.y, s.x -= a.x, s.y -= a.y, o.x -= a.x, o.y -= a.y;
  }, t.prototype.safeHCoordinateIntersection = function(n, i, s, o) {
    var a = null;
    try {
      a = qi.intersection(n, i, s, o);
    } catch (u) {
      if (u instanceof oc)
        a = t.nearestEndpoint(n, i, s, o);
      else
        throw u;
    } finally {
    }
    return a;
  }, t.prototype.intersection = function(n, i, s, o) {
    var a = this.intersectionWithNormalization(n, i, s, o);
    return this.isInSegmentEnvelopes(a) || (a = new R(t.nearestEndpoint(n, i, s, o))), this._precisionModel !== null && this._precisionModel.makePrecise(a), a;
  }, t.prototype.smallestInAbsValue = function(n, i, s, o) {
    var a = n, u = Math.abs(a);
    return Math.abs(i) < u && (a = i, u = Math.abs(i)), Math.abs(s) < u && (a = s, u = Math.abs(s)), Math.abs(o) < u && (a = o), a;
  }, t.prototype.checkDD = function(n, i, s, o, a) {
    var u = Ar.intersection(n, i, s, o), x = this.isInSegmentEnvelopes(u);
    Hn.out.println("DD in env = " + x + "  --------------------- " + u), a.distance(u) > 1e-4 && Hn.out.println("Distance = " + a.distance(u));
  }, t.prototype.intersectionWithNormalization = function(n, i, s, o) {
    var a = new R(n), u = new R(i), x = new R(s), c = new R(o), f = new R();
    this.normalizeToEnvCentre(a, u, x, c, f);
    var l = this.safeHCoordinateIntersection(a, u, x, c);
    return l.x += f.x, l.y += f.y, l;
  }, t.prototype.computeCollinearIntersection = function(n, i, s, o) {
    var a = nt.intersects(n, i, s), u = nt.intersects(n, i, o), x = nt.intersects(s, o, n), c = nt.intersects(s, o, i);
    return a && u ? (this._intPt[0] = s, this._intPt[1] = o, r.COLLINEAR_INTERSECTION) : x && c ? (this._intPt[0] = n, this._intPt[1] = i, r.COLLINEAR_INTERSECTION) : a && x ? (this._intPt[0] = s, this._intPt[1] = n, s.equals(n) && !u && !c ? r.POINT_INTERSECTION : r.COLLINEAR_INTERSECTION) : a && c ? (this._intPt[0] = s, this._intPt[1] = i, s.equals(i) && !u && !x ? r.POINT_INTERSECTION : r.COLLINEAR_INTERSECTION) : u && x ? (this._intPt[0] = o, this._intPt[1] = n, o.equals(n) && !a && !c ? r.POINT_INTERSECTION : r.COLLINEAR_INTERSECTION) : u && c ? (this._intPt[0] = o, this._intPt[1] = i, o.equals(i) && !a && !x ? r.POINT_INTERSECTION : r.COLLINEAR_INTERSECTION) : r.NO_INTERSECTION;
  }, t.prototype.normalizeToEnvCentre = function(n, i, s, o, a) {
    var u = n.x < i.x ? n.x : i.x, x = n.y < i.y ? n.y : i.y, c = n.x > i.x ? n.x : i.x, f = n.y > i.y ? n.y : i.y, l = s.x < o.x ? s.x : o.x, h = s.y < o.y ? s.y : o.y, p = s.x > o.x ? s.x : o.x, y = s.y > o.y ? s.y : o.y, v = u > l ? u : l, m = c < p ? c : p, d = x > h ? x : h, g = f < y ? f : y, _ = (v + m) / 2, b = (d + g) / 2;
    a.x = _, a.y = b, n.x -= a.x, n.y -= a.y, i.x -= a.x, i.y -= a.y, s.x -= a.x, s.y -= a.y, o.x -= a.x, o.y -= a.y;
  }, t.prototype.computeIntersect = function(n, i, s, o) {
    if (this._isProper = !1, !nt.intersects(n, i, s, o))
      return r.NO_INTERSECTION;
    var a = Z.orientationIndex(n, i, s), u = Z.orientationIndex(n, i, o);
    if (a > 0 && u > 0 || a < 0 && u < 0)
      return r.NO_INTERSECTION;
    var x = Z.orientationIndex(s, o, n), c = Z.orientationIndex(s, o, i);
    if (x > 0 && c > 0 || x < 0 && c < 0)
      return r.NO_INTERSECTION;
    var f = a === 0 && u === 0 && x === 0 && c === 0;
    return f ? this.computeCollinearIntersection(n, i, s, o) : (a === 0 || u === 0 || x === 0 || c === 0 ? (this._isProper = !1, n.equals2D(s) || n.equals2D(o) ? this._intPt[0] = n : i.equals2D(s) || i.equals2D(o) ? this._intPt[0] = i : a === 0 ? this._intPt[0] = new R(s) : u === 0 ? this._intPt[0] = new R(o) : x === 0 ? this._intPt[0] = new R(n) : c === 0 && (this._intPt[0] = new R(i))) : (this._isProper = !0, this._intPt[0] = this.intersection(n, i, s, o)), r.POINT_INTERSECTION);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t.nearestEndpoint = function(n, i, s, o) {
    var a = n, u = Z.distancePointLine(n, s, o), x = Z.distancePointLine(i, s, o);
    return x < u && (u = x, a = i), x = Z.distancePointLine(s, n, i), x < u && (u = x, a = s), x = Z.distancePointLine(o, n, i), x < u && (u = x, a = o), a;
  }, t;
}(He), Z0 = function() {
};
Z0.prototype.interfaces_ = function() {
  return [];
};
Z0.prototype.getClass = function() {
  return Z0;
};
Z0.orientationIndex = function(t, e, n) {
  var i = e.x - t.x, s = e.y - t.y, o = n.x - e.x, a = n.y - e.y;
  return Z0.signOfDet2x2(i, s, o, a);
};
Z0.signOfDet2x2 = function(t, e, n, i) {
  var s = null, o = null, a = null;
  if (s = 1, t === 0 || i === 0)
    return e === 0 || n === 0 ? 0 : e > 0 ? n > 0 ? -s : s : n > 0 ? s : -s;
  if (e === 0 || n === 0)
    return i > 0 ? t > 0 ? s : -s : t > 0 ? -s : s;
  if (e > 0 ? i > 0 ? e <= i || (s = -s, o = t, t = n, n = o, o = e, e = i, i = o) : e <= -i ? (s = -s, n = -n, i = -i) : (o = t, t = -n, n = o, o = e, e = -i, i = o) : i > 0 ? -e <= i ? (s = -s, t = -t, e = -e) : (o = -t, t = n, n = o, o = -e, e = i, i = o) : e >= i ? (t = -t, e = -e, n = -n, i = -i) : (s = -s, o = -t, t = -n, n = o, o = -e, e = -i, i = o), t > 0)
    if (n > 0) {
      if (!(t <= n)) return s;
    } else
      return s;
  else {
    if (n > 0)
      return -s;
    if (t >= n)
      s = -s, t = -t, n = -n;
    else
      return -s;
  }
  for (; ; ) {
    if (a = Math.floor(n / t), n = n - a * t, i = i - a * e, i < 0)
      return -s;
    if (i > e)
      return s;
    if (t > n + n) {
      if (e < i + i)
        return s;
    } else {
      if (e > i + i)
        return -s;
      n = t - n, i = e - i, s = -s;
    }
    if (i === 0)
      return n === 0 ? 0 : -s;
    if (n === 0 || (a = Math.floor(t / n), t = t - a * n, e = e - a * i, e < 0))
      return s;
    if (e > i)
      return -s;
    if (n > t + t) {
      if (i < e + e)
        return -s;
    } else {
      if (i > e + e)
        return s;
      t = n - t, e = i - e, s = -s;
    }
    if (e === 0)
      return t === 0 ? 0 : s;
    if (t === 0)
      return -s;
  }
};
var vs = function() {
  this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
  var t = arguments[0];
  this._p = t;
};
vs.prototype.countSegment = function(t, e) {
  if (t.x < this._p.x && e.x < this._p.x)
    return null;
  if (this._p.x === e.x && this._p.y === e.y)
    return this._isPointOnSegment = !0, null;
  if (t.y === this._p.y && e.y === this._p.y) {
    var n = t.x, i = e.x;
    return n > i && (n = e.x, i = t.x), this._p.x >= n && this._p.x <= i && (this._isPointOnSegment = !0), null;
  }
  if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {
    var s = t.x - this._p.x, o = t.y - this._p.y, a = e.x - this._p.x, u = e.y - this._p.y, x = Z0.signOfDet2x2(s, o, a, u);
    if (x === 0)
      return this._isPointOnSegment = !0, null;
    u < o && (x = -x), x > 0 && this._crossingCount++;
  }
};
vs.prototype.isPointInPolygon = function() {
  return this.getLocation() !== A.EXTERIOR;
};
vs.prototype.getLocation = function() {
  return this._isPointOnSegment ? A.BOUNDARY : this._crossingCount % 2 === 1 ? A.INTERIOR : A.EXTERIOR;
};
vs.prototype.isOnSegment = function() {
  return this._isPointOnSegment;
};
vs.prototype.interfaces_ = function() {
  return [];
};
vs.prototype.getClass = function() {
  return vs;
};
vs.locatePointInRing = function() {
  if (arguments[0] instanceof R && ct(arguments[1], Rt)) {
    for (var t = arguments[0], e = arguments[1], n = new vs(t), i = new R(), s = new R(), o = 1; o < e.size(); o++)
      if (e.getCoordinate(o, i), e.getCoordinate(o - 1, s), n.countSegment(i, s), n.isOnSegment())
        return n.getLocation();
    return n.getLocation();
  } else if (arguments[0] instanceof R && arguments[1] instanceof Array) {
    for (var a = arguments[0], u = arguments[1], x = new vs(a), c = 1; c < u.length; c++) {
      var f = u[c], l = u[c - 1];
      if (x.countSegment(f, l), x.isOnSegment())
        return x.getLocation();
    }
    return x.getLocation();
  }
};
var Z = function() {
}, hu = { CLOCKWISE: { configurable: !0 }, RIGHT: { configurable: !0 }, COUNTERCLOCKWISE: { configurable: !0 }, LEFT: { configurable: !0 }, COLLINEAR: { configurable: !0 }, STRAIGHT: { configurable: !0 } };
Z.prototype.interfaces_ = function() {
  return [];
};
Z.prototype.getClass = function() {
  return Z;
};
Z.orientationIndex = function(t, e, n) {
  return Ar.orientationIndex(t, e, n);
};
Z.signedArea = function() {
  if (arguments[0] instanceof Array) {
    var t = arguments[0];
    if (t.length < 3)
      return 0;
    for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {
      var s = t[i].x - n, o = t[i + 1].y, a = t[i - 1].y;
      e += s * (a - o);
    }
    return e / 2;
  } else if (ct(arguments[0], Rt)) {
    var u = arguments[0], x = u.size();
    if (x < 3)
      return 0;
    var c = new R(), f = new R(), l = new R();
    u.getCoordinate(0, f), u.getCoordinate(1, l);
    var h = f.x;
    l.x -= h;
    for (var p = 0, y = 1; y < x - 1; y++)
      c.y = f.y, f.x = l.x, f.y = l.y, u.getCoordinate(y + 1, l), l.x -= h, p += f.x * (c.y - l.y);
    return p / 2;
  }
};
Z.distanceLineLine = function(t, e, n, i) {
  if (t.equals(e))
    return Z.distancePointLine(t, n, i);
  if (n.equals(i))
    return Z.distancePointLine(i, t, e);
  var s = !1;
  if (!nt.intersects(t, e, n, i))
    s = !0;
  else {
    var o = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x);
    if (o === 0)
      s = !0;
    else {
      var a = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y), u = (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y), x = u / o, c = a / o;
      (c < 0 || c > 1 || x < 0 || x > 1) && (s = !0);
    }
  }
  return s ? ai.min(Z.distancePointLine(t, n, i), Z.distancePointLine(e, n, i), Z.distancePointLine(n, t, e), Z.distancePointLine(i, t, e)) : 0;
};
Z.isPointInRing = function(t, e) {
  return Z.locatePointInRing(t, e) !== A.EXTERIOR;
};
Z.computeLength = function(t) {
  var e = t.size();
  if (e <= 1)
    return 0;
  var n = 0, i = new R();
  t.getCoordinate(0, i);
  for (var s = i.x, o = i.y, a = 1; a < e; a++) {
    t.getCoordinate(a, i);
    var u = i.x, x = i.y, c = u - s, f = x - o;
    n += Math.sqrt(c * c + f * f), s = u, o = x;
  }
  return n;
};
Z.isCCW = function(t) {
  var e = t.length - 1;
  if (e < 3)
    throw new ze("Ring has fewer than 4 points, so orientation cannot be determined");
  for (var n = t[0], i = 0, s = 1; s <= e; s++) {
    var o = t[s];
    o.y > n.y && (n = o, i = s);
  }
  var a = i;
  do
    a = a - 1, a < 0 && (a = e);
  while (t[a].equals2D(n) && a !== i);
  var u = i;
  do
    u = (u + 1) % e;
  while (t[u].equals2D(n) && u !== i);
  var x = t[a], c = t[u];
  if (x.equals2D(n) || c.equals2D(n) || x.equals2D(c))
    return !1;
  var f = Z.computeOrientation(x, n, c), l = !1;
  return f === 0 ? l = x.x > c.x : l = f > 0, l;
};
Z.locatePointInRing = function(t, e) {
  return vs.locatePointInRing(t, e);
};
Z.distancePointLinePerpendicular = function(t, e, n) {
  var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y), s = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;
  return Math.abs(s) * Math.sqrt(i);
};
Z.computeOrientation = function(t, e, n) {
  return Z.orientationIndex(t, e, n);
};
Z.distancePointLine = function() {
  if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    if (e.length === 0)
      throw new ze("Line array must contain at least one vertex");
    for (var n = t.distance(e[0]), i = 0; i < e.length - 1; i++) {
      var s = Z.distancePointLine(t, e[i], e[i + 1]);
      s < n && (n = s);
    }
    return n;
  } else if (arguments.length === 3) {
    var o = arguments[0], a = arguments[1], u = arguments[2];
    if (a.x === u.x && a.y === u.y)
      return o.distance(a);
    var x = (u.x - a.x) * (u.x - a.x) + (u.y - a.y) * (u.y - a.y), c = ((o.x - a.x) * (u.x - a.x) + (o.y - a.y) * (u.y - a.y)) / x;
    if (c <= 0)
      return o.distance(a);
    if (c >= 1)
      return o.distance(u);
    var f = ((a.y - o.y) * (u.x - a.x) - (a.x - o.x) * (u.y - a.y)) / x;
    return Math.abs(f) * Math.sqrt(x);
  }
};
Z.isOnLine = function(t, e) {
  for (var n = new l0(), i = 1; i < e.length; i++) {
    var s = e[i - 1], o = e[i];
    if (n.computeIntersection(t, s, o), n.hasIntersection())
      return !0;
  }
  return !1;
};
hu.CLOCKWISE.get = function() {
  return -1;
};
hu.RIGHT.get = function() {
  return Z.CLOCKWISE;
};
hu.COUNTERCLOCKWISE.get = function() {
  return 1;
};
hu.LEFT.get = function() {
  return Z.COUNTERCLOCKWISE;
};
hu.COLLINEAR.get = function() {
  return 0;
};
hu.STRAIGHT.get = function() {
  return Z.COLLINEAR;
};
Object.defineProperties(Z, hu);
var Co = function() {
};
Co.prototype.filter = function(t) {
};
Co.prototype.interfaces_ = function() {
  return [];
};
Co.prototype.getClass = function() {
  return Co;
};
var xt = function() {
  var t = arguments[0];
  this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t, this._SRID = t.getSRID();
}, so = { serialVersionUID: { configurable: !0 }, SORTINDEX_POINT: { configurable: !0 }, SORTINDEX_MULTIPOINT: { configurable: !0 }, SORTINDEX_LINESTRING: { configurable: !0 }, SORTINDEX_LINEARRING: { configurable: !0 }, SORTINDEX_MULTILINESTRING: { configurable: !0 }, SORTINDEX_POLYGON: { configurable: !0 }, SORTINDEX_MULTIPOLYGON: { configurable: !0 }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: !0 }, geometryChangedFilter: { configurable: !0 } };
xt.prototype.isGeometryCollection = function() {
  return this.getSortIndex() === xt.SORTINDEX_GEOMETRYCOLLECTION;
};
xt.prototype.getFactory = function() {
  return this._factory;
};
xt.prototype.getGeometryN = function(t) {
  return this;
};
xt.prototype.getArea = function() {
  return 0;
};
xt.prototype.isRectangle = function() {
  return !1;
};
xt.prototype.equals = function() {
  if (arguments[0] instanceof xt) {
    var t = arguments[0];
    return t === null ? !1 : this.equalsTopo(t);
  } else if (arguments[0] instanceof Object) {
    var e = arguments[0];
    if (!(e instanceof xt))
      return !1;
    var n = e;
    return this.equalsExact(n);
  }
};
xt.prototype.equalsExact = function(t) {
  return this === t || this.equalsExact(t, 0);
};
xt.prototype.geometryChanged = function() {
  this.apply(xt.geometryChangedFilter);
};
xt.prototype.geometryChangedAction = function() {
  this._envelope = null;
};
xt.prototype.equalsNorm = function(t) {
  return t === null ? !1 : this.norm().equalsExact(t.norm());
};
xt.prototype.getLength = function() {
  return 0;
};
xt.prototype.getNumGeometries = function() {
  return 1;
};
xt.prototype.compareTo = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = t;
    return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t);
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return this.getSortIndex() !== n.getSortIndex() ? this.getSortIndex() - n.getSortIndex() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(n, i);
  }
};
xt.prototype.getUserData = function() {
  return this._userData;
};
xt.prototype.getSRID = function() {
  return this._SRID;
};
xt.prototype.getEnvelope = function() {
  return this.getFactory().toGeometry(this.getEnvelopeInternal());
};
xt.prototype.checkNotGeometryCollection = function(t) {
  if (t.getSortIndex() === xt.SORTINDEX_GEOMETRYCOLLECTION)
    throw new ze("This method does not support GeometryCollection arguments");
};
xt.prototype.equal = function(t, e, n) {
  return n === 0 ? t.equals(e) : t.distance(e) <= n;
};
xt.prototype.norm = function() {
  var t = this.copy();
  return t.normalize(), t;
};
xt.prototype.getPrecisionModel = function() {
  return this._factory.getPrecisionModel();
};
xt.prototype.getEnvelopeInternal = function() {
  return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new nt(this._envelope);
};
xt.prototype.setSRID = function(t) {
  this._SRID = t;
};
xt.prototype.setUserData = function(t) {
  this._userData = t;
};
xt.prototype.compare = function(t, e) {
  for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext(); ) {
    var s = n.next(), o = i.next(), a = s.compareTo(o);
    if (a !== 0)
      return a;
  }
  return n.hasNext() ? 1 : i.hasNext() ? -1 : 0;
};
xt.prototype.hashCode = function() {
  return this.getEnvelopeInternal().hashCode();
};
xt.prototype.isGeometryCollectionOrDerived = function() {
  return this.getSortIndex() === xt.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === xt.SORTINDEX_MULTIPOINT || this.getSortIndex() === xt.SORTINDEX_MULTILINESTRING || this.getSortIndex() === xt.SORTINDEX_MULTIPOLYGON;
};
xt.prototype.interfaces_ = function() {
  return [Uy, Ri, Ai];
};
xt.prototype.getClass = function() {
  return xt;
};
xt.hasNonEmptyElements = function(t) {
  for (var e = 0; e < t.length; e++)
    if (!t[e].isEmpty())
      return !0;
  return !1;
};
xt.hasNullElements = function(t) {
  for (var e = 0; e < t.length; e++)
    if (t[e] === null)
      return !0;
  return !1;
};
so.serialVersionUID.get = function() {
  return 8763622679187377e3;
};
so.SORTINDEX_POINT.get = function() {
  return 0;
};
so.SORTINDEX_MULTIPOINT.get = function() {
  return 1;
};
so.SORTINDEX_LINESTRING.get = function() {
  return 2;
};
so.SORTINDEX_LINEARRING.get = function() {
  return 3;
};
so.SORTINDEX_MULTILINESTRING.get = function() {
  return 4;
};
so.SORTINDEX_POLYGON.get = function() {
  return 5;
};
so.SORTINDEX_MULTIPOLYGON.get = function() {
  return 6;
};
so.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
  return 7;
};
so.geometryChangedFilter.get = function() {
  return X2;
};
Object.defineProperties(xt, so);
var X2 = function() {
};
X2.interfaces_ = function() {
  return [Co];
};
X2.filter = function(t) {
  t.geometryChangedAction();
};
var Ks = function() {
};
Ks.prototype.filter = function(t) {
};
Ks.prototype.interfaces_ = function() {
  return [];
};
Ks.prototype.getClass = function() {
  return Ks;
};
var Li = function() {
}, Do = { Mod2BoundaryNodeRule: { configurable: !0 }, EndPointBoundaryNodeRule: { configurable: !0 }, MultiValentEndPointBoundaryNodeRule: { configurable: !0 }, MonoValentEndPointBoundaryNodeRule: { configurable: !0 }, MOD2_BOUNDARY_RULE: { configurable: !0 }, ENDPOINT_BOUNDARY_RULE: { configurable: !0 }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: !0 }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: !0 }, OGC_SFS_BOUNDARY_RULE: { configurable: !0 } };
Li.prototype.isInBoundary = function(t) {
};
Li.prototype.interfaces_ = function() {
  return [];
};
Li.prototype.getClass = function() {
  return Li;
};
Do.Mod2BoundaryNodeRule.get = function() {
  return Tx;
};
Do.EndPointBoundaryNodeRule.get = function() {
  return Dx;
};
Do.MultiValentEndPointBoundaryNodeRule.get = function() {
  return Fx;
};
Do.MonoValentEndPointBoundaryNodeRule.get = function() {
  return kx;
};
Do.MOD2_BOUNDARY_RULE.get = function() {
  return new Tx();
};
Do.ENDPOINT_BOUNDARY_RULE.get = function() {
  return new Dx();
};
Do.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
  return new Fx();
};
Do.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
  return new kx();
};
Do.OGC_SFS_BOUNDARY_RULE.get = function() {
  return Li.MOD2_BOUNDARY_RULE;
};
Object.defineProperties(Li, Do);
var Tx = function() {
};
Tx.prototype.isInBoundary = function(t) {
  return t % 2 === 1;
};
Tx.prototype.interfaces_ = function() {
  return [Li];
};
Tx.prototype.getClass = function() {
  return Tx;
};
var Dx = function() {
};
Dx.prototype.isInBoundary = function(t) {
  return t > 0;
};
Dx.prototype.interfaces_ = function() {
  return [Li];
};
Dx.prototype.getClass = function() {
  return Dx;
};
var Fx = function() {
};
Fx.prototype.isInBoundary = function(t) {
  return t > 1;
};
Fx.prototype.interfaces_ = function() {
  return [Li];
};
Fx.prototype.getClass = function() {
  return Fx;
};
var kx = function() {
};
kx.prototype.isInBoundary = function(t) {
  return t === 1;
};
kx.prototype.interfaces_ = function() {
  return [Li];
};
kx.prototype.getClass = function() {
  return kx;
};
var _n = function() {
};
_n.prototype.add = function() {
};
_n.prototype.addAll = function() {
};
_n.prototype.isEmpty = function() {
};
_n.prototype.iterator = function() {
};
_n.prototype.size = function() {
};
_n.prototype.toArray = function() {
};
_n.prototype.remove = function() {
};
function q2(r) {
  this.message = r || "";
}
q2.prototype = new Error();
q2.prototype.name = "IndexOutOfBoundsException";
var ac = function() {
};
ac.prototype.hasNext = function() {
};
ac.prototype.next = function() {
};
ac.prototype.remove = function() {
};
var zi = function(r) {
  function t() {
    r.apply(this, arguments);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.get = function() {
  }, t.prototype.set = function() {
  }, t.prototype.isEmpty = function() {
  }, t;
}(_n);
function uc(r) {
  this.message = r || "";
}
uc.prototype = new Error();
uc.prototype.name = "NoSuchElementException";
var H = function(r) {
  function t() {
    r.call(this), this.array_ = [], arguments[0] instanceof _n && this.addAll(arguments[0]);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.ensureCapacity = function() {
  }, t.prototype.interfaces_ = function() {
    return [r, _n];
  }, t.prototype.add = function(n) {
    return arguments.length === 1 ? this.array_.push(n) : this.array_.splice(arguments[0], arguments[1]), !0;
  }, t.prototype.clear = function() {
    this.array_ = [];
  }, t.prototype.addAll = function(n) {
    for (var i = this, s = n.iterator(); s.hasNext(); )
      i.add(s.next());
    return !0;
  }, t.prototype.set = function(n, i) {
    var s = this.array_[n];
    return this.array_[n] = i, s;
  }, t.prototype.iterator = function() {
    return new iF(this);
  }, t.prototype.get = function(n) {
    if (n < 0 || n >= this.size())
      throw new q2();
    return this.array_[n];
  }, t.prototype.isEmpty = function() {
    return this.array_.length === 0;
  }, t.prototype.size = function() {
    return this.array_.length;
  }, t.prototype.toArray = function() {
    for (var n = this, i = [], s = 0, o = this.array_.length; s < o; s++)
      i.push(n.array_[s]);
    return i;
  }, t.prototype.remove = function(n) {
    for (var i = this, s = !1, o = 0, a = this.array_.length; o < a; o++)
      if (i.array_[o] === n) {
        i.array_.splice(o, 1), s = !0;
        break;
      }
    return s;
  }, t;
}(zi), iF = function(r) {
  function t(e) {
    r.call(this), this.arrayList_ = e, this.position_ = 0;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.next = function() {
    if (this.position_ === this.arrayList_.size())
      throw new uc();
    return this.arrayList_.get(this.position_++);
  }, t.prototype.hasNext = function() {
    return this.position_ < this.arrayList_.size();
  }, t.prototype.set = function(n) {
    return this.arrayList_.set(this.position_ - 1, n);
  }, t.prototype.remove = function() {
    this.arrayList_.remove(this.arrayList_.get(this.position_));
  }, t;
}(ac), jl = function(r) {
  function t() {
    if (r.call(this), arguments.length !== 0) {
      if (arguments.length === 1) {
        var n = arguments[0];
        this.ensureCapacity(n.length), this.add(n, !0);
      } else if (arguments.length === 2) {
        var i = arguments[0], s = arguments[1];
        this.ensureCapacity(i.length), this.add(i, s);
      }
    }
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { coordArrayType: { configurable: !0 } };
  return e.coordArrayType.get = function() {
    return new Array(0).fill(null);
  }, t.prototype.getCoordinate = function(i) {
    return this.get(i);
  }, t.prototype.addAll = function() {
    var i = this;
    if (arguments.length === 2) {
      for (var s = arguments[0], o = arguments[1], a = !1, u = s.iterator(); u.hasNext(); )
        i.add(u.next(), o), a = !0;
      return a;
    } else
      return r.prototype.addAll.apply(this, arguments);
  }, t.prototype.clone = function() {
    for (var i = this, s = r.prototype.clone.call(this), o = 0; o < this.size(); o++)
      s.add(o, i.get(o).copy());
    return s;
  }, t.prototype.toCoordinateArray = function() {
    return this.toArray(t.coordArrayType);
  }, t.prototype.add = function() {
    var i = this;
    if (arguments.length === 1) {
      var s = arguments[0];
      r.prototype.add.call(this, s);
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
        var o = arguments[0], a = arguments[1];
        return this.add(o, a, !0), !0;
      } else if (arguments[0] instanceof R && typeof arguments[1] == "boolean") {
        var u = arguments[0], x = arguments[1];
        if (!x && this.size() >= 1) {
          var c = this.get(this.size() - 1);
          if (c.equals2D(u))
            return null;
        }
        r.prototype.add.call(this, u);
      } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
        var f = arguments[0], l = arguments[1];
        return this.add(f, l), !0;
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
        var h = arguments[0], p = arguments[1], y = arguments[2];
        if (y)
          for (var v = 0; v < h.length; v++)
            i.add(h[v], p);
        else
          for (var m = h.length - 1; m >= 0; m--)
            i.add(h[m], p);
        return !0;
      } else if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof R) {
        var d = arguments[0], g = arguments[1], _ = arguments[2];
        if (!_) {
          var b = this.size();
          if (b > 0) {
            if (d > 0) {
              var w = this.get(d - 1);
              if (w.equals2D(g))
                return null;
            }
            if (d < b) {
              var E = this.get(d);
              if (E.equals2D(g))
                return null;
            }
          }
        }
        r.prototype.add.call(this, d, g);
      }
    } else if (arguments.length === 4) {
      var S = arguments[0], I = arguments[1], L = arguments[2], M = arguments[3], N = 1;
      L > M && (N = -1);
      for (var P = L; P !== M; P += N)
        i.add(S[P], I);
      return !0;
    }
  }, t.prototype.closeRing = function() {
    this.size() > 0 && this.add(new R(this.get(0)), !1);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, Object.defineProperties(t, e), t;
}(H), Ct = function() {
}, Wy = { ForwardComparator: { configurable: !0 }, BidirectionalComparator: { configurable: !0 }, coordArrayType: { configurable: !0 } };
Wy.ForwardComparator.get = function() {
  return vl;
};
Wy.BidirectionalComparator.get = function() {
  return Bx;
};
Wy.coordArrayType.get = function() {
  return new Array(0).fill(null);
};
Ct.prototype.interfaces_ = function() {
  return [];
};
Ct.prototype.getClass = function() {
  return Ct;
};
Ct.isRing = function(t) {
  return !(t.length < 4 || !t[0].equals2D(t[t.length - 1]));
};
Ct.ptNotInList = function(t, e) {
  for (var n = 0; n < t.length; n++) {
    var i = t[n];
    if (Ct.indexOf(i, e) < 0)
      return i;
  }
  return null;
};
Ct.scroll = function(t, e) {
  var n = Ct.indexOf(e, t);
  if (n < 0)
    return null;
  var i = new Array(t.length).fill(null);
  Hn.arraycopy(t, n, i, 0, t.length - n), Hn.arraycopy(t, 0, i, t.length - n, n), Hn.arraycopy(i, 0, t, 0, t.length);
};
Ct.equals = function() {
  if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    if (t === e)
      return !0;
    if (t === null || e === null || t.length !== e.length)
      return !1;
    for (var n = 0; n < t.length; n++)
      if (!t[n].equals(e[n]))
        return !1;
    return !0;
  } else if (arguments.length === 3) {
    var i = arguments[0], s = arguments[1], o = arguments[2];
    if (i === s)
      return !0;
    if (i === null || s === null || i.length !== s.length)
      return !1;
    for (var a = 0; a < i.length; a++)
      if (o.compare(i[a], s[a]) !== 0)
        return !1;
    return !0;
  }
};
Ct.intersection = function(t, e) {
  for (var n = new jl(), i = 0; i < t.length; i++)
    e.intersects(t[i]) && n.add(t[i], !0);
  return n.toCoordinateArray();
};
Ct.hasRepeatedPoints = function(t) {
  for (var e = 1; e < t.length; e++)
    if (t[e - 1].equals(t[e]))
      return !0;
  return !1;
};
Ct.removeRepeatedPoints = function(t) {
  if (!Ct.hasRepeatedPoints(t))
    return t;
  var e = new jl(t, !1);
  return e.toCoordinateArray();
};
Ct.reverse = function(t) {
  for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {
    var s = t[i];
    t[i] = t[e - i], t[e - i] = s;
  }
};
Ct.removeNull = function(t) {
  for (var e = 0, n = 0; n < t.length; n++)
    t[n] !== null && e++;
  var i = new Array(e).fill(null);
  if (e === 0)
    return i;
  for (var s = 0, o = 0; o < t.length; o++)
    t[o] !== null && (i[s++] = t[o]);
  return i;
};
Ct.copyDeep = function() {
  if (arguments.length === 1) {
    for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++)
      e[n] = new R(t[n]);
    return e;
  } else if (arguments.length === 5)
    for (var i = arguments[0], s = arguments[1], o = arguments[2], a = arguments[3], u = arguments[4], x = 0; x < u; x++)
      o[a + x] = new R(i[s + x]);
};
Ct.isEqualReversed = function(t, e) {
  for (var n = 0; n < t.length; n++) {
    var i = t[n], s = e[t.length - n - 1];
    if (i.compareTo(s) !== 0)
      return !1;
  }
  return !0;
};
Ct.envelope = function(t) {
  for (var e = new nt(), n = 0; n < t.length; n++)
    e.expandToInclude(t[n]);
  return e;
};
Ct.toCoordinateArray = function(t) {
  return t.toArray(Ct.coordArrayType);
};
Ct.atLeastNCoordinatesOrNothing = function(t, e) {
  return e.length >= t ? e : [];
};
Ct.indexOf = function(t, e) {
  for (var n = 0; n < e.length; n++)
    if (t.equals(e[n]))
      return n;
  return -1;
};
Ct.increasingDirection = function(t) {
  for (var e = 0; e < Math.trunc(t.length / 2); e++) {
    var n = t.length - 1 - e, i = t[e].compareTo(t[n]);
    if (i !== 0)
      return i;
  }
  return 1;
};
Ct.compare = function(t, e) {
  for (var n = 0; n < t.length && n < e.length; ) {
    var i = t[n].compareTo(e[n]);
    if (i !== 0)
      return i;
    n++;
  }
  return n < e.length ? -1 : n < t.length ? 1 : 0;
};
Ct.minCoordinate = function(t) {
  for (var e = null, n = 0; n < t.length; n++)
    (e === null || e.compareTo(t[n]) > 0) && (e = t[n]);
  return e;
};
Ct.extract = function(t, e, n) {
  e = ai.clamp(e, 0, t.length), n = ai.clamp(n, -1, t.length);
  var i = n - e + 1;
  n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0);
  var s = new Array(i).fill(null);
  if (i === 0)
    return s;
  for (var o = 0, a = e; a <= n; a++)
    s[o++] = t[a];
  return s;
};
Object.defineProperties(Ct, Wy);
var vl = function() {
};
vl.prototype.compare = function(t, e) {
  var n = t, i = e;
  return Ct.compare(n, i);
};
vl.prototype.interfaces_ = function() {
  return [Rx];
};
vl.prototype.getClass = function() {
  return vl;
};
var Bx = function() {
};
Bx.prototype.compare = function(t, e) {
  var n = t, i = e;
  if (n.length < i.length)
    return -1;
  if (n.length > i.length)
    return 1;
  if (n.length === 0)
    return 0;
  var s = Ct.compare(n, i), o = Ct.isEqualReversed(n, i);
  return o ? 0 : s;
};
Bx.prototype.OLDcompare = function(t, e) {
  var n = t, i = e;
  if (n.length < i.length)
    return -1;
  if (n.length > i.length)
    return 1;
  if (n.length === 0)
    return 0;
  for (var s = Ct.increasingDirection(n), o = Ct.increasingDirection(i), a = s > 0 ? 0 : n.length - 1, u = o > 0 ? 0 : n.length - 1, x = 0; x < n.length; x++) {
    var c = n[a].compareTo(i[u]);
    if (c !== 0)
      return c;
    a += s, u += o;
  }
  return 0;
};
Bx.prototype.interfaces_ = function() {
  return [Rx];
};
Bx.prototype.getClass = function() {
  return Bx;
};
var pu = function() {
};
pu.prototype.get = function() {
};
pu.prototype.put = function() {
};
pu.prototype.size = function() {
};
pu.prototype.values = function() {
};
pu.prototype.entrySet = function() {
};
var sF = function(r) {
  function t() {
    r.apply(this, arguments);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t;
}(pu);
function Ql(r) {
  this.message = r || "";
}
Ql.prototype = new Error();
Ql.prototype.name = "OperationNotSupported";
function Hy() {
}
Hy.prototype = new _n();
Hy.prototype.contains = function() {
};
var z2 = function(r) {
  function t() {
    r.call(this), this.array_ = [], arguments[0] instanceof _n && this.addAll(arguments[0]);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.contains = function(n) {
    for (var i = this, s = 0, o = this.array_.length; s < o; s++) {
      var a = i.array_[s];
      if (a === n)
        return !0;
    }
    return !1;
  }, t.prototype.add = function(n) {
    return this.contains(n) ? !1 : (this.array_.push(n), !0);
  }, t.prototype.addAll = function(n) {
    for (var i = this, s = n.iterator(); s.hasNext(); )
      i.add(s.next());
    return !0;
  }, t.prototype.remove = function(n) {
    throw new Error();
  }, t.prototype.size = function() {
    return this.array_.length;
  }, t.prototype.isEmpty = function() {
    return this.array_.length === 0;
  }, t.prototype.toArray = function() {
    for (var n = this, i = [], s = 0, o = this.array_.length; s < o; s++)
      i.push(n.array_[s]);
    return i;
  }, t.prototype.iterator = function() {
    return new oF(this);
  }, t;
}(Hy), oF = function(r) {
  function t(e) {
    r.call(this), this.hashSet_ = e, this.position_ = 0;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.next = function() {
    if (this.position_ === this.hashSet_.size())
      throw new uc();
    return this.hashSet_.array_[this.position_++];
  }, t.prototype.hasNext = function() {
    return this.position_ < this.hashSet_.size();
  }, t.prototype.remove = function() {
    throw new Ql();
  }, t;
}(ac), ho = 0, Ra = 1;
function I3(r) {
  return r === null ? ho : r.color;
}
function Le(r) {
  return r === null ? null : r.parent;
}
function xo(r, t) {
  r !== null && (r.color = t);
}
function tm(r) {
  return r === null ? null : r.left;
}
function w3(r) {
  return r === null ? null : r.right;
}
function or() {
  this.root_ = null, this.size_ = 0;
}
or.prototype = new sF();
or.prototype.get = function(r) {
  for (var t = this.root_; t !== null; ) {
    var e = r.compareTo(t.key);
    if (e < 0)
      t = t.left;
    else if (e > 0)
      t = t.right;
    else
      return t.value;
  }
  return null;
};
or.prototype.put = function(r, t) {
  if (this.root_ === null)
    return this.root_ = {
      key: r,
      value: t,
      left: null,
      right: null,
      parent: null,
      color: ho,
      getValue: function() {
        return this.value;
      },
      getKey: function() {
        return this.key;
      }
    }, this.size_ = 1, null;
  var e = this.root_, n, i;
  do
    if (n = e, i = r.compareTo(e.key), i < 0)
      e = e.left;
    else if (i > 0)
      e = e.right;
    else {
      var s = e.value;
      return e.value = t, s;
    }
  while (e !== null);
  var o = {
    key: r,
    left: null,
    right: null,
    value: t,
    parent: n,
    color: ho,
    getValue: function() {
      return this.value;
    },
    getKey: function() {
      return this.key;
    }
  };
  return i < 0 ? n.left = o : n.right = o, this.fixAfterInsertion(o), this.size_++, null;
};
or.prototype.fixAfterInsertion = function(r) {
  var t = this;
  for (r.color = Ra; r != null && r !== this.root_ && r.parent.color === Ra; )
    if (Le(r) === tm(Le(Le(r)))) {
      var e = w3(Le(Le(r)));
      I3(e) === Ra ? (xo(Le(r), ho), xo(e, ho), xo(Le(Le(r)), Ra), r = Le(Le(r))) : (r === w3(Le(r)) && (r = Le(r), t.rotateLeft(r)), xo(Le(r), ho), xo(Le(Le(r)), Ra), t.rotateRight(Le(Le(r))));
    } else {
      var n = tm(Le(Le(r)));
      I3(n) === Ra ? (xo(Le(r), ho), xo(n, ho), xo(Le(Le(r)), Ra), r = Le(Le(r))) : (r === tm(Le(r)) && (r = Le(r), t.rotateRight(r)), xo(Le(r), ho), xo(Le(Le(r)), Ra), t.rotateLeft(Le(Le(r))));
    }
  this.root_.color = ho;
};
or.prototype.values = function() {
  var r = new H(), t = this.getFirstEntry();
  if (t !== null)
    for (r.add(t.value); (t = or.successor(t)) !== null; )
      r.add(t.value);
  return r;
};
or.prototype.entrySet = function() {
  var r = new z2(), t = this.getFirstEntry();
  if (t !== null)
    for (r.add(t); (t = or.successor(t)) !== null; )
      r.add(t);
  return r;
};
or.prototype.rotateLeft = function(r) {
  if (r != null) {
    var t = r.right;
    r.right = t.left, t.left != null && (t.left.parent = r), t.parent = r.parent, r.parent === null ? this.root_ = t : r.parent.left === r ? r.parent.left = t : r.parent.right = t, t.left = r, r.parent = t;
  }
};
or.prototype.rotateRight = function(r) {
  if (r != null) {
    var t = r.left;
    r.left = t.right, t.right != null && (t.right.parent = r), t.parent = r.parent, r.parent === null ? this.root_ = t : r.parent.right === r ? r.parent.right = t : r.parent.left = t, t.right = r, r.parent = t;
  }
};
or.prototype.getFirstEntry = function() {
  var r = this.root_;
  if (r != null)
    for (; r.left != null; )
      r = r.left;
  return r;
};
or.successor = function(r) {
  if (r === null)
    return null;
  if (r.right !== null) {
    for (var t = r.right; t.left !== null; )
      t = t.left;
    return t;
  } else {
    for (var e = r.parent, n = r; e !== null && n === e.right; )
      n = e, e = e.parent;
    return e;
  }
};
or.prototype.size = function() {
  return this.size_;
};
var ml = function() {
};
ml.prototype.interfaces_ = function() {
  return [];
};
ml.prototype.getClass = function() {
  return ml;
};
function XS() {
}
XS.prototype = new Hy();
function Es() {
  this.array_ = [], arguments[0] instanceof _n && this.addAll(arguments[0]);
}
Es.prototype = new XS();
Es.prototype.contains = function(r) {
  for (var t = this, e = 0, n = this.array_.length; e < n; e++) {
    var i = t.array_[e];
    if (i.compareTo(r) === 0)
      return !0;
  }
  return !1;
};
Es.prototype.add = function(r) {
  var t = this;
  if (this.contains(r))
    return !1;
  for (var e = 0, n = this.array_.length; e < n; e++) {
    var i = t.array_[e];
    if (i.compareTo(r) === 1)
      return t.array_.splice(e, 0, r), !0;
  }
  return this.array_.push(r), !0;
};
Es.prototype.addAll = function(r) {
  for (var t = this, e = r.iterator(); e.hasNext(); )
    t.add(e.next());
  return !0;
};
Es.prototype.remove = function(r) {
  throw new Ql();
};
Es.prototype.size = function() {
  return this.array_.length;
};
Es.prototype.isEmpty = function() {
  return this.array_.length === 0;
};
Es.prototype.toArray = function() {
  for (var r = this, t = [], e = 0, n = this.array_.length; e < n; e++)
    t.push(r.array_[e]);
  return t;
};
Es.prototype.iterator = function() {
  return new Jy(this);
};
var Jy = function(r) {
  this.treeSet_ = r, this.position_ = 0;
};
Jy.prototype.next = function() {
  if (this.position_ === this.treeSet_.size())
    throw new uc();
  return this.treeSet_.array_[this.position_++];
};
Jy.prototype.hasNext = function() {
  return this.position_ < this.treeSet_.size();
};
Jy.prototype.remove = function() {
  throw new Ql();
};
var za = function() {
};
za.sort = function() {
  var t = arguments[0], e, n, i, s;
  if (arguments.length === 1)
    s = function(a, u) {
      return a.compareTo(u);
    }, t.sort(s);
  else if (arguments.length === 2)
    i = arguments[1], s = function(a, u) {
      return i.compare(a, u);
    }, t.sort(s);
  else if (arguments.length === 3) {
    n = t.slice(arguments[1], arguments[2]), n.sort();
    var o = t.slice(0, arguments[1]).concat(n, t.slice(arguments[2], t.length));
    for (t.splice(0, t.length), e = 0; e < o.length; e++)
      t.push(o[e]);
  } else if (arguments.length === 4)
    for (n = t.slice(arguments[1], arguments[2]), i = arguments[3], s = function(a, u) {
      return i.compare(a, u);
    }, n.sort(s), o = t.slice(0, arguments[1]).concat(n, t.slice(arguments[2], t.length)), t.splice(0, t.length), e = 0; e < o.length; e++)
      t.push(o[e]);
};
za.asList = function(t) {
  for (var e = new H(), n = 0, i = t.length; n < i; n++)
    e.add(t[n]);
  return e;
};
var ae = function() {
}, $i = { P: { configurable: !0 }, L: { configurable: !0 }, A: { configurable: !0 }, FALSE: { configurable: !0 }, TRUE: { configurable: !0 }, DONTCARE: { configurable: !0 }, SYM_FALSE: { configurable: !0 }, SYM_TRUE: { configurable: !0 }, SYM_DONTCARE: { configurable: !0 }, SYM_P: { configurable: !0 }, SYM_L: { configurable: !0 }, SYM_A: { configurable: !0 } };
$i.P.get = function() {
  return 0;
};
$i.L.get = function() {
  return 1;
};
$i.A.get = function() {
  return 2;
};
$i.FALSE.get = function() {
  return -1;
};
$i.TRUE.get = function() {
  return -2;
};
$i.DONTCARE.get = function() {
  return -3;
};
$i.SYM_FALSE.get = function() {
  return "F";
};
$i.SYM_TRUE.get = function() {
  return "T";
};
$i.SYM_DONTCARE.get = function() {
  return "*";
};
$i.SYM_P.get = function() {
  return "0";
};
$i.SYM_L.get = function() {
  return "1";
};
$i.SYM_A.get = function() {
  return "2";
};
ae.prototype.interfaces_ = function() {
  return [];
};
ae.prototype.getClass = function() {
  return ae;
};
ae.toDimensionSymbol = function(t) {
  switch (t) {
    case ae.FALSE:
      return ae.SYM_FALSE;
    case ae.TRUE:
      return ae.SYM_TRUE;
    case ae.DONTCARE:
      return ae.SYM_DONTCARE;
    case ae.P:
      return ae.SYM_P;
    case ae.L:
      return ae.SYM_L;
    case ae.A:
      return ae.SYM_A;
  }
  throw new ze("Unknown dimension value: " + t);
};
ae.toDimensionValue = function(t) {
  switch (yl.toUpperCase(t)) {
    case ae.SYM_FALSE:
      return ae.FALSE;
    case ae.SYM_TRUE:
      return ae.TRUE;
    case ae.SYM_DONTCARE:
      return ae.DONTCARE;
    case ae.SYM_P:
      return ae.P;
    case ae.SYM_L:
      return ae.L;
    case ae.SYM_A:
      return ae.A;
  }
  throw new ze("Unknown dimension symbol: " + t);
};
Object.defineProperties(ae, $i);
var Ss = function() {
};
Ss.prototype.filter = function(t) {
};
Ss.prototype.interfaces_ = function() {
  return [];
};
Ss.prototype.getClass = function() {
  return Ss;
};
var Wi = function() {
};
Wi.prototype.filter = function(t, e) {
};
Wi.prototype.isDone = function() {
};
Wi.prototype.isGeometryChanged = function() {
};
Wi.prototype.interfaces_ = function() {
  return [];
};
Wi.prototype.getClass = function() {
  return Wi;
};
var Ir = function(r) {
  function t(n, i) {
    if (r.call(this, i), this._geometries = n || [], r.hasNullElements(this._geometries))
      throw new ze("geometries must not contain null elements");
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { serialVersionUID: { configurable: !0 } };
  return t.prototype.computeEnvelopeInternal = function() {
    for (var i = this, s = new nt(), o = 0; o < this._geometries.length; o++)
      s.expandToInclude(i._geometries[o].getEnvelopeInternal());
    return s;
  }, t.prototype.getGeometryN = function(i) {
    return this._geometries[i];
  }, t.prototype.getSortIndex = function() {
    return r.SORTINDEX_GEOMETRYCOLLECTION;
  }, t.prototype.getCoordinates = function() {
    for (var i = this, s = new Array(this.getNumPoints()).fill(null), o = -1, a = 0; a < this._geometries.length; a++)
      for (var u = i._geometries[a].getCoordinates(), x = 0; x < u.length; x++)
        o++, s[o] = u[x];
    return s;
  }, t.prototype.getArea = function() {
    for (var i = this, s = 0, o = 0; o < this._geometries.length; o++)
      s += i._geometries[o].getArea();
    return s;
  }, t.prototype.equalsExact = function() {
    var i = this;
    if (arguments.length === 2) {
      var s = arguments[0], o = arguments[1];
      if (!this.isEquivalentClass(s))
        return !1;
      var a = s;
      if (this._geometries.length !== a._geometries.length)
        return !1;
      for (var u = 0; u < this._geometries.length; u++)
        if (!i._geometries[u].equalsExact(a._geometries[u], o))
          return !1;
      return !0;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, t.prototype.normalize = function() {
    for (var i = this, s = 0; s < this._geometries.length; s++)
      i._geometries[s].normalize();
    za.sort(this._geometries);
  }, t.prototype.getCoordinate = function() {
    return this.isEmpty() ? null : this._geometries[0].getCoordinate();
  }, t.prototype.getBoundaryDimension = function() {
    for (var i = this, s = ae.FALSE, o = 0; o < this._geometries.length; o++)
      s = Math.max(s, i._geometries[o].getBoundaryDimension());
    return s;
  }, t.prototype.getDimension = function() {
    for (var i = this, s = ae.FALSE, o = 0; o < this._geometries.length; o++)
      s = Math.max(s, i._geometries[o].getDimension());
    return s;
  }, t.prototype.getLength = function() {
    for (var i = this, s = 0, o = 0; o < this._geometries.length; o++)
      s += i._geometries[o].getLength();
    return s;
  }, t.prototype.getNumPoints = function() {
    for (var i = this, s = 0, o = 0; o < this._geometries.length; o++)
      s += i._geometries[o].getNumPoints();
    return s;
  }, t.prototype.getNumGeometries = function() {
    return this._geometries.length;
  }, t.prototype.reverse = function() {
    for (var i = this, s = this._geometries.length, o = new Array(s).fill(null), a = 0; a < this._geometries.length; a++)
      o[a] = i._geometries[a].reverse();
    return this.getFactory().createGeometryCollection(o);
  }, t.prototype.compareToSameClass = function() {
    var i = this;
    if (arguments.length === 1) {
      var s = arguments[0], o = new Es(za.asList(this._geometries)), a = new Es(za.asList(s._geometries));
      return this.compare(o, a);
    } else if (arguments.length === 2) {
      for (var u = arguments[0], x = arguments[1], c = u, f = this.getNumGeometries(), l = c.getNumGeometries(), h = 0; h < f && h < l; ) {
        var p = i.getGeometryN(h), y = c.getGeometryN(h), v = p.compareToSameClass(y, x);
        if (v !== 0)
          return v;
        h++;
      }
      return h < f ? 1 : h < l ? -1 : 0;
    }
  }, t.prototype.apply = function() {
    var i = this;
    if (ct(arguments[0], Ks))
      for (var s = arguments[0], o = 0; o < this._geometries.length; o++)
        i._geometries[o].apply(s);
    else if (ct(arguments[0], Wi)) {
      var a = arguments[0];
      if (this._geometries.length === 0)
        return null;
      for (var u = 0; u < this._geometries.length && (i._geometries[u].apply(a), !a.isDone()); u++)
        ;
      a.isGeometryChanged() && this.geometryChanged();
    } else if (ct(arguments[0], Ss)) {
      var x = arguments[0];
      x.filter(this);
      for (var c = 0; c < this._geometries.length; c++)
        i._geometries[c].apply(x);
    } else if (ct(arguments[0], Co)) {
      var f = arguments[0];
      f.filter(this);
      for (var l = 0; l < this._geometries.length; l++)
        i._geometries[l].apply(f);
    }
  }, t.prototype.getBoundary = function() {
    return this.checkNotGeometryCollection(this), mt.shouldNeverReachHere(), null;
  }, t.prototype.clone = function() {
    var i = this, s = r.prototype.clone.call(this);
    s._geometries = new Array(this._geometries.length).fill(null);
    for (var o = 0; o < this._geometries.length; o++)
      s._geometries[o] = i._geometries[o].clone();
    return s;
  }, t.prototype.getGeometryType = function() {
    return "GeometryCollection";
  }, t.prototype.copy = function() {
    for (var i = this, s = new Array(this._geometries.length).fill(null), o = 0; o < s.length; o++)
      s[o] = i._geometries[o].copy();
    return new t(s, this._factory);
  }, t.prototype.isEmpty = function() {
    for (var i = this, s = 0; s < this._geometries.length; s++)
      if (!i._geometries[s].isEmpty())
        return !1;
    return !0;
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, e.serialVersionUID.get = function() {
    return -5694727726395021e3;
  }, Object.defineProperties(t, e), t;
}(xt), Qa = function(r) {
  function t() {
    r.apply(this, arguments);
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { serialVersionUID: { configurable: !0 } };
  return t.prototype.getSortIndex = function() {
    return xt.SORTINDEX_MULTILINESTRING;
  }, t.prototype.equalsExact = function() {
    if (arguments.length === 2) {
      var i = arguments[0], s = arguments[1];
      return this.isEquivalentClass(i) ? r.prototype.equalsExact.call(this, i, s) : !1;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, t.prototype.getBoundaryDimension = function() {
    return this.isClosed() ? ae.FALSE : 0;
  }, t.prototype.isClosed = function() {
    var i = this;
    if (this.isEmpty())
      return !1;
    for (var s = 0; s < this._geometries.length; s++)
      if (!i._geometries[s].isClosed())
        return !1;
    return !0;
  }, t.prototype.getDimension = function() {
    return 1;
  }, t.prototype.reverse = function() {
    for (var i = this, s = this._geometries.length, o = new Array(s).fill(null), a = 0; a < this._geometries.length; a++)
      o[s - 1 - a] = i._geometries[a].reverse();
    return this.getFactory().createMultiLineString(o);
  }, t.prototype.getBoundary = function() {
    return new Ii(this).getBoundary();
  }, t.prototype.getGeometryType = function() {
    return "MultiLineString";
  }, t.prototype.copy = function() {
    for (var i = this, s = new Array(this._geometries.length).fill(null), o = 0; o < s.length; o++)
      s[o] = i._geometries[o].copy();
    return new t(s, this._factory);
  }, t.prototype.interfaces_ = function() {
    return [ml];
  }, t.prototype.getClass = function() {
    return t;
  }, e.serialVersionUID.get = function() {
    return 8166665132445434e3;
  }, Object.defineProperties(t, e), t;
}(Ir), Ii = function() {
  if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, arguments.length === 1) {
    var t = arguments[0], e = Li.MOD2_BOUNDARY_RULE;
    this._geom = t, this._geomFact = t.getFactory(), this._bnRule = e;
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this._geom = n, this._geomFact = n.getFactory(), this._bnRule = i;
  }
};
Ii.prototype.boundaryMultiLineString = function(t) {
  if (this._geom.isEmpty())
    return this.getEmptyMultiPoint();
  var e = this.computeBoundaryCoordinates(t);
  return e.length === 1 ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e);
};
Ii.prototype.getBoundary = function() {
  return this._geom instanceof je ? this.boundaryLineString(this._geom) : this._geom instanceof Qa ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
};
Ii.prototype.boundaryLineString = function(t) {
  if (this._geom.isEmpty())
    return this.getEmptyMultiPoint();
  if (t.isClosed()) {
    var e = this._bnRule.isInBoundary(2);
    return e ? t.getStartPoint() : this._geomFact.createMultiPoint();
  }
  return this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]);
};
Ii.prototype.getEmptyMultiPoint = function() {
  return this._geomFact.createMultiPoint();
};
Ii.prototype.computeBoundaryCoordinates = function(t) {
  var e = this, n = new H();
  this._endpointMap = new or();
  for (var i = 0; i < t.getNumGeometries(); i++) {
    var s = t.getGeometryN(i);
    s.getNumPoints() !== 0 && (e.addEndpoint(s.getCoordinateN(0)), e.addEndpoint(s.getCoordinateN(s.getNumPoints() - 1)));
  }
  for (var o = this._endpointMap.entrySet().iterator(); o.hasNext(); ) {
    var a = o.next(), u = a.getValue(), x = u.count;
    e._bnRule.isInBoundary(x) && n.add(a.getKey());
  }
  return Ct.toCoordinateArray(n);
};
Ii.prototype.addEndpoint = function(t) {
  var e = this._endpointMap.get(t);
  e === null && (e = new Dg(), this._endpointMap.put(t, e)), e.count++;
};
Ii.prototype.interfaces_ = function() {
  return [];
};
Ii.prototype.getClass = function() {
  return Ii;
};
Ii.getBoundary = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = new Ii(t);
    return e.getBoundary();
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], s = new Ii(n, i);
    return s.getBoundary();
  }
};
var Dg = function() {
  this.count = null;
};
Dg.prototype.interfaces_ = function() {
  return [];
};
Dg.prototype.getClass = function() {
  return Dg;
};
function aF() {
}
function uF() {
}
var xF = function() {
};
function cF() {
}
function fF() {
}
function lF() {
}
var wi = function() {
}, U2 = { NEWLINE: { configurable: !0 }, SIMPLE_ORDINATE_FORMAT: { configurable: !0 } };
wi.prototype.interfaces_ = function() {
  return [];
};
wi.prototype.getClass = function() {
  return wi;
};
wi.chars = function(t, e) {
  for (var n = new Array(e).fill(null), i = 0; i < e; i++)
    n[i] = t;
  return String(n);
};
wi.getStackTrace = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = new cF(), n = new aF();
    return t.printStackTrace(n), e.toString();
  } else if (arguments.length === 2) {
    var i = arguments[0], s = arguments[1], o = "";
    new uF(wi.getStackTrace(i));
    for (var a = new lF(), u = 0; u < s; u++)
      try {
        o += a.readLine() + wi.NEWLINE;
      } catch (x) {
        if (x instanceof fF)
          mt.shouldNeverReachHere();
        else
          throw x;
      } finally {
      }
    return o;
  }
};
wi.split = function(t, e) {
  for (var n = e.length, i = new H(), s = "" + t, o = s.indexOf(e); o >= 0; ) {
    var a = s.substring(0, o);
    i.add(a), s = s.substring(o + n), o = s.indexOf(e);
  }
  s.length > 0 && i.add(s);
  for (var u = new Array(i.size()).fill(null), x = 0; x < u.length; x++)
    u[x] = i.get(x);
  return u;
};
wi.toString = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return wi.SIMPLE_ORDINATE_FORMAT.format(t);
  }
};
wi.spaces = function(t) {
  return wi.chars(" ", t);
};
U2.NEWLINE.get = function() {
  return Hn.getProperty("line.separator");
};
U2.SIMPLE_ORDINATE_FORMAT.get = function() {
  return new xF();
};
Object.defineProperties(wi, U2);
var rn = function() {
};
rn.prototype.interfaces_ = function() {
  return [];
};
rn.prototype.getClass = function() {
  return rn;
};
rn.copyCoord = function(t, e, n, i) {
  for (var s = Math.min(t.getDimension(), n.getDimension()), o = 0; o < s; o++)
    n.setOrdinate(i, o, t.getOrdinate(e, o));
};
rn.isRing = function(t) {
  var e = t.size();
  return e === 0 ? !0 : e <= 3 ? !1 : t.getOrdinate(0, Rt.X) === t.getOrdinate(e - 1, Rt.X) && t.getOrdinate(0, Rt.Y) === t.getOrdinate(e - 1, Rt.Y);
};
rn.isEqual = function(t, e) {
  var n = t.size(), i = e.size();
  if (n !== i)
    return !1;
  for (var s = Math.min(t.getDimension(), e.getDimension()), o = 0; o < n; o++)
    for (var a = 0; a < s; a++) {
      var u = t.getOrdinate(o, a), x = e.getOrdinate(o, a);
      if (t.getOrdinate(o, a) !== e.getOrdinate(o, a) && !(yt.isNaN(u) && yt.isNaN(x)))
        return !1;
    }
  return !0;
};
rn.extend = function(t, e, n) {
  var i = t.create(n, e.getDimension()), s = e.size();
  if (rn.copy(e, 0, i, 0, s), s > 0)
    for (var o = s; o < n; o++)
      rn.copy(e, s - 1, i, o, 1);
  return i;
};
rn.reverse = function(t) {
  for (var e = t.size() - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++)
    rn.swap(t, i, e - i);
};
rn.swap = function(t, e, n) {
  if (e === n)
    return null;
  for (var i = 0; i < t.getDimension(); i++) {
    var s = t.getOrdinate(e, i);
    t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, s);
  }
};
rn.copy = function(t, e, n, i, s) {
  for (var o = 0; o < s; o++)
    rn.copyCoord(t, e + o, n, i + o);
};
rn.toString = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = t.size();
    if (e === 0)
      return "()";
    var n = t.getDimension(), i = new As();
    i.append("(");
    for (var s = 0; s < e; s++) {
      s > 0 && i.append(" ");
      for (var o = 0; o < n; o++)
        o > 0 && i.append(","), i.append(wi.toString(t.getOrdinate(s, o)));
    }
    return i.append(")"), i.toString();
  }
};
rn.ensureValidRing = function(t, e) {
  var n = e.size();
  if (n === 0)
    return e;
  if (n <= 3)
    return rn.createClosedRing(t, e, 4);
  var i = e.getOrdinate(0, Rt.X) === e.getOrdinate(n - 1, Rt.X) && e.getOrdinate(0, Rt.Y) === e.getOrdinate(n - 1, Rt.Y);
  return i ? e : rn.createClosedRing(t, e, n + 1);
};
rn.createClosedRing = function(t, e, n) {
  var i = t.create(n, e.getDimension()), s = e.size();
  rn.copy(e, 0, i, 0, s);
  for (var o = s; o < n; o++)
    rn.copy(e, 0, i, o, 1);
  return i;
};
var je = function(r) {
  function t(n, i) {
    r.call(this, i), this._points = null, this.init(n);
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { serialVersionUID: { configurable: !0 } };
  return t.prototype.computeEnvelopeInternal = function() {
    return this.isEmpty() ? new nt() : this._points.expandEnvelope(new nt());
  }, t.prototype.isRing = function() {
    return this.isClosed() && this.isSimple();
  }, t.prototype.getSortIndex = function() {
    return r.SORTINDEX_LINESTRING;
  }, t.prototype.getCoordinates = function() {
    return this._points.toCoordinateArray();
  }, t.prototype.equalsExact = function() {
    var i = this;
    if (arguments.length === 2) {
      var s = arguments[0], o = arguments[1];
      if (!this.isEquivalentClass(s))
        return !1;
      var a = s;
      if (this._points.size() !== a._points.size())
        return !1;
      for (var u = 0; u < this._points.size(); u++)
        if (!i.equal(i._points.getCoordinate(u), a._points.getCoordinate(u), o))
          return !1;
      return !0;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, t.prototype.normalize = function() {
    for (var i = this, s = 0; s < Math.trunc(this._points.size() / 2); s++) {
      var o = i._points.size() - 1 - s;
      if (!i._points.getCoordinate(s).equals(i._points.getCoordinate(o)))
        return i._points.getCoordinate(s).compareTo(i._points.getCoordinate(o)) > 0 && rn.reverse(i._points), null;
    }
  }, t.prototype.getCoordinate = function() {
    return this.isEmpty() ? null : this._points.getCoordinate(0);
  }, t.prototype.getBoundaryDimension = function() {
    return this.isClosed() ? ae.FALSE : 0;
  }, t.prototype.isClosed = function() {
    return this.isEmpty() ? !1 : this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
  }, t.prototype.getEndPoint = function() {
    return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
  }, t.prototype.getDimension = function() {
    return 1;
  }, t.prototype.getLength = function() {
    return Z.computeLength(this._points);
  }, t.prototype.getNumPoints = function() {
    return this._points.size();
  }, t.prototype.reverse = function() {
    var i = this._points.copy();
    rn.reverse(i);
    var s = this.getFactory().createLineString(i);
    return s;
  }, t.prototype.compareToSameClass = function() {
    var i = this;
    if (arguments.length === 1) {
      for (var s = arguments[0], o = s, a = 0, u = 0; a < this._points.size() && u < o._points.size(); ) {
        var x = i._points.getCoordinate(a).compareTo(o._points.getCoordinate(u));
        if (x !== 0)
          return x;
        a++, u++;
      }
      return a < this._points.size() ? 1 : u < o._points.size() ? -1 : 0;
    } else if (arguments.length === 2) {
      var c = arguments[0], f = arguments[1], l = c;
      return f.compare(this._points, l._points);
    }
  }, t.prototype.apply = function() {
    var i = this;
    if (ct(arguments[0], Ks))
      for (var s = arguments[0], o = 0; o < this._points.size(); o++)
        s.filter(i._points.getCoordinate(o));
    else if (ct(arguments[0], Wi)) {
      var a = arguments[0];
      if (this._points.size() === 0)
        return null;
      for (var u = 0; u < this._points.size() && (a.filter(i._points, u), !a.isDone()); u++)
        ;
      a.isGeometryChanged() && this.geometryChanged();
    } else if (ct(arguments[0], Ss)) {
      var x = arguments[0];
      x.filter(this);
    } else if (ct(arguments[0], Co)) {
      var c = arguments[0];
      c.filter(this);
    }
  }, t.prototype.getBoundary = function() {
    return new Ii(this).getBoundary();
  }, t.prototype.isEquivalentClass = function(i) {
    return i instanceof t;
  }, t.prototype.clone = function() {
    var i = r.prototype.clone.call(this);
    return i._points = this._points.clone(), i;
  }, t.prototype.getCoordinateN = function(i) {
    return this._points.getCoordinate(i);
  }, t.prototype.getGeometryType = function() {
    return "LineString";
  }, t.prototype.copy = function() {
    return new t(this._points.copy(), this._factory);
  }, t.prototype.getCoordinateSequence = function() {
    return this._points;
  }, t.prototype.isEmpty = function() {
    return this._points.size() === 0;
  }, t.prototype.init = function(i) {
    if (i === null && (i = this.getFactory().getCoordinateSequenceFactory().create([])), i.size() === 1)
      throw new ze("Invalid number of points in LineString (found " + i.size() + " - must be 0 or >= 2)");
    this._points = i;
  }, t.prototype.isCoordinate = function(i) {
    for (var s = this, o = 0; o < this._points.size(); o++)
      if (s._points.getCoordinate(o).equals(i))
        return !0;
    return !1;
  }, t.prototype.getStartPoint = function() {
    return this.isEmpty() ? null : this.getPointN(0);
  }, t.prototype.getPointN = function(i) {
    return this.getFactory().createPoint(this._points.getCoordinate(i));
  }, t.prototype.interfaces_ = function() {
    return [ml];
  }, t.prototype.getClass = function() {
    return t;
  }, e.serialVersionUID.get = function() {
    return 3110669828065365500;
  }, Object.defineProperties(t, e), t;
}(xt), _l = function() {
};
_l.prototype.interfaces_ = function() {
  return [];
};
_l.prototype.getClass = function() {
  return _l;
};
var Jr = function(r) {
  function t(n, i) {
    r.call(this, i), this._coordinates = n || null, this.init(this._coordinates);
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { serialVersionUID: { configurable: !0 } };
  return t.prototype.computeEnvelopeInternal = function() {
    if (this.isEmpty())
      return new nt();
    var i = new nt();
    return i.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), i;
  }, t.prototype.getSortIndex = function() {
    return r.SORTINDEX_POINT;
  }, t.prototype.getCoordinates = function() {
    return this.isEmpty() ? [] : [this.getCoordinate()];
  }, t.prototype.equalsExact = function() {
    if (arguments.length === 2) {
      var i = arguments[0], s = arguments[1];
      return this.isEquivalentClass(i) ? this.isEmpty() && i.isEmpty() ? !0 : this.isEmpty() !== i.isEmpty() ? !1 : this.equal(i.getCoordinate(), this.getCoordinate(), s) : !1;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, t.prototype.normalize = function() {
  }, t.prototype.getCoordinate = function() {
    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
  }, t.prototype.getBoundaryDimension = function() {
    return ae.FALSE;
  }, t.prototype.getDimension = function() {
    return 0;
  }, t.prototype.getNumPoints = function() {
    return this.isEmpty() ? 0 : 1;
  }, t.prototype.reverse = function() {
    return this.copy();
  }, t.prototype.getX = function() {
    if (this.getCoordinate() === null)
      throw new Error("getX called on empty Point");
    return this.getCoordinate().x;
  }, t.prototype.compareToSameClass = function() {
    if (arguments.length === 1) {
      var i = arguments[0], s = i;
      return this.getCoordinate().compareTo(s.getCoordinate());
    } else if (arguments.length === 2) {
      var o = arguments[0], a = arguments[1], u = o;
      return a.compare(this._coordinates, u._coordinates);
    }
  }, t.prototype.apply = function() {
    if (ct(arguments[0], Ks)) {
      var i = arguments[0];
      if (this.isEmpty())
        return null;
      i.filter(this.getCoordinate());
    } else if (ct(arguments[0], Wi)) {
      var s = arguments[0];
      if (this.isEmpty())
        return null;
      s.filter(this._coordinates, 0), s.isGeometryChanged() && this.geometryChanged();
    } else if (ct(arguments[0], Ss)) {
      var o = arguments[0];
      o.filter(this);
    } else if (ct(arguments[0], Co)) {
      var a = arguments[0];
      a.filter(this);
    }
  }, t.prototype.getBoundary = function() {
    return this.getFactory().createGeometryCollection(null);
  }, t.prototype.clone = function() {
    var i = r.prototype.clone.call(this);
    return i._coordinates = this._coordinates.clone(), i;
  }, t.prototype.getGeometryType = function() {
    return "Point";
  }, t.prototype.copy = function() {
    return new t(this._coordinates.copy(), this._factory);
  }, t.prototype.getCoordinateSequence = function() {
    return this._coordinates;
  }, t.prototype.getY = function() {
    if (this.getCoordinate() === null)
      throw new Error("getY called on empty Point");
    return this.getCoordinate().y;
  }, t.prototype.isEmpty = function() {
    return this._coordinates.size() === 0;
  }, t.prototype.init = function(i) {
    i === null && (i = this.getFactory().getCoordinateSequenceFactory().create([])), mt.isTrue(i.size() <= 1), this._coordinates = i;
  }, t.prototype.isSimple = function() {
    return !0;
  }, t.prototype.interfaces_ = function() {
    return [_l];
  }, t.prototype.getClass = function() {
    return t;
  }, e.serialVersionUID.get = function() {
    return 4902022702746615e3;
  }, Object.defineProperties(t, e), t;
}(xt), la = function() {
};
la.prototype.interfaces_ = function() {
  return [];
};
la.prototype.getClass = function() {
  return la;
};
var Mn = function(r) {
  function t(n, i, s) {
    if (r.call(this, s), this._shell = null, this._holes = null, n === null && (n = this.getFactory().createLinearRing()), i === null && (i = []), r.hasNullElements(i))
      throw new ze("holes must not contain null elements");
    if (n.isEmpty() && r.hasNonEmptyElements(i))
      throw new ze("shell is empty but holes are not");
    this._shell = n, this._holes = i;
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { serialVersionUID: { configurable: !0 } };
  return t.prototype.computeEnvelopeInternal = function() {
    return this._shell.getEnvelopeInternal();
  }, t.prototype.getSortIndex = function() {
    return r.SORTINDEX_POLYGON;
  }, t.prototype.getCoordinates = function() {
    var i = this;
    if (this.isEmpty())
      return [];
    for (var s = new Array(this.getNumPoints()).fill(null), o = -1, a = this._shell.getCoordinates(), u = 0; u < a.length; u++)
      o++, s[o] = a[u];
    for (var x = 0; x < this._holes.length; x++)
      for (var c = i._holes[x].getCoordinates(), f = 0; f < c.length; f++)
        o++, s[o] = c[f];
    return s;
  }, t.prototype.getArea = function() {
    var i = this, s = 0;
    s += Math.abs(Z.signedArea(this._shell.getCoordinateSequence()));
    for (var o = 0; o < this._holes.length; o++)
      s -= Math.abs(Z.signedArea(i._holes[o].getCoordinateSequence()));
    return s;
  }, t.prototype.isRectangle = function() {
    if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5)
      return !1;
    for (var i = this._shell.getCoordinateSequence(), s = this.getEnvelopeInternal(), o = 0; o < 5; o++) {
      var a = i.getX(o);
      if (!(a === s.getMinX() || a === s.getMaxX()))
        return !1;
      var u = i.getY(o);
      if (!(u === s.getMinY() || u === s.getMaxY()))
        return !1;
    }
    for (var x = i.getX(0), c = i.getY(0), f = 1; f <= 4; f++) {
      var l = i.getX(f), h = i.getY(f), p = l !== x, y = h !== c;
      if (p === y)
        return !1;
      x = l, c = h;
    }
    return !0;
  }, t.prototype.equalsExact = function() {
    var i = this;
    if (arguments.length === 2) {
      var s = arguments[0], o = arguments[1];
      if (!this.isEquivalentClass(s))
        return !1;
      var a = s, u = this._shell, x = a._shell;
      if (!u.equalsExact(x, o) || this._holes.length !== a._holes.length)
        return !1;
      for (var c = 0; c < this._holes.length; c++)
        if (!i._holes[c].equalsExact(a._holes[c], o))
          return !1;
      return !0;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, t.prototype.normalize = function() {
    var i = this;
    if (arguments.length === 0) {
      this.normalize(this._shell, !0);
      for (var s = 0; s < this._holes.length; s++)
        i.normalize(i._holes[s], !1);
      za.sort(this._holes);
    } else if (arguments.length === 2) {
      var o = arguments[0], a = arguments[1];
      if (o.isEmpty())
        return null;
      var u = new Array(o.getCoordinates().length - 1).fill(null);
      Hn.arraycopy(o.getCoordinates(), 0, u, 0, u.length);
      var x = Ct.minCoordinate(o.getCoordinates());
      Ct.scroll(u, x), Hn.arraycopy(u, 0, o.getCoordinates(), 0, u.length), o.getCoordinates()[u.length] = u[0], Z.isCCW(o.getCoordinates()) === a && Ct.reverse(o.getCoordinates());
    }
  }, t.prototype.getCoordinate = function() {
    return this._shell.getCoordinate();
  }, t.prototype.getNumInteriorRing = function() {
    return this._holes.length;
  }, t.prototype.getBoundaryDimension = function() {
    return 1;
  }, t.prototype.getDimension = function() {
    return 2;
  }, t.prototype.getLength = function() {
    var i = this, s = 0;
    s += this._shell.getLength();
    for (var o = 0; o < this._holes.length; o++)
      s += i._holes[o].getLength();
    return s;
  }, t.prototype.getNumPoints = function() {
    for (var i = this, s = this._shell.getNumPoints(), o = 0; o < this._holes.length; o++)
      s += i._holes[o].getNumPoints();
    return s;
  }, t.prototype.reverse = function() {
    var i = this, s = this.copy();
    s._shell = this._shell.copy().reverse(), s._holes = new Array(this._holes.length).fill(null);
    for (var o = 0; o < this._holes.length; o++)
      s._holes[o] = i._holes[o].copy().reverse();
    return s;
  }, t.prototype.convexHull = function() {
    return this.getExteriorRing().convexHull();
  }, t.prototype.compareToSameClass = function() {
    var i = this;
    if (arguments.length === 1) {
      var s = arguments[0], o = this._shell, a = s._shell;
      return o.compareToSameClass(a);
    } else if (arguments.length === 2) {
      var u = arguments[0], x = arguments[1], c = u, f = this._shell, l = c._shell, h = f.compareToSameClass(l, x);
      if (h !== 0)
        return h;
      for (var p = this.getNumInteriorRing(), y = c.getNumInteriorRing(), v = 0; v < p && v < y; ) {
        var m = i.getInteriorRingN(v), d = c.getInteriorRingN(v), g = m.compareToSameClass(d, x);
        if (g !== 0)
          return g;
        v++;
      }
      return v < p ? 1 : v < y ? -1 : 0;
    }
  }, t.prototype.apply = function(i) {
    var s = this;
    if (ct(i, Ks)) {
      this._shell.apply(i);
      for (var o = 0; o < this._holes.length; o++)
        s._holes[o].apply(i);
    } else if (ct(i, Wi)) {
      if (this._shell.apply(i), !i.isDone())
        for (var a = 0; a < this._holes.length && (s._holes[a].apply(i), !i.isDone()); a++)
          ;
      i.isGeometryChanged() && this.geometryChanged();
    } else if (ct(i, Ss))
      i.filter(this);
    else if (ct(i, Co)) {
      i.filter(this), this._shell.apply(i);
      for (var u = 0; u < this._holes.length; u++)
        s._holes[u].apply(i);
    }
  }, t.prototype.getBoundary = function() {
    var i = this;
    if (this.isEmpty())
      return this.getFactory().createMultiLineString();
    var s = new Array(this._holes.length + 1).fill(null);
    s[0] = this._shell;
    for (var o = 0; o < this._holes.length; o++)
      s[o + 1] = i._holes[o];
    return s.length <= 1 ? this.getFactory().createLinearRing(s[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(s);
  }, t.prototype.clone = function() {
    var i = this, s = r.prototype.clone.call(this);
    s._shell = this._shell.clone(), s._holes = new Array(this._holes.length).fill(null);
    for (var o = 0; o < this._holes.length; o++)
      s._holes[o] = i._holes[o].clone();
    return s;
  }, t.prototype.getGeometryType = function() {
    return "Polygon";
  }, t.prototype.copy = function() {
    for (var i = this, s = this._shell.copy(), o = new Array(this._holes.length).fill(null), a = 0; a < o.length; a++)
      o[a] = i._holes[a].copy();
    return new t(s, o, this._factory);
  }, t.prototype.getExteriorRing = function() {
    return this._shell;
  }, t.prototype.isEmpty = function() {
    return this._shell.isEmpty();
  }, t.prototype.getInteriorRingN = function(i) {
    return this._holes[i];
  }, t.prototype.interfaces_ = function() {
    return [la];
  }, t.prototype.getClass = function() {
    return t;
  }, e.serialVersionUID.get = function() {
    return -3494792200821764600;
  }, Object.defineProperties(t, e), t;
}(xt), Gx = function(r) {
  function t() {
    r.apply(this, arguments);
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { serialVersionUID: { configurable: !0 } };
  return t.prototype.getSortIndex = function() {
    return xt.SORTINDEX_MULTIPOINT;
  }, t.prototype.isValid = function() {
    return !0;
  }, t.prototype.equalsExact = function() {
    if (arguments.length === 2) {
      var i = arguments[0], s = arguments[1];
      return this.isEquivalentClass(i) ? r.prototype.equalsExact.call(this, i, s) : !1;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, t.prototype.getCoordinate = function() {
    if (arguments.length === 1) {
      var i = arguments[0];
      return this._geometries[i].getCoordinate();
    } else
      return r.prototype.getCoordinate.apply(this, arguments);
  }, t.prototype.getBoundaryDimension = function() {
    return ae.FALSE;
  }, t.prototype.getDimension = function() {
    return 0;
  }, t.prototype.getBoundary = function() {
    return this.getFactory().createGeometryCollection(null);
  }, t.prototype.getGeometryType = function() {
    return "MultiPoint";
  }, t.prototype.copy = function() {
    for (var i = this, s = new Array(this._geometries.length).fill(null), o = 0; o < s.length; o++)
      s[o] = i._geometries[o].copy();
    return new t(s, this._factory);
  }, t.prototype.interfaces_ = function() {
    return [_l];
  }, t.prototype.getClass = function() {
    return t;
  }, e.serialVersionUID.get = function() {
    return -8048474874175356e3;
  }, Object.defineProperties(t, e), t;
}(Ir), js = function(r) {
  function t(n, i) {
    n instanceof R && i instanceof St && (n = i.getCoordinateSequenceFactory().create(n)), r.call(this, n, i), this.validateConstruction();
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { MINIMUM_VALID_SIZE: { configurable: !0 }, serialVersionUID: { configurable: !0 } };
  return t.prototype.getSortIndex = function() {
    return xt.SORTINDEX_LINEARRING;
  }, t.prototype.getBoundaryDimension = function() {
    return ae.FALSE;
  }, t.prototype.isClosed = function() {
    return this.isEmpty() ? !0 : r.prototype.isClosed.call(this);
  }, t.prototype.reverse = function() {
    var i = this._points.copy();
    rn.reverse(i);
    var s = this.getFactory().createLinearRing(i);
    return s;
  }, t.prototype.validateConstruction = function() {
    if (!this.isEmpty() && !r.prototype.isClosed.call(this))
      throw new ze("Points of LinearRing do not form a closed linestring");
    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < t.MINIMUM_VALID_SIZE)
      throw new ze("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
  }, t.prototype.getGeometryType = function() {
    return "LinearRing";
  }, t.prototype.copy = function() {
    return new t(this._points.copy(), this._factory);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, e.MINIMUM_VALID_SIZE.get = function() {
    return 4;
  }, e.serialVersionUID.get = function() {
    return -4261142084085851600;
  }, Object.defineProperties(t, e), t;
}(je), Vs = function(r) {
  function t() {
    r.apply(this, arguments);
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { serialVersionUID: { configurable: !0 } };
  return t.prototype.getSortIndex = function() {
    return xt.SORTINDEX_MULTIPOLYGON;
  }, t.prototype.equalsExact = function() {
    if (arguments.length === 2) {
      var i = arguments[0], s = arguments[1];
      return this.isEquivalentClass(i) ? r.prototype.equalsExact.call(this, i, s) : !1;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, t.prototype.getBoundaryDimension = function() {
    return 1;
  }, t.prototype.getDimension = function() {
    return 2;
  }, t.prototype.reverse = function() {
    for (var i = this, s = this._geometries.length, o = new Array(s).fill(null), a = 0; a < this._geometries.length; a++)
      o[a] = i._geometries[a].reverse();
    return this.getFactory().createMultiPolygon(o);
  }, t.prototype.getBoundary = function() {
    var i = this;
    if (this.isEmpty())
      return this.getFactory().createMultiLineString();
    for (var s = new H(), o = 0; o < this._geometries.length; o++)
      for (var a = i._geometries[o], u = a.getBoundary(), x = 0; x < u.getNumGeometries(); x++)
        s.add(u.getGeometryN(x));
    var c = new Array(s.size()).fill(null);
    return this.getFactory().createMultiLineString(s.toArray(c));
  }, t.prototype.getGeometryType = function() {
    return "MultiPolygon";
  }, t.prototype.copy = function() {
    for (var i = this, s = new Array(this._geometries.length).fill(null), o = 0; o < s.length; o++)
      s[o] = i._geometries[o].copy();
    return new t(s, this._factory);
  }, t.prototype.interfaces_ = function() {
    return [la];
  }, t.prototype.getClass = function() {
    return t;
  }, e.serialVersionUID.get = function() {
    return -551033529766975900;
  }, Object.defineProperties(t, e), t;
}(Ir), Ni = function(t) {
  this._factory = t || null, this._isUserDataCopied = !1;
}, Zy = { NoOpGeometryOperation: { configurable: !0 }, CoordinateOperation: { configurable: !0 }, CoordinateSequenceOperation: { configurable: !0 } };
Ni.prototype.setCopyUserData = function(t) {
  this._isUserDataCopied = t;
};
Ni.prototype.edit = function(t, e) {
  if (t === null)
    return null;
  var n = this.editInternal(t, e);
  return this._isUserDataCopied && n.setUserData(t.getUserData()), n;
};
Ni.prototype.editInternal = function(t, e) {
  return this._factory === null && (this._factory = t.getFactory()), t instanceof Ir ? this.editGeometryCollection(t, e) : t instanceof Mn ? this.editPolygon(t, e) : t instanceof Jr ? e.edit(t, this._factory) : t instanceof je ? e.edit(t, this._factory) : (mt.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()), null);
};
Ni.prototype.editGeometryCollection = function(t, e) {
  for (var n = this, i = e.edit(t, this._factory), s = new H(), o = 0; o < i.getNumGeometries(); o++) {
    var a = n.edit(i.getGeometryN(o), e);
    a === null || a.isEmpty() || s.add(a);
  }
  return i.getClass() === Gx ? this._factory.createMultiPoint(s.toArray([])) : i.getClass() === Qa ? this._factory.createMultiLineString(s.toArray([])) : i.getClass() === Vs ? this._factory.createMultiPolygon(s.toArray([])) : this._factory.createGeometryCollection(s.toArray([]));
};
Ni.prototype.editPolygon = function(t, e) {
  var n = this, i = e.edit(t, this._factory);
  if (i === null && (i = this._factory.createPolygon(null)), i.isEmpty())
    return i;
  var s = this.edit(i.getExteriorRing(), e);
  if (s === null || s.isEmpty())
    return this._factory.createPolygon();
  for (var o = new H(), a = 0; a < i.getNumInteriorRing(); a++) {
    var u = n.edit(i.getInteriorRingN(a), e);
    u === null || u.isEmpty() || o.add(u);
  }
  return this._factory.createPolygon(s, o.toArray([]));
};
Ni.prototype.interfaces_ = function() {
  return [];
};
Ni.prototype.getClass = function() {
  return Ni;
};
Ni.GeometryEditorOperation = function() {
};
Zy.NoOpGeometryOperation.get = function() {
  return bl;
};
Zy.CoordinateOperation.get = function() {
  return Il;
};
Zy.CoordinateSequenceOperation.get = function() {
  return wl;
};
Object.defineProperties(Ni, Zy);
var bl = function() {
};
bl.prototype.edit = function(t, e) {
  return t;
};
bl.prototype.interfaces_ = function() {
  return [Ni.GeometryEditorOperation];
};
bl.prototype.getClass = function() {
  return bl;
};
var Il = function() {
};
Il.prototype.edit = function(t, e) {
  var n = this.editCoordinates(t.getCoordinates(), t);
  return n === null ? t : t instanceof js ? e.createLinearRing(n) : t instanceof je ? e.createLineString(n) : t instanceof Jr ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t;
};
Il.prototype.interfaces_ = function() {
  return [Ni.GeometryEditorOperation];
};
Il.prototype.getClass = function() {
  return Il;
};
var wl = function() {
};
wl.prototype.edit = function(t, e) {
  return t instanceof js ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof je ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Jr ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t;
};
wl.prototype.interfaces_ = function() {
  return [Ni.GeometryEditorOperation];
};
wl.prototype.getClass = function() {
  return wl;
};
var en = function() {
  var t = this;
  if (this._dimension = 3, this._coordinates = null, arguments.length === 1) {
    if (arguments[0] instanceof Array)
      this._coordinates = arguments[0], this._dimension = 3;
    else if (Number.isInteger(arguments[0])) {
      var e = arguments[0];
      this._coordinates = new Array(e).fill(null);
      for (var n = 0; n < e; n++)
        t._coordinates[n] = new R();
    } else if (ct(arguments[0], Rt)) {
      var i = arguments[0];
      if (i === null)
        return this._coordinates = new Array(0).fill(null), null;
      this._dimension = i.getDimension(), this._coordinates = new Array(i.size()).fill(null);
      for (var s = 0; s < this._coordinates.length; s++)
        t._coordinates[s] = i.getCoordinateCopy(s);
    }
  } else if (arguments.length === 2) {
    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
      var o = arguments[0], a = arguments[1];
      this._coordinates = o, this._dimension = a, o === null && (this._coordinates = new Array(0).fill(null));
    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
      var u = arguments[0], x = arguments[1];
      this._coordinates = new Array(u).fill(null), this._dimension = x;
      for (var c = 0; c < u; c++)
        t._coordinates[c] = new R();
    }
  }
}, qS = { serialVersionUID: { configurable: !0 } };
en.prototype.setOrdinate = function(t, e, n) {
  switch (e) {
    case Rt.X:
      this._coordinates[t].x = n;
      break;
    case Rt.Y:
      this._coordinates[t].y = n;
      break;
    case Rt.Z:
      this._coordinates[t].z = n;
      break;
    default:
      throw new ze("invalid ordinateIndex");
  }
};
en.prototype.size = function() {
  return this._coordinates.length;
};
en.prototype.getOrdinate = function(t, e) {
  switch (e) {
    case Rt.X:
      return this._coordinates[t].x;
    case Rt.Y:
      return this._coordinates[t].y;
    case Rt.Z:
      return this._coordinates[t].z;
  }
  return yt.NaN;
};
en.prototype.getCoordinate = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return this._coordinates[t];
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    n.x = this._coordinates[e].x, n.y = this._coordinates[e].y, n.z = this._coordinates[e].z;
  }
};
en.prototype.getCoordinateCopy = function(t) {
  return new R(this._coordinates[t]);
};
en.prototype.getDimension = function() {
  return this._dimension;
};
en.prototype.getX = function(t) {
  return this._coordinates[t].x;
};
en.prototype.clone = function() {
  for (var t = this, e = new Array(this.size()).fill(null), n = 0; n < this._coordinates.length; n++)
    e[n] = t._coordinates[n].clone();
  return new en(e, this._dimension);
};
en.prototype.expandEnvelope = function(t) {
  for (var e = this, n = 0; n < this._coordinates.length; n++)
    t.expandToInclude(e._coordinates[n]);
  return t;
};
en.prototype.copy = function() {
  for (var t = this, e = new Array(this.size()).fill(null), n = 0; n < this._coordinates.length; n++)
    e[n] = t._coordinates[n].copy();
  return new en(e, this._dimension);
};
en.prototype.toString = function() {
  var t = this;
  if (this._coordinates.length > 0) {
    var e = new As(17 * this._coordinates.length);
    e.append("("), e.append(this._coordinates[0]);
    for (var n = 1; n < this._coordinates.length; n++)
      e.append(", "), e.append(t._coordinates[n]);
    return e.append(")"), e.toString();
  } else
    return "()";
};
en.prototype.getY = function(t) {
  return this._coordinates[t].y;
};
en.prototype.toCoordinateArray = function() {
  return this._coordinates;
};
en.prototype.interfaces_ = function() {
  return [Rt, Ai];
};
en.prototype.getClass = function() {
  return en;
};
qS.serialVersionUID.get = function() {
  return -915438501601840600;
};
Object.defineProperties(en, qS);
var Qs = function() {
}, V2 = { serialVersionUID: { configurable: !0 }, instanceObject: { configurable: !0 } };
Qs.prototype.readResolve = function() {
  return Qs.instance();
};
Qs.prototype.create = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var t = arguments[0];
      return new en(t);
    } else if (ct(arguments[0], Rt)) {
      var e = arguments[0];
      return new en(e);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return i > 3 && (i = 3), i < 2 ? new en(n) : new en(n, i);
  }
};
Qs.prototype.interfaces_ = function() {
  return [Ax, Ai];
};
Qs.prototype.getClass = function() {
  return Qs;
};
Qs.instance = function() {
  return Qs.instanceObject;
};
V2.serialVersionUID.get = function() {
  return -4099577099607551500;
};
V2.instanceObject.get = function() {
  return new Qs();
};
Object.defineProperties(Qs, V2);
var zS = function(r) {
  function t() {
    r.call(this), this.map_ = /* @__PURE__ */ new Map();
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.get = function(n) {
    return this.map_.get(n) || null;
  }, t.prototype.put = function(n, i) {
    return this.map_.set(n, i), i;
  }, t.prototype.values = function() {
    for (var n = new H(), i = this.map_.values(), s = i.next(); !s.done; )
      n.add(s.value), s = i.next();
    return n;
  }, t.prototype.entrySet = function() {
    var n = new z2();
    return this.map_.entries().forEach(function(i) {
      return n.add(i);
    }), n;
  }, t.prototype.size = function() {
    return this.map_.size();
  }, t;
}(pu), xe = function r() {
  if (this._modelType = null, this._scale = null, arguments.length === 0)
    this._modelType = r.FLOATING;
  else if (arguments.length === 1) {
    if (arguments[0] instanceof Cs) {
      var t = arguments[0];
      this._modelType = t, t === r.FIXED && this.setScale(1);
    } else if (typeof arguments[0] == "number") {
      var e = arguments[0];
      this._modelType = r.FIXED, this.setScale(e);
    } else if (arguments[0] instanceof r) {
      var n = arguments[0];
      this._modelType = n._modelType, this._scale = n._scale;
    }
  }
}, W2 = { serialVersionUID: { configurable: !0 }, maximumPreciseValue: { configurable: !0 } };
xe.prototype.equals = function(t) {
  if (!(t instanceof xe))
    return !1;
  var e = t;
  return this._modelType === e._modelType && this._scale === e._scale;
};
xe.prototype.compareTo = function(t) {
  var e = t, n = this.getMaximumSignificantDigits(), i = e.getMaximumSignificantDigits();
  return new ws(n).compareTo(new ws(i));
};
xe.prototype.getScale = function() {
  return this._scale;
};
xe.prototype.isFloating = function() {
  return this._modelType === xe.FLOATING || this._modelType === xe.FLOATING_SINGLE;
};
xe.prototype.getType = function() {
  return this._modelType;
};
xe.prototype.toString = function() {
  var t = "UNKNOWN";
  return this._modelType === xe.FLOATING ? t = "Floating" : this._modelType === xe.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === xe.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t;
};
xe.prototype.makePrecise = function() {
  if (typeof arguments[0] == "number") {
    var t = arguments[0];
    if (yt.isNaN(t))
      return t;
    if (this._modelType === xe.FLOATING_SINGLE) {
      var e = t;
      return e;
    }
    return this._modelType === xe.FIXED ? Math.round(t * this._scale) / this._scale : t;
  } else if (arguments[0] instanceof R) {
    var n = arguments[0];
    if (this._modelType === xe.FLOATING)
      return null;
    n.x = this.makePrecise(n.x), n.y = this.makePrecise(n.y);
  }
};
xe.prototype.getMaximumSignificantDigits = function() {
  var t = 16;
  return this._modelType === xe.FLOATING ? t = 16 : this._modelType === xe.FLOATING_SINGLE ? t = 6 : this._modelType === xe.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t;
};
xe.prototype.setScale = function(t) {
  this._scale = Math.abs(t);
};
xe.prototype.interfaces_ = function() {
  return [Ai, Ri];
};
xe.prototype.getClass = function() {
  return xe;
};
xe.mostPrecise = function(t, e) {
  return t.compareTo(e) >= 0 ? t : e;
};
W2.serialVersionUID.get = function() {
  return 7777263578777804e3;
};
W2.maximumPreciseValue.get = function() {
  return 9007199254740992;
};
Object.defineProperties(xe, W2);
var Cs = function r(t) {
  this._name = t || null, r.nameToTypeMap.put(t, this);
}, H2 = { serialVersionUID: { configurable: !0 }, nameToTypeMap: { configurable: !0 } };
Cs.prototype.readResolve = function() {
  return Cs.nameToTypeMap.get(this._name);
};
Cs.prototype.toString = function() {
  return this._name;
};
Cs.prototype.interfaces_ = function() {
  return [Ai];
};
Cs.prototype.getClass = function() {
  return Cs;
};
H2.serialVersionUID.get = function() {
  return -552860263173159e4;
};
H2.nameToTypeMap.get = function() {
  return new zS();
};
Object.defineProperties(Cs, H2);
xe.Type = Cs;
xe.FIXED = new Cs("FIXED");
xe.FLOATING = new Cs("FLOATING");
xe.FLOATING_SINGLE = new Cs("FLOATING SINGLE");
var St = function r() {
  this._precisionModel = new xe(), this._SRID = 0, this._coordinateSequenceFactory = r.getDefaultCoordinateSequenceFactory(), arguments.length === 0 || (arguments.length === 1 ? ct(arguments[0], Ax) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof xe && (this._precisionModel = arguments[0]) : arguments.length === 2 ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : arguments.length === 3 && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
}, US = { serialVersionUID: { configurable: !0 } };
St.prototype.toGeometry = function(t) {
  return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new R(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new R(t.getMinX(), t.getMinY()), new R(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new R(t.getMinX(), t.getMinY()), new R(t.getMinX(), t.getMaxY()), new R(t.getMaxX(), t.getMaxY()), new R(t.getMaxX(), t.getMinY()), new R(t.getMinX(), t.getMinY())]), null);
};
St.prototype.createLineString = function(t) {
  if (t) {
    if (t instanceof Array)
      return new je(this.getCoordinateSequenceFactory().create(t), this);
    if (ct(t, Rt))
      return new je(t, this);
  } else return new je(this.getCoordinateSequenceFactory().create([]), this);
};
St.prototype.createMultiLineString = function() {
  if (arguments.length === 0)
    return new Qa(null, this);
  if (arguments.length === 1) {
    var t = arguments[0];
    return new Qa(t, this);
  }
};
St.prototype.buildGeometry = function(t) {
  for (var e = null, n = !1, i = !1, s = t.iterator(); s.hasNext(); ) {
    var o = s.next(), a = o.getClass();
    e === null && (e = a), a !== e && (n = !0), o.isGeometryCollectionOrDerived() && (i = !0);
  }
  if (e === null)
    return this.createGeometryCollection();
  if (n || i)
    return this.createGeometryCollection(St.toGeometryArray(t));
  var u = t.iterator().next(), x = t.size() > 1;
  if (x) {
    if (u instanceof Mn)
      return this.createMultiPolygon(St.toPolygonArray(t));
    if (u instanceof je)
      return this.createMultiLineString(St.toLineStringArray(t));
    if (u instanceof Jr)
      return this.createMultiPoint(St.toPointArray(t));
    mt.shouldNeverReachHere("Unhandled class: " + u.getClass().getName());
  }
  return u;
};
St.prototype.createMultiPointFromCoords = function(t) {
  return this.createMultiPoint(t !== null ? this.getCoordinateSequenceFactory().create(t) : null);
};
St.prototype.createPoint = function() {
  if (arguments.length === 0)
    return this.createPoint(this.getCoordinateSequenceFactory().create([]));
  if (arguments.length === 1) {
    if (arguments[0] instanceof R) {
      var t = arguments[0];
      return this.createPoint(t !== null ? this.getCoordinateSequenceFactory().create([t]) : null);
    } else if (ct(arguments[0], Rt)) {
      var e = arguments[0];
      return new Jr(e, this);
    }
  }
};
St.prototype.getCoordinateSequenceFactory = function() {
  return this._coordinateSequenceFactory;
};
St.prototype.createPolygon = function() {
  if (arguments.length === 0)
    return new Mn(null, null, this);
  if (arguments.length === 1) {
    if (ct(arguments[0], Rt)) {
      var t = arguments[0];
      return this.createPolygon(this.createLinearRing(t));
    } else if (arguments[0] instanceof Array) {
      var e = arguments[0];
      return this.createPolygon(this.createLinearRing(e));
    } else if (arguments[0] instanceof js) {
      var n = arguments[0];
      return this.createPolygon(n, null);
    }
  } else if (arguments.length === 2) {
    var i = arguments[0], s = arguments[1];
    return new Mn(i, s, this);
  }
};
St.prototype.getSRID = function() {
  return this._SRID;
};
St.prototype.createGeometryCollection = function() {
  if (arguments.length === 0)
    return new Ir(null, this);
  if (arguments.length === 1) {
    var t = arguments[0];
    return new Ir(t, this);
  }
};
St.prototype.createGeometry = function(t) {
  var e = new Ni(this);
  return e.edit(t, {
    edit: function() {
      if (arguments.length === 2) {
        var n = arguments[0];
        return this._coordinateSequenceFactory.create(n);
      }
    }
  });
};
St.prototype.getPrecisionModel = function() {
  return this._precisionModel;
};
St.prototype.createLinearRing = function() {
  if (arguments.length === 0)
    return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var t = arguments[0];
      return this.createLinearRing(t !== null ? this.getCoordinateSequenceFactory().create(t) : null);
    } else if (ct(arguments[0], Rt)) {
      var e = arguments[0];
      return new js(e, this);
    }
  }
};
St.prototype.createMultiPolygon = function() {
  if (arguments.length === 0)
    return new Vs(null, this);
  if (arguments.length === 1) {
    var t = arguments[0];
    return new Vs(t, this);
  }
};
St.prototype.createMultiPoint = function() {
  var t = this;
  if (arguments.length === 0)
    return new Gx(null, this);
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var e = arguments[0];
      return new Gx(e, this);
    } else if (arguments[0] instanceof Array) {
      var n = arguments[0];
      return this.createMultiPoint(n !== null ? this.getCoordinateSequenceFactory().create(n) : null);
    } else if (ct(arguments[0], Rt)) {
      var i = arguments[0];
      if (i === null)
        return this.createMultiPoint(new Array(0).fill(null));
      for (var s = new Array(i.size()).fill(null), o = 0; o < i.size(); o++) {
        var a = t.getCoordinateSequenceFactory().create(1, i.getDimension());
        rn.copy(i, o, a, 0, 1), s[o] = t.createPoint(a);
      }
      return this.createMultiPoint(s);
    }
  }
};
St.prototype.interfaces_ = function() {
  return [Ai];
};
St.prototype.getClass = function() {
  return St;
};
St.toMultiPolygonArray = function(t) {
  var e = new Array(t.size()).fill(null);
  return t.toArray(e);
};
St.toGeometryArray = function(t) {
  if (t === null)
    return null;
  var e = new Array(t.size()).fill(null);
  return t.toArray(e);
};
St.getDefaultCoordinateSequenceFactory = function() {
  return Qs.instance();
};
St.toMultiLineStringArray = function(t) {
  var e = new Array(t.size()).fill(null);
  return t.toArray(e);
};
St.toLineStringArray = function(t) {
  var e = new Array(t.size()).fill(null);
  return t.toArray(e);
};
St.toMultiPointArray = function(t) {
  var e = new Array(t.size()).fill(null);
  return t.toArray(e);
};
St.toLinearRingArray = function(t) {
  var e = new Array(t.size()).fill(null);
  return t.toArray(e);
};
St.toPointArray = function(t) {
  var e = new Array(t.size()).fill(null);
  return t.toArray(e);
};
St.toPolygonArray = function(t) {
  var e = new Array(t.size()).fill(null);
  return t.toArray(e);
};
St.createPointFromInternalCoord = function(t, e) {
  return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
};
US.serialVersionUID.get = function() {
  return -6820524753094096e3;
};
Object.defineProperties(St, US);
var hF = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Ky = function(t) {
  this.geometryFactory = t || new St();
};
Ky.prototype.read = function(t) {
  var e;
  typeof t == "string" ? e = JSON.parse(t) : e = t;
  var n = e.type;
  if (!xs[n])
    throw new Error("Unknown GeoJSON type: " + e.type);
  return hF.indexOf(n) !== -1 ? xs[n].apply(this, [e.coordinates]) : n === "GeometryCollection" ? xs[n].apply(this, [e.geometries]) : xs[n].apply(this, [e]);
};
Ky.prototype.write = function(t) {
  var e = t.getGeometryType();
  if (!lo[e])
    throw new Error("Geometry is not supported");
  return lo[e].apply(this, [t]);
};
var xs = {
  /**
   * Parse a GeoJSON Feature object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
   */
  Feature: function(r) {
    var t = {};
    for (var e in r)
      t[e] = r[e];
    if (r.geometry) {
      var n = r.geometry.type;
      if (!xs[n])
        throw new Error("Unknown GeoJSON type: " + r.type);
      t.geometry = this.read(r.geometry);
    }
    return r.bbox && (t.bbox = xs.bbox.apply(this, [r.bbox])), t;
  },
  /**
   * Parse a GeoJSON FeatureCollection object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
   */
  FeatureCollection: function(r) {
    var t = this, e = {};
    if (r.features) {
      e.features = [];
      for (var n = 0; n < r.features.length; ++n)
        e.features.push(t.read(r.features[n]));
    }
    return r.bbox && (e.bbox = this.parse.bbox.apply(this, [r.bbox])), e;
  },
  /**
   * Convert the ordinates in an array to an array of Coordinates
   *
   * @param {Array}
   *          array Array with {Number}s.
   *
   * @return {Array} Array with Coordinates.
   */
  coordinates: function(r) {
    for (var t = [], e = 0; e < r.length; ++e) {
      var n = r[e];
      t.push(new R(n[0], n[1]));
    }
    return t;
  },
  /**
   * Convert the bbox to a LinearRing
   *
   * @param {Array}
   *          array Array with [xMin, yMin, xMax, yMax].
   *
   * @return {Array} Array with Coordinates.
   */
  bbox: function(r) {
    return this.geometryFactory.createLinearRing([
      new R(r[0], r[1]),
      new R(r[2], r[1]),
      new R(r[2], r[3]),
      new R(r[0], r[3]),
      new R(r[0], r[1])
    ]);
  },
  /**
   * Convert an Array with ordinates to a Point
   *
   * @param {Array}
   *          array Array with ordinates.
   *
   * @return {Point} Point.
   */
  Point: function(r) {
    var t = new R(r[0], r[1]);
    return this.geometryFactory.createPoint(t);
  },
  /**
   * Convert an Array with coordinates to a MultiPoint
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiPoint} MultiPoint.
   */
  MultiPoint: function(r) {
    for (var t = this, e = [], n = 0; n < r.length; ++n)
      e.push(xs.Point.apply(t, [r[n]]));
    return this.geometryFactory.createMultiPoint(e);
  },
  /**
   * Convert an Array with coordinates to a LineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {LineString} LineString.
   */
  LineString: function(r) {
    var t = xs.coordinates.apply(this, [r]);
    return this.geometryFactory.createLineString(t);
  },
  /**
   * Convert an Array with coordinates to a MultiLineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiLineString} MultiLineString.
   */
  MultiLineString: function(r) {
    for (var t = this, e = [], n = 0; n < r.length; ++n)
      e.push(xs.LineString.apply(t, [r[n]]));
    return this.geometryFactory.createMultiLineString(e);
  },
  /**
   * Convert an Array to a Polygon
   *
   * @param {Array}
   *          array Array with shell and holes.
   *
   * @return {Polygon} Polygon.
   */
  Polygon: function(r) {
    for (var t = this, e = xs.coordinates.apply(this, [r[0]]), n = this.geometryFactory.createLinearRing(e), i = [], s = 1; s < r.length; ++s) {
      var o = r[s], a = xs.coordinates.apply(t, [o]), u = t.geometryFactory.createLinearRing(a);
      i.push(u);
    }
    return this.geometryFactory.createPolygon(n, i);
  },
  /**
   * Convert an Array to a MultiPolygon
   *
   * @param {Array}
   *          array Array of arrays with shell and rings.
   *
   * @return {MultiPolygon} MultiPolygon.
   */
  MultiPolygon: function(r) {
    for (var t = this, e = [], n = 0; n < r.length; ++n) {
      var i = r[n];
      e.push(xs.Polygon.apply(t, [i]));
    }
    return this.geometryFactory.createMultiPolygon(e);
  },
  /**
   * Convert an Array to a GeometryCollection
   *
   * @param {Array}
   *          array Array of GeoJSON geometries.
   *
   * @return {GeometryCollection} GeometryCollection.
   */
  GeometryCollection: function(r) {
    for (var t = this, e = [], n = 0; n < r.length; ++n) {
      var i = r[n];
      e.push(t.read(i));
    }
    return this.geometryFactory.createGeometryCollection(e);
  }
}, lo = {
  /**
   * Convert a Coordinate to an Array
   *
   * @param {Coordinate}
   *          coordinate Coordinate to convert.
   *
   * @return {Array} Array of ordinates.
   */
  coordinate: function(r) {
    return [r.x, r.y];
  },
  /**
   * Convert a Point to a GeoJSON object
   *
   * @param {Point}
   *          point Point to convert.
   *
   * @return {Array} Array of 2 ordinates (paired to a coordinate).
   */
  Point: function(r) {
    var t = lo.coordinate.apply(this, [r.getCoordinate()]);
    return {
      type: "Point",
      coordinates: t
    };
  },
  /**
   * Convert a MultiPoint to a GeoJSON object
   *
   * @param {MultiPoint}
   *          multipoint MultiPoint to convert.
   *
   * @return {Array} Array of coordinates.
   */
  MultiPoint: function(r) {
    for (var t = this, e = [], n = 0; n < r._geometries.length; ++n) {
      var i = r._geometries[n], s = lo.Point.apply(t, [i]);
      e.push(s.coordinates);
    }
    return {
      type: "MultiPoint",
      coordinates: e
    };
  },
  /**
   * Convert a LineString to a GeoJSON object
   *
   * @param {LineString}
   *          linestring LineString to convert.
   *
   * @return {Array} Array of coordinates.
   */
  LineString: function(r) {
    for (var t = this, e = [], n = r.getCoordinates(), i = 0; i < n.length; ++i) {
      var s = n[i];
      e.push(lo.coordinate.apply(t, [s]));
    }
    return {
      type: "LineString",
      coordinates: e
    };
  },
  /**
   * Convert a MultiLineString to a GeoJSON object
   *
   * @param {MultiLineString}
   *          multilinestring MultiLineString to convert.
   *
   * @return {Array} Array of Array of coordinates.
   */
  MultiLineString: function(r) {
    for (var t = this, e = [], n = 0; n < r._geometries.length; ++n) {
      var i = r._geometries[n], s = lo.LineString.apply(t, [i]);
      e.push(s.coordinates);
    }
    return {
      type: "MultiLineString",
      coordinates: e
    };
  },
  /**
   * Convert a Polygon to a GeoJSON object
   *
   * @param {Polygon}
   *          polygon Polygon to convert.
   *
   * @return {Array} Array with shell, holes.
   */
  Polygon: function(r) {
    var t = this, e = [], n = lo.LineString.apply(this, [r._shell]);
    e.push(n.coordinates);
    for (var i = 0; i < r._holes.length; ++i) {
      var s = r._holes[i], o = lo.LineString.apply(t, [s]);
      e.push(o.coordinates);
    }
    return {
      type: "Polygon",
      coordinates: e
    };
  },
  /**
   * Convert a MultiPolygon to a GeoJSON object
   *
   * @param {MultiPolygon}
   *          multipolygon MultiPolygon to convert.
   *
   * @return {Array} Array of polygons.
   */
  MultiPolygon: function(r) {
    for (var t = this, e = [], n = 0; n < r._geometries.length; ++n) {
      var i = r._geometries[n], s = lo.Polygon.apply(t, [i]);
      e.push(s.coordinates);
    }
    return {
      type: "MultiPolygon",
      coordinates: e
    };
  },
  /**
   * Convert a GeometryCollection to a GeoJSON object
   *
   * @param {GeometryCollection}
   *          collection GeometryCollection to convert.
   *
   * @return {Array} Array of geometries.
   */
  GeometryCollection: function(r) {
    for (var t = this, e = [], n = 0; n < r._geometries.length; ++n) {
      var i = r._geometries[n], s = i.getGeometryType();
      e.push(lo[s].apply(t, [i]));
    }
    return {
      type: "GeometryCollection",
      geometries: e
    };
  }
}, J2 = function(t) {
  this.geometryFactory = t || new St(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ky(this.geometryFactory);
};
J2.prototype.read = function(t) {
  var e = this.parser.read(t);
  return this.precisionModel.getType() === xe.FIXED && this.reducePrecision(e), e;
};
J2.prototype.reducePrecision = function(t) {
  var e = this, n, i;
  if (t.coordinate)
    this.precisionModel.makePrecise(t.coordinate);
  else if (t.points)
    for (n = 0, i = t.points.length; n < i; n++)
      e.precisionModel.makePrecise(t.points[n]);
  else if (t.geometries)
    for (n = 0, i = t.geometries.length; n < i; n++)
      e.reducePrecision(t.geometries[n]);
};
var VS = function() {
  this.parser = new Ky(this.geometryFactory);
};
VS.prototype.write = function(t) {
  return this.parser.write(t);
};
var z = function() {
}, jy = { ON: { configurable: !0 }, LEFT: { configurable: !0 }, RIGHT: { configurable: !0 } };
z.prototype.interfaces_ = function() {
  return [];
};
z.prototype.getClass = function() {
  return z;
};
z.opposite = function(t) {
  return t === z.LEFT ? z.RIGHT : t === z.RIGHT ? z.LEFT : t;
};
jy.ON.get = function() {
  return 0;
};
jy.LEFT.get = function() {
  return 1;
};
jy.RIGHT.get = function() {
  return 2;
};
Object.defineProperties(z, jy);
function Qy(r) {
  this.message = r || "";
}
Qy.prototype = new Error();
Qy.prototype.name = "EmptyStackException";
function Ts() {
  this.array_ = [];
}
Ts.prototype = new zi();
Ts.prototype.add = function(r) {
  return this.array_.push(r), !0;
};
Ts.prototype.get = function(r) {
  if (r < 0 || r >= this.size())
    throw new Error();
  return this.array_[r];
};
Ts.prototype.push = function(r) {
  return this.array_.push(r), r;
};
Ts.prototype.pop = function(r) {
  if (this.array_.length === 0)
    throw new Qy();
  return this.array_.pop();
};
Ts.prototype.peek = function() {
  if (this.array_.length === 0)
    throw new Qy();
  return this.array_[this.array_.length - 1];
};
Ts.prototype.empty = function() {
  return this.array_.length === 0;
};
Ts.prototype.isEmpty = function() {
  return this.empty();
};
Ts.prototype.search = function(r) {
  return this.array_.indexOf(r);
};
Ts.prototype.size = function() {
  return this.array_.length;
};
Ts.prototype.toArray = function() {
  for (var r = this, t = [], e = 0, n = this.array_.length; e < n; e++)
    t.push(r.array_[e]);
  return t;
};
var Ms = function() {
  this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
};
Ms.prototype.getCoordinate = function() {
  return this._minCoord;
};
Ms.prototype.getRightmostSide = function(t, e) {
  var n = this.getRightmostSideOfSegment(t, e);
  return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n;
};
Ms.prototype.findRightmostEdgeAtVertex = function() {
  var t = this._minDe.getEdge().getCoordinates();
  mt.isTrue(this._minIndex > 0 && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge");
  var e = t[this._minIndex - 1], n = t[this._minIndex + 1], i = Z.computeOrientation(this._minCoord, n, e), s = !1;
  (e.y < this._minCoord.y && n.y < this._minCoord.y && i === Z.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && i === Z.CLOCKWISE) && (s = !0), s && (this._minIndex = this._minIndex - 1);
};
Ms.prototype.getRightmostSideOfSegment = function(t, e) {
  var n = t.getEdge(), i = n.getCoordinates();
  if (e < 0 || e + 1 >= i.length || i[e].y === i[e + 1].y)
    return -1;
  var s = z.LEFT;
  return i[e].y < i[e + 1].y && (s = z.RIGHT), s;
};
Ms.prototype.getEdge = function() {
  return this._orientedDe;
};
Ms.prototype.checkForRightmostCoordinate = function(t) {
  for (var e = this, n = t.getEdge().getCoordinates(), i = 0; i < n.length - 1; i++)
    (e._minCoord === null || n[i].x > e._minCoord.x) && (e._minDe = t, e._minIndex = i, e._minCoord = n[i]);
};
Ms.prototype.findRightmostEdgeAtNode = function() {
  var t = this._minDe.getNode(), e = t.getEdges();
  this._minDe = e.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
};
Ms.prototype.findEdge = function(t) {
  for (var e = this, n = t.iterator(); n.hasNext(); ) {
    var i = n.next();
    i.isForward() && e.checkForRightmostCoordinate(i);
  }
  mt.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
  var s = this.getRightmostSide(this._minDe, this._minIndex);
  s === z.LEFT && (this._orientedDe = this._minDe.getSym());
};
Ms.prototype.interfaces_ = function() {
  return [];
};
Ms.prototype.getClass = function() {
  return Ms;
};
var Mo = function(r) {
  function t(e, n) {
    r.call(this, t.msgWithCoord(e, n)), this.pt = n ? new R(n) : null, this.name = "TopologyException";
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.getCoordinate = function() {
    return this.pt;
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t.msgWithCoord = function(n, i) {
    return i ? n : n + " [ " + i + " ]";
  }, t;
}(So), $y = function() {
  this.array_ = [];
};
$y.prototype.addLast = function(t) {
  this.array_.push(t);
};
$y.prototype.removeFirst = function() {
  return this.array_.shift();
};
$y.prototype.isEmpty = function() {
  return this.array_.length === 0;
};
var wr = function() {
  this._finder = null, this._dirEdgeList = new H(), this._nodes = new H(), this._rightMostCoord = null, this._env = null, this._finder = new Ms();
};
wr.prototype.clearVisitedEdges = function() {
  for (var t = this._dirEdgeList.iterator(); t.hasNext(); ) {
    var e = t.next();
    e.setVisited(!1);
  }
};
wr.prototype.getRightmostCoordinate = function() {
  return this._rightMostCoord;
};
wr.prototype.computeNodeDepth = function(t) {
  for (var e = this, n = null, i = t.getEdges().iterator(); i.hasNext(); ) {
    var s = i.next();
    if (s.isVisited() || s.getSym().isVisited()) {
      n = s;
      break;
    }
  }
  if (n === null)
    throw new Mo("unable to find edge to compute depths at " + t.getCoordinate());
  t.getEdges().computeDepths(n);
  for (var o = t.getEdges().iterator(); o.hasNext(); ) {
    var a = o.next();
    a.setVisited(!0), e.copySymDepths(a);
  }
};
wr.prototype.computeDepth = function(t) {
  this.clearVisitedEdges();
  var e = this._finder.getEdge();
  e.setEdgeDepths(z.RIGHT, t), this.copySymDepths(e), this.computeDepths(e);
};
wr.prototype.create = function(t) {
  this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
};
wr.prototype.findResultEdges = function() {
  for (var t = this._dirEdgeList.iterator(); t.hasNext(); ) {
    var e = t.next();
    e.getDepth(z.RIGHT) >= 1 && e.getDepth(z.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0);
  }
};
wr.prototype.computeDepths = function(t) {
  var e = this, n = new z2(), i = new $y(), s = t.getNode();
  for (i.addLast(s), n.add(s), t.setVisited(!0); !i.isEmpty(); ) {
    var o = i.removeFirst();
    n.add(o), e.computeNodeDepth(o);
    for (var a = o.getEdges().iterator(); a.hasNext(); ) {
      var u = a.next(), x = u.getSym();
      if (!x.isVisited()) {
        var c = x.getNode();
        n.contains(c) || (i.addLast(c), n.add(c));
      }
    }
  }
};
wr.prototype.compareTo = function(t) {
  var e = t;
  return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0;
};
wr.prototype.getEnvelope = function() {
  if (this._env === null) {
    for (var t = new nt(), e = this._dirEdgeList.iterator(); e.hasNext(); )
      for (var n = e.next(), i = n.getEdge().getCoordinates(), s = 0; s < i.length - 1; s++)
        t.expandToInclude(i[s]);
    this._env = t;
  }
  return this._env;
};
wr.prototype.addReachable = function(t) {
  var e = this, n = new Ts();
  for (n.add(t); !n.empty(); ) {
    var i = n.pop();
    e.add(i, n);
  }
};
wr.prototype.copySymDepths = function(t) {
  var e = t.getSym();
  e.setDepth(z.LEFT, t.getDepth(z.RIGHT)), e.setDepth(z.RIGHT, t.getDepth(z.LEFT));
};
wr.prototype.add = function(t, e) {
  var n = this;
  t.setVisited(!0), this._nodes.add(t);
  for (var i = t.getEdges().iterator(); i.hasNext(); ) {
    var s = i.next();
    n._dirEdgeList.add(s);
    var o = s.getSym(), a = o.getNode();
    a.isVisited() || e.push(a);
  }
};
wr.prototype.getNodes = function() {
  return this._nodes;
};
wr.prototype.getDirectedEdges = function() {
  return this._dirEdgeList;
};
wr.prototype.interfaces_ = function() {
  return [Ri];
};
wr.prototype.getClass = function() {
  return wr;
};
var Re = function r() {
  var t = this;
  if (this.location = null, arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var e = arguments[0];
      this.init(e.length);
    } else if (Number.isInteger(arguments[0])) {
      var n = arguments[0];
      this.init(1), this.location[z.ON] = n;
    } else if (arguments[0] instanceof r) {
      var i = arguments[0];
      if (this.init(i.location.length), i !== null)
        for (var s = 0; s < this.location.length; s++)
          t.location[s] = i.location[s];
    }
  } else if (arguments.length === 3) {
    var o = arguments[0], a = arguments[1], u = arguments[2];
    this.init(3), this.location[z.ON] = o, this.location[z.LEFT] = a, this.location[z.RIGHT] = u;
  }
};
Re.prototype.setAllLocations = function(t) {
  for (var e = this, n = 0; n < this.location.length; n++)
    e.location[n] = t;
};
Re.prototype.isNull = function() {
  for (var t = this, e = 0; e < this.location.length; e++)
    if (t.location[e] !== A.NONE)
      return !1;
  return !0;
};
Re.prototype.setAllLocationsIfNull = function(t) {
  for (var e = this, n = 0; n < this.location.length; n++)
    e.location[n] === A.NONE && (e.location[n] = t);
};
Re.prototype.isLine = function() {
  return this.location.length === 1;
};
Re.prototype.merge = function(t) {
  var e = this;
  if (t.location.length > this.location.length) {
    var n = new Array(3).fill(null);
    n[z.ON] = this.location[z.ON], n[z.LEFT] = A.NONE, n[z.RIGHT] = A.NONE, this.location = n;
  }
  for (var i = 0; i < this.location.length; i++)
    e.location[i] === A.NONE && i < t.location.length && (e.location[i] = t.location[i]);
};
Re.prototype.getLocations = function() {
  return this.location;
};
Re.prototype.flip = function() {
  if (this.location.length <= 1)
    return null;
  var t = this.location[z.LEFT];
  this.location[z.LEFT] = this.location[z.RIGHT], this.location[z.RIGHT] = t;
};
Re.prototype.toString = function() {
  var t = new As();
  return this.location.length > 1 && t.append(A.toLocationSymbol(this.location[z.LEFT])), t.append(A.toLocationSymbol(this.location[z.ON])), this.location.length > 1 && t.append(A.toLocationSymbol(this.location[z.RIGHT])), t.toString();
};
Re.prototype.setLocations = function(t, e, n) {
  this.location[z.ON] = t, this.location[z.LEFT] = e, this.location[z.RIGHT] = n;
};
Re.prototype.get = function(t) {
  return t < this.location.length ? this.location[t] : A.NONE;
};
Re.prototype.isArea = function() {
  return this.location.length > 1;
};
Re.prototype.isAnyNull = function() {
  for (var t = this, e = 0; e < this.location.length; e++)
    if (t.location[e] === A.NONE)
      return !0;
  return !1;
};
Re.prototype.setLocation = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.setLocation(z.ON, t);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    this.location[e] = n;
  }
};
Re.prototype.init = function(t) {
  this.location = new Array(t).fill(null), this.setAllLocations(A.NONE);
};
Re.prototype.isEqualOnSide = function(t, e) {
  return this.location[e] === t.location[e];
};
Re.prototype.allPositionsEqual = function(t) {
  for (var e = this, n = 0; n < this.location.length; n++)
    if (e.location[n] !== t)
      return !1;
  return !0;
};
Re.prototype.interfaces_ = function() {
  return [];
};
Re.prototype.getClass = function() {
  return Re;
};
var ye = function r() {
  if (this.elt = new Array(2).fill(null), arguments.length === 1) {
    if (Number.isInteger(arguments[0])) {
      var t = arguments[0];
      this.elt[0] = new Re(t), this.elt[1] = new Re(t);
    } else if (arguments[0] instanceof r) {
      var e = arguments[0];
      this.elt[0] = new Re(e.elt[0]), this.elt[1] = new Re(e.elt[1]);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this.elt[0] = new Re(A.NONE), this.elt[1] = new Re(A.NONE), this.elt[n].setLocation(i);
  } else if (arguments.length === 3) {
    var s = arguments[0], o = arguments[1], a = arguments[2];
    this.elt[0] = new Re(s, o, a), this.elt[1] = new Re(s, o, a);
  } else if (arguments.length === 4) {
    var u = arguments[0], x = arguments[1], c = arguments[2], f = arguments[3];
    this.elt[0] = new Re(A.NONE, A.NONE, A.NONE), this.elt[1] = new Re(A.NONE, A.NONE, A.NONE), this.elt[u].setLocations(x, c, f);
  }
};
ye.prototype.getGeometryCount = function() {
  var t = 0;
  return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;
};
ye.prototype.setAllLocations = function(t, e) {
  this.elt[t].setAllLocations(e);
};
ye.prototype.isNull = function(t) {
  return this.elt[t].isNull();
};
ye.prototype.setAllLocationsIfNull = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    this.elt[e].setAllLocationsIfNull(n);
  }
};
ye.prototype.isLine = function(t) {
  return this.elt[t].isLine();
};
ye.prototype.merge = function(t) {
  for (var e = this, n = 0; n < 2; n++)
    e.elt[n] === null && t.elt[n] !== null ? e.elt[n] = new Re(t.elt[n]) : e.elt[n].merge(t.elt[n]);
};
ye.prototype.flip = function() {
  this.elt[0].flip(), this.elt[1].flip();
};
ye.prototype.getLocation = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return this.elt[t].get(z.ON);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    return this.elt[e].get(n);
  }
};
ye.prototype.toString = function() {
  var t = new As();
  return this.elt[0] !== null && (t.append("A:"), t.append(this.elt[0].toString())), this.elt[1] !== null && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString();
};
ye.prototype.isArea = function() {
  if (arguments.length === 0)
    return this.elt[0].isArea() || this.elt[1].isArea();
  if (arguments.length === 1) {
    var t = arguments[0];
    return this.elt[t].isArea();
  }
};
ye.prototype.isAnyNull = function(t) {
  return this.elt[t].isAnyNull();
};
ye.prototype.setLocation = function() {
  if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    this.elt[t].setLocation(z.ON, e);
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], s = arguments[2];
    this.elt[n].setLocation(i, s);
  }
};
ye.prototype.isEqualOnSide = function(t, e) {
  return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);
};
ye.prototype.allPositionsEqual = function(t, e) {
  return this.elt[t].allPositionsEqual(e);
};
ye.prototype.toLine = function(t) {
  this.elt[t].isArea() && (this.elt[t] = new Re(this.elt[t].location[0]));
};
ye.prototype.interfaces_ = function() {
  return [];
};
ye.prototype.getClass = function() {
  return ye;
};
ye.toLineLabel = function(t) {
  for (var e = new ye(A.NONE), n = 0; n < 2; n++)
    e.setLocation(n, t.getLocation(n));
  return e;
};
var pn = function() {
  this._startDe = null, this._maxNodeDegree = -1, this._edges = new H(), this._pts = new H(), this._label = new ye(A.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new H(), this._geometryFactory = null;
  var t = arguments[0], e = arguments[1];
  this._geometryFactory = e, this.computePoints(t), this.computeRing();
};
pn.prototype.computeRing = function() {
  var t = this;
  if (this._ring !== null)
    return null;
  for (var e = new Array(this._pts.size()).fill(null), n = 0; n < this._pts.size(); n++)
    e[n] = t._pts.get(n);
  this._ring = this._geometryFactory.createLinearRing(e), this._isHole = Z.isCCW(this._ring.getCoordinates());
};
pn.prototype.isIsolated = function() {
  return this._label.getGeometryCount() === 1;
};
pn.prototype.computePoints = function(t) {
  var e = this;
  this._startDe = t;
  var n = t, i = !0;
  do {
    if (n === null)
      throw new Mo("Found null DirectedEdge");
    if (n.getEdgeRing() === e)
      throw new Mo("Directed Edge visited twice during ring-building at " + n.getCoordinate());
    e._edges.add(n);
    var s = n.getLabel();
    mt.isTrue(s.isArea()), e.mergeLabel(s), e.addPoints(n.getEdge(), n.isForward(), i), i = !1, e.setEdgeRing(n, e), n = e.getNext(n);
  } while (n !== this._startDe);
};
pn.prototype.getLinearRing = function() {
  return this._ring;
};
pn.prototype.getCoordinate = function(t) {
  return this._pts.get(t);
};
pn.prototype.computeMaxNodeDegree = function() {
  var t = this;
  this._maxNodeDegree = 0;
  var e = this._startDe;
  do {
    var n = e.getNode(), i = n.getEdges().getOutgoingDegree(t);
    i > t._maxNodeDegree && (t._maxNodeDegree = i), e = t.getNext(e);
  } while (e !== this._startDe);
  this._maxNodeDegree *= 2;
};
pn.prototype.addPoints = function(t, e, n) {
  var i = this, s = t.getCoordinates();
  if (e) {
    var o = 1;
    n && (o = 0);
    for (var a = o; a < s.length; a++)
      i._pts.add(s[a]);
  } else {
    var u = s.length - 2;
    n && (u = s.length - 1);
    for (var x = u; x >= 0; x--)
      i._pts.add(s[x]);
  }
};
pn.prototype.isHole = function() {
  return this._isHole;
};
pn.prototype.setInResult = function() {
  var t = this._startDe;
  do
    t.getEdge().setInResult(!0), t = t.getNext();
  while (t !== this._startDe);
};
pn.prototype.containsPoint = function(t) {
  var e = this.getLinearRing(), n = e.getEnvelopeInternal();
  if (!n.contains(t) || !Z.isPointInRing(t, e.getCoordinates()))
    return !1;
  for (var i = this._holes.iterator(); i.hasNext(); ) {
    var s = i.next();
    if (s.containsPoint(t))
      return !1;
  }
  return !0;
};
pn.prototype.addHole = function(t) {
  this._holes.add(t);
};
pn.prototype.isShell = function() {
  return this._shell === null;
};
pn.prototype.getLabel = function() {
  return this._label;
};
pn.prototype.getEdges = function() {
  return this._edges;
};
pn.prototype.getMaxNodeDegree = function() {
  return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
};
pn.prototype.getShell = function() {
  return this._shell;
};
pn.prototype.mergeLabel = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.mergeLabel(t, 0), this.mergeLabel(t, 1);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1], i = e.getLocation(n, z.RIGHT);
    if (i === A.NONE)
      return null;
    if (this._label.getLocation(n) === A.NONE)
      return this._label.setLocation(n, i), null;
  }
};
pn.prototype.setShell = function(t) {
  this._shell = t, t !== null && t.addHole(this);
};
pn.prototype.toPolygon = function(t) {
  for (var e = this, n = new Array(this._holes.size()).fill(null), i = 0; i < this._holes.size(); i++)
    n[i] = e._holes.get(i).getLinearRing();
  var s = t.createPolygon(this.getLinearRing(), n);
  return s;
};
pn.prototype.interfaces_ = function() {
  return [];
};
pn.prototype.getClass = function() {
  return pn;
};
var pF = function(r) {
  function t() {
    var e = arguments[0], n = arguments[1];
    r.call(this, e, n);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.setEdgeRing = function(n, i) {
    n.setMinEdgeRing(i);
  }, t.prototype.getNext = function(n) {
    return n.getNextMin();
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(pn), dF = function(r) {
  function t() {
    var e = arguments[0], n = arguments[1];
    r.call(this, e, n);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.buildMinimalRings = function() {
    var n = this, i = new H(), s = this._startDe;
    do {
      if (s.getMinEdgeRing() === null) {
        var o = new pF(s, n._geometryFactory);
        i.add(o);
      }
      s = s.getNext();
    } while (s !== this._startDe);
    return i;
  }, t.prototype.setEdgeRing = function(n, i) {
    n.setEdgeRing(i);
  }, t.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
    var n = this, i = this._startDe;
    do {
      var s = i.getNode();
      s.getEdges().linkMinimalDirectedEdges(n), i = i.getNext();
    } while (i !== this._startDe);
  }, t.prototype.getNext = function(n) {
    return n.getNext();
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(pn), ui = function() {
  if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, arguments.length !== 0) {
    if (arguments.length === 1) {
      var t = arguments[0];
      this._label = t;
    }
  }
};
ui.prototype.setVisited = function(t) {
  this._isVisited = t;
};
ui.prototype.setInResult = function(t) {
  this._isInResult = t;
};
ui.prototype.isCovered = function() {
  return this._isCovered;
};
ui.prototype.isCoveredSet = function() {
  return this._isCoveredSet;
};
ui.prototype.setLabel = function(t) {
  this._label = t;
};
ui.prototype.getLabel = function() {
  return this._label;
};
ui.prototype.setCovered = function(t) {
  this._isCovered = t, this._isCoveredSet = !0;
};
ui.prototype.updateIM = function(t) {
  mt.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t);
};
ui.prototype.isInResult = function() {
  return this._isInResult;
};
ui.prototype.isVisited = function() {
  return this._isVisited;
};
ui.prototype.interfaces_ = function() {
  return [];
};
ui.prototype.getClass = function() {
  return ui;
};
var tv = function(r) {
  function t() {
    r.call(this), this._coord = null, this._edges = null;
    var e = arguments[0], n = arguments[1];
    this._coord = e, this._edges = n, this._label = new ye(0, A.NONE);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.isIncidentEdgeInResult = function() {
    for (var n = this.getEdges().getEdges().iterator(); n.hasNext(); ) {
      var i = n.next();
      if (i.getEdge().isInResult())
        return !0;
    }
    return !1;
  }, t.prototype.isIsolated = function() {
    return this._label.getGeometryCount() === 1;
  }, t.prototype.getCoordinate = function() {
    return this._coord;
  }, t.prototype.print = function(n) {
    n.println("node " + this._coord + " lbl: " + this._label);
  }, t.prototype.computeIM = function(n) {
  }, t.prototype.computeMergedLocation = function(n, i) {
    var s = A.NONE;
    if (s = this._label.getLocation(i), !n.isNull(i)) {
      var o = n.getLocation(i);
      s !== A.BOUNDARY && (s = o);
    }
    return s;
  }, t.prototype.setLabel = function() {
    if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1];
      this._label === null ? this._label = new ye(n, i) : this._label.setLocation(n, i);
    } else
      return r.prototype.setLabel.apply(this, arguments);
  }, t.prototype.getEdges = function() {
    return this._edges;
  }, t.prototype.mergeLabel = function() {
    var n = this;
    if (arguments[0] instanceof t) {
      var i = arguments[0];
      this.mergeLabel(i._label);
    } else if (arguments[0] instanceof ye)
      for (var s = arguments[0], o = 0; o < 2; o++) {
        var a = n.computeMergedLocation(s, o), u = n._label.getLocation(o);
        u === A.NONE && n._label.setLocation(o, a);
      }
  }, t.prototype.add = function(n) {
    this._edges.insert(n), n.setNode(this);
  }, t.prototype.setLabelBoundary = function(n) {
    if (this._label === null)
      return null;
    var i = A.NONE;
    this._label !== null && (i = this._label.getLocation(n));
    var s = null;
    switch (i) {
      case A.BOUNDARY:
        s = A.INTERIOR;
        break;
      case A.INTERIOR:
        s = A.BOUNDARY;
        break;
      default:
        s = A.BOUNDARY;
        break;
    }
    this._label.setLocation(n, s);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(ui), Ps = function() {
  this.nodeMap = new or(), this.nodeFact = null;
  var t = arguments[0];
  this.nodeFact = t;
};
Ps.prototype.find = function(t) {
  return this.nodeMap.get(t);
};
Ps.prototype.addNode = function() {
  if (arguments[0] instanceof R) {
    var t = arguments[0], e = this.nodeMap.get(t);
    return e === null && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e;
  } else if (arguments[0] instanceof tv) {
    var n = arguments[0], i = this.nodeMap.get(n.getCoordinate());
    return i === null ? (this.nodeMap.put(n.getCoordinate(), n), n) : (i.mergeLabel(n), i);
  }
};
Ps.prototype.print = function(t) {
  for (var e = this.iterator(); e.hasNext(); ) {
    var n = e.next();
    n.print(t);
  }
};
Ps.prototype.iterator = function() {
  return this.nodeMap.values().iterator();
};
Ps.prototype.values = function() {
  return this.nodeMap.values();
};
Ps.prototype.getBoundaryNodes = function(t) {
  for (var e = new H(), n = this.iterator(); n.hasNext(); ) {
    var i = n.next();
    i.getLabel().getLocation(t) === A.BOUNDARY && e.add(i);
  }
  return e;
};
Ps.prototype.add = function(t) {
  var e = t.getCoordinate(), n = this.addNode(e);
  n.add(t);
};
Ps.prototype.interfaces_ = function() {
  return [];
};
Ps.prototype.getClass = function() {
  return Ps;
};
var be = function() {
}, $l = { NE: { configurable: !0 }, NW: { configurable: !0 }, SW: { configurable: !0 }, SE: { configurable: !0 } };
be.prototype.interfaces_ = function() {
  return [];
};
be.prototype.getClass = function() {
  return be;
};
be.isNorthern = function(t) {
  return t === be.NE || t === be.NW;
};
be.isOpposite = function(t, e) {
  if (t === e)
    return !1;
  var n = (t - e + 4) % 4;
  return n === 2;
};
be.commonHalfPlane = function(t, e) {
  if (t === e)
    return t;
  var n = (t - e + 4) % 4;
  if (n === 2)
    return -1;
  var i = t < e ? t : e, s = t > e ? t : e;
  return i === 0 && s === 3 ? 3 : i;
};
be.isInHalfPlane = function(t, e) {
  return e === be.SE ? t === be.SE || t === be.SW : t === e || t === e + 1;
};
be.quadrant = function() {
  if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
    var t = arguments[0], e = arguments[1];
    if (t === 0 && e === 0)
      throw new ze("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
    return t >= 0 ? e >= 0 ? be.NE : be.SE : e >= 0 ? be.NW : be.SW;
  } else if (arguments[0] instanceof R && arguments[1] instanceof R) {
    var n = arguments[0], i = arguments[1];
    if (i.x === n.x && i.y === n.y)
      throw new ze("Cannot compute the quadrant for two identical points " + n);
    return i.x >= n.x ? i.y >= n.y ? be.NE : be.SE : i.y >= n.y ? be.NW : be.SW;
  }
};
$l.NE.get = function() {
  return 0;
};
$l.NW.get = function() {
  return 1;
};
$l.SW.get = function() {
  return 2;
};
$l.SE.get = function() {
  return 3;
};
Object.defineProperties(be, $l);
var ar = function() {
  if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
    var t = arguments[0];
    this._edge = t;
  } else if (arguments.length === 3) {
    var e = arguments[0], n = arguments[1], i = arguments[2], s = null;
    this._edge = e, this.init(n, i), this._label = s;
  } else if (arguments.length === 4) {
    var o = arguments[0], a = arguments[1], u = arguments[2], x = arguments[3];
    this._edge = o, this.init(a, u), this._label = x;
  }
};
ar.prototype.compareDirection = function(t) {
  return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : Z.computeOrientation(t._p0, t._p1, this._p1);
};
ar.prototype.getDy = function() {
  return this._dy;
};
ar.prototype.getCoordinate = function() {
  return this._p0;
};
ar.prototype.setNode = function(t) {
  this._node = t;
};
ar.prototype.print = function(t) {
  var e = Math.atan2(this._dy, this._dx), n = this.getClass().getName(), i = n.lastIndexOf("."), s = n.substring(i + 1);
  t.print("  " + s + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label);
};
ar.prototype.compareTo = function(t) {
  var e = t;
  return this.compareDirection(e);
};
ar.prototype.getDirectedCoordinate = function() {
  return this._p1;
};
ar.prototype.getDx = function() {
  return this._dx;
};
ar.prototype.getLabel = function() {
  return this._label;
};
ar.prototype.getEdge = function() {
  return this._edge;
};
ar.prototype.getQuadrant = function() {
  return this._quadrant;
};
ar.prototype.getNode = function() {
  return this._node;
};
ar.prototype.toString = function() {
  var t = Math.atan2(this._dy, this._dx), e = this.getClass().getName(), n = e.lastIndexOf("."), i = e.substring(n + 1);
  return "  " + i + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label;
};
ar.prototype.computeLabel = function(t) {
};
ar.prototype.init = function(t, e) {
  this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = be.quadrant(this._dx, this._dy), mt.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
};
ar.prototype.interfaces_ = function() {
  return [Ri];
};
ar.prototype.getClass = function() {
  return ar;
};
var r_ = function(r) {
  function t() {
    var e = arguments[0], n = arguments[1];
    if (r.call(this, e), this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n, n)
      this.init(e.getCoordinate(0), e.getCoordinate(1));
    else {
      var i = e.getNumPoints() - 1;
      this.init(e.getCoordinate(i), e.getCoordinate(i - 1));
    }
    this.computeDirectedLabel();
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.getNextMin = function() {
    return this._nextMin;
  }, t.prototype.getDepth = function(n) {
    return this._depth[n];
  }, t.prototype.setVisited = function(n) {
    this._isVisited = n;
  }, t.prototype.computeDirectedLabel = function() {
    this._label = new ye(this._edge.getLabel()), this._isForward || this._label.flip();
  }, t.prototype.getNext = function() {
    return this._next;
  }, t.prototype.setDepth = function(n, i) {
    if (this._depth[n] !== -999 && this._depth[n] !== i)
      throw new Mo("assigned depths do not match", this.getCoordinate());
    this._depth[n] = i;
  }, t.prototype.isInteriorAreaEdge = function() {
    for (var n = this, i = !0, s = 0; s < 2; s++)
      n._label.isArea(s) && n._label.getLocation(s, z.LEFT) === A.INTERIOR && n._label.getLocation(s, z.RIGHT) === A.INTERIOR || (i = !1);
    return i;
  }, t.prototype.setNextMin = function(n) {
    this._nextMin = n;
  }, t.prototype.print = function(n) {
    r.prototype.print.call(this, n), n.print(" " + this._depth[z.LEFT] + "/" + this._depth[z.RIGHT]), n.print(" (" + this.getDepthDelta() + ")"), this._isInResult && n.print(" inResult");
  }, t.prototype.setMinEdgeRing = function(n) {
    this._minEdgeRing = n;
  }, t.prototype.isLineEdge = function() {
    var n = this._label.isLine(0) || this._label.isLine(1), i = !this._label.isArea(0) || this._label.allPositionsEqual(0, A.EXTERIOR), s = !this._label.isArea(1) || this._label.allPositionsEqual(1, A.EXTERIOR);
    return n && i && s;
  }, t.prototype.setEdgeRing = function(n) {
    this._edgeRing = n;
  }, t.prototype.getMinEdgeRing = function() {
    return this._minEdgeRing;
  }, t.prototype.getDepthDelta = function() {
    var n = this._edge.getDepthDelta();
    return this._isForward || (n = -n), n;
  }, t.prototype.setInResult = function(n) {
    this._isInResult = n;
  }, t.prototype.getSym = function() {
    return this._sym;
  }, t.prototype.isForward = function() {
    return this._isForward;
  }, t.prototype.getEdge = function() {
    return this._edge;
  }, t.prototype.printEdge = function(n) {
    this.print(n), n.print(" "), this._isForward ? this._edge.print(n) : this._edge.printReverse(n);
  }, t.prototype.setSym = function(n) {
    this._sym = n;
  }, t.prototype.setVisitedEdge = function(n) {
    this.setVisited(n), this._sym.setVisited(n);
  }, t.prototype.setEdgeDepths = function(n, i) {
    var s = this.getEdge().getDepthDelta();
    this._isForward || (s = -s);
    var o = 1;
    n === z.LEFT && (o = -1);
    var a = z.opposite(n), u = s * o, x = i + u;
    this.setDepth(n, i), this.setDepth(a, x);
  }, t.prototype.getEdgeRing = function() {
    return this._edgeRing;
  }, t.prototype.isInResult = function() {
    return this._isInResult;
  }, t.prototype.setNext = function(n) {
    this._next = n;
  }, t.prototype.isVisited = function() {
    return this._isVisited;
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t.depthFactor = function(n, i) {
    return n === A.EXTERIOR && i === A.INTERIOR ? 1 : n === A.INTERIOR && i === A.EXTERIOR ? -1 : 0;
  }, t;
}(ar), Yx = function() {
};
Yx.prototype.createNode = function(t) {
  return new tv(t, null);
};
Yx.prototype.interfaces_ = function() {
  return [];
};
Yx.prototype.getClass = function() {
  return Yx;
};
var Je = function() {
  if (this._edges = new H(), this._nodes = null, this._edgeEndList = new H(), arguments.length === 0)
    this._nodes = new Ps(new Yx());
  else if (arguments.length === 1) {
    var t = arguments[0];
    this._nodes = new Ps(t);
  }
};
Je.prototype.printEdges = function(t) {
  var e = this;
  t.println("Edges:");
  for (var n = 0; n < this._edges.size(); n++) {
    t.println("edge " + n + ":");
    var i = e._edges.get(n);
    i.print(t), i.eiList.print(t);
  }
};
Je.prototype.find = function(t) {
  return this._nodes.find(t);
};
Je.prototype.addNode = function() {
  if (arguments[0] instanceof tv) {
    var t = arguments[0];
    return this._nodes.addNode(t);
  } else if (arguments[0] instanceof R) {
    var e = arguments[0];
    return this._nodes.addNode(e);
  }
};
Je.prototype.getNodeIterator = function() {
  return this._nodes.iterator();
};
Je.prototype.linkResultDirectedEdges = function() {
  for (var t = this._nodes.iterator(); t.hasNext(); ) {
    var e = t.next();
    e.getEdges().linkResultDirectedEdges();
  }
};
Je.prototype.debugPrintln = function(t) {
  Hn.out.println(t);
};
Je.prototype.isBoundaryNode = function(t, e) {
  var n = this._nodes.find(e);
  if (n === null)
    return !1;
  var i = n.getLabel();
  return i !== null && i.getLocation(t) === A.BOUNDARY;
};
Je.prototype.linkAllDirectedEdges = function() {
  for (var t = this._nodes.iterator(); t.hasNext(); ) {
    var e = t.next();
    e.getEdges().linkAllDirectedEdges();
  }
};
Je.prototype.matchInSameDirection = function(t, e, n, i) {
  return t.equals(n) ? Z.computeOrientation(t, e, i) === Z.COLLINEAR && be.quadrant(t, e) === be.quadrant(n, i) : !1;
};
Je.prototype.getEdgeEnds = function() {
  return this._edgeEndList;
};
Je.prototype.debugPrint = function(t) {
  Hn.out.print(t);
};
Je.prototype.getEdgeIterator = function() {
  return this._edges.iterator();
};
Je.prototype.findEdgeInSameDirection = function(t, e) {
  for (var n = this, i = 0; i < this._edges.size(); i++) {
    var s = n._edges.get(i), o = s.getCoordinates();
    if (n.matchInSameDirection(t, e, o[0], o[1]) || n.matchInSameDirection(t, e, o[o.length - 1], o[o.length - 2]))
      return s;
  }
  return null;
};
Je.prototype.insertEdge = function(t) {
  this._edges.add(t);
};
Je.prototype.findEdgeEnd = function(t) {
  for (var e = this.getEdgeEnds().iterator(); e.hasNext(); ) {
    var n = e.next();
    if (n.getEdge() === t)
      return n;
  }
  return null;
};
Je.prototype.addEdges = function(t) {
  for (var e = this, n = t.iterator(); n.hasNext(); ) {
    var i = n.next();
    e._edges.add(i);
    var s = new r_(i, !0), o = new r_(i, !1);
    s.setSym(o), o.setSym(s), e.add(s), e.add(o);
  }
};
Je.prototype.add = function(t) {
  this._nodes.add(t), this._edgeEndList.add(t);
};
Je.prototype.getNodes = function() {
  return this._nodes.values();
};
Je.prototype.findEdge = function(t, e) {
  for (var n = this, i = 0; i < this._edges.size(); i++) {
    var s = n._edges.get(i), o = s.getCoordinates();
    if (t.equals(o[0]) && e.equals(o[1]))
      return s;
  }
  return null;
};
Je.prototype.interfaces_ = function() {
  return [];
};
Je.prototype.getClass = function() {
  return Je;
};
Je.linkResultDirectedEdges = function(t) {
  for (var e = t.iterator(); e.hasNext(); ) {
    var n = e.next();
    n.getEdges().linkResultDirectedEdges();
  }
};
var Zr = function() {
  this._geometryFactory = null, this._shellList = new H();
  var t = arguments[0];
  this._geometryFactory = t;
};
Zr.prototype.sortShellsAndHoles = function(t, e, n) {
  for (var i = t.iterator(); i.hasNext(); ) {
    var s = i.next();
    s.isHole() ? n.add(s) : e.add(s);
  }
};
Zr.prototype.computePolygons = function(t) {
  for (var e = this, n = new H(), i = t.iterator(); i.hasNext(); ) {
    var s = i.next(), o = s.toPolygon(e._geometryFactory);
    n.add(o);
  }
  return n;
};
Zr.prototype.placeFreeHoles = function(t, e) {
  for (var n = this, i = e.iterator(); i.hasNext(); ) {
    var s = i.next();
    if (s.getShell() === null) {
      var o = n.findEdgeRingContaining(s, t);
      if (o === null)
        throw new Mo("unable to assign hole to a shell", s.getCoordinate(0));
      s.setShell(o);
    }
  }
};
Zr.prototype.buildMinimalEdgeRings = function(t, e, n) {
  for (var i = this, s = new H(), o = t.iterator(); o.hasNext(); ) {
    var a = o.next();
    if (a.getMaxNodeDegree() > 2) {
      a.linkDirectedEdgesForMinimalEdgeRings();
      var u = a.buildMinimalRings(), x = i.findShell(u);
      x !== null ? (i.placePolygonHoles(x, u), e.add(x)) : n.addAll(u);
    } else
      s.add(a);
  }
  return s;
};
Zr.prototype.containsPoint = function(t) {
  for (var e = this._shellList.iterator(); e.hasNext(); ) {
    var n = e.next();
    if (n.containsPoint(t))
      return !0;
  }
  return !1;
};
Zr.prototype.buildMaximalEdgeRings = function(t) {
  for (var e = this, n = new H(), i = t.iterator(); i.hasNext(); ) {
    var s = i.next();
    if (s.isInResult() && s.getLabel().isArea() && s.getEdgeRing() === null) {
      var o = new dF(s, e._geometryFactory);
      n.add(o), o.setInResult();
    }
  }
  return n;
};
Zr.prototype.placePolygonHoles = function(t, e) {
  for (var n = e.iterator(); n.hasNext(); ) {
    var i = n.next();
    i.isHole() && i.setShell(t);
  }
};
Zr.prototype.getPolygons = function() {
  var t = this.computePolygons(this._shellList);
  return t;
};
Zr.prototype.findEdgeRingContaining = function(t, e) {
  for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), s = n.getCoordinateN(0), o = null, a = null, u = e.iterator(); u.hasNext(); ) {
    var x = u.next(), c = x.getLinearRing(), f = c.getEnvelopeInternal();
    o !== null && (a = o.getLinearRing().getEnvelopeInternal());
    var l = !1;
    f.contains(i) && Z.isPointInRing(s, c.getCoordinates()) && (l = !0), l && (o === null || a.contains(f)) && (o = x);
  }
  return o;
};
Zr.prototype.findShell = function(t) {
  for (var e = 0, n = null, i = t.iterator(); i.hasNext(); ) {
    var s = i.next();
    s.isHole() || (n = s, e++);
  }
  return mt.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n;
};
Zr.prototype.add = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.add(t.getEdgeEnds(), t.getNodes());
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    Je.linkResultDirectedEdges(n);
    var i = this.buildMaximalEdgeRings(e), s = new H(), o = this.buildMinimalEdgeRings(i, this._shellList, s);
    this.sortShellsAndHoles(o, this._shellList, s), this.placeFreeHoles(this._shellList, s);
  }
};
Zr.prototype.interfaces_ = function() {
  return [];
};
Zr.prototype.getClass = function() {
  return Zr;
};
var Xx = function() {
};
Xx.prototype.getBounds = function() {
};
Xx.prototype.interfaces_ = function() {
  return [];
};
Xx.prototype.getClass = function() {
  return Xx;
};
var Hi = function() {
  this._bounds = null, this._item = null;
  var t = arguments[0], e = arguments[1];
  this._bounds = t, this._item = e;
};
Hi.prototype.getItem = function() {
  return this._item;
};
Hi.prototype.getBounds = function() {
  return this._bounds;
};
Hi.prototype.interfaces_ = function() {
  return [Xx, Ai];
};
Hi.prototype.getClass = function() {
  return Hi;
};
var Po = function() {
  this._size = null, this._items = null, this._size = 0, this._items = new H(), this._items.add(null);
};
Po.prototype.poll = function() {
  if (this.isEmpty())
    return null;
  var t = this._items.get(1);
  return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t;
};
Po.prototype.size = function() {
  return this._size;
};
Po.prototype.reorder = function(t) {
  for (var e = this, n = null, i = this._items.get(t); t * 2 <= this._size && (n = t * 2, n !== e._size && e._items.get(n + 1).compareTo(e._items.get(n)) < 0 && n++, e._items.get(n).compareTo(i) < 0); t = n)
    e._items.set(t, e._items.get(n));
  this._items.set(t, i);
};
Po.prototype.clear = function() {
  this._size = 0, this._items.clear();
};
Po.prototype.isEmpty = function() {
  return this._size === 0;
};
Po.prototype.add = function(t) {
  var e = this;
  this._items.add(null), this._size += 1;
  var n = this._size;
  for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(n / 2))) < 0; n /= 2)
    e._items.set(n, e._items.get(Math.trunc(n / 2)));
  this._items.set(n, t);
};
Po.prototype.interfaces_ = function() {
  return [];
};
Po.prototype.getClass = function() {
  return Po;
};
var ha = function() {
};
ha.prototype.visitItem = function(t) {
};
ha.prototype.interfaces_ = function() {
  return [];
};
ha.prototype.getClass = function() {
  return ha;
};
var K0 = function() {
};
K0.prototype.insert = function(t, e) {
};
K0.prototype.remove = function(t, e) {
};
K0.prototype.query = function() {
};
K0.prototype.interfaces_ = function() {
  return [];
};
K0.prototype.getClass = function() {
  return K0;
};
var Sn = function() {
  if (this._childBoundables = new H(), this._bounds = null, this._level = null, arguments.length !== 0) {
    if (arguments.length === 1) {
      var t = arguments[0];
      this._level = t;
    }
  }
}, WS = { serialVersionUID: { configurable: !0 } };
Sn.prototype.getLevel = function() {
  return this._level;
};
Sn.prototype.size = function() {
  return this._childBoundables.size();
};
Sn.prototype.getChildBoundables = function() {
  return this._childBoundables;
};
Sn.prototype.addChildBoundable = function(t) {
  mt.isTrue(this._bounds === null), this._childBoundables.add(t);
};
Sn.prototype.isEmpty = function() {
  return this._childBoundables.isEmpty();
};
Sn.prototype.getBounds = function() {
  return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
};
Sn.prototype.interfaces_ = function() {
  return [Xx, Ai];
};
Sn.prototype.getClass = function() {
  return Sn;
};
WS.serialVersionUID.get = function() {
  return 6493722185909574e3;
};
Object.defineProperties(Sn, WS);
var Ji = function() {
};
Ji.reverseOrder = function() {
  return {
    compare: function(e, n) {
      return n.compareTo(e);
    }
  };
};
Ji.min = function(t) {
  return Ji.sort(t), t.get(0);
};
Ji.sort = function(t, e) {
  var n = t.toArray();
  e ? za.sort(n, e) : za.sort(n);
  for (var i = t.iterator(), s = 0, o = n.length; s < o; s++)
    i.next(), i.set(n[s]);
};
Ji.singletonList = function(t) {
  var e = new H();
  return e.add(t), e;
};
var fn = function() {
  this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
  var t = arguments[0], e = arguments[1], n = arguments[2];
  this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance();
};
fn.prototype.expandToQueue = function(t, e) {
  var n = fn.isComposite(this._boundable1), i = fn.isComposite(this._boundable2);
  if (n && i)
    return fn.area(this._boundable1) > fn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t, e), null) : (this.expand(this._boundable2, this._boundable1, t, e), null);
  if (n)
    return this.expand(this._boundable1, this._boundable2, t, e), null;
  if (i)
    return this.expand(this._boundable2, this._boundable1, t, e), null;
  throw new ze("neither boundable is composite");
};
fn.prototype.isLeaves = function() {
  return !(fn.isComposite(this._boundable1) || fn.isComposite(this._boundable2));
};
fn.prototype.compareTo = function(t) {
  var e = t;
  return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;
};
fn.prototype.expand = function(t, e, n, i) {
  for (var s = this, o = t.getChildBoundables(), a = o.iterator(); a.hasNext(); ) {
    var u = a.next(), x = new fn(u, e, s._itemDistance);
    x.getDistance() < i && n.add(x);
  }
};
fn.prototype.getBoundable = function(t) {
  return t === 0 ? this._boundable1 : this._boundable2;
};
fn.prototype.getDistance = function() {
  return this._distance;
};
fn.prototype.distance = function() {
  return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
};
fn.prototype.interfaces_ = function() {
  return [Ri];
};
fn.prototype.getClass = function() {
  return fn;
};
fn.area = function(t) {
  return t.getBounds().getArea();
};
fn.isComposite = function(t) {
  return t instanceof Sn;
};
var Dn = function r() {
  if (this._root = null, this._built = !1, this._itemBoundables = new H(), this._nodeCapacity = null, arguments.length === 0) {
    var t = r.DEFAULT_NODE_CAPACITY;
    this._nodeCapacity = t;
  } else if (arguments.length === 1) {
    var e = arguments[0];
    mt.isTrue(e > 1, "Node capacity must be greater than 1"), this._nodeCapacity = e;
  }
}, ev = { IntersectsOp: { configurable: !0 }, serialVersionUID: { configurable: !0 }, DEFAULT_NODE_CAPACITY: { configurable: !0 } };
Dn.prototype.getNodeCapacity = function() {
  return this._nodeCapacity;
};
Dn.prototype.lastNode = function(t) {
  return t.get(t.size() - 1);
};
Dn.prototype.size = function() {
  var t = this;
  if (arguments.length === 0)
    return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
  if (arguments.length === 1) {
    for (var e = arguments[0], n = 0, i = e.getChildBoundables().iterator(); i.hasNext(); ) {
      var s = i.next();
      s instanceof Sn ? n += t.size(s) : s instanceof Hi && (n += 1);
    }
    return n;
  }
};
Dn.prototype.removeItem = function(t, e) {
  for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext(); ) {
    var s = i.next();
    s instanceof Hi && s.getItem() === e && (n = s);
  }
  return n !== null ? (t.getChildBoundables().remove(n), !0) : !1;
};
Dn.prototype.itemsTree = function() {
  var t = this;
  if (arguments.length === 0) {
    this.build();
    var e = this.itemsTree(this._root);
    return e === null ? new H() : e;
  } else if (arguments.length === 1) {
    for (var n = arguments[0], i = new H(), s = n.getChildBoundables().iterator(); s.hasNext(); ) {
      var o = s.next();
      if (o instanceof Sn) {
        var a = t.itemsTree(o);
        a !== null && i.add(a);
      } else o instanceof Hi ? i.add(o.getItem()) : mt.shouldNeverReachHere();
    }
    return i.size() <= 0 ? null : i;
  }
};
Dn.prototype.insert = function(t, e) {
  mt.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new Hi(t, e));
};
Dn.prototype.boundablesAtLevel = function() {
  var t = this;
  if (arguments.length === 1) {
    var e = arguments[0], n = new H();
    return this.boundablesAtLevel(e, this._root, n), n;
  } else if (arguments.length === 3) {
    var i = arguments[0], s = arguments[1], o = arguments[2];
    if (mt.isTrue(i > -2), s.getLevel() === i)
      return o.add(s), null;
    for (var a = s.getChildBoundables().iterator(); a.hasNext(); ) {
      var u = a.next();
      u instanceof Sn ? t.boundablesAtLevel(i, u, o) : (mt.isTrue(u instanceof Hi), i === -1 && o.add(u));
    }
    return null;
  }
};
Dn.prototype.query = function() {
  var t = this;
  if (arguments.length === 1) {
    var e = arguments[0];
    this.build();
    var n = new H();
    return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), e) && this.query(e, this._root, n), n;
  } else if (arguments.length === 2) {
    var i = arguments[0], s = arguments[1];
    if (this.build(), this.isEmpty())
      return null;
    this.getIntersectsOp().intersects(this._root.getBounds(), i) && this.query(i, this._root, s);
  } else if (arguments.length === 3) {
    if (ct(arguments[2], ha) && arguments[0] instanceof Object && arguments[1] instanceof Sn)
      for (var o = arguments[0], a = arguments[1], u = arguments[2], x = a.getChildBoundables(), c = 0; c < x.size(); c++) {
        var f = x.get(c);
        t.getIntersectsOp().intersects(f.getBounds(), o) && (f instanceof Sn ? t.query(o, f, u) : f instanceof Hi ? u.visitItem(f.getItem()) : mt.shouldNeverReachHere());
      }
    else if (ct(arguments[2], zi) && arguments[0] instanceof Object && arguments[1] instanceof Sn)
      for (var l = arguments[0], h = arguments[1], p = arguments[2], y = h.getChildBoundables(), v = 0; v < y.size(); v++) {
        var m = y.get(v);
        t.getIntersectsOp().intersects(m.getBounds(), l) && (m instanceof Sn ? t.query(l, m, p) : m instanceof Hi ? p.add(m.getItem()) : mt.shouldNeverReachHere());
      }
  }
};
Dn.prototype.build = function() {
  if (this._built)
    return null;
  this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;
};
Dn.prototype.getRoot = function() {
  return this.build(), this._root;
};
Dn.prototype.remove = function() {
  var t = this;
  if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    return this.build(), this.getIntersectsOp().intersects(this._root.getBounds(), e) ? this.remove(e, this._root, n) : !1;
  } else if (arguments.length === 3) {
    var i = arguments[0], s = arguments[1], o = arguments[2], a = this.removeItem(s, o);
    if (a)
      return !0;
    for (var u = null, x = s.getChildBoundables().iterator(); x.hasNext(); ) {
      var c = x.next();
      if (t.getIntersectsOp().intersects(c.getBounds(), i) && c instanceof Sn && (a = t.remove(i, c, o), a)) {
        u = c;
        break;
      }
    }
    return u !== null && u.getChildBoundables().isEmpty() && s.getChildBoundables().remove(u), a;
  }
};
Dn.prototype.createHigherLevels = function(t, e) {
  mt.isTrue(!t.isEmpty());
  var n = this.createParentBoundables(t, e + 1);
  return n.size() === 1 ? n.get(0) : this.createHigherLevels(n, e + 1);
};
Dn.prototype.depth = function() {
  var t = this;
  if (arguments.length === 0)
    return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
  if (arguments.length === 1) {
    for (var e = arguments[0], n = 0, i = e.getChildBoundables().iterator(); i.hasNext(); ) {
      var s = i.next();
      if (s instanceof Sn) {
        var o = t.depth(s);
        o > n && (n = o);
      }
    }
    return n + 1;
  }
};
Dn.prototype.createParentBoundables = function(t, e) {
  var n = this;
  mt.isTrue(!t.isEmpty());
  var i = new H();
  i.add(this.createNode(e));
  var s = new H(t);
  Ji.sort(s, this.getComparator());
  for (var o = s.iterator(); o.hasNext(); ) {
    var a = o.next();
    n.lastNode(i).getChildBoundables().size() === n.getNodeCapacity() && i.add(n.createNode(e)), n.lastNode(i).addChildBoundable(a);
  }
  return i;
};
Dn.prototype.isEmpty = function() {
  return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
};
Dn.prototype.interfaces_ = function() {
  return [Ai];
};
Dn.prototype.getClass = function() {
  return Dn;
};
Dn.compareDoubles = function(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
};
ev.IntersectsOp.get = function() {
  return gF;
};
ev.serialVersionUID.get = function() {
  return -3886435814360241e3;
};
ev.DEFAULT_NODE_CAPACITY.get = function() {
  return 10;
};
Object.defineProperties(Dn, ev);
var gF = function() {
}, qx = function() {
};
qx.prototype.distance = function(t, e) {
};
qx.prototype.interfaces_ = function() {
  return [];
};
qx.prototype.getClass = function() {
  return qx;
};
var HS = function(r) {
  function t(n) {
    n = n || t.DEFAULT_NODE_CAPACITY, r.call(this, n);
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { STRtreeNode: { configurable: !0 }, serialVersionUID: { configurable: !0 }, xComparator: { configurable: !0 }, yComparator: { configurable: !0 }, intersectsOp: { configurable: !0 }, DEFAULT_NODE_CAPACITY: { configurable: !0 } };
  return t.prototype.createParentBoundablesFromVerticalSlices = function(i, s) {
    var o = this;
    mt.isTrue(i.length > 0);
    for (var a = new H(), u = 0; u < i.length; u++)
      a.addAll(o.createParentBoundablesFromVerticalSlice(i[u], s));
    return a;
  }, t.prototype.createNode = function(i) {
    return new E3(i);
  }, t.prototype.size = function() {
    return arguments.length === 0 ? r.prototype.size.call(this) : r.prototype.size.apply(this, arguments);
  }, t.prototype.insert = function() {
    if (arguments.length === 2) {
      var i = arguments[0], s = arguments[1];
      if (i.isNull())
        return null;
      r.prototype.insert.call(this, i, s);
    } else
      return r.prototype.insert.apply(this, arguments);
  }, t.prototype.getIntersectsOp = function() {
    return t.intersectsOp;
  }, t.prototype.verticalSlices = function(i, s) {
    for (var o = Math.trunc(Math.ceil(i.size() / s)), a = new Array(s).fill(null), u = i.iterator(), x = 0; x < s; x++) {
      a[x] = new H();
      for (var c = 0; u.hasNext() && c < o; ) {
        var f = u.next();
        a[x].add(f), c++;
      }
    }
    return a;
  }, t.prototype.query = function() {
    if (arguments.length === 1) {
      var i = arguments[0];
      return r.prototype.query.call(this, i);
    } else if (arguments.length === 2) {
      var s = arguments[0], o = arguments[1];
      r.prototype.query.call(this, s, o);
    } else if (arguments.length === 3) {
      if (ct(arguments[2], ha) && arguments[0] instanceof Object && arguments[1] instanceof Sn) {
        var a = arguments[0], u = arguments[1], x = arguments[2];
        r.prototype.query.call(this, a, u, x);
      } else if (ct(arguments[2], zi) && arguments[0] instanceof Object && arguments[1] instanceof Sn) {
        var c = arguments[0], f = arguments[1], l = arguments[2];
        r.prototype.query.call(this, c, f, l);
      }
    }
  }, t.prototype.getComparator = function() {
    return t.yComparator;
  }, t.prototype.createParentBoundablesFromVerticalSlice = function(i, s) {
    return r.prototype.createParentBoundables.call(this, i, s);
  }, t.prototype.remove = function() {
    if (arguments.length === 2) {
      var i = arguments[0], s = arguments[1];
      return r.prototype.remove.call(this, i, s);
    } else
      return r.prototype.remove.apply(this, arguments);
  }, t.prototype.depth = function() {
    return arguments.length === 0 ? r.prototype.depth.call(this) : r.prototype.depth.apply(this, arguments);
  }, t.prototype.createParentBoundables = function(i, s) {
    mt.isTrue(!i.isEmpty());
    var o = Math.trunc(Math.ceil(i.size() / this.getNodeCapacity())), a = new H(i);
    Ji.sort(a, t.xComparator);
    var u = this.verticalSlices(a, Math.trunc(Math.ceil(Math.sqrt(o))));
    return this.createParentBoundablesFromVerticalSlices(u, s);
  }, t.prototype.nearestNeighbour = function() {
    if (arguments.length === 1) {
      if (ct(arguments[0], qx)) {
        var i = arguments[0], s = new fn(this.getRoot(), this.getRoot(), i);
        return this.nearestNeighbour(s);
      } else if (arguments[0] instanceof fn) {
        var o = arguments[0];
        return this.nearestNeighbour(o, yt.POSITIVE_INFINITY);
      }
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof t && ct(arguments[1], qx)) {
        var a = arguments[0], u = arguments[1], x = new fn(this.getRoot(), a.getRoot(), u);
        return this.nearestNeighbour(x);
      } else if (arguments[0] instanceof fn && typeof arguments[1] == "number") {
        var c = arguments[0], f = arguments[1], l = f, h = null, p = new Po();
        for (p.add(c); !p.isEmpty() && l > 0; ) {
          var y = p.poll(), v = y.getDistance();
          if (v >= l)
            break;
          y.isLeaves() ? (l = v, h = y) : y.expandToQueue(p, l);
        }
        return [h.getBoundable(0).getItem(), h.getBoundable(1).getItem()];
      }
    } else if (arguments.length === 3) {
      var m = arguments[0], d = arguments[1], g = arguments[2], _ = new Hi(m, d), b = new fn(this.getRoot(), _, g);
      return this.nearestNeighbour(b)[0];
    }
  }, t.prototype.interfaces_ = function() {
    return [K0, Ai];
  }, t.prototype.getClass = function() {
    return t;
  }, t.centreX = function(i) {
    return t.avg(i.getMinX(), i.getMaxX());
  }, t.avg = function(i, s) {
    return (i + s) / 2;
  }, t.centreY = function(i) {
    return t.avg(i.getMinY(), i.getMaxY());
  }, e.STRtreeNode.get = function() {
    return E3;
  }, e.serialVersionUID.get = function() {
    return 259274702368956900;
  }, e.xComparator.get = function() {
    return {
      interfaces_: function() {
        return [Rx];
      },
      compare: function(n, i) {
        return r.compareDoubles(t.centreX(n.getBounds()), t.centreX(i.getBounds()));
      }
    };
  }, e.yComparator.get = function() {
    return {
      interfaces_: function() {
        return [Rx];
      },
      compare: function(n, i) {
        return r.compareDoubles(t.centreY(n.getBounds()), t.centreY(i.getBounds()));
      }
    };
  }, e.intersectsOp.get = function() {
    return {
      interfaces_: function() {
        return [r.IntersectsOp];
      },
      intersects: function(n, i) {
        return n.intersects(i);
      }
    };
  }, e.DEFAULT_NODE_CAPACITY.get = function() {
    return 10;
  }, Object.defineProperties(t, e), t;
}(Dn), E3 = function(r) {
  function t() {
    var e = arguments[0];
    r.call(this, e);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.computeBounds = function() {
    for (var n = null, i = this.getChildBoundables().iterator(); i.hasNext(); ) {
      var s = i.next();
      n === null ? n = new nt(s.getBounds()) : n.expandToInclude(s.getBounds());
    }
    return n;
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(Sn), Nr = function() {
};
Nr.prototype.interfaces_ = function() {
  return [];
};
Nr.prototype.getClass = function() {
  return Nr;
};
Nr.relativeSign = function(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
};
Nr.compare = function(t, e, n) {
  if (e.equals2D(n))
    return 0;
  var i = Nr.relativeSign(e.x, n.x), s = Nr.relativeSign(e.y, n.y);
  switch (t) {
    case 0:
      return Nr.compareValue(i, s);
    case 1:
      return Nr.compareValue(s, i);
    case 2:
      return Nr.compareValue(s, -i);
    case 3:
      return Nr.compareValue(-i, s);
    case 4:
      return Nr.compareValue(-i, -s);
    case 5:
      return Nr.compareValue(-s, -i);
    case 6:
      return Nr.compareValue(-s, i);
    case 7:
      return Nr.compareValue(i, -s);
  }
  return mt.shouldNeverReachHere("invalid octant value"), 0;
};
Nr.compareValue = function(t, e) {
  return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;
};
var pa = function() {
  this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
  var t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3];
  this._segString = t, this.coord = new R(e), this.segmentIndex = n, this._segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n));
};
pa.prototype.getCoordinate = function() {
  return this.coord;
};
pa.prototype.print = function(t) {
  t.print(this.coord), t.print(" seg # = " + this.segmentIndex);
};
pa.prototype.compareTo = function(t) {
  var e = t;
  return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : Nr.compare(this._segmentOctant, this.coord, e.coord);
};
pa.prototype.isEndPoint = function(t) {
  return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === t;
};
pa.prototype.isInterior = function() {
  return this._isInterior;
};
pa.prototype.interfaces_ = function() {
  return [Ri];
};
pa.prototype.getClass = function() {
  return pa;
};
var Er = function() {
  this._nodeMap = new or(), this._edge = null;
  var t = arguments[0];
  this._edge = t;
};
Er.prototype.getSplitCoordinates = function() {
  var t = this, e = new jl();
  this.addEndpoints();
  for (var n = this.iterator(), i = n.next(); n.hasNext(); ) {
    var s = n.next();
    t.addEdgeCoordinates(i, s, e), i = s;
  }
  return e.toCoordinateArray();
};
Er.prototype.addCollapsedNodes = function() {
  var t = this, e = new H();
  this.findCollapsesFromInsertedNodes(e), this.findCollapsesFromExistingVertices(e);
  for (var n = e.iterator(); n.hasNext(); ) {
    var i = n.next().intValue();
    t.add(t._edge.getCoordinate(i), i);
  }
};
Er.prototype.print = function(t) {
  t.println("Intersections:");
  for (var e = this.iterator(); e.hasNext(); ) {
    var n = e.next();
    n.print(t);
  }
};
Er.prototype.findCollapsesFromExistingVertices = function(t) {
  for (var e = this, n = 0; n < this._edge.size() - 2; n++) {
    var i = e._edge.getCoordinate(n), s = e._edge.getCoordinate(n + 2);
    i.equals2D(s) && t.add(new ws(n + 1));
  }
};
Er.prototype.addEdgeCoordinates = function(t, e, n) {
  var i = this, s = this._edge.getCoordinate(e.segmentIndex), o = e.isInterior() || !e.coord.equals2D(s);
  n.add(new R(t.coord), !1);
  for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++)
    n.add(i._edge.getCoordinate(a));
  o && n.add(new R(e.coord));
};
Er.prototype.iterator = function() {
  return this._nodeMap.values().iterator();
};
Er.prototype.addSplitEdges = function(t) {
  var e = this;
  this.addEndpoints(), this.addCollapsedNodes();
  for (var n = this.iterator(), i = n.next(); n.hasNext(); ) {
    var s = n.next(), o = e.createSplitEdge(i, s);
    t.add(o), i = s;
  }
};
Er.prototype.findCollapseIndex = function(t, e, n) {
  if (!t.coord.equals2D(e.coord))
    return !1;
  var i = e.segmentIndex - t.segmentIndex;
  return e.isInterior() || i--, i === 1 ? (n[0] = t.segmentIndex + 1, !0) : !1;
};
Er.prototype.findCollapsesFromInsertedNodes = function(t) {
  for (var e = this, n = new Array(1).fill(null), i = this.iterator(), s = i.next(); i.hasNext(); ) {
    var o = i.next(), a = e.findCollapseIndex(s, o, n);
    a && t.add(new ws(n[0])), s = o;
  }
};
Er.prototype.getEdge = function() {
  return this._edge;
};
Er.prototype.addEndpoints = function() {
  var t = this._edge.size() - 1;
  this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t);
};
Er.prototype.createSplitEdge = function(t, e) {
  var n = this, i = e.segmentIndex - t.segmentIndex + 2, s = this._edge.getCoordinate(e.segmentIndex), o = e.isInterior() || !e.coord.equals2D(s);
  o || i--;
  var a = new Array(i).fill(null), u = 0;
  a[u++] = new R(t.coord);
  for (var x = t.segmentIndex + 1; x <= e.segmentIndex; x++)
    a[u++] = n._edge.getCoordinate(x);
  return o && (a[u] = new R(e.coord)), new sn(a, this._edge.getData());
};
Er.prototype.add = function(t, e) {
  var n = new pa(this._edge, t, e, this._edge.getSegmentOctant(e)), i = this._nodeMap.get(n);
  return i !== null ? (mt.isTrue(i.coord.equals2D(t), "Found equal nodes with different coordinates"), i) : (this._nodeMap.put(n, n), n);
};
Er.prototype.checkSplitEdgesCorrectness = function(t) {
  var e = this._edge.getCoordinates(), n = t.get(0), i = n.getCoordinate(0);
  if (!i.equals2D(e[0]))
    throw new So("bad split edge start point at " + i);
  var s = t.get(t.size() - 1), o = s.getCoordinates(), a = o[o.length - 1];
  if (!a.equals2D(e[e.length - 1]))
    throw new So("bad split edge end point at " + a);
};
Er.prototype.interfaces_ = function() {
  return [];
};
Er.prototype.getClass = function() {
  return Er;
};
var j0 = function() {
};
j0.prototype.interfaces_ = function() {
  return [];
};
j0.prototype.getClass = function() {
  return j0;
};
j0.octant = function() {
  if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
    var t = arguments[0], e = arguments[1];
    if (t === 0 && e === 0)
      throw new ze("Cannot compute the octant for point ( " + t + ", " + e + " )");
    var n = Math.abs(t), i = Math.abs(e);
    return t >= 0 ? e >= 0 ? n >= i ? 0 : 1 : n >= i ? 7 : 6 : e >= 0 ? n >= i ? 3 : 2 : n >= i ? 4 : 5;
  } else if (arguments[0] instanceof R && arguments[1] instanceof R) {
    var s = arguments[0], o = arguments[1], a = o.x - s.x, u = o.y - s.y;
    if (a === 0 && u === 0)
      throw new ze("Cannot compute the octant for two identical points " + s);
    return j0.octant(a, u);
  }
};
var $s = function() {
};
$s.prototype.getCoordinates = function() {
};
$s.prototype.size = function() {
};
$s.prototype.getCoordinate = function(t) {
};
$s.prototype.isClosed = function() {
};
$s.prototype.setData = function(t) {
};
$s.prototype.getData = function() {
};
$s.prototype.interfaces_ = function() {
  return [];
};
$s.prototype.getClass = function() {
  return $s;
};
var El = function() {
};
El.prototype.addIntersection = function(t, e) {
};
El.prototype.interfaces_ = function() {
  return [$s];
};
El.prototype.getClass = function() {
  return El;
};
var sn = function() {
  this._nodeList = new Er(this), this._pts = null, this._data = null;
  var t = arguments[0], e = arguments[1];
  this._pts = t, this._data = e;
};
sn.prototype.getCoordinates = function() {
  return this._pts;
};
sn.prototype.size = function() {
  return this._pts.length;
};
sn.prototype.getCoordinate = function(t) {
  return this._pts[t];
};
sn.prototype.isClosed = function() {
  return this._pts[0].equals(this._pts[this._pts.length - 1]);
};
sn.prototype.getSegmentOctant = function(t) {
  return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));
};
sn.prototype.setData = function(t) {
  this._data = t;
};
sn.prototype.safeOctant = function(t, e) {
  return t.equals2D(e) ? 0 : j0.octant(t, e);
};
sn.prototype.getData = function() {
  return this._data;
};
sn.prototype.addIntersection = function() {
  if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    this.addIntersectionNode(t, e);
  } else if (arguments.length === 4) {
    var n = arguments[0], i = arguments[1], s = arguments[3], o = new R(n.getIntersection(s));
    this.addIntersection(o, i);
  }
};
sn.prototype.toString = function() {
  return Vi.toLineString(new en(this._pts));
};
sn.prototype.getNodeList = function() {
  return this._nodeList;
};
sn.prototype.addIntersectionNode = function(t, e) {
  var n = e, i = n + 1;
  if (i < this._pts.length) {
    var s = this._pts[i];
    t.equals2D(s) && (n = i);
  }
  var o = this._nodeList.add(t, n);
  return o;
};
sn.prototype.addIntersections = function(t, e, n) {
  for (var i = this, s = 0; s < t.getIntersectionNum(); s++)
    i.addIntersection(t, e, n, s);
};
sn.prototype.interfaces_ = function() {
  return [El];
};
sn.prototype.getClass = function() {
  return sn;
};
sn.getNodedSubstrings = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = new H();
    return sn.getNodedSubstrings(t, e), e;
  } else if (arguments.length === 2)
    for (var n = arguments[0], i = arguments[1], s = n.iterator(); s.hasNext(); ) {
      var o = s.next();
      o.getNodeList().addSplitEdges(i);
    }
};
var rt = function() {
  if (this.p0 = null, this.p1 = null, arguments.length === 0)
    this.p0 = new R(), this.p1 = new R();
  else if (arguments.length === 1) {
    var t = arguments[0];
    this.p0 = new R(t.p0), this.p1 = new R(t.p1);
  } else if (arguments.length === 2)
    this.p0 = arguments[0], this.p1 = arguments[1];
  else if (arguments.length === 4) {
    var e = arguments[0], n = arguments[1], i = arguments[2], s = arguments[3];
    this.p0 = new R(e, n), this.p1 = new R(i, s);
  }
}, JS = { serialVersionUID: { configurable: !0 } };
rt.prototype.minX = function() {
  return Math.min(this.p0.x, this.p1.x);
};
rt.prototype.orientationIndex = function() {
  if (arguments[0] instanceof rt) {
    var t = arguments[0], e = Z.orientationIndex(this.p0, this.p1, t.p0), n = Z.orientationIndex(this.p0, this.p1, t.p1);
    return e >= 0 && n >= 0 || e <= 0 && n <= 0 ? Math.max(e, n) : 0;
  } else if (arguments[0] instanceof R) {
    var i = arguments[0];
    return Z.orientationIndex(this.p0, this.p1, i);
  }
};
rt.prototype.toGeometry = function(t) {
  return t.createLineString([this.p0, this.p1]);
};
rt.prototype.isVertical = function() {
  return this.p0.x === this.p1.x;
};
rt.prototype.equals = function(t) {
  if (!(t instanceof rt))
    return !1;
  var e = t;
  return this.p0.equals(e.p0) && this.p1.equals(e.p1);
};
rt.prototype.intersection = function(t) {
  var e = new l0();
  return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null;
};
rt.prototype.project = function() {
  if (arguments[0] instanceof R) {
    var t = arguments[0];
    if (t.equals(this.p0) || t.equals(this.p1))
      return new R(t);
    var e = this.projectionFactor(t), n = new R();
    return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n;
  } else if (arguments[0] instanceof rt) {
    var i = arguments[0], s = this.projectionFactor(i.p0), o = this.projectionFactor(i.p1);
    if (s >= 1 && o >= 1 || s <= 0 && o <= 0)
      return null;
    var a = this.project(i.p0);
    s < 0 && (a = this.p0), s > 1 && (a = this.p1);
    var u = this.project(i.p1);
    return o < 0 && (u = this.p0), o > 1 && (u = this.p1), new rt(a, u);
  }
};
rt.prototype.normalize = function() {
  this.p1.compareTo(this.p0) < 0 && this.reverse();
};
rt.prototype.angle = function() {
  return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
};
rt.prototype.getCoordinate = function(t) {
  return t === 0 ? this.p0 : this.p1;
};
rt.prototype.distancePerpendicular = function(t) {
  return Z.distancePointLinePerpendicular(t, this.p0, this.p1);
};
rt.prototype.minY = function() {
  return Math.min(this.p0.y, this.p1.y);
};
rt.prototype.midPoint = function() {
  return rt.midPoint(this.p0, this.p1);
};
rt.prototype.projectionFactor = function(t) {
  if (t.equals(this.p0))
    return 0;
  if (t.equals(this.p1))
    return 1;
  var e = this.p1.x - this.p0.x, n = this.p1.y - this.p0.y, i = e * e + n * n;
  if (i <= 0)
    return yt.NaN;
  var s = ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i;
  return s;
};
rt.prototype.closestPoints = function(t) {
  var e = this.intersection(t);
  if (e !== null)
    return [e, e];
  var n = new Array(2).fill(null), i = yt.MAX_VALUE, s = null, o = this.closestPoint(t.p0);
  i = o.distance(t.p0), n[0] = o, n[1] = t.p0;
  var a = this.closestPoint(t.p1);
  s = a.distance(t.p1), s < i && (i = s, n[0] = a, n[1] = t.p1);
  var u = t.closestPoint(this.p0);
  s = u.distance(this.p0), s < i && (i = s, n[0] = this.p0, n[1] = u);
  var x = t.closestPoint(this.p1);
  return s = x.distance(this.p1), s < i && (i = s, n[0] = this.p1, n[1] = x), n;
};
rt.prototype.closestPoint = function(t) {
  var e = this.projectionFactor(t);
  if (e > 0 && e < 1)
    return this.project(t);
  var n = this.p0.distance(t), i = this.p1.distance(t);
  return n < i ? this.p0 : this.p1;
};
rt.prototype.maxX = function() {
  return Math.max(this.p0.x, this.p1.x);
};
rt.prototype.getLength = function() {
  return this.p0.distance(this.p1);
};
rt.prototype.compareTo = function(t) {
  var e = t, n = this.p0.compareTo(e.p0);
  return n !== 0 ? n : this.p1.compareTo(e.p1);
};
rt.prototype.reverse = function() {
  var t = this.p0;
  this.p0 = this.p1, this.p1 = t;
};
rt.prototype.equalsTopo = function(t) {
  return this.p0.equals(t.p0) && (this.p1.equals(t.p1) || this.p0.equals(t.p1)) && this.p1.equals(t.p0);
};
rt.prototype.lineIntersection = function(t) {
  try {
    var e = qi.intersection(this.p0, this.p1, t.p0, t.p1);
    return e;
  } catch (n) {
    if (!(n instanceof oc)) throw n;
  } finally {
  }
  return null;
};
rt.prototype.maxY = function() {
  return Math.max(this.p0.y, this.p1.y);
};
rt.prototype.pointAlongOffset = function(t, e) {
  var n = this.p0.x + t * (this.p1.x - this.p0.x), i = this.p0.y + t * (this.p1.y - this.p0.y), s = this.p1.x - this.p0.x, o = this.p1.y - this.p0.y, a = Math.sqrt(s * s + o * o), u = 0, x = 0;
  if (e !== 0) {
    if (a <= 0)
      throw new Error("Cannot compute offset from zero-length line segment");
    u = e * s / a, x = e * o / a;
  }
  var c = n - x, f = i + u, l = new R(c, f);
  return l;
};
rt.prototype.setCoordinates = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.setCoordinates(t.p0, t.p1);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y;
  }
};
rt.prototype.segmentFraction = function(t) {
  var e = this.projectionFactor(t);
  return e < 0 ? e = 0 : (e > 1 || yt.isNaN(e)) && (e = 1), e;
};
rt.prototype.toString = function() {
  return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
};
rt.prototype.isHorizontal = function() {
  return this.p0.y === this.p1.y;
};
rt.prototype.distance = function() {
  if (arguments[0] instanceof rt) {
    var t = arguments[0];
    return Z.distanceLineLine(this.p0, this.p1, t.p0, t.p1);
  } else if (arguments[0] instanceof R) {
    var e = arguments[0];
    return Z.distancePointLine(e, this.p0, this.p1);
  }
};
rt.prototype.pointAlong = function(t) {
  var e = new R();
  return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e;
};
rt.prototype.hashCode = function() {
  var t = yt.doubleToLongBits(this.p0.x);
  t ^= yt.doubleToLongBits(this.p0.y) * 31;
  var e = Math.trunc(t) ^ Math.trunc(t >> 32), n = yt.doubleToLongBits(this.p1.x);
  n ^= yt.doubleToLongBits(this.p1.y) * 31;
  var i = Math.trunc(n) ^ Math.trunc(n >> 32);
  return e ^ i;
};
rt.prototype.interfaces_ = function() {
  return [Ri, Ai];
};
rt.prototype.getClass = function() {
  return rt;
};
rt.midPoint = function(t, e) {
  return new R((t.x + e.x) / 2, (t.y + e.y) / 2);
};
JS.serialVersionUID.get = function() {
  return 3252005833466256400;
};
Object.defineProperties(rt, JS);
var Sl = function() {
  this.tempEnv1 = new nt(), this.tempEnv2 = new nt(), this._overlapSeg1 = new rt(), this._overlapSeg2 = new rt();
};
Sl.prototype.overlap = function() {
  if (arguments.length !== 2) {
    if (arguments.length === 4) {
      var t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3];
      t.getLineSegment(e, this._overlapSeg1), n.getLineSegment(i, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
    }
  }
};
Sl.prototype.interfaces_ = function() {
  return [];
};
Sl.prototype.getClass = function() {
  return Sl;
};
var Kr = function() {
  this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
  var t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3];
  this._pts = t, this._start = e, this._end = n, this._context = i;
};
Kr.prototype.getLineSegment = function(t, e) {
  e.p0 = this._pts[t], e.p1 = this._pts[t + 1];
};
Kr.prototype.computeSelect = function(t, e, n, i) {
  var s = this._pts[e], o = this._pts[n];
  if (i.tempEnv1.init(s, o), n - e === 1)
    return i.select(this, e), null;
  if (!t.intersects(i.tempEnv1))
    return null;
  var a = Math.trunc((e + n) / 2);
  e < a && this.computeSelect(t, e, a, i), a < n && this.computeSelect(t, a, n, i);
};
Kr.prototype.getCoordinates = function() {
  for (var t = this, e = new Array(this._end - this._start + 1).fill(null), n = 0, i = this._start; i <= this._end; i++)
    e[n++] = t._pts[i];
  return e;
};
Kr.prototype.computeOverlaps = function(t, e) {
  this.computeOverlapsInternal(this._start, this._end, t, t._start, t._end, e);
};
Kr.prototype.setId = function(t) {
  this._id = t;
};
Kr.prototype.select = function(t, e) {
  this.computeSelect(t, this._start, this._end, e);
};
Kr.prototype.getEnvelope = function() {
  if (this._env === null) {
    var t = this._pts[this._start], e = this._pts[this._end];
    this._env = new nt(t, e);
  }
  return this._env;
};
Kr.prototype.getEndIndex = function() {
  return this._end;
};
Kr.prototype.getStartIndex = function() {
  return this._start;
};
Kr.prototype.getContext = function() {
  return this._context;
};
Kr.prototype.getId = function() {
  return this._id;
};
Kr.prototype.computeOverlapsInternal = function(t, e, n, i, s, o) {
  var a = this._pts[t], u = this._pts[e], x = n._pts[i], c = n._pts[s];
  if (e - t === 1 && s - i === 1)
    return o.overlap(this, t, n, i), null;
  if (o.tempEnv1.init(a, u), o.tempEnv2.init(x, c), !o.tempEnv1.intersects(o.tempEnv2))
    return null;
  var f = Math.trunc((t + e) / 2), l = Math.trunc((i + s) / 2);
  t < f && (i < l && this.computeOverlapsInternal(t, f, n, i, l, o), l < s && this.computeOverlapsInternal(t, f, n, l, s, o)), f < e && (i < l && this.computeOverlapsInternal(f, e, n, i, l, o), l < s && this.computeOverlapsInternal(f, e, n, l, s, o));
};
Kr.prototype.interfaces_ = function() {
  return [];
};
Kr.prototype.getClass = function() {
  return Kr;
};
var ms = function() {
};
ms.prototype.interfaces_ = function() {
  return [];
};
ms.prototype.getClass = function() {
  return ms;
};
ms.getChainStartIndices = function(t) {
  var e = 0, n = new H();
  n.add(new ws(e));
  do {
    var i = ms.findChainEnd(t, e);
    n.add(new ws(i)), e = i;
  } while (e < t.length - 1);
  var s = ms.toIntArray(n);
  return s;
};
ms.findChainEnd = function(t, e) {
  for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]); )
    n++;
  if (n >= t.length - 1)
    return t.length - 1;
  for (var i = be.quadrant(t[n], t[n + 1]), s = e + 1; s < t.length; ) {
    if (!t[s - 1].equals2D(t[s])) {
      var o = be.quadrant(t[s - 1], t[s]);
      if (o !== i)
        break;
    }
    s++;
  }
  return s - 1;
};
ms.getChains = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return ms.getChains(t, null);
  } else if (arguments.length === 2) {
    for (var e = arguments[0], n = arguments[1], i = new H(), s = ms.getChainStartIndices(e), o = 0; o < s.length - 1; o++) {
      var a = new Kr(e, s[o], s[o + 1], n);
      i.add(a);
    }
    return i;
  }
};
ms.toIntArray = function(t) {
  for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++)
    e[n] = t.get(n).intValue();
  return e;
};
var $a = function() {
};
$a.prototype.computeNodes = function(t) {
};
$a.prototype.getNodedSubstrings = function() {
};
$a.prototype.interfaces_ = function() {
  return [];
};
$a.prototype.getClass = function() {
  return $a;
};
var Cl = function() {
  if (this._segInt = null, arguments.length !== 0) {
    if (arguments.length === 1) {
      var t = arguments[0];
      this.setSegmentIntersector(t);
    }
  }
};
Cl.prototype.setSegmentIntersector = function(t) {
  this._segInt = t;
};
Cl.prototype.interfaces_ = function() {
  return [$a];
};
Cl.prototype.getClass = function() {
  return Cl;
};
var Z2 = function(r) {
  function t(n) {
    n ? r.call(this, n) : r.call(this), this._monoChains = new H(), this._index = new HS(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
  }
  r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t;
  var e = { SegmentOverlapAction: { configurable: !0 } };
  return t.prototype.getMonotoneChains = function() {
    return this._monoChains;
  }, t.prototype.getNodedSubstrings = function() {
    return sn.getNodedSubstrings(this._nodedSegStrings);
  }, t.prototype.getIndex = function() {
    return this._index;
  }, t.prototype.add = function(i) {
    for (var s = this, o = ms.getChains(i.getCoordinates(), i), a = o.iterator(); a.hasNext(); ) {
      var u = a.next();
      u.setId(s._idCounter++), s._index.insert(u.getEnvelope(), u), s._monoChains.add(u);
    }
  }, t.prototype.computeNodes = function(i) {
    var s = this;
    this._nodedSegStrings = i;
    for (var o = i.iterator(); o.hasNext(); )
      s.add(o.next());
    this.intersectChains();
  }, t.prototype.intersectChains = function() {
    for (var i = this, s = new S3(this._segInt), o = this._monoChains.iterator(); o.hasNext(); )
      for (var a = o.next(), u = i._index.query(a.getEnvelope()), x = u.iterator(); x.hasNext(); ) {
        var c = x.next();
        if (c.getId() > a.getId() && (a.computeOverlaps(c, s), i._nOverlaps++), i._segInt.isDone())
          return null;
      }
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, e.SegmentOverlapAction.get = function() {
    return S3;
  }, Object.defineProperties(t, e), t;
}(Cl), S3 = function(r) {
  function t() {
    r.call(this), this._si = null;
    var e = arguments[0];
    this._si = e;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.overlap = function() {
    if (arguments.length === 4) {
      var n = arguments[0], i = arguments[1], s = arguments[2], o = arguments[3], a = n.getContext(), u = s.getContext();
      this._si.processIntersections(a, i, u, o);
    } else
      return r.prototype.overlap.apply(this, arguments);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(Sl), ue = function r() {
  if (this._quadrantSegments = r.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = r.CAP_ROUND, this._joinStyle = r.JOIN_ROUND, this._mitreLimit = r.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = r.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
    if (arguments.length === 1) {
      var t = arguments[0];
      this.setQuadrantSegments(t);
    } else if (arguments.length === 2) {
      var e = arguments[0], n = arguments[1];
      this.setQuadrantSegments(e), this.setEndCapStyle(n);
    } else if (arguments.length === 4) {
      var i = arguments[0], s = arguments[1], o = arguments[2], a = arguments[3];
      this.setQuadrantSegments(i), this.setEndCapStyle(s), this.setJoinStyle(o), this.setMitreLimit(a);
    }
  }
}, Fo = { CAP_ROUND: { configurable: !0 }, CAP_FLAT: { configurable: !0 }, CAP_SQUARE: { configurable: !0 }, JOIN_ROUND: { configurable: !0 }, JOIN_MITRE: { configurable: !0 }, JOIN_BEVEL: { configurable: !0 }, DEFAULT_QUADRANT_SEGMENTS: { configurable: !0 }, DEFAULT_MITRE_LIMIT: { configurable: !0 }, DEFAULT_SIMPLIFY_FACTOR: { configurable: !0 } };
ue.prototype.getEndCapStyle = function() {
  return this._endCapStyle;
};
ue.prototype.isSingleSided = function() {
  return this._isSingleSided;
};
ue.prototype.setQuadrantSegments = function(t) {
  this._quadrantSegments = t, this._quadrantSegments === 0 && (this._joinStyle = ue.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = ue.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== ue.JOIN_ROUND && (this._quadrantSegments = ue.DEFAULT_QUADRANT_SEGMENTS);
};
ue.prototype.getJoinStyle = function() {
  return this._joinStyle;
};
ue.prototype.setJoinStyle = function(t) {
  this._joinStyle = t;
};
ue.prototype.setSimplifyFactor = function(t) {
  this._simplifyFactor = t < 0 ? 0 : t;
};
ue.prototype.getSimplifyFactor = function() {
  return this._simplifyFactor;
};
ue.prototype.getQuadrantSegments = function() {
  return this._quadrantSegments;
};
ue.prototype.setEndCapStyle = function(t) {
  this._endCapStyle = t;
};
ue.prototype.getMitreLimit = function() {
  return this._mitreLimit;
};
ue.prototype.setMitreLimit = function(t) {
  this._mitreLimit = t;
};
ue.prototype.setSingleSided = function(t) {
  this._isSingleSided = t;
};
ue.prototype.interfaces_ = function() {
  return [];
};
ue.prototype.getClass = function() {
  return ue;
};
ue.bufferDistanceError = function(t) {
  var e = Math.PI / 2 / t;
  return 1 - Math.cos(e / 2);
};
Fo.CAP_ROUND.get = function() {
  return 1;
};
Fo.CAP_FLAT.get = function() {
  return 2;
};
Fo.CAP_SQUARE.get = function() {
  return 3;
};
Fo.JOIN_ROUND.get = function() {
  return 1;
};
Fo.JOIN_MITRE.get = function() {
  return 2;
};
Fo.JOIN_BEVEL.get = function() {
  return 3;
};
Fo.DEFAULT_QUADRANT_SEGMENTS.get = function() {
  return 8;
};
Fo.DEFAULT_MITRE_LIMIT.get = function() {
  return 5;
};
Fo.DEFAULT_SIMPLIFY_FACTOR.get = function() {
  return 0.01;
};
Object.defineProperties(ue, Fo);
var $e = function(t) {
  this._distanceTol = null, this._isDeleted = null, this._angleOrientation = Z.COUNTERCLOCKWISE, this._inputLine = t || null;
}, th = { INIT: { configurable: !0 }, DELETE: { configurable: !0 }, KEEP: { configurable: !0 }, NUM_PTS_TO_CHECK: { configurable: !0 } };
$e.prototype.isDeletable = function(t, e, n, i) {
  var s = this._inputLine[t], o = this._inputLine[e], a = this._inputLine[n];
  return !this.isConcave(s, o, a) || !this.isShallow(s, o, a, i) ? !1 : this.isShallowSampled(s, o, t, n, i);
};
$e.prototype.deleteShallowConcavities = function() {
  for (var t = this, e = 1, n = this.findNextNonDeletedIndex(e), i = this.findNextNonDeletedIndex(n), s = !1; i < this._inputLine.length; ) {
    var o = !1;
    t.isDeletable(e, n, i, t._distanceTol) && (t._isDeleted[n] = $e.DELETE, o = !0, s = !0), o ? e = i : e = n, n = t.findNextNonDeletedIndex(e), i = t.findNextNonDeletedIndex(n);
  }
  return s;
};
$e.prototype.isShallowConcavity = function(t, e, n, i) {
  var s = Z.computeOrientation(t, e, n), o = s === this._angleOrientation;
  if (!o)
    return !1;
  var a = Z.distancePointLine(e, t, n);
  return a < i;
};
$e.prototype.isShallowSampled = function(t, e, n, i, s) {
  var o = this, a = Math.trunc((i - n) / $e.NUM_PTS_TO_CHECK);
  a <= 0 && (a = 1);
  for (var u = n; u < i; u += a)
    if (!o.isShallow(t, e, o._inputLine[u], s))
      return !1;
  return !0;
};
$e.prototype.isConcave = function(t, e, n) {
  var i = Z.computeOrientation(t, e, n), s = i === this._angleOrientation;
  return s;
};
$e.prototype.simplify = function(t) {
  var e = this;
  this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = Z.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
  var n = !1;
  do
    n = e.deleteShallowConcavities();
  while (n);
  return this.collapseLine();
};
$e.prototype.findNextNonDeletedIndex = function(t) {
  for (var e = t + 1; e < this._inputLine.length && this._isDeleted[e] === $e.DELETE; )
    e++;
  return e;
};
$e.prototype.isShallow = function(t, e, n, i) {
  var s = Z.distancePointLine(e, t, n);
  return s < i;
};
$e.prototype.collapseLine = function() {
  for (var t = this, e = new jl(), n = 0; n < this._inputLine.length; n++)
    t._isDeleted[n] !== $e.DELETE && e.add(t._inputLine[n]);
  return e.toCoordinateArray();
};
$e.prototype.interfaces_ = function() {
  return [];
};
$e.prototype.getClass = function() {
  return $e;
};
$e.simplify = function(t, e) {
  var n = new $e(t);
  return n.simplify(e);
};
th.INIT.get = function() {
  return 0;
};
th.DELETE.get = function() {
  return 1;
};
th.KEEP.get = function() {
  return 1;
};
th.NUM_PTS_TO_CHECK.get = function() {
  return 10;
};
Object.defineProperties($e, th);
var xi = function() {
  this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new H();
}, ZS = { COORDINATE_ARRAY_TYPE: { configurable: !0 } };
xi.prototype.getCoordinates = function() {
  var t = this._ptList.toArray(xi.COORDINATE_ARRAY_TYPE);
  return t;
};
xi.prototype.setPrecisionModel = function(t) {
  this._precisionModel = t;
};
xi.prototype.addPt = function(t) {
  var e = new R(t);
  if (this._precisionModel.makePrecise(e), this.isRedundant(e))
    return null;
  this._ptList.add(e);
};
xi.prototype.revere = function() {
};
xi.prototype.addPts = function(t, e) {
  var n = this;
  if (e)
    for (var i = 0; i < t.length; i++)
      n.addPt(t[i]);
  else
    for (var s = t.length - 1; s >= 0; s--)
      n.addPt(t[s]);
};
xi.prototype.isRedundant = function(t) {
  if (this._ptList.size() < 1)
    return !1;
  var e = this._ptList.get(this._ptList.size() - 1), n = t.distance(e);
  return n < this._minimimVertexDistance;
};
xi.prototype.toString = function() {
  var t = new St(), e = t.createLineString(this.getCoordinates());
  return e.toString();
};
xi.prototype.closeRing = function() {
  if (this._ptList.size() < 1)
    return null;
  var t = new R(this._ptList.get(0)), e = this._ptList.get(this._ptList.size() - 1);
  if (t.equals(e))
    return null;
  this._ptList.add(t);
};
xi.prototype.setMinimumVertexDistance = function(t) {
  this._minimimVertexDistance = t;
};
xi.prototype.interfaces_ = function() {
  return [];
};
xi.prototype.getClass = function() {
  return xi;
};
ZS.COORDINATE_ARRAY_TYPE.get = function() {
  return new Array(0).fill(null);
};
Object.defineProperties(xi, ZS);
var Ot = function() {
}, du = { PI_TIMES_2: { configurable: !0 }, PI_OVER_2: { configurable: !0 }, PI_OVER_4: { configurable: !0 }, COUNTERCLOCKWISE: { configurable: !0 }, CLOCKWISE: { configurable: !0 }, NONE: { configurable: !0 } };
Ot.prototype.interfaces_ = function() {
  return [];
};
Ot.prototype.getClass = function() {
  return Ot;
};
Ot.toDegrees = function(t) {
  return t * 180 / Math.PI;
};
Ot.normalize = function(t) {
  for (; t > Math.PI; )
    t -= Ot.PI_TIMES_2;
  for (; t <= -Math.PI; )
    t += Ot.PI_TIMES_2;
  return t;
};
Ot.angle = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return Math.atan2(t.y, t.x);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1], i = n.x - e.x, s = n.y - e.y;
    return Math.atan2(s, i);
  }
};
Ot.isAcute = function(t, e, n) {
  var i = t.x - e.x, s = t.y - e.y, o = n.x - e.x, a = n.y - e.y, u = i * o + s * a;
  return u > 0;
};
Ot.isObtuse = function(t, e, n) {
  var i = t.x - e.x, s = t.y - e.y, o = n.x - e.x, a = n.y - e.y, u = i * o + s * a;
  return u < 0;
};
Ot.interiorAngle = function(t, e, n) {
  var i = Ot.angle(e, t), s = Ot.angle(e, n);
  return Math.abs(s - i);
};
Ot.normalizePositive = function(t) {
  if (t < 0) {
    for (; t < 0; )
      t += Ot.PI_TIMES_2;
    t >= Ot.PI_TIMES_2 && (t = 0);
  } else {
    for (; t >= Ot.PI_TIMES_2; )
      t -= Ot.PI_TIMES_2;
    t < 0 && (t = 0);
  }
  return t;
};
Ot.angleBetween = function(t, e, n) {
  var i = Ot.angle(e, t), s = Ot.angle(e, n);
  return Ot.diff(i, s);
};
Ot.diff = function(t, e) {
  var n = null;
  return t < e ? n = e - t : n = t - e, n > Math.PI && (n = 2 * Math.PI - n), n;
};
Ot.toRadians = function(t) {
  return t * Math.PI / 180;
};
Ot.getTurn = function(t, e) {
  var n = Math.sin(e - t);
  return n > 0 ? Ot.COUNTERCLOCKWISE : n < 0 ? Ot.CLOCKWISE : Ot.NONE;
};
Ot.angleBetweenOriented = function(t, e, n) {
  var i = Ot.angle(e, t), s = Ot.angle(e, n), o = s - i;
  return o <= -Math.PI ? o + Ot.PI_TIMES_2 : o > Math.PI ? o - Ot.PI_TIMES_2 : o;
};
du.PI_TIMES_2.get = function() {
  return 2 * Math.PI;
};
du.PI_OVER_2.get = function() {
  return Math.PI / 2;
};
du.PI_OVER_4.get = function() {
  return Math.PI / 4;
};
du.COUNTERCLOCKWISE.get = function() {
  return Z.COUNTERCLOCKWISE;
};
du.CLOCKWISE.get = function() {
  return Z.CLOCKWISE;
};
du.NONE.get = function() {
  return Z.COLLINEAR;
};
Object.defineProperties(Ot, du);
var Be = function r() {
  this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new rt(), this._seg1 = new rt(), this._offset0 = new rt(), this._offset1 = new rt(), this._side = 0, this._hasNarrowConcaveAngle = !1;
  var t = arguments[0], e = arguments[1], n = arguments[2];
  this._precisionModel = t, this._bufParams = e, this._li = new l0(), this._filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), e.getQuadrantSegments() >= 8 && e.getJoinStyle() === ue.JOIN_ROUND && (this._closingSegLengthFactor = r.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n);
}, eh = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: !0 }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: !0 }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: !0 }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: !0 } };
Be.prototype.addNextSegment = function(t, e) {
  if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2))
    return null;
  var n = Z.computeOrientation(this._s0, this._s1, this._s2), i = n === Z.CLOCKWISE && this._side === z.LEFT || n === Z.COUNTERCLOCKWISE && this._side === z.RIGHT;
  n === 0 ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);
};
Be.prototype.addLineEndCap = function(t, e) {
  var n = new rt(t, e), i = new rt();
  this.computeOffsetSegment(n, z.LEFT, this._distance, i);
  var s = new rt();
  this.computeOffsetSegment(n, z.RIGHT, this._distance, s);
  var o = e.x - t.x, a = e.y - t.y, u = Math.atan2(a, o);
  switch (this._bufParams.getEndCapStyle()) {
    case ue.CAP_ROUND:
      this._segList.addPt(i.p1), this.addFilletArc(e, u + Math.PI / 2, u - Math.PI / 2, Z.CLOCKWISE, this._distance), this._segList.addPt(s.p1);
      break;
    case ue.CAP_FLAT:
      this._segList.addPt(i.p1), this._segList.addPt(s.p1);
      break;
    case ue.CAP_SQUARE:
      var x = new R();
      x.x = Math.abs(this._distance) * Math.cos(u), x.y = Math.abs(this._distance) * Math.sin(u);
      var c = new R(i.p1.x + x.x, i.p1.y + x.y), f = new R(s.p1.x + x.x, s.p1.y + x.y);
      this._segList.addPt(c), this._segList.addPt(f);
      break;
  }
};
Be.prototype.getCoordinates = function() {
  var t = this._segList.getCoordinates();
  return t;
};
Be.prototype.addMitreJoin = function(t, e, n, i) {
  var s = !0, o = null;
  try {
    o = qi.intersection(e.p0, e.p1, n.p0, n.p1);
    var a = i <= 0 ? 1 : o.distance(t) / Math.abs(i);
    a > this._bufParams.getMitreLimit() && (s = !1);
  } catch (u) {
    if (u instanceof oc)
      o = new R(0, 0), s = !1;
    else
      throw u;
  } finally {
  }
  s ? this._segList.addPt(o) : this.addLimitedMitreJoin(e, n, i, this._bufParams.getMitreLimit());
};
Be.prototype.addFilletCorner = function(t, e, n, i, s) {
  var o = e.x - t.x, a = e.y - t.y, u = Math.atan2(a, o), x = n.x - t.x, c = n.y - t.y, f = Math.atan2(c, x);
  i === Z.CLOCKWISE ? u <= f && (u += 2 * Math.PI) : u >= f && (u -= 2 * Math.PI), this._segList.addPt(e), this.addFilletArc(t, u, f, i, s), this._segList.addPt(n);
};
Be.prototype.addOutsideTurn = function(t, e) {
  if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Be.OFFSET_SEGMENT_SEPARATION_FACTOR)
    return this._segList.addPt(this._offset0.p1), null;
  this._bufParams.getJoinStyle() === ue.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === ue.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0));
};
Be.prototype.createSquare = function(t) {
  this._segList.addPt(new R(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new R(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new R(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new R(t.x - this._distance, t.y + this._distance)), this._segList.closeRing();
};
Be.prototype.addSegments = function(t, e) {
  this._segList.addPts(t, e);
};
Be.prototype.addFirstSegment = function() {
  this._segList.addPt(this._offset1.p0);
};
Be.prototype.addLastSegment = function() {
  this._segList.addPt(this._offset1.p1);
};
Be.prototype.initSideSegments = function(t, e, n) {
  this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1);
};
Be.prototype.addLimitedMitreJoin = function(t, e, n, i) {
  var s = this._seg0.p1, o = Ot.angle(s, this._seg0.p0), a = Ot.angleBetweenOriented(this._seg0.p0, s, this._seg1.p1), u = a / 2, x = Ot.normalize(o + u), c = Ot.normalize(x + Math.PI), f = i * n, l = f * Math.abs(Math.sin(u)), h = n - l, p = s.x + f * Math.cos(c), y = s.y + f * Math.sin(c), v = new R(p, y), m = new rt(s, v), d = m.pointAlongOffset(1, h), g = m.pointAlongOffset(1, -h);
  this._side === z.LEFT ? (this._segList.addPt(d), this._segList.addPt(g)) : (this._segList.addPt(g), this._segList.addPt(d));
};
Be.prototype.computeOffsetSegment = function(t, e, n, i) {
  var s = e === z.LEFT ? 1 : -1, o = t.p1.x - t.p0.x, a = t.p1.y - t.p0.y, u = Math.sqrt(o * o + a * a), x = s * n * o / u, c = s * n * a / u;
  i.p0.x = t.p0.x - c, i.p0.y = t.p0.y + x, i.p1.x = t.p1.x - c, i.p1.y = t.p1.y + x;
};
Be.prototype.addFilletArc = function(t, e, n, i, s) {
  var o = this, a = i === Z.CLOCKWISE ? -1 : 1, u = Math.abs(e - n), x = Math.trunc(u / this._filletAngleQuantum + 0.5);
  if (x < 1)
    return null;
  for (var c = 0, f = u / x, l = c, h = new R(); l < u; ) {
    var p = e + a * l;
    h.x = t.x + s * Math.cos(p), h.y = t.y + s * Math.sin(p), o._segList.addPt(h), l += f;
  }
};
Be.prototype.addInsideTurn = function(t, e) {
  if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection())
    this._segList.addPt(this._li.getIntersection(0));
  else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * Be.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
    this._segList.addPt(this._offset0.p1);
  else {
    if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
      var n = new R((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
      this._segList.addPt(n);
      var i = new R((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
      this._segList.addPt(i);
    } else
      this._segList.addPt(this._s1);
    this._segList.addPt(this._offset1.p0);
  }
};
Be.prototype.createCircle = function(t) {
  var e = new R(t.x + this._distance, t.y);
  this._segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
};
Be.prototype.addBevelJoin = function(t, e) {
  this._segList.addPt(t.p1), this._segList.addPt(e.p0);
};
Be.prototype.init = function(t) {
  this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new xi(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * Be.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
};
Be.prototype.addCollinear = function(t) {
  this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
  var e = this._li.getIntersectionNum();
  e >= 2 && (this._bufParams.getJoinStyle() === ue.JOIN_BEVEL || this._bufParams.getJoinStyle() === ue.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, Z.CLOCKWISE, this._distance));
};
Be.prototype.closeRing = function() {
  this._segList.closeRing();
};
Be.prototype.hasNarrowConcaveAngle = function() {
  return this._hasNarrowConcaveAngle;
};
Be.prototype.interfaces_ = function() {
  return [];
};
Be.prototype.getClass = function() {
  return Be;
};
eh.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
  return 1e-3;
};
eh.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
  return 1e-3;
};
eh.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
  return 1e-6;
};
eh.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
  return 80;
};
Object.defineProperties(Be, eh);
var kr = function() {
  this._distance = 0, this._precisionModel = null, this._bufParams = null;
  var t = arguments[0], e = arguments[1];
  this._precisionModel = t, this._bufParams = e;
};
kr.prototype.getOffsetCurve = function(t, e) {
  if (this._distance = e, e === 0)
    return null;
  var n = e < 0, i = Math.abs(e), s = this.getSegGen(i);
  t.length <= 1 ? this.computePointCurve(t[0], s) : this.computeOffsetCurve(t, n, s);
  var o = s.getCoordinates();
  return n && Ct.reverse(o), o;
};
kr.prototype.computeSingleSidedBufferCurve = function(t, e, n) {
  var i = this.simplifyTolerance(this._distance);
  if (e) {
    n.addSegments(t, !0);
    var s = $e.simplify(t, -i), o = s.length - 1;
    n.initSideSegments(s[o], s[o - 1], z.LEFT), n.addFirstSegment();
    for (var a = o - 2; a >= 0; a--)
      n.addNextSegment(s[a], !0);
  } else {
    n.addSegments(t, !1);
    var u = $e.simplify(t, i), x = u.length - 1;
    n.initSideSegments(u[0], u[1], z.LEFT), n.addFirstSegment();
    for (var c = 2; c <= x; c++)
      n.addNextSegment(u[c], !0);
  }
  n.addLastSegment(), n.closeRing();
};
kr.prototype.computeRingBufferCurve = function(t, e, n) {
  var i = this.simplifyTolerance(this._distance);
  e === z.RIGHT && (i = -i);
  var s = $e.simplify(t, i), o = s.length - 1;
  n.initSideSegments(s[o - 1], s[0], e);
  for (var a = 1; a <= o; a++) {
    var u = a !== 1;
    n.addNextSegment(s[a], u);
  }
  n.closeRing();
};
kr.prototype.computeLineBufferCurve = function(t, e) {
  var n = this.simplifyTolerance(this._distance), i = $e.simplify(t, n), s = i.length - 1;
  e.initSideSegments(i[0], i[1], z.LEFT);
  for (var o = 2; o <= s; o++)
    e.addNextSegment(i[o], !0);
  e.addLastSegment(), e.addLineEndCap(i[s - 1], i[s]);
  var a = $e.simplify(t, -n), u = a.length - 1;
  e.initSideSegments(a[u], a[u - 1], z.LEFT);
  for (var x = u - 2; x >= 0; x--)
    e.addNextSegment(a[x], !0);
  e.addLastSegment(), e.addLineEndCap(a[1], a[0]), e.closeRing();
};
kr.prototype.computePointCurve = function(t, e) {
  switch (this._bufParams.getEndCapStyle()) {
    case ue.CAP_ROUND:
      e.createCircle(t);
      break;
    case ue.CAP_SQUARE:
      e.createSquare(t);
      break;
  }
};
kr.prototype.getLineCurve = function(t, e) {
  if (this._distance = e, e < 0 && !this._bufParams.isSingleSided() || e === 0)
    return null;
  var n = Math.abs(e), i = this.getSegGen(n);
  if (t.length <= 1)
    this.computePointCurve(t[0], i);
  else if (this._bufParams.isSingleSided()) {
    var s = e < 0;
    this.computeSingleSidedBufferCurve(t, s, i);
  } else
    this.computeLineBufferCurve(t, i);
  var o = i.getCoordinates();
  return o;
};
kr.prototype.getBufferParameters = function() {
  return this._bufParams;
};
kr.prototype.simplifyTolerance = function(t) {
  return t * this._bufParams.getSimplifyFactor();
};
kr.prototype.getRingCurve = function(t, e, n) {
  if (this._distance = n, t.length <= 2)
    return this.getLineCurve(t, n);
  if (n === 0)
    return kr.copyCoordinates(t);
  var i = this.getSegGen(n);
  return this.computeRingBufferCurve(t, e, i), i.getCoordinates();
};
kr.prototype.computeOffsetCurve = function(t, e, n) {
  var i = this.simplifyTolerance(this._distance);
  if (e) {
    var s = $e.simplify(t, -i), o = s.length - 1;
    n.initSideSegments(s[o], s[o - 1], z.LEFT), n.addFirstSegment();
    for (var a = o - 2; a >= 0; a--)
      n.addNextSegment(s[a], !0);
  } else {
    var u = $e.simplify(t, i), x = u.length - 1;
    n.initSideSegments(u[0], u[1], z.LEFT), n.addFirstSegment();
    for (var c = 2; c <= x; c++)
      n.addNextSegment(u[c], !0);
  }
  n.addLastSegment();
};
kr.prototype.getSegGen = function(t) {
  return new Be(this._precisionModel, this._bufParams, t);
};
kr.prototype.interfaces_ = function() {
  return [];
};
kr.prototype.getClass = function() {
  return kr;
};
kr.copyCoordinates = function(t) {
  for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++)
    e[n] = new R(t[n]);
  return e;
};
var Q0 = function() {
  this._subgraphs = null, this._seg = new rt(), this._cga = new Z();
  var t = arguments[0];
  this._subgraphs = t;
}, KS = { DepthSegment: { configurable: !0 } };
Q0.prototype.findStabbedSegments = function() {
  var t = this;
  if (arguments.length === 1) {
    for (var e = arguments[0], n = new H(), i = this._subgraphs.iterator(); i.hasNext(); ) {
      var s = i.next(), o = s.getEnvelope();
      e.y < o.getMinY() || e.y > o.getMaxY() || t.findStabbedSegments(e, s.getDirectedEdges(), n);
    }
    return n;
  } else if (arguments.length === 3) {
    if (ct(arguments[2], zi) && arguments[0] instanceof R && arguments[1] instanceof r_)
      for (var a = arguments[0], u = arguments[1], x = arguments[2], c = u.getEdge().getCoordinates(), f = 0; f < c.length - 1; f++) {
        t._seg.p0 = c[f], t._seg.p1 = c[f + 1], t._seg.p0.y > t._seg.p1.y && t._seg.reverse();
        var l = Math.max(t._seg.p0.x, t._seg.p1.x);
        if (!(l < a.x) && !t._seg.isHorizontal() && !(a.y < t._seg.p0.y || a.y > t._seg.p1.y) && Z.computeOrientation(t._seg.p0, t._seg.p1, a) !== Z.RIGHT) {
          var h = u.getDepth(z.LEFT);
          t._seg.p0.equals(c[f]) || (h = u.getDepth(z.RIGHT));
          var p = new t0(t._seg, h);
          x.add(p);
        }
      }
    else if (ct(arguments[2], zi) && arguments[0] instanceof R && ct(arguments[1], zi))
      for (var y = arguments[0], v = arguments[1], m = arguments[2], d = v.iterator(); d.hasNext(); ) {
        var g = d.next();
        g.isForward() && t.findStabbedSegments(y, g, m);
      }
  }
};
Q0.prototype.getDepth = function(t) {
  var e = this.findStabbedSegments(t);
  if (e.size() === 0)
    return 0;
  var n = Ji.min(e);
  return n._leftDepth;
};
Q0.prototype.interfaces_ = function() {
  return [];
};
Q0.prototype.getClass = function() {
  return Q0;
};
KS.DepthSegment.get = function() {
  return t0;
};
Object.defineProperties(Q0, KS);
var t0 = function() {
  this._upwardSeg = null, this._leftDepth = null;
  var t = arguments[0], e = arguments[1];
  this._upwardSeg = new rt(t), this._leftDepth = e;
};
t0.prototype.compareTo = function(t) {
  var e = t;
  if (this._upwardSeg.minX() >= e._upwardSeg.maxX())
    return 1;
  if (this._upwardSeg.maxX() <= e._upwardSeg.minX())
    return -1;
  var n = this._upwardSeg.orientationIndex(e._upwardSeg);
  return n !== 0 || (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg), n !== 0) ? n : this._upwardSeg.compareTo(e._upwardSeg);
};
t0.prototype.compareX = function(t, e) {
  var n = t.p0.compareTo(e.p0);
  return n !== 0 ? n : t.p1.compareTo(e.p1);
};
t0.prototype.toString = function() {
  return this._upwardSeg.toString();
};
t0.prototype.interfaces_ = function() {
  return [Ri];
};
t0.prototype.getClass = function() {
  return t0;
};
var ce = function(t, e, n) {
  this.p0 = t || null, this.p1 = e || null, this.p2 = n || null;
};
ce.prototype.area = function() {
  return ce.area(this.p0, this.p1, this.p2);
};
ce.prototype.signedArea = function() {
  return ce.signedArea(this.p0, this.p1, this.p2);
};
ce.prototype.interpolateZ = function(t) {
  if (t === null)
    throw new ze("Supplied point is null.");
  return ce.interpolateZ(t, this.p0, this.p1, this.p2);
};
ce.prototype.longestSideLength = function() {
  return ce.longestSideLength(this.p0, this.p1, this.p2);
};
ce.prototype.isAcute = function() {
  return ce.isAcute(this.p0, this.p1, this.p2);
};
ce.prototype.circumcentre = function() {
  return ce.circumcentre(this.p0, this.p1, this.p2);
};
ce.prototype.area3D = function() {
  return ce.area3D(this.p0, this.p1, this.p2);
};
ce.prototype.centroid = function() {
  return ce.centroid(this.p0, this.p1, this.p2);
};
ce.prototype.inCentre = function() {
  return ce.inCentre(this.p0, this.p1, this.p2);
};
ce.prototype.interfaces_ = function() {
  return [];
};
ce.prototype.getClass = function() {
  return ce;
};
ce.area = function(t, e, n) {
  return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);
};
ce.signedArea = function(t, e, n) {
  return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;
};
ce.det = function(t, e, n, i) {
  return t * i - e * n;
};
ce.interpolateZ = function(t, e, n, i) {
  var s = e.x, o = e.y, a = n.x - s, u = i.x - s, x = n.y - o, c = i.y - o, f = a * c - u * x, l = t.x - s, h = t.y - o, p = (c * l - u * h) / f, y = (-x * l + a * h) / f, v = e.z + p * (n.z - e.z) + y * (i.z - e.z);
  return v;
};
ce.longestSideLength = function(t, e, n) {
  var i = t.distance(e), s = e.distance(n), o = n.distance(t), a = i;
  return s > a && (a = s), o > a && (a = o), a;
};
ce.isAcute = function(t, e, n) {
  return !(!Ot.isAcute(t, e, n) || !Ot.isAcute(e, n, t) || !Ot.isAcute(n, t, e));
};
ce.circumcentre = function(t, e, n) {
  var i = n.x, s = n.y, o = t.x - i, a = t.y - s, u = e.x - i, x = e.y - s, c = 2 * ce.det(o, a, u, x), f = ce.det(a, o * o + a * a, x, u * u + x * x), l = ce.det(o, o * o + a * a, u, u * u + x * x), h = i - f / c, p = s + l / c;
  return new R(h, p);
};
ce.perpendicularBisector = function(t, e) {
  var n = e.x - t.x, i = e.y - t.y, s = new qi(t.x + n / 2, t.y + i / 2, 1), o = new qi(t.x - i + n / 2, t.y + n + i / 2, 1);
  return new qi(s, o);
};
ce.angleBisector = function(t, e, n) {
  var i = e.distance(t), s = e.distance(n), o = i / (i + s), a = n.x - t.x, u = n.y - t.y, x = new R(t.x + o * a, t.y + o * u);
  return x;
};
ce.area3D = function(t, e, n) {
  var i = e.x - t.x, s = e.y - t.y, o = e.z - t.z, a = n.x - t.x, u = n.y - t.y, x = n.z - t.z, c = s * x - o * u, f = o * a - i * x, l = i * u - s * a, h = c * c + f * f + l * l, p = Math.sqrt(h) / 2;
  return p;
};
ce.centroid = function(t, e, n) {
  var i = (t.x + e.x + n.x) / 3, s = (t.y + e.y + n.y) / 3;
  return new R(i, s);
};
ce.inCentre = function(t, e, n) {
  var i = e.distance(n), s = t.distance(n), o = t.distance(e), a = i + s + o, u = (i * t.x + s * e.x + o * n.x) / a, x = (i * t.y + s * e.y + o * n.y) / a;
  return new R(u, x);
};
var Oi = function() {
  this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new H();
  var t = arguments[0], e = arguments[1], n = arguments[2];
  this._inputGeom = t, this._distance = e, this._curveBuilder = n;
};
Oi.prototype.addPoint = function(t) {
  if (this._distance <= 0)
    return null;
  var e = t.getCoordinates(), n = this._curveBuilder.getLineCurve(e, this._distance);
  this.addCurve(n, A.EXTERIOR, A.INTERIOR);
};
Oi.prototype.addPolygon = function(t) {
  var e = this, n = this._distance, i = z.LEFT;
  this._distance < 0 && (n = -this._distance, i = z.RIGHT);
  var s = t.getExteriorRing(), o = Ct.removeRepeatedPoints(s.getCoordinates());
  if (this._distance < 0 && this.isErodedCompletely(s, this._distance) || this._distance <= 0 && o.length < 3)
    return null;
  this.addPolygonRing(o, n, i, A.EXTERIOR, A.INTERIOR);
  for (var a = 0; a < t.getNumInteriorRing(); a++) {
    var u = t.getInteriorRingN(a), x = Ct.removeRepeatedPoints(u.getCoordinates());
    e._distance > 0 && e.isErodedCompletely(u, -e._distance) || e.addPolygonRing(x, n, z.opposite(i), A.INTERIOR, A.EXTERIOR);
  }
};
Oi.prototype.isTriangleErodedCompletely = function(t, e) {
  var n = new ce(t[0], t[1], t[2]), i = n.inCentre(), s = Z.distancePointLine(i, n.p0, n.p1);
  return s < Math.abs(e);
};
Oi.prototype.addLineString = function(t) {
  if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided())
    return null;
  var e = Ct.removeRepeatedPoints(t.getCoordinates()), n = this._curveBuilder.getLineCurve(e, this._distance);
  this.addCurve(n, A.EXTERIOR, A.INTERIOR);
};
Oi.prototype.addCurve = function(t, e, n) {
  if (t === null || t.length < 2)
    return null;
  var i = new sn(t, new ye(0, A.BOUNDARY, e, n));
  this._curveList.add(i);
};
Oi.prototype.getCurves = function() {
  return this.add(this._inputGeom), this._curveList;
};
Oi.prototype.addPolygonRing = function(t, e, n, i, s) {
  if (e === 0 && t.length < js.MINIMUM_VALID_SIZE)
    return null;
  var o = i, a = s;
  t.length >= js.MINIMUM_VALID_SIZE && Z.isCCW(t) && (o = s, a = i, n = z.opposite(n));
  var u = this._curveBuilder.getRingCurve(t, n, e);
  this.addCurve(u, o, a);
};
Oi.prototype.add = function(t) {
  if (t.isEmpty())
    return null;
  t instanceof Mn ? this.addPolygon(t) : t instanceof je ? this.addLineString(t) : t instanceof Jr ? this.addPoint(t) : t instanceof Gx ? this.addCollection(t) : t instanceof Qa ? this.addCollection(t) : t instanceof Vs ? this.addCollection(t) : t instanceof Ir && this.addCollection(t);
};
Oi.prototype.isErodedCompletely = function(t, e) {
  var n = t.getCoordinates();
  if (n.length < 4)
    return e < 0;
  if (n.length === 4)
    return this.isTriangleErodedCompletely(n, e);
  var i = t.getEnvelopeInternal(), s = Math.min(i.getHeight(), i.getWidth());
  return e < 0 && 2 * Math.abs(e) > s;
};
Oi.prototype.addCollection = function(t) {
  for (var e = this, n = 0; n < t.getNumGeometries(); n++) {
    var i = t.getGeometryN(n);
    e.add(i);
  }
};
Oi.prototype.interfaces_ = function() {
  return [];
};
Oi.prototype.getClass = function() {
  return Oi;
};
var zx = function() {
};
zx.prototype.locate = function(t) {
};
zx.prototype.interfaces_ = function() {
  return [];
};
zx.prototype.getClass = function() {
  return zx;
};
var Ws = function() {
  this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
  var t = arguments[0];
  this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries();
};
Ws.prototype.next = function() {
  if (this._atStart)
    return this._atStart = !1, Ws.isAtomic(this._parent) && this._index++, this._parent;
  if (this._subcollectionIterator !== null) {
    if (this._subcollectionIterator.hasNext())
      return this._subcollectionIterator.next();
    this._subcollectionIterator = null;
  }
  if (this._index >= this._max)
    throw new uc();
  var t = this._parent.getGeometryN(this._index++);
  return t instanceof Ir ? (this._subcollectionIterator = new Ws(t), this._subcollectionIterator.next()) : t;
};
Ws.prototype.remove = function() {
  throw new Error(this.getClass().getName());
};
Ws.prototype.hasNext = function() {
  if (this._atStart)
    return !0;
  if (this._subcollectionIterator !== null) {
    if (this._subcollectionIterator.hasNext())
      return !0;
    this._subcollectionIterator = null;
  }
  return !(this._index >= this._max);
};
Ws.prototype.interfaces_ = function() {
  return [ac];
};
Ws.prototype.getClass = function() {
  return Ws;
};
Ws.isAtomic = function(t) {
  return !(t instanceof Ir);
};
var si = function() {
  this._geom = null;
  var t = arguments[0];
  this._geom = t;
};
si.prototype.locate = function(t) {
  return si.locate(t, this._geom);
};
si.prototype.interfaces_ = function() {
  return [zx];
};
si.prototype.getClass = function() {
  return si;
};
si.isPointInRing = function(t, e) {
  return e.getEnvelopeInternal().intersects(t) ? Z.isPointInRing(t, e.getCoordinates()) : !1;
};
si.containsPointInPolygon = function(t, e) {
  if (e.isEmpty())
    return !1;
  var n = e.getExteriorRing();
  if (!si.isPointInRing(t, n))
    return !1;
  for (var i = 0; i < e.getNumInteriorRing(); i++) {
    var s = e.getInteriorRingN(i);
    if (si.isPointInRing(t, s))
      return !1;
  }
  return !0;
};
si.containsPoint = function(t, e) {
  if (e instanceof Mn)
    return si.containsPointInPolygon(t, e);
  if (e instanceof Ir)
    for (var n = new Ws(e); n.hasNext(); ) {
      var i = n.next();
      if (i !== e && si.containsPoint(t, i))
        return !0;
    }
  return !1;
};
si.locate = function(t, e) {
  return e.isEmpty() ? A.EXTERIOR : si.containsPoint(t, e) ? A.INTERIOR : A.EXTERIOR;
};
var ur = function() {
  this._edgeMap = new or(), this._edgeList = null, this._ptInAreaLocation = [A.NONE, A.NONE];
};
ur.prototype.getNextCW = function(t) {
  this.getEdges();
  var e = this._edgeList.indexOf(t), n = e - 1;
  return e === 0 && (n = this._edgeList.size() - 1), this._edgeList.get(n);
};
ur.prototype.propagateSideLabels = function(t) {
  for (var e = A.NONE, n = this.iterator(); n.hasNext(); ) {
    var i = n.next(), s = i.getLabel();
    s.isArea(t) && s.getLocation(t, z.LEFT) !== A.NONE && (e = s.getLocation(t, z.LEFT));
  }
  if (e === A.NONE)
    return null;
  for (var o = e, a = this.iterator(); a.hasNext(); ) {
    var u = a.next(), x = u.getLabel();
    if (x.getLocation(t, z.ON) === A.NONE && x.setLocation(t, z.ON, o), x.isArea(t)) {
      var c = x.getLocation(t, z.LEFT), f = x.getLocation(t, z.RIGHT);
      if (f !== A.NONE) {
        if (f !== o)
          throw new Mo("side location conflict", u.getCoordinate());
        c === A.NONE && mt.shouldNeverReachHere("found single null side (at " + u.getCoordinate() + ")"), o = c;
      } else
        mt.isTrue(x.getLocation(t, z.LEFT) === A.NONE, "found single null side"), x.setLocation(t, z.RIGHT, o), x.setLocation(t, z.LEFT, o);
    }
  }
};
ur.prototype.getCoordinate = function() {
  var t = this.iterator();
  if (!t.hasNext())
    return null;
  var e = t.next();
  return e.getCoordinate();
};
ur.prototype.print = function(t) {
  Hn.out.println("EdgeEndStar:   " + this.getCoordinate());
  for (var e = this.iterator(); e.hasNext(); ) {
    var n = e.next();
    n.print(t);
  }
};
ur.prototype.isAreaLabelsConsistent = function(t) {
  return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
};
ur.prototype.checkAreaLabelsConsistent = function(t) {
  var e = this.getEdges();
  if (e.size() <= 0)
    return !0;
  var n = e.size() - 1, i = e.get(n).getLabel(), s = i.getLocation(t, z.LEFT);
  mt.isTrue(s !== A.NONE, "Found unlabelled area edge");
  for (var o = s, a = this.iterator(); a.hasNext(); ) {
    var u = a.next(), x = u.getLabel();
    mt.isTrue(x.isArea(t), "Found non-area edge");
    var c = x.getLocation(t, z.LEFT), f = x.getLocation(t, z.RIGHT);
    if (c === f || f !== o)
      return !1;
    o = c;
  }
  return !0;
};
ur.prototype.findIndex = function(t) {
  var e = this;
  this.iterator();
  for (var n = 0; n < this._edgeList.size(); n++) {
    var i = e._edgeList.get(n);
    if (i === t)
      return n;
  }
  return -1;
};
ur.prototype.iterator = function() {
  return this.getEdges().iterator();
};
ur.prototype.getEdges = function() {
  return this._edgeList === null && (this._edgeList = new H(this._edgeMap.values())), this._edgeList;
};
ur.prototype.getLocation = function(t, e, n) {
  return this._ptInAreaLocation[t] === A.NONE && (this._ptInAreaLocation[t] = si.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t];
};
ur.prototype.toString = function() {
  var t = new As();
  t.append("EdgeEndStar:   " + this.getCoordinate()), t.append(`
`);
  for (var e = this.iterator(); e.hasNext(); ) {
    var n = e.next();
    t.append(n), t.append(`
`);
  }
  return t.toString();
};
ur.prototype.computeEdgeEndLabels = function(t) {
  for (var e = this.iterator(); e.hasNext(); ) {
    var n = e.next();
    n.computeLabel(t);
  }
};
ur.prototype.computeLabelling = function(t) {
  var e = this;
  this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
  for (var n = [!1, !1], i = this.iterator(); i.hasNext(); )
    for (var s = i.next(), o = s.getLabel(), a = 0; a < 2; a++)
      o.isLine(a) && o.getLocation(a) === A.BOUNDARY && (n[a] = !0);
  for (var u = this.iterator(); u.hasNext(); )
    for (var x = u.next(), c = x.getLabel(), f = 0; f < 2; f++)
      if (c.isAnyNull(f)) {
        var l = A.NONE;
        if (n[f])
          l = A.EXTERIOR;
        else {
          var h = x.getCoordinate();
          l = e.getLocation(f, h, t);
        }
        c.setAllLocationsIfNull(f, l);
      }
};
ur.prototype.getDegree = function() {
  return this._edgeMap.size();
};
ur.prototype.insertEdgeEnd = function(t, e) {
  this._edgeMap.put(t, e), this._edgeList = null;
};
ur.prototype.interfaces_ = function() {
  return [];
};
ur.prototype.getClass = function() {
  return ur;
};
var yF = function(r) {
  function t() {
    r.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.linkResultDirectedEdges = function() {
    var n = this;
    this.getResultAreaEdges();
    for (var i = null, s = null, o = this._SCANNING_FOR_INCOMING, a = 0; a < this._resultAreaEdgeList.size(); a++) {
      var u = n._resultAreaEdgeList.get(a), x = u.getSym();
      if (u.getLabel().isArea())
        switch (i === null && u.isInResult() && (i = u), o) {
          case n._SCANNING_FOR_INCOMING:
            if (!x.isInResult())
              continue;
            s = x, o = n._LINKING_TO_OUTGOING;
            break;
          case n._LINKING_TO_OUTGOING:
            if (!u.isInResult())
              continue;
            s.setNext(u), o = n._SCANNING_FOR_INCOMING;
            break;
        }
    }
    if (o === this._LINKING_TO_OUTGOING) {
      if (i === null)
        throw new Mo("no outgoing dirEdge found", this.getCoordinate());
      mt.isTrue(i.isInResult(), "unable to link last incoming dirEdge"), s.setNext(i);
    }
  }, t.prototype.insert = function(n) {
    var i = n;
    this.insertEdgeEnd(i, i);
  }, t.prototype.getRightmostEdge = function() {
    var n = this.getEdges(), i = n.size();
    if (i < 1)
      return null;
    var s = n.get(0);
    if (i === 1)
      return s;
    var o = n.get(i - 1), a = s.getQuadrant(), u = o.getQuadrant();
    return be.isNorthern(a) && be.isNorthern(u) ? s : !be.isNorthern(a) && !be.isNorthern(u) ? o : s.getDy() !== 0 ? s : o.getDy() !== 0 ? o : (mt.shouldNeverReachHere("found two horizontal edges incident on node"), null);
  }, t.prototype.print = function(n) {
    Hn.out.println("DirectedEdgeStar: " + this.getCoordinate());
    for (var i = this.iterator(); i.hasNext(); ) {
      var s = i.next();
      n.print("out "), s.print(n), n.println(), n.print("in "), s.getSym().print(n), n.println();
    }
  }, t.prototype.getResultAreaEdges = function() {
    var n = this;
    if (this._resultAreaEdgeList !== null)
      return this._resultAreaEdgeList;
    this._resultAreaEdgeList = new H();
    for (var i = this.iterator(); i.hasNext(); ) {
      var s = i.next();
      (s.isInResult() || s.getSym().isInResult()) && n._resultAreaEdgeList.add(s);
    }
    return this._resultAreaEdgeList;
  }, t.prototype.updateLabelling = function(n) {
    for (var i = this.iterator(); i.hasNext(); ) {
      var s = i.next(), o = s.getLabel();
      o.setAllLocationsIfNull(0, n.getLocation(0)), o.setAllLocationsIfNull(1, n.getLocation(1));
    }
  }, t.prototype.linkAllDirectedEdges = function() {
    var n = this;
    this.getEdges();
    for (var i = null, s = null, o = this._edgeList.size() - 1; o >= 0; o--) {
      var a = n._edgeList.get(o), u = a.getSym();
      s === null && (s = u), i !== null && u.setNext(i), i = a;
    }
    s.setNext(i);
  }, t.prototype.computeDepths = function() {
    var n = this;
    if (arguments.length === 1) {
      var i = arguments[0], s = this.findIndex(i), o = i.getDepth(z.LEFT), a = i.getDepth(z.RIGHT), u = this.computeDepths(s + 1, this._edgeList.size(), o), x = this.computeDepths(0, s, u);
      if (x !== a)
        throw new Mo("depth mismatch at " + i.getCoordinate());
    } else if (arguments.length === 3) {
      for (var c = arguments[0], f = arguments[1], l = arguments[2], h = l, p = c; p < f; p++) {
        var y = n._edgeList.get(p);
        y.setEdgeDepths(z.RIGHT, h), h = y.getDepth(z.LEFT);
      }
      return h;
    }
  }, t.prototype.mergeSymLabels = function() {
    for (var n = this.iterator(); n.hasNext(); ) {
      var i = n.next(), s = i.getLabel();
      s.merge(i.getSym().getLabel());
    }
  }, t.prototype.linkMinimalDirectedEdges = function(n) {
    for (var i = this, s = null, o = null, a = this._SCANNING_FOR_INCOMING, u = this._resultAreaEdgeList.size() - 1; u >= 0; u--) {
      var x = i._resultAreaEdgeList.get(u), c = x.getSym();
      switch (s === null && x.getEdgeRing() === n && (s = x), a) {
        case i._SCANNING_FOR_INCOMING:
          if (c.getEdgeRing() !== n)
            continue;
          o = c, a = i._LINKING_TO_OUTGOING;
          break;
        case i._LINKING_TO_OUTGOING:
          if (x.getEdgeRing() !== n)
            continue;
          o.setNextMin(x), a = i._SCANNING_FOR_INCOMING;
          break;
      }
    }
    a === this._LINKING_TO_OUTGOING && (mt.isTrue(s !== null, "found null for first outgoing dirEdge"), mt.isTrue(s.getEdgeRing() === n, "unable to link last incoming dirEdge"), o.setNextMin(s));
  }, t.prototype.getOutgoingDegree = function() {
    if (arguments.length === 0) {
      for (var n = 0, i = this.iterator(); i.hasNext(); ) {
        var s = i.next();
        s.isInResult() && n++;
      }
      return n;
    } else if (arguments.length === 1) {
      for (var o = arguments[0], a = 0, u = this.iterator(); u.hasNext(); ) {
        var x = u.next();
        x.getEdgeRing() === o && a++;
      }
      return a;
    }
  }, t.prototype.getLabel = function() {
    return this._label;
  }, t.prototype.findCoveredLineEdges = function() {
    for (var n = A.NONE, i = this.iterator(); i.hasNext(); ) {
      var s = i.next(), o = s.getSym();
      if (!s.isLineEdge()) {
        if (s.isInResult()) {
          n = A.INTERIOR;
          break;
        }
        if (o.isInResult()) {
          n = A.EXTERIOR;
          break;
        }
      }
    }
    if (n === A.NONE)
      return null;
    for (var a = n, u = this.iterator(); u.hasNext(); ) {
      var x = u.next(), c = x.getSym();
      x.isLineEdge() ? x.getEdge().setCovered(a === A.INTERIOR) : (x.isInResult() && (a = A.EXTERIOR), c.isInResult() && (a = A.INTERIOR));
    }
  }, t.prototype.computeLabelling = function(n) {
    var i = this;
    r.prototype.computeLabelling.call(this, n), this._label = new ye(A.NONE);
    for (var s = this.iterator(); s.hasNext(); )
      for (var o = s.next(), a = o.getEdge(), u = a.getLabel(), x = 0; x < 2; x++) {
        var c = u.getLocation(x);
        (c === A.INTERIOR || c === A.BOUNDARY) && i._label.setLocation(x, A.INTERIOR);
      }
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(ur), jS = function(r) {
  function t() {
    r.apply(this, arguments);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.createNode = function(n) {
    return new tv(n, new yF());
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(Yx), da = function r() {
  this._pts = null, this._orientation = null;
  var t = arguments[0];
  this._pts = t, this._orientation = r.orientation(t);
};
da.prototype.compareTo = function(t) {
  var e = t, n = da.compareOriented(this._pts, this._orientation, e._pts, e._orientation);
  return n;
};
da.prototype.interfaces_ = function() {
  return [Ri];
};
da.prototype.getClass = function() {
  return da;
};
da.orientation = function(t) {
  return Ct.increasingDirection(t) === 1;
};
da.compareOriented = function(t, e, n, i) {
  for (var s = e ? 1 : -1, o = i ? 1 : -1, a = e ? t.length : -1, u = i ? n.length : -1, x = e ? 0 : t.length - 1, c = i ? 0 : n.length - 1; ; ) {
    var f = t[x].compareTo(n[c]);
    if (f !== 0)
      return f;
    x += s, c += o;
    var l = x === a, h = c === u;
    if (l && !h)
      return -1;
    if (!l && h)
      return 1;
    if (l && h)
      return 0;
  }
};
var Zi = function() {
  this._edges = new H(), this._ocaMap = new or();
};
Zi.prototype.print = function(t) {
  var e = this;
  t.print("MULTILINESTRING ( ");
  for (var n = 0; n < this._edges.size(); n++) {
    var i = e._edges.get(n);
    n > 0 && t.print(","), t.print("(");
    for (var s = i.getCoordinates(), o = 0; o < s.length; o++)
      o > 0 && t.print(","), t.print(s[o].x + " " + s[o].y);
    t.println(")");
  }
  t.print(")  ");
};
Zi.prototype.addAll = function(t) {
  for (var e = this, n = t.iterator(); n.hasNext(); )
    e.add(n.next());
};
Zi.prototype.findEdgeIndex = function(t) {
  for (var e = this, n = 0; n < this._edges.size(); n++)
    if (e._edges.get(n).equals(t))
      return n;
  return -1;
};
Zi.prototype.iterator = function() {
  return this._edges.iterator();
};
Zi.prototype.getEdges = function() {
  return this._edges;
};
Zi.prototype.get = function(t) {
  return this._edges.get(t);
};
Zi.prototype.findEqualEdge = function(t) {
  var e = new da(t.getCoordinates()), n = this._ocaMap.get(e);
  return n;
};
Zi.prototype.add = function(t) {
  this._edges.add(t);
  var e = new da(t.getCoordinates());
  this._ocaMap.put(e, t);
};
Zi.prototype.interfaces_ = function() {
  return [];
};
Zi.prototype.getClass = function() {
  return Zi;
};
var e0 = function() {
};
e0.prototype.processIntersections = function(t, e, n, i) {
};
e0.prototype.isDone = function() {
};
e0.prototype.interfaces_ = function() {
  return [];
};
e0.prototype.getClass = function() {
  return e0;
};
var ci = function() {
  this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
  var t = arguments[0];
  this._li = t;
};
ci.prototype.isTrivialIntersection = function(t, e, n, i) {
  if (t === n && this._li.getIntersectionNum() === 1) {
    if (ci.isAdjacentSegments(e, i))
      return !0;
    if (t.isClosed()) {
      var s = t.size() - 1;
      if (e === 0 && i === s || i === 0 && e === s)
        return !0;
    }
  }
  return !1;
};
ci.prototype.getProperIntersectionPoint = function() {
  return this._properIntersectionPoint;
};
ci.prototype.hasProperInteriorIntersection = function() {
  return this._hasProperInterior;
};
ci.prototype.getLineIntersector = function() {
  return this._li;
};
ci.prototype.hasProperIntersection = function() {
  return this._hasProper;
};
ci.prototype.processIntersections = function(t, e, n, i) {
  if (t === n && e === i)
    return null;
  this.numTests++;
  var s = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], a = n.getCoordinates()[i], u = n.getCoordinates()[i + 1];
  this._li.computeIntersection(s, o, a, u), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));
};
ci.prototype.hasIntersection = function() {
  return this._hasIntersection;
};
ci.prototype.isDone = function() {
  return !1;
};
ci.prototype.hasInteriorIntersection = function() {
  return this._hasInterior;
};
ci.prototype.interfaces_ = function() {
  return [e0];
};
ci.prototype.getClass = function() {
  return ci;
};
ci.isAdjacentSegments = function(t, e) {
  return Math.abs(t - e) === 1;
};
var Ls = function() {
  this.coord = null, this.segmentIndex = null, this.dist = null;
  var t = arguments[0], e = arguments[1], n = arguments[2];
  this.coord = new R(t), this.segmentIndex = e, this.dist = n;
};
Ls.prototype.getSegmentIndex = function() {
  return this.segmentIndex;
};
Ls.prototype.getCoordinate = function() {
  return this.coord;
};
Ls.prototype.print = function(t) {
  t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist);
};
Ls.prototype.compareTo = function(t) {
  var e = t;
  return this.compare(e.segmentIndex, e.dist);
};
Ls.prototype.isEndPoint = function(t) {
  return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === t;
};
Ls.prototype.toString = function() {
  return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
};
Ls.prototype.getDistance = function() {
  return this.dist;
};
Ls.prototype.compare = function(t, e) {
  return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0;
};
Ls.prototype.interfaces_ = function() {
  return [Ri];
};
Ls.prototype.getClass = function() {
  return Ls;
};
var to = function() {
  this._nodeMap = new or(), this.edge = null;
  var t = arguments[0];
  this.edge = t;
};
to.prototype.print = function(t) {
  t.println("Intersections:");
  for (var e = this.iterator(); e.hasNext(); ) {
    var n = e.next();
    n.print(t);
  }
};
to.prototype.iterator = function() {
  return this._nodeMap.values().iterator();
};
to.prototype.addSplitEdges = function(t) {
  var e = this;
  this.addEndpoints();
  for (var n = this.iterator(), i = n.next(); n.hasNext(); ) {
    var s = n.next(), o = e.createSplitEdge(i, s);
    t.add(o), i = s;
  }
};
to.prototype.addEndpoints = function() {
  var t = this.edge.pts.length - 1;
  this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);
};
to.prototype.createSplitEdge = function(t, e) {
  var n = this, i = e.segmentIndex - t.segmentIndex + 2, s = this.edge.pts[e.segmentIndex], o = e.dist > 0 || !e.coord.equals2D(s);
  o || i--;
  var a = new Array(i).fill(null), u = 0;
  a[u++] = new R(t.coord);
  for (var x = t.segmentIndex + 1; x <= e.segmentIndex; x++)
    a[u++] = n.edge.pts[x];
  return o && (a[u] = e.coord), new Fg(a, new ye(this.edge._label));
};
to.prototype.add = function(t, e, n) {
  var i = new Ls(t, e, n), s = this._nodeMap.get(i);
  return s !== null ? s : (this._nodeMap.put(i, i), i);
};
to.prototype.isIntersection = function(t) {
  for (var e = this.iterator(); e.hasNext(); ) {
    var n = e.next();
    if (n.coord.equals(t))
      return !0;
  }
  return !1;
};
to.prototype.interfaces_ = function() {
  return [];
};
to.prototype.getClass = function() {
  return to;
};
var n0 = function() {
};
n0.prototype.getChainStartIndices = function(t) {
  var e = this, n = 0, i = new H();
  i.add(new ws(n));
  do {
    var s = e.findChainEnd(t, n);
    i.add(new ws(s)), n = s;
  } while (n < t.length - 1);
  var o = n0.toIntArray(i);
  return o;
};
n0.prototype.findChainEnd = function(t, e) {
  for (var n = be.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length; ) {
    var s = be.quadrant(t[i - 1], t[i]);
    if (s !== n)
      break;
    i++;
  }
  return i - 1;
};
n0.prototype.interfaces_ = function() {
  return [];
};
n0.prototype.getClass = function() {
  return n0;
};
n0.toIntArray = function(t) {
  for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++)
    e[n] = t.get(n).intValue();
  return e;
};
var Lo = function() {
  this.e = null, this.pts = null, this.startIndex = null, this.env1 = new nt(), this.env2 = new nt();
  var t = arguments[0];
  this.e = t, this.pts = t.getCoordinates();
  var e = new n0();
  this.startIndex = e.getChainStartIndices(this.pts);
};
Lo.prototype.getCoordinates = function() {
  return this.pts;
};
Lo.prototype.getMaxX = function(t) {
  var e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x;
  return e > n ? e : n;
};
Lo.prototype.getMinX = function(t) {
  var e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x;
  return e < n ? e : n;
};
Lo.prototype.computeIntersectsForChain = function() {
  if (arguments.length === 4) {
    var t = arguments[0], e = arguments[1], n = arguments[2], i = arguments[3];
    this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i);
  } else if (arguments.length === 6) {
    var s = arguments[0], o = arguments[1], a = arguments[2], u = arguments[3], x = arguments[4], c = arguments[5], f = this.pts[s], l = this.pts[o], h = a.pts[u], p = a.pts[x];
    if (o - s === 1 && x - u === 1)
      return c.addIntersections(this.e, s, a.e, u), null;
    if (this.env1.init(f, l), this.env2.init(h, p), !this.env1.intersects(this.env2))
      return null;
    var y = Math.trunc((s + o) / 2), v = Math.trunc((u + x) / 2);
    s < y && (u < v && this.computeIntersectsForChain(s, y, a, u, v, c), v < x && this.computeIntersectsForChain(s, y, a, v, x, c)), y < o && (u < v && this.computeIntersectsForChain(y, o, a, u, v, c), v < x && this.computeIntersectsForChain(y, o, a, v, x, c));
  }
};
Lo.prototype.getStartIndexes = function() {
  return this.startIndex;
};
Lo.prototype.computeIntersects = function(t, e) {
  for (var n = this, i = 0; i < this.startIndex.length - 1; i++)
    for (var s = 0; s < t.startIndex.length - 1; s++)
      n.computeIntersectsForChain(i, t, s, e);
};
Lo.prototype.interfaces_ = function() {
  return [];
};
Lo.prototype.getClass = function() {
  return Lo;
};
var Vn = function r() {
  var t = this;
  this._depth = Array(2).fill().map(function() {
    return Array(3);
  });
  for (var e = 0; e < 2; e++)
    for (var n = 0; n < 3; n++)
      t._depth[e][n] = r.NULL_VALUE;
}, QS = { NULL_VALUE: { configurable: !0 } };
Vn.prototype.getDepth = function(t, e) {
  return this._depth[t][e];
};
Vn.prototype.setDepth = function(t, e, n) {
  this._depth[t][e] = n;
};
Vn.prototype.isNull = function() {
  var t = this;
  if (arguments.length === 0) {
    for (var e = 0; e < 2; e++)
      for (var n = 0; n < 3; n++)
        if (t._depth[e][n] !== Vn.NULL_VALUE)
          return !1;
    return !0;
  } else if (arguments.length === 1) {
    var i = arguments[0];
    return this._depth[i][1] === Vn.NULL_VALUE;
  } else if (arguments.length === 2) {
    var s = arguments[0], o = arguments[1];
    return this._depth[s][o] === Vn.NULL_VALUE;
  }
};
Vn.prototype.normalize = function() {
  for (var t = this, e = 0; e < 2; e++)
    if (!t.isNull(e)) {
      var n = t._depth[e][1];
      t._depth[e][2] < n && (n = t._depth[e][2]), n < 0 && (n = 0);
      for (var i = 1; i < 3; i++) {
        var s = 0;
        t._depth[e][i] > n && (s = 1), t._depth[e][i] = s;
      }
    }
};
Vn.prototype.getDelta = function(t) {
  return this._depth[t][z.RIGHT] - this._depth[t][z.LEFT];
};
Vn.prototype.getLocation = function(t, e) {
  return this._depth[t][e] <= 0 ? A.EXTERIOR : A.INTERIOR;
};
Vn.prototype.toString = function() {
  return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
};
Vn.prototype.add = function() {
  var t = this;
  if (arguments.length === 1)
    for (var e = arguments[0], n = 0; n < 2; n++)
      for (var i = 1; i < 3; i++) {
        var s = e.getLocation(n, i);
        (s === A.EXTERIOR || s === A.INTERIOR) && (t.isNull(n, i) ? t._depth[n][i] = Vn.depthAtLocation(s) : t._depth[n][i] += Vn.depthAtLocation(s));
      }
  else if (arguments.length === 3) {
    var o = arguments[0], a = arguments[1], u = arguments[2];
    u === A.INTERIOR && this._depth[o][a]++;
  }
};
Vn.prototype.interfaces_ = function() {
  return [];
};
Vn.prototype.getClass = function() {
  return Vn;
};
Vn.depthAtLocation = function(t) {
  return t === A.EXTERIOR ? 0 : t === A.INTERIOR ? 1 : Vn.NULL_VALUE;
};
QS.NULL_VALUE.get = function() {
  return -1;
};
Object.defineProperties(Vn, QS);
var Fg = function(r) {
  function t() {
    if (r.call(this), this.pts = null, this._env = null, this.eiList = new to(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new Vn(), this._depthDelta = 0, arguments.length === 1) {
      var e = arguments[0];
      t.call(this, e, null);
    } else if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1];
      this.pts = n, this._label = i;
    }
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.getDepth = function() {
    return this._depth;
  }, t.prototype.getCollapsedEdge = function() {
    var n = new Array(2).fill(null);
    n[0] = this.pts[0], n[1] = this.pts[1];
    var i = new t(n, ye.toLineLabel(this._label));
    return i;
  }, t.prototype.isIsolated = function() {
    return this._isIsolated;
  }, t.prototype.getCoordinates = function() {
    return this.pts;
  }, t.prototype.setIsolated = function(n) {
    this._isIsolated = n;
  }, t.prototype.setName = function(n) {
    this._name = n;
  }, t.prototype.equals = function(n) {
    var i = this;
    if (!(n instanceof t))
      return !1;
    var s = n;
    if (this.pts.length !== s.pts.length)
      return !1;
    for (var o = !0, a = !0, u = this.pts.length, x = 0; x < this.pts.length; x++)
      if (i.pts[x].equals2D(s.pts[x]) || (o = !1), i.pts[x].equals2D(s.pts[--u]) || (a = !1), !o && !a)
        return !1;
    return !0;
  }, t.prototype.getCoordinate = function() {
    if (arguments.length === 0)
      return this.pts.length > 0 ? this.pts[0] : null;
    if (arguments.length === 1) {
      var n = arguments[0];
      return this.pts[n];
    }
  }, t.prototype.print = function(n) {
    var i = this;
    n.print("edge " + this._name + ": "), n.print("LINESTRING (");
    for (var s = 0; s < this.pts.length; s++)
      s > 0 && n.print(","), n.print(i.pts[s].x + " " + i.pts[s].y);
    n.print(")  " + this._label + " " + this._depthDelta);
  }, t.prototype.computeIM = function(n) {
    t.updateIM(this._label, n);
  }, t.prototype.isCollapsed = function() {
    return !this._label.isArea() || this.pts.length !== 3 ? !1 : !!this.pts[0].equals(this.pts[2]);
  }, t.prototype.isClosed = function() {
    return this.pts[0].equals(this.pts[this.pts.length - 1]);
  }, t.prototype.getMaximumSegmentIndex = function() {
    return this.pts.length - 1;
  }, t.prototype.getDepthDelta = function() {
    return this._depthDelta;
  }, t.prototype.getNumPoints = function() {
    return this.pts.length;
  }, t.prototype.printReverse = function(n) {
    var i = this;
    n.print("edge " + this._name + ": ");
    for (var s = this.pts.length - 1; s >= 0; s--)
      n.print(i.pts[s] + " ");
    n.println("");
  }, t.prototype.getMonotoneChainEdge = function() {
    return this._mce === null && (this._mce = new Lo(this)), this._mce;
  }, t.prototype.getEnvelope = function() {
    var n = this;
    if (this._env === null) {
      this._env = new nt();
      for (var i = 0; i < this.pts.length; i++)
        n._env.expandToInclude(n.pts[i]);
    }
    return this._env;
  }, t.prototype.addIntersection = function(n, i, s, o) {
    var a = new R(n.getIntersection(o)), u = i, x = n.getEdgeDistance(s, o), c = u + 1;
    if (c < this.pts.length) {
      var f = this.pts[c];
      a.equals2D(f) && (u = c, x = 0);
    }
    this.eiList.add(a, u, x);
  }, t.prototype.toString = function() {
    var n = this, i = new As();
    i.append("edge " + this._name + ": "), i.append("LINESTRING (");
    for (var s = 0; s < this.pts.length; s++)
      s > 0 && i.append(","), i.append(n.pts[s].x + " " + n.pts[s].y);
    return i.append(")  " + this._label + " " + this._depthDelta), i.toString();
  }, t.prototype.isPointwiseEqual = function(n) {
    var i = this;
    if (this.pts.length !== n.pts.length)
      return !1;
    for (var s = 0; s < this.pts.length; s++)
      if (!i.pts[s].equals2D(n.pts[s]))
        return !1;
    return !0;
  }, t.prototype.setDepthDelta = function(n) {
    this._depthDelta = n;
  }, t.prototype.getEdgeIntersectionList = function() {
    return this.eiList;
  }, t.prototype.addIntersections = function(n, i, s) {
    for (var o = this, a = 0; a < n.getIntersectionNum(); a++)
      o.addIntersection(n, i, s, a);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t.updateIM = function() {
    if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1];
      i.setAtLeastIfValid(n.getLocation(0, z.ON), n.getLocation(1, z.ON), 1), n.isArea() && (i.setAtLeastIfValid(n.getLocation(0, z.LEFT), n.getLocation(1, z.LEFT), 2), i.setAtLeastIfValid(n.getLocation(0, z.RIGHT), n.getLocation(1, z.RIGHT), 2));
    } else
      return r.prototype.updateIM.apply(this, arguments);
  }, t;
}(ui), _r = function(t) {
  this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Zi(), this._bufParams = t || null;
};
_r.prototype.setWorkingPrecisionModel = function(t) {
  this._workingPrecisionModel = t;
};
_r.prototype.insertUniqueEdge = function(t) {
  var e = this._edgeList.findEqualEdge(t);
  if (e !== null) {
    var n = e.getLabel(), i = t.getLabel();
    e.isPointwiseEqual(t) || (i = new ye(t.getLabel()), i.flip()), n.merge(i);
    var s = _r.depthDelta(i), o = e.getDepthDelta(), a = o + s;
    e.setDepthDelta(a);
  } else
    this._edgeList.add(t), t.setDepthDelta(_r.depthDelta(t.getLabel()));
};
_r.prototype.buildSubgraphs = function(t, e) {
  for (var n = new H(), i = t.iterator(); i.hasNext(); ) {
    var s = i.next(), o = s.getRightmostCoordinate(), a = new Q0(n), u = a.getDepth(o);
    s.computeDepth(u), s.findResultEdges(), n.add(s), e.add(s.getDirectedEdges(), s.getNodes());
  }
};
_r.prototype.createSubgraphs = function(t) {
  for (var e = new H(), n = t.getNodes().iterator(); n.hasNext(); ) {
    var i = n.next();
    if (!i.isVisited()) {
      var s = new wr();
      s.create(i), e.add(s);
    }
  }
  return Ji.sort(e, Ji.reverseOrder()), e;
};
_r.prototype.createEmptyResultGeometry = function() {
  var t = this._geomFact.createPolygon();
  return t;
};
_r.prototype.getNoder = function(t) {
  if (this._workingNoder !== null)
    return this._workingNoder;
  var e = new Z2(), n = new l0();
  return n.setPrecisionModel(t), e.setSegmentIntersector(new ci(n)), e;
};
_r.prototype.buffer = function(t, e) {
  var n = this._workingPrecisionModel;
  n === null && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();
  var i = new kr(n, this._bufParams), s = new Oi(t, e, i), o = s.getCurves();
  if (o.size() <= 0)
    return this.createEmptyResultGeometry();
  this.computeNodedEdges(o, n), this._graph = new Je(new jS()), this._graph.addEdges(this._edgeList.getEdges());
  var a = this.createSubgraphs(this._graph), u = new Zr(this._geomFact);
  this.buildSubgraphs(a, u);
  var x = u.getPolygons();
  if (x.size() <= 0)
    return this.createEmptyResultGeometry();
  var c = this._geomFact.buildGeometry(x);
  return c;
};
_r.prototype.computeNodedEdges = function(t, e) {
  var n = this, i = this.getNoder(e);
  i.computeNodes(t);
  for (var s = i.getNodedSubstrings(), o = s.iterator(); o.hasNext(); ) {
    var a = o.next(), u = a.getCoordinates();
    if (!(u.length === 2 && u[0].equals2D(u[1]))) {
      var x = a.getData(), c = new Fg(a.getCoordinates(), new ye(x));
      n.insertUniqueEdge(c);
    }
  }
};
_r.prototype.setNoder = function(t) {
  this._workingNoder = t;
};
_r.prototype.interfaces_ = function() {
  return [];
};
_r.prototype.getClass = function() {
  return _r;
};
_r.depthDelta = function(t) {
  var e = t.getLocation(0, z.LEFT), n = t.getLocation(0, z.RIGHT);
  return e === A.INTERIOR && n === A.EXTERIOR ? 1 : e === A.EXTERIOR && n === A.INTERIOR ? -1 : 0;
};
_r.convertSegStrings = function(t) {
  for (var e = new St(), n = new H(); t.hasNext(); ) {
    var i = t.next(), s = e.createLineString(i.getCoordinates());
    n.add(s);
  }
  return e.buildGeometry(n);
};
var ga = function() {
  if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    this._noder = t, this._scaleFactor = e, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
  } else if (arguments.length === 4) {
    var n = arguments[0], i = arguments[1], s = arguments[2], o = arguments[3];
    this._noder = n, this._scaleFactor = i, this._offsetX = s, this._offsetY = o, this._isScaled = !this.isIntegerPrecision();
  }
};
ga.prototype.rescale = function() {
  var t = this;
  if (ct(arguments[0], _n))
    for (var e = arguments[0], n = e.iterator(); n.hasNext(); ) {
      var i = n.next();
      t.rescale(i.getCoordinates());
    }
  else if (arguments[0] instanceof Array) {
    for (var s = arguments[0], o = 0; o < s.length; o++)
      s[o].x = s[o].x / t._scaleFactor + t._offsetX, s[o].y = s[o].y / t._scaleFactor + t._offsetY;
    s.length === 2 && s[0].equals2D(s[1]) && Hn.out.println(s);
  }
};
ga.prototype.scale = function() {
  var t = this;
  if (ct(arguments[0], _n)) {
    for (var e = arguments[0], n = new H(), i = e.iterator(); i.hasNext(); ) {
      var s = i.next();
      n.add(new sn(t.scale(s.getCoordinates()), s.getData()));
    }
    return n;
  } else if (arguments[0] instanceof Array) {
    for (var o = arguments[0], a = new Array(o.length).fill(null), u = 0; u < o.length; u++)
      a[u] = new R(Math.round((o[u].x - t._offsetX) * t._scaleFactor), Math.round((o[u].y - t._offsetY) * t._scaleFactor), o[u].z);
    var x = Ct.removeRepeatedPoints(a);
    return x;
  }
};
ga.prototype.isIntegerPrecision = function() {
  return this._scaleFactor === 1;
};
ga.prototype.getNodedSubstrings = function() {
  var t = this._noder.getNodedSubstrings();
  return this._isScaled && this.rescale(t), t;
};
ga.prototype.computeNodes = function(t) {
  var e = t;
  this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e);
};
ga.prototype.interfaces_ = function() {
  return [$a];
};
ga.prototype.getClass = function() {
  return ga;
};
var Ns = function() {
  this._li = new l0(), this._segStrings = null;
  var t = arguments[0];
  this._segStrings = t;
}, $S = { fact: { configurable: !0 } };
Ns.prototype.checkEndPtVertexIntersections = function() {
  var t = this;
  if (arguments.length === 0)
    for (var e = this._segStrings.iterator(); e.hasNext(); ) {
      var n = e.next(), i = n.getCoordinates();
      t.checkEndPtVertexIntersections(i[0], t._segStrings), t.checkEndPtVertexIntersections(i[i.length - 1], t._segStrings);
    }
  else if (arguments.length === 2) {
    for (var s = arguments[0], o = arguments[1], a = o.iterator(); a.hasNext(); )
      for (var u = a.next(), x = u.getCoordinates(), c = 1; c < x.length - 1; c++)
        if (x[c].equals(s))
          throw new So("found endpt/interior pt intersection at index " + c + " :pt " + s);
  }
};
Ns.prototype.checkInteriorIntersections = function() {
  var t = this;
  if (arguments.length === 0)
    for (var e = this._segStrings.iterator(); e.hasNext(); )
      for (var n = e.next(), i = this._segStrings.iterator(); i.hasNext(); ) {
        var s = i.next();
        t.checkInteriorIntersections(n, s);
      }
  else if (arguments.length === 2)
    for (var o = arguments[0], a = arguments[1], u = o.getCoordinates(), x = a.getCoordinates(), c = 0; c < u.length - 1; c++)
      for (var f = 0; f < x.length - 1; f++)
        t.checkInteriorIntersections(o, c, a, f);
  else if (arguments.length === 4) {
    var l = arguments[0], h = arguments[1], p = arguments[2], y = arguments[3];
    if (l === p && h === y)
      return null;
    var v = l.getCoordinates()[h], m = l.getCoordinates()[h + 1], d = p.getCoordinates()[y], g = p.getCoordinates()[y + 1];
    if (this._li.computeIntersection(v, m, d, g), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, v, m) || this.hasInteriorIntersection(this._li, d, g)))
      throw new So("found non-noded intersection at " + v + "-" + m + " and " + d + "-" + g);
  }
};
Ns.prototype.checkValid = function() {
  this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
};
Ns.prototype.checkCollapses = function() {
  var t = this;
  if (arguments.length === 0)
    for (var e = this._segStrings.iterator(); e.hasNext(); ) {
      var n = e.next();
      t.checkCollapses(n);
    }
  else if (arguments.length === 1)
    for (var i = arguments[0], s = i.getCoordinates(), o = 0; o < s.length - 2; o++)
      t.checkCollapse(s[o], s[o + 1], s[o + 2]);
};
Ns.prototype.hasInteriorIntersection = function(t, e, n) {
  for (var i = 0; i < t.getIntersectionNum(); i++) {
    var s = t.getIntersection(i);
    if (!(s.equals(e) || s.equals(n)))
      return !0;
  }
  return !1;
};
Ns.prototype.checkCollapse = function(t, e, n) {
  if (t.equals(n))
    throw new So("found non-noded collapse at " + Ns.fact.createLineString([t, e, n]));
};
Ns.prototype.interfaces_ = function() {
  return [];
};
Ns.prototype.getClass = function() {
  return Ns;
};
$S.fact.get = function() {
  return new St();
};
Object.defineProperties(Ns, $S);
var Br = function() {
  this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
  var t = arguments[0], e = arguments[1], n = arguments[2];
  if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0)
    throw new ze("Scale factor must be non-zero");
  e !== 1 && (this._pt = new R(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new R(), this._p1Scaled = new R()), this.initCorners(this._pt);
}, t6 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: !0 } };
Br.prototype.intersectsScaled = function(t, e) {
  var n = Math.min(t.x, e.x), i = Math.max(t.x, e.x), s = Math.min(t.y, e.y), o = Math.max(t.y, e.y), a = this._maxx < n || this._minx > i || this._maxy < s || this._miny > o;
  if (a)
    return !1;
  var u = this.intersectsToleranceSquare(t, e);
  return mt.isTrue(!(a && u), "Found bad envelope test"), u;
};
Br.prototype.initCorners = function(t) {
  var e = 0.5;
  this._minx = t.x - e, this._maxx = t.x + e, this._miny = t.y - e, this._maxy = t.y + e, this._corner[0] = new R(this._maxx, this._maxy), this._corner[1] = new R(this._minx, this._maxy), this._corner[2] = new R(this._minx, this._miny), this._corner[3] = new R(this._maxx, this._miny);
};
Br.prototype.intersects = function(t, e) {
  return this._scaleFactor === 1 ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
};
Br.prototype.scale = function(t) {
  return Math.round(t * this._scaleFactor);
};
Br.prototype.getCoordinate = function() {
  return this._originalPt;
};
Br.prototype.copyScaled = function(t, e) {
  e.x = this.scale(t.x), e.y = this.scale(t.y);
};
Br.prototype.getSafeEnvelope = function() {
  if (this._safeEnv === null) {
    var t = Br.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
    this._safeEnv = new nt(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t);
  }
  return this._safeEnv;
};
Br.prototype.intersectsPixelClosure = function(t, e) {
  return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.hasIntersection()) || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.hasIntersection()) || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.hasIntersection()));
};
Br.prototype.intersectsToleranceSquare = function(t, e) {
  var n = !1, i = !1;
  return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.isProper()) || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.isProper()) || (this._li.hasIntersection() && (i = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.isProper()) || n && i || t.equals(this._pt) || e.equals(this._pt));
};
Br.prototype.addSnappedNode = function(t, e) {
  var n = t.getCoordinate(e), i = t.getCoordinate(e + 1);
  return this.intersects(n, i) ? (t.addIntersection(this.getCoordinate(), e), !0) : !1;
};
Br.prototype.interfaces_ = function() {
  return [];
};
Br.prototype.getClass = function() {
  return Br;
};
t6.SAFE_ENV_EXPANSION_FACTOR.get = function() {
  return 0.75;
};
Object.defineProperties(Br, t6);
var Ml = function() {
  this.tempEnv1 = new nt(), this.selectedSegment = new rt();
};
Ml.prototype.select = function() {
  if (arguments.length !== 1) {
    if (arguments.length === 2) {
      var t = arguments[0], e = arguments[1];
      t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment);
    }
  }
};
Ml.prototype.interfaces_ = function() {
  return [];
};
Ml.prototype.getClass = function() {
  return Ml;
};
var Ux = function() {
  this._index = null;
  var t = arguments[0];
  this._index = t;
}, e6 = { HotPixelSnapAction: { configurable: !0 } };
Ux.prototype.snap = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return this.snap(t, null, -1);
  } else if (arguments.length === 3) {
    var e = arguments[0], n = arguments[1], i = arguments[2], s = e.getSafeEnvelope(), o = new n6(e, n, i);
    return this._index.query(s, {
      interfaces_: function() {
        return [ha];
      },
      visitItem: function(a) {
        var u = a;
        u.select(s, o);
      }
    }), o.isNodeAdded();
  }
};
Ux.prototype.interfaces_ = function() {
  return [];
};
Ux.prototype.getClass = function() {
  return Ux;
};
e6.HotPixelSnapAction.get = function() {
  return n6;
};
Object.defineProperties(Ux, e6);
var n6 = function(r) {
  function t() {
    r.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
    var e = arguments[0], n = arguments[1], i = arguments[2];
    this._hotPixel = e, this._parentEdge = n, this._hotPixelVertexIndex = i;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.isNodeAdded = function() {
    return this._isNodeAdded;
  }, t.prototype.select = function() {
    if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1], s = n.getContext();
      if (this._parentEdge !== null && s === this._parentEdge && i === this._hotPixelVertexIndex)
        return null;
      this._isNodeAdded = this._hotPixel.addSnappedNode(s, i);
    } else
      return r.prototype.select.apply(this, arguments);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(Ml), $0 = function() {
  this._li = null, this._interiorIntersections = null;
  var t = arguments[0];
  this._li = t, this._interiorIntersections = new H();
};
$0.prototype.processIntersections = function(t, e, n, i) {
  var s = this;
  if (t === n && e === i)
    return null;
  var o = t.getCoordinates()[e], a = t.getCoordinates()[e + 1], u = n.getCoordinates()[i], x = n.getCoordinates()[i + 1];
  if (this._li.computeIntersection(o, a, u, x), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
    for (var c = 0; c < this._li.getIntersectionNum(); c++)
      s._interiorIntersections.add(s._li.getIntersection(c));
    t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1);
  }
};
$0.prototype.isDone = function() {
  return !1;
};
$0.prototype.getInteriorIntersections = function() {
  return this._interiorIntersections;
};
$0.prototype.interfaces_ = function() {
  return [e0];
};
$0.prototype.getClass = function() {
  return $0;
};
var eo = function() {
  this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
  var t = arguments[0];
  this._pm = t, this._li = new l0(), this._li.setPrecisionModel(t), this._scaleFactor = t.getScale();
};
eo.prototype.checkCorrectness = function(t) {
  var e = sn.getNodedSubstrings(t), n = new Ns(e);
  try {
    n.checkValid();
  } catch (i) {
    if (i instanceof GS)
      i.printStackTrace();
    else
      throw i;
  } finally {
  }
};
eo.prototype.getNodedSubstrings = function() {
  return sn.getNodedSubstrings(this._nodedSegStrings);
};
eo.prototype.snapRound = function(t, e) {
  var n = this.findInteriorIntersections(t, e);
  this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);
};
eo.prototype.findInteriorIntersections = function(t, e) {
  var n = new $0(e);
  return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections();
};
eo.prototype.computeVertexSnaps = function() {
  var t = this;
  if (ct(arguments[0], _n))
    for (var e = arguments[0], n = e.iterator(); n.hasNext(); ) {
      var i = n.next();
      t.computeVertexSnaps(i);
    }
  else if (arguments[0] instanceof sn)
    for (var s = arguments[0], o = s.getCoordinates(), a = 0; a < o.length; a++) {
      var u = new Br(o[a], t._scaleFactor, t._li), x = t._pointSnapper.snap(u, s, a);
      x && s.addIntersection(o[a], a);
    }
};
eo.prototype.computeNodes = function(t) {
  this._nodedSegStrings = t, this._noder = new Z2(), this._pointSnapper = new Ux(this._noder.getIndex()), this.snapRound(t, this._li);
};
eo.prototype.computeIntersectionSnaps = function(t) {
  for (var e = this, n = t.iterator(); n.hasNext(); ) {
    var i = n.next(), s = new Br(i, e._scaleFactor, e._li);
    e._pointSnapper.snap(s);
  }
};
eo.prototype.interfaces_ = function() {
  return [$a];
};
eo.prototype.getClass = function() {
  return eo;
};
var zn = function() {
  if (this._argGeom = null, this._distance = null, this._bufParams = new ue(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
    var t = arguments[0];
    this._argGeom = t;
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    this._argGeom = e, this._bufParams = n;
  }
}, xc = { CAP_ROUND: { configurable: !0 }, CAP_BUTT: { configurable: !0 }, CAP_FLAT: { configurable: !0 }, CAP_SQUARE: { configurable: !0 }, MAX_PRECISION_DIGITS: { configurable: !0 } };
zn.prototype.bufferFixedPrecision = function(t) {
  var e = new ga(new eo(new xe(1)), t.getScale()), n = new _r(this._bufParams);
  n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance);
};
zn.prototype.bufferReducedPrecision = function() {
  var t = this;
  if (arguments.length === 0) {
    for (var e = zn.MAX_PRECISION_DIGITS; e >= 0; e--) {
      try {
        t.bufferReducedPrecision(e);
      } catch (o) {
        if (o instanceof Mo)
          t._saveException = o;
        else
          throw o;
      } finally {
      }
      if (t._resultGeometry !== null)
        return null;
    }
    throw this._saveException;
  } else if (arguments.length === 1) {
    var n = arguments[0], i = zn.precisionScaleFactor(this._argGeom, this._distance, n), s = new xe(i);
    this.bufferFixedPrecision(s);
  }
};
zn.prototype.computeGeometry = function() {
  if (this.bufferOriginalPrecision(), this._resultGeometry !== null)
    return null;
  var t = this._argGeom.getFactory().getPrecisionModel();
  t.getType() === xe.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();
};
zn.prototype.setQuadrantSegments = function(t) {
  this._bufParams.setQuadrantSegments(t);
};
zn.prototype.bufferOriginalPrecision = function() {
  try {
    var t = new _r(this._bufParams);
    this._resultGeometry = t.buffer(this._argGeom, this._distance);
  } catch (e) {
    if (e instanceof So)
      this._saveException = e;
    else
      throw e;
  } finally {
  }
};
zn.prototype.getResultGeometry = function(t) {
  return this._distance = t, this.computeGeometry(), this._resultGeometry;
};
zn.prototype.setEndCapStyle = function(t) {
  this._bufParams.setEndCapStyle(t);
};
zn.prototype.interfaces_ = function() {
  return [];
};
zn.prototype.getClass = function() {
  return zn;
};
zn.bufferOp = function() {
  if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1], n = new zn(t), i = n.getResultGeometry(e);
    return i;
  } else if (arguments.length === 3) {
    if (Number.isInteger(arguments[2]) && arguments[0] instanceof xt && typeof arguments[1] == "number") {
      var s = arguments[0], o = arguments[1], a = arguments[2], u = new zn(s);
      u.setQuadrantSegments(a);
      var x = u.getResultGeometry(o);
      return x;
    } else if (arguments[2] instanceof ue && arguments[0] instanceof xt && typeof arguments[1] == "number") {
      var c = arguments[0], f = arguments[1], l = arguments[2], h = new zn(c, l), p = h.getResultGeometry(f);
      return p;
    }
  } else if (arguments.length === 4) {
    var y = arguments[0], v = arguments[1], m = arguments[2], d = arguments[3], g = new zn(y);
    g.setQuadrantSegments(m), g.setEndCapStyle(d);
    var _ = g.getResultGeometry(v);
    return _;
  }
};
zn.precisionScaleFactor = function(t, e, n) {
  var i = t.getEnvelopeInternal(), s = ai.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())), o = e > 0 ? e : 0, a = s + 2 * o, u = Math.trunc(Math.log(a) / Math.log(10) + 1), x = n - u, c = Math.pow(10, x);
  return c;
};
xc.CAP_ROUND.get = function() {
  return ue.CAP_ROUND;
};
xc.CAP_BUTT.get = function() {
  return ue.CAP_FLAT;
};
xc.CAP_FLAT.get = function() {
  return ue.CAP_FLAT;
};
xc.CAP_SQUARE.get = function() {
  return ue.CAP_SQUARE;
};
xc.MAX_PRECISION_DIGITS.get = function() {
  return 12;
};
Object.defineProperties(zn, xc);
var yr = function() {
  this._pt = [new R(), new R()], this._distance = yt.NaN, this._isNull = !0;
};
yr.prototype.getCoordinates = function() {
  return this._pt;
};
yr.prototype.getCoordinate = function(t) {
  return this._pt[t];
};
yr.prototype.setMinimum = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.setMinimum(t._pt[0], t._pt[1]);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    if (this._isNull)
      return this.initialize(e, n), null;
    var i = e.distance(n);
    i < this._distance && this.initialize(e, n, i);
  }
};
yr.prototype.initialize = function() {
  if (arguments.length === 0)
    this._isNull = !0;
  else if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1;
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], s = arguments[2];
    this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = s, this._isNull = !1;
  }
};
yr.prototype.getDistance = function() {
  return this._distance;
};
yr.prototype.setMaximum = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.setMaximum(t._pt[0], t._pt[1]);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    if (this._isNull)
      return this.initialize(e, n), null;
    var i = e.distance(n);
    i > this._distance && this.initialize(e, n, i);
  }
};
yr.prototype.interfaces_ = function() {
  return [];
};
yr.prototype.getClass = function() {
  return yr;
};
var qs = function() {
};
qs.prototype.interfaces_ = function() {
  return [];
};
qs.prototype.getClass = function() {
  return qs;
};
qs.computeDistance = function() {
  if (arguments[2] instanceof yr && arguments[0] instanceof je && arguments[1] instanceof R)
    for (var t = arguments[0], e = arguments[1], n = arguments[2], i = t.getCoordinates(), s = new rt(), o = 0; o < i.length - 1; o++) {
      s.setCoordinates(i[o], i[o + 1]);
      var a = s.closestPoint(e);
      n.setMinimum(a, e);
    }
  else if (arguments[2] instanceof yr && arguments[0] instanceof Mn && arguments[1] instanceof R) {
    var u = arguments[0], x = arguments[1], c = arguments[2];
    qs.computeDistance(u.getExteriorRing(), x, c);
    for (var f = 0; f < u.getNumInteriorRing(); f++)
      qs.computeDistance(u.getInteriorRingN(f), x, c);
  } else if (arguments[2] instanceof yr && arguments[0] instanceof xt && arguments[1] instanceof R) {
    var l = arguments[0], h = arguments[1], p = arguments[2];
    if (l instanceof je)
      qs.computeDistance(l, h, p);
    else if (l instanceof Mn)
      qs.computeDistance(l, h, p);
    else if (l instanceof Ir)
      for (var y = l, v = 0; v < y.getNumGeometries(); v++) {
        var m = y.getGeometryN(v);
        qs.computeDistance(m, h, p);
      }
    else
      p.setMinimum(l.getCoordinate(), h);
  } else if (arguments[2] instanceof yr && arguments[0] instanceof rt && arguments[1] instanceof R) {
    var d = arguments[0], g = arguments[1], _ = arguments[2], b = d.closestPoint(g);
    _.setMinimum(b, g);
  }
};
var r0 = function(t) {
  this._maxPtDist = new yr(), this._inputGeom = t || null;
}, K2 = { MaxPointDistanceFilter: { configurable: !0 }, MaxMidpointDistanceFilter: { configurable: !0 } };
r0.prototype.computeMaxMidpointDistance = function(t) {
  var e = new ya(this._inputGeom);
  t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());
};
r0.prototype.computeMaxVertexDistance = function(t) {
  var e = new tu(this._inputGeom);
  t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance());
};
r0.prototype.findDistance = function(t) {
  return this.computeMaxVertexDistance(t), this.computeMaxMidpointDistance(t), this._maxPtDist.getDistance();
};
r0.prototype.getDistancePoints = function() {
  return this._maxPtDist;
};
r0.prototype.interfaces_ = function() {
  return [];
};
r0.prototype.getClass = function() {
  return r0;
};
K2.MaxPointDistanceFilter.get = function() {
  return tu;
};
K2.MaxMidpointDistanceFilter.get = function() {
  return ya;
};
Object.defineProperties(r0, K2);
var tu = function(t) {
  this._maxPtDist = new yr(), this._minPtDist = new yr(), this._geom = t || null;
};
tu.prototype.filter = function(t) {
  this._minPtDist.initialize(), qs.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
};
tu.prototype.getMaxPointDistance = function() {
  return this._maxPtDist;
};
tu.prototype.interfaces_ = function() {
  return [Ks];
};
tu.prototype.getClass = function() {
  return tu;
};
var ya = function(t) {
  this._maxPtDist = new yr(), this._minPtDist = new yr(), this._geom = t || null;
};
ya.prototype.filter = function(t, e) {
  if (e === 0)
    return null;
  var n = t.getCoordinate(e - 1), i = t.getCoordinate(e), s = new R((n.x + i.x) / 2, (n.y + i.y) / 2);
  this._minPtDist.initialize(), qs.computeDistance(this._geom, s, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
};
ya.prototype.isDone = function() {
  return !1;
};
ya.prototype.isGeometryChanged = function() {
  return !1;
};
ya.prototype.getMaxPointDistance = function() {
  return this._maxPtDist;
};
ya.prototype.interfaces_ = function() {
  return [Wi];
};
ya.prototype.getClass = function() {
  return ya;
};
var Io = function(t) {
  this._comps = t || null;
};
Io.prototype.filter = function(t) {
  t instanceof Mn && this._comps.add(t);
};
Io.prototype.interfaces_ = function() {
  return [Ss];
};
Io.prototype.getClass = function() {
  return Io;
};
Io.getPolygons = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return Io.getPolygons(t, new H());
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    return e instanceof Mn ? n.add(e) : e instanceof Ir && e.apply(new Io(n)), n;
  }
};
var qn = function() {
  if (this._lines = null, this._isForcedToLineString = !1, arguments.length === 1) {
    var t = arguments[0];
    this._lines = t;
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    this._lines = e, this._isForcedToLineString = n;
  }
};
qn.prototype.filter = function(t) {
  if (this._isForcedToLineString && t instanceof js) {
    var e = t.getFactory().createLineString(t.getCoordinateSequence());
    return this._lines.add(e), null;
  }
  t instanceof je && this._lines.add(t);
};
qn.prototype.setForceToLineString = function(t) {
  this._isForcedToLineString = t;
};
qn.prototype.interfaces_ = function() {
  return [Co];
};
qn.prototype.getClass = function() {
  return qn;
};
qn.getGeometry = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return t.getFactory().buildGeometry(qn.getLines(t));
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    return e.getFactory().buildGeometry(qn.getLines(e, n));
  }
};
qn.getLines = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return qn.getLines(t, !1);
  } else if (arguments.length === 2) {
    if (ct(arguments[0], _n) && ct(arguments[1], _n)) {
      for (var e = arguments[0], n = arguments[1], i = e.iterator(); i.hasNext(); ) {
        var s = i.next();
        qn.getLines(s, n);
      }
      return n;
    } else if (arguments[0] instanceof xt && typeof arguments[1] == "boolean") {
      var o = arguments[0], a = arguments[1], u = new H();
      return o.apply(new qn(u, a)), u;
    } else if (arguments[0] instanceof xt && ct(arguments[1], _n)) {
      var x = arguments[0], c = arguments[1];
      return x instanceof je ? c.add(x) : x.apply(new qn(c)), c;
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] == "boolean" && ct(arguments[0], _n) && ct(arguments[1], _n)) {
      for (var f = arguments[0], l = arguments[1], h = arguments[2], p = f.iterator(); p.hasNext(); ) {
        var y = p.next();
        qn.getLines(y, l, h);
      }
      return l;
    } else if (typeof arguments[2] == "boolean" && arguments[0] instanceof xt && ct(arguments[1], _n)) {
      var v = arguments[0], m = arguments[1], d = arguments[2];
      return v.apply(new qn(m, d)), m;
    }
  }
};
var Ki = function() {
  if (this._boundaryRule = Li.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, arguments.length !== 0) {
    if (arguments.length === 1) {
      var t = arguments[0];
      if (t === null)
        throw new ze("Rule must be non-null");
      this._boundaryRule = t;
    }
  }
};
Ki.prototype.locateInternal = function() {
  var t = this;
  if (arguments[0] instanceof R && arguments[1] instanceof Mn) {
    var e = arguments[0], n = arguments[1];
    if (n.isEmpty())
      return A.EXTERIOR;
    var i = n.getExteriorRing(), s = this.locateInPolygonRing(e, i);
    if (s === A.EXTERIOR)
      return A.EXTERIOR;
    if (s === A.BOUNDARY)
      return A.BOUNDARY;
    for (var o = 0; o < n.getNumInteriorRing(); o++) {
      var a = n.getInteriorRingN(o), u = t.locateInPolygonRing(e, a);
      if (u === A.INTERIOR)
        return A.EXTERIOR;
      if (u === A.BOUNDARY)
        return A.BOUNDARY;
    }
    return A.INTERIOR;
  } else if (arguments[0] instanceof R && arguments[1] instanceof je) {
    var x = arguments[0], c = arguments[1];
    if (!c.getEnvelopeInternal().intersects(x))
      return A.EXTERIOR;
    var f = c.getCoordinates();
    return !c.isClosed() && (x.equals(f[0]) || x.equals(f[f.length - 1])) ? A.BOUNDARY : Z.isOnLine(x, f) ? A.INTERIOR : A.EXTERIOR;
  } else if (arguments[0] instanceof R && arguments[1] instanceof Jr) {
    var l = arguments[0], h = arguments[1], p = h.getCoordinate();
    return p.equals2D(l) ? A.INTERIOR : A.EXTERIOR;
  }
};
Ki.prototype.locateInPolygonRing = function(t, e) {
  return e.getEnvelopeInternal().intersects(t) ? Z.locatePointInRing(t, e.getCoordinates()) : A.EXTERIOR;
};
Ki.prototype.intersects = function(t, e) {
  return this.locate(t, e) !== A.EXTERIOR;
};
Ki.prototype.updateLocationInfo = function(t) {
  t === A.INTERIOR && (this._isIn = !0), t === A.BOUNDARY && this._numBoundaries++;
};
Ki.prototype.computeLocation = function(t, e) {
  var n = this;
  if (e instanceof Jr && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof je)
    this.updateLocationInfo(this.locateInternal(t, e));
  else if (e instanceof Mn)
    this.updateLocationInfo(this.locateInternal(t, e));
  else if (e instanceof Qa)
    for (var i = e, s = 0; s < i.getNumGeometries(); s++) {
      var o = i.getGeometryN(s);
      n.updateLocationInfo(n.locateInternal(t, o));
    }
  else if (e instanceof Vs)
    for (var a = e, u = 0; u < a.getNumGeometries(); u++) {
      var x = a.getGeometryN(u);
      n.updateLocationInfo(n.locateInternal(t, x));
    }
  else if (e instanceof Ir)
    for (var c = new Ws(e); c.hasNext(); ) {
      var f = c.next();
      f !== e && n.computeLocation(t, f);
    }
};
Ki.prototype.locate = function(t, e) {
  return e.isEmpty() ? A.EXTERIOR : e instanceof je ? this.locateInternal(t, e) : e instanceof Mn ? this.locateInternal(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? A.BOUNDARY : this._numBoundaries > 0 || this._isIn ? A.INTERIOR : A.EXTERIOR);
};
Ki.prototype.interfaces_ = function() {
  return [];
};
Ki.prototype.getClass = function() {
  return Ki;
};
var vr = function r() {
  if (this._component = null, this._segIndex = null, this._pt = null, arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    r.call(this, t, r.INSIDE_AREA, e);
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], s = arguments[2];
    this._component = n, this._segIndex = i, this._pt = s;
  }
}, r6 = { INSIDE_AREA: { configurable: !0 } };
vr.prototype.isInsideArea = function() {
  return this._segIndex === vr.INSIDE_AREA;
};
vr.prototype.getCoordinate = function() {
  return this._pt;
};
vr.prototype.getGeometryComponent = function() {
  return this._component;
};
vr.prototype.getSegmentIndex = function() {
  return this._segIndex;
};
vr.prototype.interfaces_ = function() {
  return [];
};
vr.prototype.getClass = function() {
  return vr;
};
r6.INSIDE_AREA.get = function() {
  return -1;
};
Object.defineProperties(vr, r6);
var sa = function(t) {
  this._pts = t || null;
};
sa.prototype.filter = function(t) {
  t instanceof Jr && this._pts.add(t);
};
sa.prototype.interfaces_ = function() {
  return [Ss];
};
sa.prototype.getClass = function() {
  return sa;
};
sa.getPoints = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return t instanceof Jr ? Ji.singletonList(t) : sa.getPoints(t, new H());
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    return e instanceof Jr ? n.add(e) : e instanceof Ir && e.apply(new sa(n)), n;
  }
};
var eu = function() {
  this._locations = null;
  var t = arguments[0];
  this._locations = t;
};
eu.prototype.filter = function(t) {
  (t instanceof Jr || t instanceof je || t instanceof Mn) && this._locations.add(new vr(t, 0, t.getCoordinate()));
};
eu.prototype.interfaces_ = function() {
  return [Ss];
};
eu.prototype.getClass = function() {
  return eu;
};
eu.getLocations = function(t) {
  var e = new H();
  return t.apply(new eu(e)), e;
};
var Jn = function() {
  if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Ki(), this._minDistanceLocation = null, this._minDistance = yt.MAX_VALUE, arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    this._geom = [t, e], this._terminateDistance = 0;
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], s = arguments[2];
    this._geom = new Array(2).fill(null), this._geom[0] = n, this._geom[1] = i, this._terminateDistance = s;
  }
};
Jn.prototype.computeContainmentDistance = function() {
  var t = this;
  if (arguments.length === 0) {
    var e = new Array(2).fill(null);
    if (this.computeContainmentDistance(0, e), this._minDistance <= this._terminateDistance)
      return null;
    this.computeContainmentDistance(1, e);
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], s = 1 - n, o = Io.getPolygons(this._geom[n]);
    if (o.size() > 0) {
      var a = eu.getLocations(this._geom[s]);
      if (this.computeContainmentDistance(a, o, i), this._minDistance <= this._terminateDistance)
        return this._minDistanceLocation[s] = i[0], this._minDistanceLocation[n] = i[1], null;
    }
  } else if (arguments.length === 3) {
    if (arguments[2] instanceof Array && ct(arguments[0], zi) && ct(arguments[1], zi)) {
      for (var u = arguments[0], x = arguments[1], c = arguments[2], f = 0; f < u.size(); f++)
        for (var l = u.get(f), h = 0; h < x.size(); h++)
          if (t.computeContainmentDistance(l, x.get(h), c), t._minDistance <= t._terminateDistance)
            return null;
    } else if (arguments[2] instanceof Array && arguments[0] instanceof vr && arguments[1] instanceof Mn) {
      var p = arguments[0], y = arguments[1], v = arguments[2], m = p.getCoordinate();
      if (A.EXTERIOR !== this._ptLocator.locate(m, y))
        return this._minDistance = 0, v[0] = p, v[1] = new vr(y, m), null;
    }
  }
};
Jn.prototype.computeMinDistanceLinesPoints = function(t, e, n) {
  for (var i = this, s = 0; s < t.size(); s++)
    for (var o = t.get(s), a = 0; a < e.size(); a++) {
      var u = e.get(a);
      if (i.computeMinDistance(o, u, n), i._minDistance <= i._terminateDistance)
        return null;
    }
};
Jn.prototype.computeFacetDistance = function() {
  var t = new Array(2).fill(null), e = qn.getLines(this._geom[0]), n = qn.getLines(this._geom[1]), i = sa.getPoints(this._geom[0]), s = sa.getPoints(this._geom[1]);
  if (this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance || (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, s, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance) || (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, i, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance))
    return null;
  t[0] = null, t[1] = null, this.computeMinDistancePoints(i, s, t), this.updateMinDistance(t, !1);
};
Jn.prototype.nearestLocations = function() {
  return this.computeMinDistance(), this._minDistanceLocation;
};
Jn.prototype.updateMinDistance = function(t, e) {
  if (t[0] === null)
    return null;
  e ? (this._minDistanceLocation[0] = t[1], this._minDistanceLocation[1] = t[0]) : (this._minDistanceLocation[0] = t[0], this._minDistanceLocation[1] = t[1]);
};
Jn.prototype.nearestPoints = function() {
  this.computeMinDistance();
  var t = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
  return t;
};
Jn.prototype.computeMinDistance = function() {
  var t = this;
  if (arguments.length === 0) {
    if (this._minDistanceLocation !== null || (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance))
      return null;
    this.computeFacetDistance();
  } else if (arguments.length === 3) {
    if (arguments[2] instanceof Array && arguments[0] instanceof je && arguments[1] instanceof Jr) {
      var e = arguments[0], n = arguments[1], i = arguments[2];
      if (e.getEnvelopeInternal().distance(n.getEnvelopeInternal()) > this._minDistance)
        return null;
      for (var s = e.getCoordinates(), o = n.getCoordinate(), a = 0; a < s.length - 1; a++) {
        var u = Z.distancePointLine(o, s[a], s[a + 1]);
        if (u < t._minDistance) {
          t._minDistance = u;
          var x = new rt(s[a], s[a + 1]), c = x.closestPoint(o);
          i[0] = new vr(e, a, c), i[1] = new vr(n, 0, o);
        }
        if (t._minDistance <= t._terminateDistance)
          return null;
      }
    } else if (arguments[2] instanceof Array && arguments[0] instanceof je && arguments[1] instanceof je) {
      var f = arguments[0], l = arguments[1], h = arguments[2];
      if (f.getEnvelopeInternal().distance(l.getEnvelopeInternal()) > this._minDistance)
        return null;
      for (var p = f.getCoordinates(), y = l.getCoordinates(), v = 0; v < p.length - 1; v++)
        for (var m = 0; m < y.length - 1; m++) {
          var d = Z.distanceLineLine(p[v], p[v + 1], y[m], y[m + 1]);
          if (d < t._minDistance) {
            t._minDistance = d;
            var g = new rt(p[v], p[v + 1]), _ = new rt(y[m], y[m + 1]), b = g.closestPoints(_);
            h[0] = new vr(f, v, b[0]), h[1] = new vr(l, m, b[1]);
          }
          if (t._minDistance <= t._terminateDistance)
            return null;
        }
    }
  }
};
Jn.prototype.computeMinDistancePoints = function(t, e, n) {
  for (var i = this, s = 0; s < t.size(); s++)
    for (var o = t.get(s), a = 0; a < e.size(); a++) {
      var u = e.get(a), x = o.getCoordinate().distance(u.getCoordinate());
      if (x < i._minDistance && (i._minDistance = x, n[0] = new vr(o, 0, o.getCoordinate()), n[1] = new vr(u, 0, u.getCoordinate())), i._minDistance <= i._terminateDistance)
        return null;
    }
};
Jn.prototype.distance = function() {
  if (this._geom[0] === null || this._geom[1] === null)
    throw new ze("null geometries are not supported");
  return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
};
Jn.prototype.computeMinDistanceLines = function(t, e, n) {
  for (var i = this, s = 0; s < t.size(); s++)
    for (var o = t.get(s), a = 0; a < e.size(); a++) {
      var u = e.get(a);
      if (i.computeMinDistance(o, u, n), i._minDistance <= i._terminateDistance)
        return null;
    }
};
Jn.prototype.interfaces_ = function() {
  return [];
};
Jn.prototype.getClass = function() {
  return Jn;
};
Jn.distance = function(t, e) {
  var n = new Jn(t, e);
  return n.distance();
};
Jn.isWithinDistance = function(t, e, n) {
  var i = new Jn(t, e, n);
  return i.distance() <= n;
};
Jn.nearestPoints = function(t, e) {
  var n = new Jn(t, e);
  return n.nearestPoints();
};
var nr = function() {
  this._pt = [new R(), new R()], this._distance = yt.NaN, this._isNull = !0;
};
nr.prototype.getCoordinates = function() {
  return this._pt;
};
nr.prototype.getCoordinate = function(t) {
  return this._pt[t];
};
nr.prototype.setMinimum = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.setMinimum(t._pt[0], t._pt[1]);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    if (this._isNull)
      return this.initialize(e, n), null;
    var i = e.distance(n);
    i < this._distance && this.initialize(e, n, i);
  }
};
nr.prototype.initialize = function() {
  if (arguments.length === 0)
    this._isNull = !0;
  else if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1;
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], s = arguments[2];
    this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = s, this._isNull = !1;
  }
};
nr.prototype.toString = function() {
  return Vi.toLineString(this._pt[0], this._pt[1]);
};
nr.prototype.getDistance = function() {
  return this._distance;
};
nr.prototype.setMaximum = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    this.setMaximum(t._pt[0], t._pt[1]);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1];
    if (this._isNull)
      return this.initialize(e, n), null;
    var i = e.distance(n);
    i > this._distance && this.initialize(e, n, i);
  }
};
nr.prototype.interfaces_ = function() {
  return [];
};
nr.prototype.getClass = function() {
  return nr;
};
var ls = function() {
};
ls.prototype.interfaces_ = function() {
  return [];
};
ls.prototype.getClass = function() {
  return ls;
};
ls.computeDistance = function() {
  if (arguments[2] instanceof nr && arguments[0] instanceof je && arguments[1] instanceof R)
    for (var t = arguments[0], e = arguments[1], n = arguments[2], i = new rt(), s = t.getCoordinates(), o = 0; o < s.length - 1; o++) {
      i.setCoordinates(s[o], s[o + 1]);
      var a = i.closestPoint(e);
      n.setMinimum(a, e);
    }
  else if (arguments[2] instanceof nr && arguments[0] instanceof Mn && arguments[1] instanceof R) {
    var u = arguments[0], x = arguments[1], c = arguments[2];
    ls.computeDistance(u.getExteriorRing(), x, c);
    for (var f = 0; f < u.getNumInteriorRing(); f++)
      ls.computeDistance(u.getInteriorRingN(f), x, c);
  } else if (arguments[2] instanceof nr && arguments[0] instanceof xt && arguments[1] instanceof R) {
    var l = arguments[0], h = arguments[1], p = arguments[2];
    if (l instanceof je)
      ls.computeDistance(l, h, p);
    else if (l instanceof Mn)
      ls.computeDistance(l, h, p);
    else if (l instanceof Ir)
      for (var y = l, v = 0; v < y.getNumGeometries(); v++) {
        var m = y.getGeometryN(v);
        ls.computeDistance(m, h, p);
      }
    else
      p.setMinimum(l.getCoordinate(), h);
  } else if (arguments[2] instanceof nr && arguments[0] instanceof rt && arguments[1] instanceof R) {
    var d = arguments[0], g = arguments[1], _ = arguments[2], b = d.closestPoint(g);
    _.setMinimum(b, g);
  }
};
var Ei = function() {
  this._g0 = null, this._g1 = null, this._ptDist = new nr(), this._densifyFrac = 0;
  var t = arguments[0], e = arguments[1];
  this._g0 = t, this._g1 = e;
}, j2 = { MaxPointDistanceFilter: { configurable: !0 }, MaxDensifiedByFractionDistanceFilter: { configurable: !0 } };
Ei.prototype.getCoordinates = function() {
  return this._ptDist.getCoordinates();
};
Ei.prototype.setDensifyFraction = function(t) {
  if (t > 1 || t <= 0)
    throw new ze("Fraction is not in range (0.0 - 1.0]");
  this._densifyFrac = t;
};
Ei.prototype.compute = function(t, e) {
  this.computeOrientedDistance(t, e, this._ptDist), this.computeOrientedDistance(e, t, this._ptDist);
};
Ei.prototype.distance = function() {
  return this.compute(this._g0, this._g1), this._ptDist.getDistance();
};
Ei.prototype.computeOrientedDistance = function(t, e, n) {
  var i = new nu(e);
  if (t.apply(i), n.setMaximum(i.getMaxPointDistance()), this._densifyFrac > 0) {
    var s = new va(e, this._densifyFrac);
    t.apply(s), n.setMaximum(s.getMaxPointDistance());
  }
};
Ei.prototype.orientedDistance = function() {
  return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
};
Ei.prototype.interfaces_ = function() {
  return [];
};
Ei.prototype.getClass = function() {
  return Ei;
};
Ei.distance = function() {
  if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1], n = new Ei(t, e);
    return n.distance();
  } else if (arguments.length === 3) {
    var i = arguments[0], s = arguments[1], o = arguments[2], a = new Ei(i, s);
    return a.setDensifyFraction(o), a.distance();
  }
};
j2.MaxPointDistanceFilter.get = function() {
  return nu;
};
j2.MaxDensifiedByFractionDistanceFilter.get = function() {
  return va;
};
Object.defineProperties(Ei, j2);
var nu = function() {
  this._maxPtDist = new nr(), this._minPtDist = new nr(), this._euclideanDist = new ls(), this._geom = null;
  var t = arguments[0];
  this._geom = t;
};
nu.prototype.filter = function(t) {
  this._minPtDist.initialize(), ls.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
};
nu.prototype.getMaxPointDistance = function() {
  return this._maxPtDist;
};
nu.prototype.interfaces_ = function() {
  return [Ks];
};
nu.prototype.getClass = function() {
  return nu;
};
var va = function() {
  this._maxPtDist = new nr(), this._minPtDist = new nr(), this._geom = null, this._numSubSegs = 0;
  var t = arguments[0], e = arguments[1];
  this._geom = t, this._numSubSegs = Math.trunc(Math.round(1 / e));
};
va.prototype.filter = function(t, e) {
  var n = this;
  if (e === 0)
    return null;
  for (var i = t.getCoordinate(e - 1), s = t.getCoordinate(e), o = (s.x - i.x) / this._numSubSegs, a = (s.y - i.y) / this._numSubSegs, u = 0; u < this._numSubSegs; u++) {
    var x = i.x + u * o, c = i.y + u * a, f = new R(x, c);
    n._minPtDist.initialize(), ls.computeDistance(n._geom, f, n._minPtDist), n._maxPtDist.setMaximum(n._minPtDist);
  }
};
va.prototype.isDone = function() {
  return !1;
};
va.prototype.isGeometryChanged = function() {
  return !1;
};
va.prototype.getMaxPointDistance = function() {
  return this._maxPtDist;
};
va.prototype.interfaces_ = function() {
  return [Wi];
};
va.prototype.getClass = function() {
  return va;
};
var Wr = function(t, e, n) {
  this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = !0, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._bufDistance = e || null, this._result = n || null;
}, Q2 = { VERBOSE: { configurable: !0 }, MAX_DISTANCE_DIFF_FRAC: { configurable: !0 } };
Wr.prototype.checkMaximumDistance = function(t, e, n) {
  var i = new Ei(e, t);
  if (i.setDensifyFraction(0.25), this._maxDistanceFound = i.orientedDistance(), this._maxDistanceFound > n) {
    this._isValid = !1;
    var s = i.getCoordinates();
    this._errorLocation = s[1], this._errorIndicator = t.getFactory().createLineString(s), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Vi.toLineString(s[0], s[1]) + ")";
  }
};
Wr.prototype.isValid = function() {
  var t = Math.abs(this._bufDistance), e = Wr.MAX_DISTANCE_DIFF_FRAC * t;
  return this._minValidDistance = t - e, this._maxValidDistance = t + e, this._input.isEmpty() || this._result.isEmpty() ? !0 : (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Wr.VERBOSE && Hn.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
};
Wr.prototype.checkNegativeValid = function() {
  if (!(this._input instanceof Mn || this._input instanceof Vs || this._input instanceof Ir))
    return null;
  var t = this.getPolygonLines(this._input);
  if (this.checkMinimumDistance(t, this._result, this._minValidDistance), !this._isValid)
    return null;
  this.checkMaximumDistance(t, this._result, this._maxValidDistance);
};
Wr.prototype.getErrorIndicator = function() {
  return this._errorIndicator;
};
Wr.prototype.checkMinimumDistance = function(t, e, n) {
  var i = new Jn(t, e, n);
  if (this._minDistanceFound = i.distance(), this._minDistanceFound < n) {
    this._isValid = !1;
    var s = i.nearestPoints();
    this._errorLocation = i.nearestPoints()[1], this._errorIndicator = t.getFactory().createLineString(s), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Vi.toLineString(s[0], s[1]) + " )";
  }
};
Wr.prototype.checkPositiveValid = function() {
  var t = this._result.getBoundary();
  if (this.checkMinimumDistance(this._input, t, this._minValidDistance), !this._isValid)
    return null;
  this.checkMaximumDistance(this._input, t, this._maxValidDistance);
};
Wr.prototype.getErrorLocation = function() {
  return this._errorLocation;
};
Wr.prototype.getPolygonLines = function(t) {
  for (var e = new H(), n = new qn(e), i = Io.getPolygons(t), s = i.iterator(); s.hasNext(); ) {
    var o = s.next();
    o.apply(n);
  }
  return t.getFactory().buildGeometry(e);
};
Wr.prototype.getErrorMessage = function() {
  return this._errMsg;
};
Wr.prototype.interfaces_ = function() {
  return [];
};
Wr.prototype.getClass = function() {
  return Wr;
};
Q2.VERBOSE.get = function() {
  return !1;
};
Q2.MAX_DISTANCE_DIFF_FRAC.get = function() {
  return 0.012;
};
Object.defineProperties(Wr, Q2);
var Zn = function(t, e, n) {
  this._isValid = !0, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._distance = e || null, this._result = n || null;
}, $2 = { VERBOSE: { configurable: !0 }, MAX_ENV_DIFF_FRAC: { configurable: !0 } };
Zn.prototype.isValid = function() {
  return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
};
Zn.prototype.checkEnvelope = function() {
  if (this._distance < 0)
    return null;
  var t = this._distance * Zn.MAX_ENV_DIFF_FRAC;
  t === 0 && (t = 1e-3);
  var e = new nt(this._input.getEnvelopeInternal());
  e.expandBy(this._distance);
  var n = new nt(this._result.getEnvelopeInternal());
  n.expandBy(t), n.contains(e) || (this._isValid = !1, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n)), this.report("Envelope");
};
Zn.prototype.checkDistance = function() {
  var t = new Wr(this._input, this._distance, this._result);
  t.isValid() || (this._isValid = !1, this._errorMsg = t.getErrorMessage(), this._errorLocation = t.getErrorLocation(), this._errorIndicator = t.getErrorIndicator()), this.report("Distance");
};
Zn.prototype.checkArea = function() {
  var t = this._input.getArea(), e = this._result.getArea();
  this._distance > 0 && t > e && (this._isValid = !1, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t < e && (this._isValid = !1, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
};
Zn.prototype.checkPolygonal = function() {
  this._result instanceof Mn || this._result instanceof Vs || (this._isValid = !1), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
};
Zn.prototype.getErrorIndicator = function() {
  return this._errorIndicator;
};
Zn.prototype.getErrorLocation = function() {
  return this._errorLocation;
};
Zn.prototype.checkExpectedEmpty = function() {
  if (this._input.getDimension() >= 2 || this._distance > 0)
    return null;
  this._result.isEmpty() || (this._isValid = !1, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), this.report("ExpectedEmpty");
};
Zn.prototype.report = function(t) {
  if (!Zn.VERBOSE)
    return null;
  Hn.out.println("Check " + t + ": " + (this._isValid ? "passed" : "FAILED"));
};
Zn.prototype.getErrorMessage = function() {
  return this._errorMsg;
};
Zn.prototype.interfaces_ = function() {
  return [];
};
Zn.prototype.getClass = function() {
  return Zn;
};
Zn.isValidMsg = function(t, e, n) {
  var i = new Zn(t, e, n);
  return i.isValid() ? null : i.getErrorMessage();
};
Zn.isValid = function(t, e, n) {
  var i = new Zn(t, e, n);
  return !!i.isValid();
};
$2.VERBOSE.get = function() {
  return !1;
};
$2.MAX_ENV_DIFF_FRAC.get = function() {
  return 0.012;
};
Object.defineProperties(Zn, $2);
var Os = function() {
  this._pts = null, this._data = null;
  var t = arguments[0], e = arguments[1];
  this._pts = t, this._data = e;
};
Os.prototype.getCoordinates = function() {
  return this._pts;
};
Os.prototype.size = function() {
  return this._pts.length;
};
Os.prototype.getCoordinate = function(t) {
  return this._pts[t];
};
Os.prototype.isClosed = function() {
  return this._pts[0].equals(this._pts[this._pts.length - 1]);
};
Os.prototype.getSegmentOctant = function(t) {
  return t === this._pts.length - 1 ? -1 : j0.octant(this.getCoordinate(t), this.getCoordinate(t + 1));
};
Os.prototype.setData = function(t) {
  this._data = t;
};
Os.prototype.getData = function() {
  return this._data;
};
Os.prototype.toString = function() {
  return Vi.toLineString(new en(this._pts));
};
Os.prototype.interfaces_ = function() {
  return [$s];
};
Os.prototype.getClass = function() {
  return Os;
};
var Fn = function() {
  this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new H(), this._intersectionCount = 0, this._keepIntersections = !0;
  var t = arguments[0];
  this._li = t, this._interiorIntersection = null;
};
Fn.prototype.getInteriorIntersection = function() {
  return this._interiorIntersection;
};
Fn.prototype.setCheckEndSegmentsOnly = function(t) {
  this._isCheckEndSegmentsOnly = t;
};
Fn.prototype.getIntersectionSegments = function() {
  return this._intSegments;
};
Fn.prototype.count = function() {
  return this._intersectionCount;
};
Fn.prototype.getIntersections = function() {
  return this._intersections;
};
Fn.prototype.setFindAllIntersections = function(t) {
  this._findAllIntersections = t;
};
Fn.prototype.setKeepIntersections = function(t) {
  this._keepIntersections = t;
};
Fn.prototype.processIntersections = function(t, e, n, i) {
  if (!this._findAllIntersections && this.hasIntersection() || t === n && e === i)
    return null;
  if (this._isCheckEndSegmentsOnly) {
    var s = this.isEndSegment(t, e) || this.isEndSegment(n, i);
    if (!s)
      return null;
  }
  var o = t.getCoordinates()[e], a = t.getCoordinates()[e + 1], u = n.getCoordinates()[i], x = n.getCoordinates()[i + 1];
  this._li.computeIntersection(o, a, u, x), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = o, this._intSegments[1] = a, this._intSegments[2] = u, this._intSegments[3] = x, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
};
Fn.prototype.isEndSegment = function(t, e) {
  return e === 0 || e >= t.size() - 2;
};
Fn.prototype.hasIntersection = function() {
  return this._interiorIntersection !== null;
};
Fn.prototype.isDone = function() {
  return this._findAllIntersections ? !1 : this._interiorIntersection !== null;
};
Fn.prototype.interfaces_ = function() {
  return [e0];
};
Fn.prototype.getClass = function() {
  return Fn;
};
Fn.createAllIntersectionsFinder = function(t) {
  var e = new Fn(t);
  return e.setFindAllIntersections(!0), e;
};
Fn.createAnyIntersectionFinder = function(t) {
  return new Fn(t);
};
Fn.createIntersectionCounter = function(t) {
  var e = new Fn(t);
  return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e;
};
var ji = function() {
  this._li = new l0(), this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0;
  var t = arguments[0];
  this._segStrings = t;
};
ji.prototype.execute = function() {
  if (this._segInt !== null)
    return null;
  this.checkInteriorIntersections();
};
ji.prototype.getIntersections = function() {
  return this._segInt.getIntersections();
};
ji.prototype.isValid = function() {
  return this.execute(), this._isValid;
};
ji.prototype.setFindAllIntersections = function(t) {
  this._findAllIntersections = t;
};
ji.prototype.checkInteriorIntersections = function() {
  this._isValid = !0, this._segInt = new Fn(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
  var t = new Z2();
  if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection())
    return this._isValid = !1, null;
};
ji.prototype.checkValid = function() {
  if (this.execute(), !this._isValid)
    throw new Mo(this.getErrorMessage(), this._segInt.getInteriorIntersection());
};
ji.prototype.getErrorMessage = function() {
  if (this._isValid)
    return "no intersections found";
  var t = this._segInt.getIntersectionSegments();
  return "found non-noded intersection between " + Vi.toLineString(t[0], t[1]) + " and " + Vi.toLineString(t[2], t[3]);
};
ji.prototype.interfaces_ = function() {
  return [];
};
ji.prototype.getClass = function() {
  return ji;
};
ji.computeIntersections = function(t) {
  var e = new ji(t);
  return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections();
};
var i0 = function r() {
  this._nv = null;
  var t = arguments[0];
  this._nv = new ji(r.toSegmentStrings(t));
};
i0.prototype.checkValid = function() {
  this._nv.checkValid();
};
i0.prototype.interfaces_ = function() {
  return [];
};
i0.prototype.getClass = function() {
  return i0;
};
i0.toSegmentStrings = function(t) {
  for (var e = new H(), n = t.iterator(); n.hasNext(); ) {
    var i = n.next();
    e.add(new Os(i.getCoordinates(), i));
  }
  return e;
};
i0.checkValid = function(t) {
  var e = new i0(t);
  e.checkValid();
};
var ru = function(t) {
  this._mapOp = t;
};
ru.prototype.map = function(t) {
  for (var e = this, n = new H(), i = 0; i < t.getNumGeometries(); i++) {
    var s = e._mapOp.map(t.getGeometryN(i));
    s.isEmpty() || n.add(s);
  }
  return t.getFactory().createGeometryCollection(St.toGeometryArray(n));
};
ru.prototype.interfaces_ = function() {
  return [];
};
ru.prototype.getClass = function() {
  return ru;
};
ru.map = function(t, e) {
  var n = new ru(e);
  return n.map(t);
};
var Rs = function() {
  this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new H(), this._resultLineList = new H();
  var t = arguments[0], e = arguments[1], n = arguments[2];
  this._op = t, this._geometryFactory = e, this._ptLocator = n;
};
Rs.prototype.collectLines = function(t) {
  for (var e = this, n = this._op.getGraph().getEdgeEnds().iterator(); n.hasNext(); ) {
    var i = n.next();
    e.collectLineEdge(i, t, e._lineEdgesList), e.collectBoundaryTouchEdge(i, t, e._lineEdgesList);
  }
};
Rs.prototype.labelIsolatedLine = function(t, e) {
  var n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e));
  t.getLabel().setLocation(e, n);
};
Rs.prototype.build = function(t) {
  return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList;
};
Rs.prototype.collectLineEdge = function(t, e, n) {
  var i = t.getLabel(), s = t.getEdge();
  t.isLineEdge() && !t.isVisited() && vt.isResultOfOp(i, e) && !s.isCovered() && (n.add(s), t.setVisitedEdge(!0));
};
Rs.prototype.findCoveredLineEdges = function() {
  for (var t = this, e = this._op.getGraph().getNodes().iterator(); e.hasNext(); ) {
    var n = e.next();
    n.getEdges().findCoveredLineEdges();
  }
  for (var i = this._op.getGraph().getEdgeEnds().iterator(); i.hasNext(); ) {
    var s = i.next(), o = s.getEdge();
    if (s.isLineEdge() && !o.isCoveredSet()) {
      var a = t._op.isCoveredByA(s.getCoordinate());
      o.setCovered(a);
    }
  }
};
Rs.prototype.labelIsolatedLines = function(t) {
  for (var e = this, n = t.iterator(); n.hasNext(); ) {
    var i = n.next(), s = i.getLabel();
    i.isIsolated() && (s.isNull(0) ? e.labelIsolatedLine(i, 0) : e.labelIsolatedLine(i, 1));
  }
};
Rs.prototype.buildLines = function(t) {
  for (var e = this, n = this._lineEdgesList.iterator(); n.hasNext(); ) {
    var i = n.next(), s = e._geometryFactory.createLineString(i.getCoordinates());
    e._resultLineList.add(s), i.setInResult(!0);
  }
};
Rs.prototype.collectBoundaryTouchEdge = function(t, e, n) {
  var i = t.getLabel();
  if (t.isLineEdge() || t.isVisited() || t.isInteriorAreaEdge() || t.getEdge().isInResult())
    return null;
  mt.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), vt.isResultOfOp(i, e) && e === vt.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0));
};
Rs.prototype.interfaces_ = function() {
  return [];
};
Rs.prototype.getClass = function() {
  return Rs;
};
var iu = function() {
  this._op = null, this._geometryFactory = null, this._resultPointList = new H();
  var t = arguments[0], e = arguments[1];
  this._op = t, this._geometryFactory = e;
};
iu.prototype.filterCoveredNodeToPoint = function(t) {
  var e = t.getCoordinate();
  if (!this._op.isCoveredByLA(e)) {
    var n = this._geometryFactory.createPoint(e);
    this._resultPointList.add(n);
  }
};
iu.prototype.extractNonCoveredResultNodes = function(t) {
  for (var e = this, n = this._op.getGraph().getNodes().iterator(); n.hasNext(); ) {
    var i = n.next();
    if (!i.isInResult() && !i.isIncidentEdgeInResult() && (i.getEdges().getDegree() === 0 || t === vt.INTERSECTION)) {
      var s = i.getLabel();
      vt.isResultOfOp(s, t) && e.filterCoveredNodeToPoint(i);
    }
  }
};
iu.prototype.build = function(t) {
  return this.extractNonCoveredResultNodes(t), this._resultPointList;
};
iu.prototype.interfaces_ = function() {
  return [];
};
iu.prototype.getClass = function() {
  return iu;
};
var Gr = function() {
  this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1;
};
Gr.prototype.transformPoint = function(t, e) {
  return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t));
};
Gr.prototype.transformPolygon = function(t, e) {
  var n = this, i = !0, s = this.transformLinearRing(t.getExteriorRing(), t);
  (s === null || !(s instanceof js) || s.isEmpty()) && (i = !1);
  for (var o = new H(), a = 0; a < t.getNumInteriorRing(); a++) {
    var u = n.transformLinearRing(t.getInteriorRingN(a), t);
    u === null || u.isEmpty() || (u instanceof js || (i = !1), o.add(u));
  }
  if (i)
    return this._factory.createPolygon(s, o.toArray([]));
  var x = new H();
  return s !== null && x.add(s), x.addAll(o), this._factory.buildGeometry(x);
};
Gr.prototype.createCoordinateSequence = function(t) {
  return this._factory.getCoordinateSequenceFactory().create(t);
};
Gr.prototype.getInputGeometry = function() {
  return this._inputGeom;
};
Gr.prototype.transformMultiLineString = function(t, e) {
  for (var n = this, i = new H(), s = 0; s < t.getNumGeometries(); s++) {
    var o = n.transformLineString(t.getGeometryN(s), t);
    o !== null && (o.isEmpty() || i.add(o));
  }
  return this._factory.buildGeometry(i);
};
Gr.prototype.transformCoordinates = function(t, e) {
  return this.copy(t);
};
Gr.prototype.transformLineString = function(t, e) {
  return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t));
};
Gr.prototype.transformMultiPoint = function(t, e) {
  for (var n = this, i = new H(), s = 0; s < t.getNumGeometries(); s++) {
    var o = n.transformPoint(t.getGeometryN(s), t);
    o !== null && (o.isEmpty() || i.add(o));
  }
  return this._factory.buildGeometry(i);
};
Gr.prototype.transformMultiPolygon = function(t, e) {
  for (var n = this, i = new H(), s = 0; s < t.getNumGeometries(); s++) {
    var o = n.transformPolygon(t.getGeometryN(s), t);
    o !== null && (o.isEmpty() || i.add(o));
  }
  return this._factory.buildGeometry(i);
};
Gr.prototype.copy = function(t) {
  return t.copy();
};
Gr.prototype.transformGeometryCollection = function(t, e) {
  for (var n = this, i = new H(), s = 0; s < t.getNumGeometries(); s++) {
    var o = n.transform(t.getGeometryN(s));
    o !== null && (n._pruneEmptyGeometry && o.isEmpty() || i.add(o));
  }
  return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(St.toGeometryArray(i)) : this._factory.buildGeometry(i);
};
Gr.prototype.transform = function(t) {
  if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof Jr)
    return this.transformPoint(t, null);
  if (t instanceof Gx)
    return this.transformMultiPoint(t, null);
  if (t instanceof js)
    return this.transformLinearRing(t, null);
  if (t instanceof je)
    return this.transformLineString(t, null);
  if (t instanceof Qa)
    return this.transformMultiLineString(t, null);
  if (t instanceof Mn)
    return this.transformPolygon(t, null);
  if (t instanceof Vs)
    return this.transformMultiPolygon(t, null);
  if (t instanceof Ir)
    return this.transformGeometryCollection(t, null);
  throw new ze("Unknown Geometry subtype: " + t.getClass().getName());
};
Gr.prototype.transformLinearRing = function(t, e) {
  var n = this.transformCoordinates(t.getCoordinateSequence(), t);
  if (n === null)
    return this._factory.createLinearRing(null);
  var i = n.size();
  return i > 0 && i < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n);
};
Gr.prototype.interfaces_ = function() {
  return [];
};
Gr.prototype.getClass = function() {
  return Gr;
};
var no = function r() {
  if (this._snapTolerance = 0, this._srcPts = null, this._seg = new rt(), this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof je && typeof arguments[1] == "number") {
    var t = arguments[0], e = arguments[1];
    r.call(this, t.getCoordinates(), e);
  } else if (arguments[0] instanceof Array && typeof arguments[1] == "number") {
    var n = arguments[0], i = arguments[1];
    this._srcPts = n, this._isClosed = r.isClosed(n), this._snapTolerance = i;
  }
};
no.prototype.snapVertices = function(t, e) {
  for (var n = this, i = this._isClosed ? t.size() - 1 : t.size(), s = 0; s < i; s++) {
    var o = t.get(s), a = n.findSnapForVertex(o, e);
    a !== null && (t.set(s, new R(a)), s === 0 && n._isClosed && t.set(t.size() - 1, new R(a)));
  }
};
no.prototype.findSnapForVertex = function(t, e) {
  for (var n = this, i = 0; i < e.length; i++) {
    if (t.equals2D(e[i]))
      return null;
    if (t.distance(e[i]) < n._snapTolerance)
      return e[i];
  }
  return null;
};
no.prototype.snapTo = function(t) {
  var e = new jl(this._srcPts);
  this.snapVertices(e, t), this.snapSegments(e, t);
  var n = e.toCoordinateArray();
  return n;
};
no.prototype.snapSegments = function(t, e) {
  var n = this;
  if (e.length === 0)
    return null;
  var i = e.length;
  e[0].equals2D(e[e.length - 1]) && (i = e.length - 1);
  for (var s = 0; s < i; s++) {
    var o = e[s], a = n.findSegmentIndexToSnap(o, t);
    a >= 0 && t.add(a + 1, new R(o), !1);
  }
};
no.prototype.findSegmentIndexToSnap = function(t, e) {
  for (var n = this, i = yt.MAX_VALUE, s = -1, o = 0; o < e.size() - 1; o++) {
    if (n._seg.p0 = e.get(o), n._seg.p1 = e.get(o + 1), n._seg.p0.equals2D(t) || n._seg.p1.equals2D(t)) {
      if (n._allowSnappingToSourceVertices)
        continue;
      return -1;
    }
    var a = n._seg.distance(t);
    a < n._snapTolerance && a < i && (i = a, s = o);
  }
  return s;
};
no.prototype.setAllowSnappingToSourceVertices = function(t) {
  this._allowSnappingToSourceVertices = t;
};
no.prototype.interfaces_ = function() {
  return [];
};
no.prototype.getClass = function() {
  return no;
};
no.isClosed = function(t) {
  return t.length <= 1 ? !1 : t[0].equals2D(t[t.length - 1]);
};
var nn = function(t) {
  this._srcGeom = t || null;
}, i6 = { SNAP_PRECISION_FACTOR: { configurable: !0 } };
nn.prototype.snapTo = function(t, e) {
  var n = this.extractTargetCoordinates(t), i = new s6(e, n);
  return i.transform(this._srcGeom);
};
nn.prototype.snapToSelf = function(t, e) {
  var n = this.extractTargetCoordinates(this._srcGeom), i = new s6(t, n, !0), s = i.transform(this._srcGeom), o = s;
  return e && ct(o, la) && (o = s.buffer(0)), o;
};
nn.prototype.computeSnapTolerance = function(t) {
  var e = this.computeMinimumSegmentLength(t), n = e / 10;
  return n;
};
nn.prototype.extractTargetCoordinates = function(t) {
  for (var e = new Es(), n = t.getCoordinates(), i = 0; i < n.length; i++)
    e.add(n[i]);
  return e.toArray(new Array(0).fill(null));
};
nn.prototype.computeMinimumSegmentLength = function(t) {
  for (var e = yt.MAX_VALUE, n = 0; n < t.length - 1; n++) {
    var i = t[n].distance(t[n + 1]);
    i < e && (e = i);
  }
  return e;
};
nn.prototype.interfaces_ = function() {
  return [];
};
nn.prototype.getClass = function() {
  return nn;
};
nn.snap = function(t, e, n) {
  var i = new Array(2).fill(null), s = new nn(t);
  i[0] = s.snapTo(e, n);
  var o = new nn(e);
  return i[1] = o.snapTo(i[0], n), i;
};
nn.computeOverlaySnapTolerance = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = nn.computeSizeBasedSnapTolerance(t), n = t.getPrecisionModel();
    if (n.getType() === xe.FIXED) {
      var i = 1 / n.getScale() * 2 / 1.415;
      i > e && (e = i);
    }
    return e;
  } else if (arguments.length === 2) {
    var s = arguments[0], o = arguments[1];
    return Math.min(nn.computeOverlaySnapTolerance(s), nn.computeOverlaySnapTolerance(o));
  }
};
nn.computeSizeBasedSnapTolerance = function(t) {
  var e = t.getEnvelopeInternal(), n = Math.min(e.getHeight(), e.getWidth()), i = n * nn.SNAP_PRECISION_FACTOR;
  return i;
};
nn.snapToSelf = function(t, e, n) {
  var i = new nn(t);
  return i.snapToSelf(e, n);
};
i6.SNAP_PRECISION_FACTOR.get = function() {
  return 1e-9;
};
Object.defineProperties(nn, i6);
var s6 = function(r) {
  function t(e, n, i) {
    r.call(this), this._snapTolerance = e || null, this._snapPts = n || null, this._isSelfSnap = i !== void 0 ? i : !1;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.snapLine = function(n, i) {
    var s = new no(n, this._snapTolerance);
    return s.setAllowSnappingToSourceVertices(this._isSelfSnap), s.snapTo(i);
  }, t.prototype.transformCoordinates = function(n, i) {
    var s = n.toCoordinateArray(), o = this.snapLine(s, this._snapPts);
    return this._factory.getCoordinateSequenceFactory().create(o);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(Gr), gr = function() {
  this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
};
gr.prototype.getCommon = function() {
  return yt.longBitsToDouble(this._commonBits);
};
gr.prototype.add = function(t) {
  var e = yt.doubleToLongBits(t);
  if (this._isFirst)
    return this._commonBits = e, this._commonSignExp = gr.signExpBits(this._commonBits), this._isFirst = !1, null;
  var n = gr.signExpBits(e);
  if (n !== this._commonSignExp)
    return this._commonBits = 0, null;
  this._commonMantissaBitsCount = gr.numCommonMostSigMantissaBits(this._commonBits, e), this._commonBits = gr.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
};
gr.prototype.toString = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = yt.longBitsToDouble(t), n = yt.toBinaryString(t), i = "0000000000000000000000000000000000000000000000000000000000000000" + n, s = i.substring(i.length - 64), o = s.substring(0, 1) + "  " + s.substring(1, 12) + "(exp) " + s.substring(12) + " [ " + e + " ]";
    return o;
  }
};
gr.prototype.interfaces_ = function() {
  return [];
};
gr.prototype.getClass = function() {
  return gr;
};
gr.getBit = function(t, e) {
  var n = 1 << e;
  return t & n ? 1 : 0;
};
gr.signExpBits = function(t) {
  return t >> 52;
};
gr.zeroLowerBits = function(t, e) {
  var n = (1 << e) - 1, i = ~n, s = t & i;
  return s;
};
gr.numCommonMostSigMantissaBits = function(t, e) {
  for (var n = 0, i = 52; i >= 0; i--) {
    if (gr.getBit(t, i) !== gr.getBit(e, i))
      return n;
    n++;
  }
  return 52;
};
var ma = function() {
  this._commonCoord = null, this._ccFilter = new su();
}, tb = { CommonCoordinateFilter: { configurable: !0 }, Translater: { configurable: !0 } };
ma.prototype.addCommonBits = function(t) {
  var e = new _a(this._commonCoord);
  t.apply(e), t.geometryChanged();
};
ma.prototype.removeCommonBits = function(t) {
  if (this._commonCoord.x === 0 && this._commonCoord.y === 0)
    return t;
  var e = new R(this._commonCoord);
  e.x = -e.x, e.y = -e.y;
  var n = new _a(e);
  return t.apply(n), t.geometryChanged(), t;
};
ma.prototype.getCommonCoordinate = function() {
  return this._commonCoord;
};
ma.prototype.add = function(t) {
  t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
};
ma.prototype.interfaces_ = function() {
  return [];
};
ma.prototype.getClass = function() {
  return ma;
};
tb.CommonCoordinateFilter.get = function() {
  return su;
};
tb.Translater.get = function() {
  return _a;
};
Object.defineProperties(ma, tb);
var su = function() {
  this._commonBitsX = new gr(), this._commonBitsY = new gr();
};
su.prototype.filter = function(t) {
  this._commonBitsX.add(t.x), this._commonBitsY.add(t.y);
};
su.prototype.getCommonCoordinate = function() {
  return new R(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
};
su.prototype.interfaces_ = function() {
  return [Ks];
};
su.prototype.getClass = function() {
  return su;
};
var _a = function() {
  this.trans = null;
  var t = arguments[0];
  this.trans = t;
};
_a.prototype.filter = function(t, e) {
  var n = t.getOrdinate(e, 0) + this.trans.x, i = t.getOrdinate(e, 1) + this.trans.y;
  t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i);
};
_a.prototype.isDone = function() {
  return !1;
};
_a.prototype.isGeometryChanged = function() {
  return !0;
};
_a.prototype.interfaces_ = function() {
  return [Wi];
};
_a.prototype.getClass = function() {
  return _a;
};
var kn = function(t, e) {
  this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance();
};
kn.prototype.selfSnap = function(t) {
  var e = new nn(t), n = e.snapTo(t, this._snapTolerance);
  return n;
};
kn.prototype.removeCommonBits = function(t) {
  this._cbr = new ma(), this._cbr.add(t[0]), this._cbr.add(t[1]);
  var e = new Array(2).fill(null);
  return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e;
};
kn.prototype.prepareResult = function(t) {
  return this._cbr.addCommonBits(t), t;
};
kn.prototype.getResultGeometry = function(t) {
  var e = this.snap(this._geom), n = vt.overlayOp(e[0], e[1], t);
  return this.prepareResult(n);
};
kn.prototype.checkValid = function(t) {
  t.isValid() || Hn.out.println("Snapped geometry is invalid");
};
kn.prototype.computeSnapTolerance = function() {
  this._snapTolerance = nn.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
};
kn.prototype.snap = function(t) {
  var e = this.removeCommonBits(t), n = nn.snap(e[0], e[1], this._snapTolerance);
  return n;
};
kn.prototype.interfaces_ = function() {
  return [];
};
kn.prototype.getClass = function() {
  return kn;
};
kn.overlayOp = function(t, e, n) {
  var i = new kn(t, e);
  return i.getResultGeometry(n);
};
kn.union = function(t, e) {
  return kn.overlayOp(t, e, vt.UNION);
};
kn.intersection = function(t, e) {
  return kn.overlayOp(t, e, vt.INTERSECTION);
};
kn.symDifference = function(t, e) {
  return kn.overlayOp(t, e, vt.SYMDIFFERENCE);
};
kn.difference = function(t, e) {
  return kn.overlayOp(t, e, vt.DIFFERENCE);
};
var Sr = function(t, e) {
  this._geom = new Array(2).fill(null), this._geom[0] = t, this._geom[1] = e;
};
Sr.prototype.getResultGeometry = function(t) {
  var e = null, n = !1, i = null;
  try {
    e = vt.overlayOp(this._geom[0], this._geom[1], t);
    var s = !0;
    s && (n = !0);
  } catch (o) {
    if (o instanceof So)
      i = o;
    else
      throw o;
  } finally {
  }
  if (!n)
    try {
      e = kn.overlayOp(this._geom[0], this._geom[1], t);
    } catch (o) {
      throw o instanceof So ? i : o;
    } finally {
    }
  return e;
};
Sr.prototype.interfaces_ = function() {
  return [];
};
Sr.prototype.getClass = function() {
  return Sr;
};
Sr.overlayOp = function(t, e, n) {
  var i = new Sr(t, e);
  return i.getResultGeometry(n);
};
Sr.union = function(t, e) {
  return Sr.overlayOp(t, e, vt.UNION);
};
Sr.intersection = function(t, e) {
  return Sr.overlayOp(t, e, vt.INTERSECTION);
};
Sr.symDifference = function(t, e) {
  return Sr.overlayOp(t, e, vt.SYMDIFFERENCE);
};
Sr.difference = function(t, e) {
  return Sr.overlayOp(t, e, vt.DIFFERENCE);
};
var Pl = function() {
  this.mce = null, this.chainIndex = null;
  var t = arguments[0], e = arguments[1];
  this.mce = t, this.chainIndex = e;
};
Pl.prototype.computeIntersections = function(t, e) {
  this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e);
};
Pl.prototype.interfaces_ = function() {
  return [];
};
Pl.prototype.getClass = function() {
  return Pl;
};
var jr = function r() {
  if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, arguments.length === 2) {
    var t = arguments[0], e = arguments[1];
    this._eventType = r.DELETE, this._xValue = t, this._insertEvent = e;
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], s = arguments[2];
    this._eventType = r.INSERT, this._label = n, this._xValue = i, this._obj = s;
  }
}, eb = { INSERT: { configurable: !0 }, DELETE: { configurable: !0 } };
jr.prototype.isDelete = function() {
  return this._eventType === jr.DELETE;
};
jr.prototype.setDeleteEventIndex = function(t) {
  this._deleteEventIndex = t;
};
jr.prototype.getObject = function() {
  return this._obj;
};
jr.prototype.compareTo = function(t) {
  var e = t;
  return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0;
};
jr.prototype.getInsertEvent = function() {
  return this._insertEvent;
};
jr.prototype.isInsert = function() {
  return this._eventType === jr.INSERT;
};
jr.prototype.isSameLabel = function(t) {
  return this._label === null ? !1 : this._label === t._label;
};
jr.prototype.getDeleteEventIndex = function() {
  return this._deleteEventIndex;
};
jr.prototype.interfaces_ = function() {
  return [Ri];
};
jr.prototype.getClass = function() {
  return jr;
};
eb.INSERT.get = function() {
  return 1;
};
eb.DELETE.get = function() {
  return 2;
};
Object.defineProperties(jr, eb);
var kg = function() {
};
kg.prototype.interfaces_ = function() {
  return [];
};
kg.prototype.getClass = function() {
  return kg;
};
var Kn = function() {
  this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1;
  var t = arguments[0], e = arguments[1], n = arguments[2];
  this._li = t, this._includeProper = e, this._recordIsolated = n;
};
Kn.prototype.isTrivialIntersection = function(t, e, n, i) {
  if (t === n && this._li.getIntersectionNum() === 1) {
    if (Kn.isAdjacentSegments(e, i))
      return !0;
    if (t.isClosed()) {
      var s = t.getNumPoints() - 1;
      if (e === 0 && i === s || i === 0 && e === s)
        return !0;
    }
  }
  return !1;
};
Kn.prototype.getProperIntersectionPoint = function() {
  return this._properIntersectionPoint;
};
Kn.prototype.setIsDoneIfProperInt = function(t) {
  this._isDoneWhenProperInt = t;
};
Kn.prototype.hasProperInteriorIntersection = function() {
  return this._hasProperInterior;
};
Kn.prototype.isBoundaryPointInternal = function(t, e) {
  for (var n = e.iterator(); n.hasNext(); ) {
    var i = n.next(), s = i.getCoordinate();
    if (t.isIntersection(s))
      return !0;
  }
  return !1;
};
Kn.prototype.hasProperIntersection = function() {
  return this._hasProper;
};
Kn.prototype.hasIntersection = function() {
  return this._hasIntersection;
};
Kn.prototype.isDone = function() {
  return this._isDone;
};
Kn.prototype.isBoundaryPoint = function(t, e) {
  return e === null ? !1 : !!(this.isBoundaryPointInternal(t, e[0]) || this.isBoundaryPointInternal(t, e[1]));
};
Kn.prototype.setBoundaryNodes = function(t, e) {
  this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e;
};
Kn.prototype.addIntersections = function(t, e, n, i) {
  if (t === n && e === i)
    return null;
  this.numTests++;
  var s = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], a = n.getCoordinates()[i], u = n.getCoordinates()[i + 1];
  this._li.computeIntersection(s, o, a, u), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, (this._includeProper || !this._li.isProper()) && (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))));
};
Kn.prototype.interfaces_ = function() {
  return [];
};
Kn.prototype.getClass = function() {
  return Kn;
};
Kn.isAdjacentSegments = function(t, e) {
  return Math.abs(t - e) === 1;
};
var vF = function(r) {
  function t() {
    r.call(this), this.events = new H(), this.nOverlaps = null;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.prepareEvents = function() {
    var n = this;
    Ji.sort(this.events);
    for (var i = 0; i < this.events.size(); i++) {
      var s = n.events.get(i);
      s.isDelete() && s.getInsertEvent().setDeleteEventIndex(i);
    }
  }, t.prototype.computeIntersections = function() {
    var n = this;
    if (arguments.length === 1) {
      var i = arguments[0];
      this.nOverlaps = 0, this.prepareEvents();
      for (var s = 0; s < this.events.size(); s++) {
        var o = n.events.get(s);
        if (o.isInsert() && n.processOverlaps(s, o.getDeleteEventIndex(), o, i), i.isDone())
          break;
      }
    } else if (arguments.length === 3) {
      if (arguments[2] instanceof Kn && ct(arguments[0], zi) && ct(arguments[1], zi)) {
        var a = arguments[0], u = arguments[1], x = arguments[2];
        this.addEdges(a, a), this.addEdges(u, u), this.computeIntersections(x);
      } else if (typeof arguments[2] == "boolean" && ct(arguments[0], zi) && arguments[1] instanceof Kn) {
        var c = arguments[0], f = arguments[1], l = arguments[2];
        l ? this.addEdges(c, null) : this.addEdges(c), this.computeIntersections(f);
      }
    }
  }, t.prototype.addEdge = function(n, i) {
    for (var s = this, o = n.getMonotoneChainEdge(), a = o.getStartIndexes(), u = 0; u < a.length - 1; u++) {
      var x = new Pl(o, u), c = new jr(i, o.getMinX(u), x);
      s.events.add(c), s.events.add(new jr(o.getMaxX(u), c));
    }
  }, t.prototype.processOverlaps = function(n, i, s, o) {
    for (var a = this, u = s.getObject(), x = n; x < i; x++) {
      var c = a.events.get(x);
      if (c.isInsert()) {
        var f = c.getObject();
        s.isSameLabel(c) || (u.computeIntersections(f, o), a.nOverlaps++);
      }
    }
  }, t.prototype.addEdges = function() {
    var n = this;
    if (arguments.length === 1)
      for (var i = arguments[0], s = i.iterator(); s.hasNext(); ) {
        var o = s.next();
        n.addEdge(o, o);
      }
    else if (arguments.length === 2)
      for (var a = arguments[0], u = arguments[1], x = a.iterator(); x.hasNext(); ) {
        var c = x.next();
        n.addEdge(c, u);
      }
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(kg), ro = function() {
  this._min = yt.POSITIVE_INFINITY, this._max = yt.NEGATIVE_INFINITY;
}, o6 = { NodeComparator: { configurable: !0 } };
ro.prototype.getMin = function() {
  return this._min;
};
ro.prototype.intersects = function(t, e) {
  return !(this._min > e || this._max < t);
};
ro.prototype.getMax = function() {
  return this._max;
};
ro.prototype.toString = function() {
  return Vi.toLineString(new R(this._min, 0), new R(this._max, 0));
};
ro.prototype.interfaces_ = function() {
  return [];
};
ro.prototype.getClass = function() {
  return ro;
};
o6.NodeComparator.get = function() {
  return Ll;
};
Object.defineProperties(ro, o6);
var Ll = function() {
};
Ll.prototype.compare = function(t, e) {
  var n = t, i = e, s = (n._min + n._max) / 2, o = (i._min + i._max) / 2;
  return s < o ? -1 : s > o ? 1 : 0;
};
Ll.prototype.interfaces_ = function() {
  return [Rx];
};
Ll.prototype.getClass = function() {
  return Ll;
};
var mF = function(r) {
  function t() {
    r.call(this), this._item = null;
    var e = arguments[0], n = arguments[1], i = arguments[2];
    this._min = e, this._max = n, this._item = i;
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.query = function(n, i, s) {
    if (!this.intersects(n, i))
      return null;
    s.visitItem(this._item);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(ro), _F = function(r) {
  function t() {
    r.call(this), this._node1 = null, this._node2 = null;
    var e = arguments[0], n = arguments[1];
    this._node1 = e, this._node2 = n, this.buildExtent(this._node1, this._node2);
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.buildExtent = function(n, i) {
    this._min = Math.min(n._min, i._min), this._max = Math.max(n._max, i._max);
  }, t.prototype.query = function(n, i, s) {
    if (!this.intersects(n, i))
      return null;
    this._node1 !== null && this._node1.query(n, i, s), this._node2 !== null && this._node2.query(n, i, s);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(ro), io = function() {
  this._leaves = new H(), this._root = null, this._level = 0;
};
io.prototype.buildTree = function() {
  var t = this;
  Ji.sort(this._leaves, new ro.NodeComparator());
  for (var e = this._leaves, n = null, i = new H(); ; ) {
    if (t.buildLevel(e, i), i.size() === 1)
      return i.get(0);
    n = e, e = i, i = n;
  }
};
io.prototype.insert = function(t, e, n) {
  if (this._root !== null)
    throw new Error("Index cannot be added to once it has been queried");
  this._leaves.add(new mF(t, e, n));
};
io.prototype.query = function(t, e, n) {
  this.init(), this._root.query(t, e, n);
};
io.prototype.buildRoot = function() {
  if (this._root !== null)
    return null;
  this._root = this.buildTree();
};
io.prototype.printNode = function(t) {
  Hn.out.println(Vi.toLineString(new R(t._min, this._level), new R(t._max, this._level)));
};
io.prototype.init = function() {
  if (this._root !== null)
    return null;
  this.buildRoot();
};
io.prototype.buildLevel = function(t, e) {
  this._level++, e.clear();
  for (var n = 0; n < t.size(); n += 2) {
    var i = t.get(n), s = n + 1 < t.size() ? t.get(n) : null;
    if (s === null)
      e.add(i);
    else {
      var o = new _F(t.get(n), t.get(n + 1));
      e.add(o);
    }
  }
};
io.prototype.interfaces_ = function() {
  return [];
};
io.prototype.getClass = function() {
  return io;
};
var Vx = function() {
  this._items = new H();
};
Vx.prototype.visitItem = function(t) {
  this._items.add(t);
};
Vx.prototype.getItems = function() {
  return this._items;
};
Vx.prototype.interfaces_ = function() {
  return [ha];
};
Vx.prototype.getClass = function() {
  return Vx;
};
var Wx = function() {
  this._index = null;
  var t = arguments[0];
  if (!ct(t, la))
    throw new ze("Argument must be Polygonal");
  this._index = new s0(t);
}, nb = { SegmentVisitor: { configurable: !0 }, IntervalIndexedGeometry: { configurable: !0 } };
Wx.prototype.locate = function(t) {
  var e = new vs(t), n = new Hx(e);
  return this._index.query(t.y, t.y, n), e.getLocation();
};
Wx.prototype.interfaces_ = function() {
  return [zx];
};
Wx.prototype.getClass = function() {
  return Wx;
};
nb.SegmentVisitor.get = function() {
  return Hx;
};
nb.IntervalIndexedGeometry.get = function() {
  return s0;
};
Object.defineProperties(Wx, nb);
var Hx = function() {
  this._counter = null;
  var t = arguments[0];
  this._counter = t;
};
Hx.prototype.visitItem = function(t) {
  var e = t;
  this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1));
};
Hx.prototype.interfaces_ = function() {
  return [ha];
};
Hx.prototype.getClass = function() {
  return Hx;
};
var s0 = function() {
  this._index = new io();
  var t = arguments[0];
  this.init(t);
};
s0.prototype.init = function(t) {
  for (var e = this, n = qn.getLines(t), i = n.iterator(); i.hasNext(); ) {
    var s = i.next(), o = s.getCoordinates();
    e.addLine(o);
  }
};
s0.prototype.addLine = function(t) {
  for (var e = this, n = 1; n < t.length; n++) {
    var i = new rt(t[n - 1], t[n]), s = Math.min(i.p0.y, i.p1.y), o = Math.max(i.p0.y, i.p1.y);
    e._index.insert(s, o, i);
  }
};
s0.prototype.query = function() {
  if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1], n = new Vx();
    return this._index.query(t, e, n), n.getItems();
  } else if (arguments.length === 3) {
    var i = arguments[0], s = arguments[1], o = arguments[2];
    this._index.query(i, s, o);
  }
};
s0.prototype.interfaces_ = function() {
  return [];
};
s0.prototype.getClass = function() {
  return s0;
};
var wc = function(r) {
  function t() {
    if (r.call(this), this._parentGeom = null, this._lineEdgeMap = new zS(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Ki(), arguments.length === 2) {
      var e = arguments[0], n = arguments[1], i = Li.OGC_SFS_BOUNDARY_RULE;
      this._argIndex = e, this._parentGeom = n, this._boundaryNodeRule = i, n !== null && this.add(n);
    } else if (arguments.length === 3) {
      var s = arguments[0], o = arguments[1], a = arguments[2];
      this._argIndex = s, this._parentGeom = o, this._boundaryNodeRule = a, o !== null && this.add(o);
    }
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.insertBoundaryPoint = function(n, i) {
    var s = this._nodes.addNode(i), o = s.getLabel(), a = 1, u = A.NONE;
    u = o.getLocation(n, z.ON), u === A.BOUNDARY && a++;
    var x = t.determineBoundary(this._boundaryNodeRule, a);
    o.setLocation(n, x);
  }, t.prototype.computeSelfNodes = function() {
    if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1];
      return this.computeSelfNodes(n, i, !1);
    } else if (arguments.length === 3) {
      var s = arguments[0], o = arguments[1], a = arguments[2], u = new Kn(s, !0, !1);
      u.setIsDoneIfProperInt(a);
      var x = this.createEdgeSetIntersector(), c = this._parentGeom instanceof js || this._parentGeom instanceof Mn || this._parentGeom instanceof Vs, f = o || !c;
      return x.computeIntersections(this._edges, u, f), this.addSelfIntersectionNodes(this._argIndex), u;
    }
  }, t.prototype.computeSplitEdges = function(n) {
    for (var i = this._edges.iterator(); i.hasNext(); ) {
      var s = i.next();
      s.eiList.addSplitEdges(n);
    }
  }, t.prototype.computeEdgeIntersections = function(n, i, s) {
    var o = new Kn(i, s, !0);
    o.setBoundaryNodes(this.getBoundaryNodes(), n.getBoundaryNodes());
    var a = this.createEdgeSetIntersector();
    return a.computeIntersections(this._edges, n._edges, o), o;
  }, t.prototype.getGeometry = function() {
    return this._parentGeom;
  }, t.prototype.getBoundaryNodeRule = function() {
    return this._boundaryNodeRule;
  }, t.prototype.hasTooFewPoints = function() {
    return this._hasTooFewPoints;
  }, t.prototype.addPoint = function() {
    if (arguments[0] instanceof Jr) {
      var n = arguments[0], i = n.getCoordinate();
      this.insertPoint(this._argIndex, i, A.INTERIOR);
    } else if (arguments[0] instanceof R) {
      var s = arguments[0];
      this.insertPoint(this._argIndex, s, A.INTERIOR);
    }
  }, t.prototype.addPolygon = function(n) {
    var i = this;
    this.addPolygonRing(n.getExteriorRing(), A.EXTERIOR, A.INTERIOR);
    for (var s = 0; s < n.getNumInteriorRing(); s++) {
      var o = n.getInteriorRingN(s);
      i.addPolygonRing(o, A.INTERIOR, A.EXTERIOR);
    }
  }, t.prototype.addEdge = function(n) {
    this.insertEdge(n);
    var i = n.getCoordinates();
    this.insertPoint(this._argIndex, i[0], A.BOUNDARY), this.insertPoint(this._argIndex, i[i.length - 1], A.BOUNDARY);
  }, t.prototype.addLineString = function(n) {
    var i = Ct.removeRepeatedPoints(n.getCoordinates());
    if (i.length < 2)
      return this._hasTooFewPoints = !0, this._invalidPoint = i[0], null;
    var s = new Fg(i, new ye(this._argIndex, A.INTERIOR));
    this._lineEdgeMap.put(n, s), this.insertEdge(s), mt.isTrue(i.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, i[0]), this.insertBoundaryPoint(this._argIndex, i[i.length - 1]);
  }, t.prototype.getInvalidPoint = function() {
    return this._invalidPoint;
  }, t.prototype.getBoundaryPoints = function() {
    for (var n = this.getBoundaryNodes(), i = new Array(n.size()).fill(null), s = 0, o = n.iterator(); o.hasNext(); ) {
      var a = o.next();
      i[s++] = a.getCoordinate().copy();
    }
    return i;
  }, t.prototype.getBoundaryNodes = function() {
    return this._boundaryNodes === null && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
  }, t.prototype.addSelfIntersectionNode = function(n, i, s) {
    if (this.isBoundaryNode(n, i))
      return null;
    s === A.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(n, i) : this.insertPoint(n, i, s);
  }, t.prototype.addPolygonRing = function(n, i, s) {
    if (n.isEmpty())
      return null;
    var o = Ct.removeRepeatedPoints(n.getCoordinates());
    if (o.length < 4)
      return this._hasTooFewPoints = !0, this._invalidPoint = o[0], null;
    var a = i, u = s;
    Z.isCCW(o) && (a = s, u = i);
    var x = new Fg(o, new ye(this._argIndex, A.BOUNDARY, a, u));
    this._lineEdgeMap.put(n, x), this.insertEdge(x), this.insertPoint(this._argIndex, o[0], A.BOUNDARY);
  }, t.prototype.insertPoint = function(n, i, s) {
    var o = this._nodes.addNode(i), a = o.getLabel();
    a === null ? o._label = new ye(n, s) : a.setLocation(n, s);
  }, t.prototype.createEdgeSetIntersector = function() {
    return new vF();
  }, t.prototype.addSelfIntersectionNodes = function(n) {
    for (var i = this, s = this._edges.iterator(); s.hasNext(); )
      for (var o = s.next(), a = o.getLabel().getLocation(n), u = o.eiList.iterator(); u.hasNext(); ) {
        var x = u.next();
        i.addSelfIntersectionNode(n, x.coord, a);
      }
  }, t.prototype.add = function() {
    if (arguments.length === 1) {
      var n = arguments[0];
      if (n.isEmpty())
        return null;
      if (n instanceof Vs && (this._useBoundaryDeterminationRule = !1), n instanceof Mn)
        this.addPolygon(n);
      else if (n instanceof je)
        this.addLineString(n);
      else if (n instanceof Jr)
        this.addPoint(n);
      else if (n instanceof Gx)
        this.addCollection(n);
      else if (n instanceof Qa)
        this.addCollection(n);
      else if (n instanceof Vs)
        this.addCollection(n);
      else if (n instanceof Ir)
        this.addCollection(n);
      else
        throw new Error(n.getClass().getName());
    } else
      return r.prototype.add.apply(this, arguments);
  }, t.prototype.addCollection = function(n) {
    for (var i = this, s = 0; s < n.getNumGeometries(); s++) {
      var o = n.getGeometryN(s);
      i.add(o);
    }
  }, t.prototype.locate = function(n) {
    return ct(this._parentGeom, la) && this._parentGeom.getNumGeometries() > 50 ? (this._areaPtLocator === null && (this._areaPtLocator = new Wx(this._parentGeom)), this._areaPtLocator.locate(n)) : this._ptLocator.locate(n, this._parentGeom);
  }, t.prototype.findEdge = function() {
    if (arguments.length === 1) {
      var n = arguments[0];
      return this._lineEdgeMap.get(n);
    } else
      return r.prototype.findEdge.apply(this, arguments);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t.determineBoundary = function(n, i) {
    return n.isInBoundary(i) ? A.BOUNDARY : A.INTERIOR;
  }, t;
}(Je), Jx = function() {
  if (this._li = new l0(), this._resultPrecisionModel = null, this._arg = null, arguments.length === 1) {
    var t = arguments[0];
    this.setComputationPrecision(t.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new wc(0, t);
  } else if (arguments.length === 2) {
    var e = arguments[0], n = arguments[1], i = Li.OGC_SFS_BOUNDARY_RULE;
    e.getPrecisionModel().compareTo(n.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e.getPrecisionModel()) : this.setComputationPrecision(n.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new wc(0, e, i), this._arg[1] = new wc(1, n, i);
  } else if (arguments.length === 3) {
    var s = arguments[0], o = arguments[1], a = arguments[2];
    s.getPrecisionModel().compareTo(o.getPrecisionModel()) >= 0 ? this.setComputationPrecision(s.getPrecisionModel()) : this.setComputationPrecision(o.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new wc(0, s, a), this._arg[1] = new wc(1, o, a);
  }
};
Jx.prototype.getArgGeometry = function(t) {
  return this._arg[t].getGeometry();
};
Jx.prototype.setComputationPrecision = function(t) {
  this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel);
};
Jx.prototype.interfaces_ = function() {
  return [];
};
Jx.prototype.getClass = function() {
  return Jx;
};
var Ua = function() {
};
Ua.prototype.interfaces_ = function() {
  return [];
};
Ua.prototype.getClass = function() {
  return Ua;
};
Ua.map = function() {
  if (arguments[0] instanceof xt && ct(arguments[1], Ua.MapOp)) {
    for (var t = arguments[0], e = arguments[1], n = new H(), i = 0; i < t.getNumGeometries(); i++) {
      var s = e.map(t.getGeometryN(i));
      s !== null && n.add(s);
    }
    return t.getFactory().buildGeometry(n);
  } else if (ct(arguments[0], _n) && ct(arguments[1], Ua.MapOp)) {
    for (var o = arguments[0], a = arguments[1], u = new H(), x = o.iterator(); x.hasNext(); ) {
      var c = x.next(), f = a.map(c);
      f !== null && u.add(f);
    }
    return u;
  }
};
Ua.MapOp = function() {
};
var vt = function(r) {
  function t() {
    var e = arguments[0], n = arguments[1];
    r.call(this, e, n), this._ptLocator = new Ki(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Zi(), this._resultPolyList = new H(), this._resultLineList = new H(), this._resultPointList = new H(), this._graph = new Je(new jS()), this._geomFact = e.getFactory();
  }
  return r && (t.__proto__ = r), t.prototype = Object.create(r && r.prototype), t.prototype.constructor = t, t.prototype.insertUniqueEdge = function(n) {
    var i = this._edgeList.findEqualEdge(n);
    if (i !== null) {
      var s = i.getLabel(), o = n.getLabel();
      i.isPointwiseEqual(n) || (o = new ye(n.getLabel()), o.flip());
      var a = i.getDepth();
      a.isNull() && a.add(s), a.add(o), s.merge(o);
    } else
      this._edgeList.add(n);
  }, t.prototype.getGraph = function() {
    return this._graph;
  }, t.prototype.cancelDuplicateResultEdges = function() {
    for (var n = this._graph.getEdgeEnds().iterator(); n.hasNext(); ) {
      var i = n.next(), s = i.getSym();
      i.isInResult() && s.isInResult() && (i.setInResult(!1), s.setInResult(!1));
    }
  }, t.prototype.isCoveredByLA = function(n) {
    return !!(this.isCovered(n, this._resultLineList) || this.isCovered(n, this._resultPolyList));
  }, t.prototype.computeGeometry = function(n, i, s, o) {
    var a = new H();
    return a.addAll(n), a.addAll(i), a.addAll(s), a.isEmpty() ? t.createEmptyResult(o, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(a);
  }, t.prototype.mergeSymLabels = function() {
    for (var n = this._graph.getNodes().iterator(); n.hasNext(); ) {
      var i = n.next();
      i.getEdges().mergeSymLabels();
    }
  }, t.prototype.isCovered = function(n, i) {
    for (var s = this, o = i.iterator(); o.hasNext(); ) {
      var a = o.next(), u = s._ptLocator.locate(n, a);
      if (u !== A.EXTERIOR)
        return !0;
    }
    return !1;
  }, t.prototype.replaceCollapsedEdges = function() {
    for (var n = new H(), i = this._edgeList.iterator(); i.hasNext(); ) {
      var s = i.next();
      s.isCollapsed() && (i.remove(), n.add(s.getCollapsedEdge()));
    }
    this._edgeList.addAll(n);
  }, t.prototype.updateNodeLabelling = function() {
    for (var n = this._graph.getNodes().iterator(); n.hasNext(); ) {
      var i = n.next(), s = i.getEdges().getLabel();
      i.getLabel().merge(s);
    }
  }, t.prototype.getResultGeometry = function(n) {
    return this.computeOverlay(n), this._resultGeom;
  }, t.prototype.insertUniqueEdges = function(n) {
    for (var i = this, s = n.iterator(); s.hasNext(); ) {
      var o = s.next();
      i.insertUniqueEdge(o);
    }
  }, t.prototype.computeOverlay = function(n) {
    this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);
    var i = new H();
    this._arg[0].computeSplitEdges(i), this._arg[1].computeSplitEdges(i), this.insertUniqueEdges(i), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), i0.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(n), this.cancelDuplicateResultEdges();
    var s = new Zr(this._geomFact);
    s.add(this._graph), this._resultPolyList = s.getPolygons();
    var o = new Rs(this, this._geomFact, this._ptLocator);
    this._resultLineList = o.build(n);
    var a = new iu(this, this._geomFact, this._ptLocator);
    this._resultPointList = a.build(n), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, n);
  }, t.prototype.labelIncompleteNode = function(n, i) {
    var s = this._ptLocator.locate(n.getCoordinate(), this._arg[i].getGeometry());
    n.getLabel().setLocation(i, s);
  }, t.prototype.copyPoints = function(n) {
    for (var i = this, s = this._arg[n].getNodeIterator(); s.hasNext(); ) {
      var o = s.next(), a = i._graph.addNode(o.getCoordinate());
      a.setLabel(n, o.getLabel().getLocation(n));
    }
  }, t.prototype.findResultAreaEdges = function(n) {
    for (var i = this._graph.getEdgeEnds().iterator(); i.hasNext(); ) {
      var s = i.next(), o = s.getLabel();
      o.isArea() && !s.isInteriorAreaEdge() && t.isResultOfOp(o.getLocation(0, z.RIGHT), o.getLocation(1, z.RIGHT), n) && s.setInResult(!0);
    }
  }, t.prototype.computeLabelsFromDepths = function() {
    for (var n = this._edgeList.iterator(); n.hasNext(); ) {
      var i = n.next(), s = i.getLabel(), o = i.getDepth();
      if (!o.isNull()) {
        o.normalize();
        for (var a = 0; a < 2; a++)
          !s.isNull(a) && s.isArea() && !o.isNull(a) && (o.getDelta(a) === 0 ? s.toLine(a) : (mt.isTrue(!o.isNull(a, z.LEFT), "depth of LEFT side has not been initialized"), s.setLocation(a, z.LEFT, o.getLocation(a, z.LEFT)), mt.isTrue(!o.isNull(a, z.RIGHT), "depth of RIGHT side has not been initialized"), s.setLocation(a, z.RIGHT, o.getLocation(a, z.RIGHT))));
      }
    }
  }, t.prototype.computeLabelling = function() {
    for (var n = this, i = this._graph.getNodes().iterator(); i.hasNext(); ) {
      var s = i.next();
      s.getEdges().computeLabelling(n._arg);
    }
    this.mergeSymLabels(), this.updateNodeLabelling();
  }, t.prototype.labelIncompleteNodes = function() {
    for (var n = this, i = this._graph.getNodes().iterator(); i.hasNext(); ) {
      var s = i.next(), o = s.getLabel();
      s.isIsolated() && (o.isNull(0) ? n.labelIncompleteNode(s, 0) : n.labelIncompleteNode(s, 1)), s.getEdges().updateLabelling(o);
    }
  }, t.prototype.isCoveredByA = function(n) {
    return !!this.isCovered(n, this._resultPolyList);
  }, t.prototype.interfaces_ = function() {
    return [];
  }, t.prototype.getClass = function() {
    return t;
  }, t;
}(Jx);
vt.overlayOp = function(r, t, e) {
  var n = new vt(r, t), i = n.getResultGeometry(e);
  return i;
};
vt.intersection = function(r, t) {
  if (r.isEmpty() || t.isEmpty())
    return vt.createEmptyResult(vt.INTERSECTION, r, t, r.getFactory());
  if (r.isGeometryCollection()) {
    var e = t;
    return ru.map(r, {
      interfaces_: function() {
        return [Ua.MapOp];
      },
      map: function(n) {
        return n.intersection(e);
      }
    });
  }
  return r.checkNotGeometryCollection(r), r.checkNotGeometryCollection(t), Sr.overlayOp(r, t, vt.INTERSECTION);
};
vt.symDifference = function(r, t) {
  if (r.isEmpty() || t.isEmpty()) {
    if (r.isEmpty() && t.isEmpty())
      return vt.createEmptyResult(vt.SYMDIFFERENCE, r, t, r.getFactory());
    if (r.isEmpty())
      return t.copy();
    if (t.isEmpty())
      return r.copy();
  }
  return r.checkNotGeometryCollection(r), r.checkNotGeometryCollection(t), Sr.overlayOp(r, t, vt.SYMDIFFERENCE);
};
vt.resultDimension = function(r, t, e) {
  var n = t.getDimension(), i = e.getDimension(), s = -1;
  switch (r) {
    case vt.INTERSECTION:
      s = Math.min(n, i);
      break;
    case vt.UNION:
      s = Math.max(n, i);
      break;
    case vt.DIFFERENCE:
      s = n;
      break;
    case vt.SYMDIFFERENCE:
      s = Math.max(n, i);
      break;
  }
  return s;
};
vt.createEmptyResult = function(r, t, e, n) {
  var i = null;
  switch (vt.resultDimension(r, t, e)) {
    case -1:
      i = n.createGeometryCollection(new Array(0).fill(null));
      break;
    case 0:
      i = n.createPoint();
      break;
    case 1:
      i = n.createLineString();
      break;
    case 2:
      i = n.createPolygon();
      break;
  }
  return i;
};
vt.difference = function(r, t) {
  return r.isEmpty() ? vt.createEmptyResult(vt.DIFFERENCE, r, t, r.getFactory()) : t.isEmpty() ? r.copy() : (r.checkNotGeometryCollection(r), r.checkNotGeometryCollection(t), Sr.overlayOp(r, t, vt.DIFFERENCE));
};
vt.isResultOfOp = function() {
  if (arguments.length === 2) {
    var r = arguments[0], t = arguments[1], e = r.getLocation(0), n = r.getLocation(1);
    return vt.isResultOfOp(e, n, t);
  } else if (arguments.length === 3) {
    var i = arguments[0], s = arguments[1], o = arguments[2];
    switch (i === A.BOUNDARY && (i = A.INTERIOR), s === A.BOUNDARY && (s = A.INTERIOR), o) {
      case vt.INTERSECTION:
        return i === A.INTERIOR && s === A.INTERIOR;
      case vt.UNION:
        return i === A.INTERIOR || s === A.INTERIOR;
      case vt.DIFFERENCE:
        return i === A.INTERIOR && s !== A.INTERIOR;
      case vt.SYMDIFFERENCE:
        return i === A.INTERIOR && s !== A.INTERIOR || i !== A.INTERIOR && s === A.INTERIOR;
    }
    return !1;
  }
};
vt.INTERSECTION = 1;
vt.UNION = 2;
vt.DIFFERENCE = 3;
vt.SYMDIFFERENCE = 4;
var oa = function() {
  this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Ki(), this._seg = new rt();
  var t = arguments[0], e = arguments[1];
  this._g = t, this._boundaryDistanceTolerance = e, this._linework = this.extractLinework(t);
};
oa.prototype.isWithinToleranceOfBoundary = function(t) {
  for (var e = this, n = 0; n < this._linework.getNumGeometries(); n++)
    for (var i = e._linework.getGeometryN(n), s = i.getCoordinateSequence(), o = 0; o < s.size() - 1; o++) {
      s.getCoordinate(o, e._seg.p0), s.getCoordinate(o + 1, e._seg.p1);
      var a = e._seg.distance(t);
      if (a <= e._boundaryDistanceTolerance)
        return !0;
    }
  return !1;
};
oa.prototype.getLocation = function(t) {
  return this.isWithinToleranceOfBoundary(t) ? A.BOUNDARY : this._ptLocator.locate(t, this._g);
};
oa.prototype.extractLinework = function(t) {
  var e = new Zx();
  t.apply(e);
  var n = e.getLinework(), i = St.toLineStringArray(n);
  return t.getFactory().createMultiLineString(i);
};
oa.prototype.interfaces_ = function() {
  return [];
};
oa.prototype.getClass = function() {
  return oa;
};
var Zx = function() {
  this._linework = null, this._linework = new H();
};
Zx.prototype.getLinework = function() {
  return this._linework;
};
Zx.prototype.filter = function(t) {
  var e = this;
  if (t instanceof Mn) {
    var n = t;
    this._linework.add(n.getExteriorRing());
    for (var i = 0; i < n.getNumInteriorRing(); i++)
      e._linework.add(n.getInteriorRingN(i));
  }
};
Zx.prototype.interfaces_ = function() {
  return [Ss];
};
Zx.prototype.getClass = function() {
  return Zx;
};
var o0 = function() {
  this._g = null, this._doLeft = !0, this._doRight = !0;
  var t = arguments[0];
  this._g = t;
};
o0.prototype.extractPoints = function(t, e, n) {
  for (var i = this, s = t.getCoordinates(), o = 0; o < s.length - 1; o++)
    i.computeOffsetPoints(s[o], s[o + 1], e, n);
};
o0.prototype.setSidesToGenerate = function(t, e) {
  this._doLeft = t, this._doRight = e;
};
o0.prototype.getPoints = function(t) {
  for (var e = this, n = new H(), i = qn.getLines(this._g), s = i.iterator(); s.hasNext(); ) {
    var o = s.next();
    e.extractPoints(o, t, n);
  }
  return n;
};
o0.prototype.computeOffsetPoints = function(t, e, n, i) {
  var s = e.x - t.x, o = e.y - t.y, a = Math.sqrt(s * s + o * o), u = n * s / a, x = n * o / a, c = (e.x + t.x) / 2, f = (e.y + t.y) / 2;
  if (this._doLeft) {
    var l = new R(c - x, f + u);
    i.add(l);
  }
  if (this._doRight) {
    var h = new R(c + x, f - u);
    i.add(h);
  }
};
o0.prototype.interfaces_ = function() {
  return [];
};
o0.prototype.getClass = function() {
  return o0;
};
var fi = function r() {
  this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = r.TOLERANCE, this._testCoords = new H();
  var t = arguments[0], e = arguments[1], n = arguments[2];
  this._boundaryDistanceTolerance = r.computeBoundaryDistanceTolerance(t, e), this._geom = [t, e, n], this._locFinder = [new oa(this._geom[0], this._boundaryDistanceTolerance), new oa(this._geom[1], this._boundaryDistanceTolerance), new oa(this._geom[2], this._boundaryDistanceTolerance)];
}, a6 = { TOLERANCE: { configurable: !0 } };
fi.prototype.reportResult = function(t, e, n) {
  Hn.out.println("Overlay result invalid - A:" + A.toLocationSymbol(e[0]) + " B:" + A.toLocationSymbol(e[1]) + " expected:" + (n ? "i" : "e") + " actual:" + A.toLocationSymbol(e[2]));
};
fi.prototype.isValid = function(t) {
  this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
  var e = this.checkValid(t);
  return e;
};
fi.prototype.checkValid = function() {
  var t = this;
  if (arguments.length === 1) {
    for (var e = arguments[0], n = 0; n < this._testCoords.size(); n++) {
      var i = t._testCoords.get(n);
      if (!t.checkValid(e, i))
        return t._invalidLocation = i, !1;
    }
    return !0;
  } else if (arguments.length === 2) {
    var s = arguments[0], o = arguments[1];
    return this._location[0] = this._locFinder[0].getLocation(o), this._location[1] = this._locFinder[1].getLocation(o), this._location[2] = this._locFinder[2].getLocation(o), fi.hasLocation(this._location, A.BOUNDARY) ? !0 : this.isValidResult(s, this._location);
  }
};
fi.prototype.addTestPts = function(t) {
  var e = new o0(t);
  this._testCoords.addAll(e.getPoints(5 * this._boundaryDistanceTolerance));
};
fi.prototype.isValidResult = function(t, e) {
  var n = vt.isResultOfOp(e[0], e[1], t), i = e[2] === A.INTERIOR, s = !(n ^ i);
  return s || this.reportResult(t, e, n), s;
};
fi.prototype.getInvalidLocation = function() {
  return this._invalidLocation;
};
fi.prototype.interfaces_ = function() {
  return [];
};
fi.prototype.getClass = function() {
  return fi;
};
fi.hasLocation = function(t, e) {
  for (var n = 0; n < 3; n++)
    if (t[n] === e)
      return !0;
  return !1;
};
fi.computeBoundaryDistanceTolerance = function(t, e) {
  return Math.min(nn.computeSizeBasedSnapTolerance(t), nn.computeSizeBasedSnapTolerance(e));
};
fi.isValid = function(t, e, n, i) {
  var s = new fi(t, e, i);
  return s.isValid(n);
};
a6.TOLERANCE.get = function() {
  return 1e-6;
};
Object.defineProperties(fi, a6);
var ri = function r(t) {
  this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null, this._geomFactory = r.extractFactory(t), this._inputGeoms = t;
};
ri.prototype.extractElements = function(t, e) {
  var n = this;
  if (t === null)
    return null;
  for (var i = 0; i < t.getNumGeometries(); i++) {
    var s = t.getGeometryN(i);
    n._skipEmpty && s.isEmpty() || e.add(s);
  }
};
ri.prototype.combine = function() {
  for (var t = this, e = new H(), n = this._inputGeoms.iterator(); n.hasNext(); ) {
    var i = n.next();
    t.extractElements(i, e);
  }
  return e.size() === 0 ? this._geomFactory !== null ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(e);
};
ri.prototype.interfaces_ = function() {
  return [];
};
ri.prototype.getClass = function() {
  return ri;
};
ri.combine = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = new ri(t);
    return e.combine();
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], s = new ri(ri.createList(n, i));
    return s.combine();
  } else if (arguments.length === 3) {
    var o = arguments[0], a = arguments[1], u = arguments[2], x = new ri(ri.createList(o, a, u));
    return x.combine();
  }
};
ri.extractFactory = function(t) {
  return t.isEmpty() ? null : t.iterator().next().getFactory();
};
ri.createList = function() {
  if (arguments.length === 2) {
    var t = arguments[0], e = arguments[1], n = new H();
    return n.add(t), n.add(e), n;
  } else if (arguments.length === 3) {
    var i = arguments[0], s = arguments[1], o = arguments[2], a = new H();
    return a.add(i), a.add(s), a.add(o), a;
  }
};
var ln = function() {
  this._inputPolys = null, this._geomFactory = null;
  var t = arguments[0];
  this._inputPolys = t, this._inputPolys === null && (this._inputPolys = new H());
}, u6 = { STRTREE_NODE_CAPACITY: { configurable: !0 } };
ln.prototype.reduceToGeometries = function(t) {
  for (var e = this, n = new H(), i = t.iterator(); i.hasNext(); ) {
    var s = i.next(), o = null;
    ct(s, zi) ? o = e.unionTree(s) : s instanceof xt && (o = s), n.add(o);
  }
  return n;
};
ln.prototype.extractByEnvelope = function(t, e, n) {
  for (var i = new H(), s = 0; s < e.getNumGeometries(); s++) {
    var o = e.getGeometryN(s);
    o.getEnvelopeInternal().intersects(t) ? i.add(o) : n.add(o);
  }
  return this._geomFactory.buildGeometry(i);
};
ln.prototype.unionOptimized = function(t, e) {
  var n = t.getEnvelopeInternal(), i = e.getEnvelopeInternal();
  if (!n.intersects(i)) {
    var s = ri.combine(t, e);
    return s;
  }
  if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1)
    return this.unionActual(t, e);
  var o = n.intersection(i);
  return this.unionUsingEnvelopeIntersection(t, e, o);
};
ln.prototype.union = function() {
  if (this._inputPolys === null)
    throw new Error("union() method cannot be called twice");
  if (this._inputPolys.isEmpty())
    return null;
  this._geomFactory = this._inputPolys.iterator().next().getFactory();
  for (var t = new HS(ln.STRTREE_NODE_CAPACITY), e = this._inputPolys.iterator(); e.hasNext(); ) {
    var n = e.next();
    t.insert(n.getEnvelopeInternal(), n);
  }
  this._inputPolys = null;
  var i = t.itemsTree(), s = this.unionTree(i);
  return s;
};
ln.prototype.binaryUnion = function() {
  if (arguments.length === 1) {
    var t = arguments[0];
    return this.binaryUnion(t, 0, t.size());
  } else if (arguments.length === 3) {
    var e = arguments[0], n = arguments[1], i = arguments[2];
    if (i - n <= 1) {
      var s = ln.getGeometry(e, n);
      return this.unionSafe(s, null);
    } else {
      if (i - n === 2)
        return this.unionSafe(ln.getGeometry(e, n), ln.getGeometry(e, n + 1));
      var o = Math.trunc((i + n) / 2), a = this.binaryUnion(e, n, o), u = this.binaryUnion(e, o, i);
      return this.unionSafe(a, u);
    }
  }
};
ln.prototype.repeatedUnion = function(t) {
  for (var e = null, n = t.iterator(); n.hasNext(); ) {
    var i = n.next();
    e === null ? e = i.copy() : e = e.union(i);
  }
  return e;
};
ln.prototype.unionSafe = function(t, e) {
  return t === null && e === null ? null : t === null ? e.copy() : e === null ? t.copy() : this.unionOptimized(t, e);
};
ln.prototype.unionActual = function(t, e) {
  return ln.restrictToPolygons(t.union(e));
};
ln.prototype.unionTree = function(t) {
  var e = this.reduceToGeometries(t), n = this.binaryUnion(e);
  return n;
};
ln.prototype.unionUsingEnvelopeIntersection = function(t, e, n) {
  var i = new H(), s = this.extractByEnvelope(n, t, i), o = this.extractByEnvelope(n, e, i), a = this.unionActual(s, o);
  i.add(a);
  var u = ri.combine(i);
  return u;
};
ln.prototype.bufferUnion = function() {
  if (arguments.length === 1) {
    var t = arguments[0], e = t.get(0).getFactory(), n = e.buildGeometry(t), i = n.buffer(0);
    return i;
  } else if (arguments.length === 2) {
    var s = arguments[0], o = arguments[1], a = s.getFactory(), u = a.createGeometryCollection([s, o]), x = u.buffer(0);
    return x;
  }
};
ln.prototype.interfaces_ = function() {
  return [];
};
ln.prototype.getClass = function() {
  return ln;
};
ln.restrictToPolygons = function(t) {
  if (ct(t, la))
    return t;
  var e = Io.getPolygons(t);
  return e.size() === 1 ? e.get(0) : t.getFactory().createMultiPolygon(St.toPolygonArray(e));
};
ln.getGeometry = function(t, e) {
  return e >= t.size() ? null : t.get(e);
};
ln.union = function(t) {
  var e = new ln(t);
  return e.union();
};
u6.STRTREE_NODE_CAPACITY.get = function() {
  return 4;
};
Object.defineProperties(ln, u6);
var Bg = function() {
};
Bg.prototype.interfaces_ = function() {
  return [];
};
Bg.prototype.getClass = function() {
  return Bg;
};
Bg.union = function(t, e) {
  if (t.isEmpty() || e.isEmpty()) {
    if (t.isEmpty() && e.isEmpty())
      return vt.createEmptyResult(vt.UNION, t, e, t.getFactory());
    if (t.isEmpty())
      return e.copy();
    if (e.isEmpty())
      return t.copy();
  }
  return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), Sr.overlayOp(t, e, vt.UNION);
};
function h0() {
  return new Gg();
}
function Gg() {
  this.reset();
}
Gg.prototype = {
  constructor: Gg,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(r) {
    C3(Sh, r, this.t), C3(this, Sh.s, this.s), this.s ? this.t += Sh.t : this.s = Sh.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var Sh = new Gg();
function C3(r, t, e) {
  var n = r.s = t + e, i = n - t, s = n - i;
  r.t = t - s + (e - i);
}
var Ke = 1e-6, Se = Math.PI, vo = Se / 2, M3 = Se / 4, No = Se * 2, Aa = 180 / Se, as = Se / 180, mr = Math.abs, bF = Math.atan, Kx = Math.atan2, bn = Math.cos, In = Math.sin, cc = Math.sqrt;
function x6(r) {
  return r > 1 ? 0 : r < -1 ? Se : Math.acos(r);
}
function ou(r) {
  return r > 1 ? vo : r < -1 ? -vo : Math.asin(r);
}
function Gc() {
}
function Yg(r, t) {
  r && L3.hasOwnProperty(r.type) && L3[r.type](r, t);
}
var P3 = {
  Feature: function(r, t) {
    Yg(r.geometry, t);
  },
  FeatureCollection: function(r, t) {
    for (var e = r.features, n = -1, i = e.length; ++n < i; ) Yg(e[n].geometry, t);
  }
}, L3 = {
  Sphere: function(r, t) {
    t.sphere();
  },
  Point: function(r, t) {
    r = r.coordinates, t.point(r[0], r[1], r[2]);
  },
  MultiPoint: function(r, t) {
    for (var e = r.coordinates, n = -1, i = e.length; ++n < i; ) r = e[n], t.point(r[0], r[1], r[2]);
  },
  LineString: function(r, t) {
    i_(r.coordinates, t, 0);
  },
  MultiLineString: function(r, t) {
    for (var e = r.coordinates, n = -1, i = e.length; ++n < i; ) i_(e[n], t, 0);
  },
  Polygon: function(r, t) {
    N3(r.coordinates, t);
  },
  MultiPolygon: function(r, t) {
    for (var e = r.coordinates, n = -1, i = e.length; ++n < i; ) N3(e[n], t);
  },
  GeometryCollection: function(r, t) {
    for (var e = r.geometries, n = -1, i = e.length; ++n < i; ) Yg(e[n], t);
  }
};
function i_(r, t, e) {
  var n = -1, i = r.length - e, s;
  for (t.lineStart(); ++n < i; ) s = r[n], t.point(s[0], s[1], s[2]);
  t.lineEnd();
}
function N3(r, t) {
  var e = -1, n = r.length;
  for (t.polygonStart(); ++e < n; ) i_(r[e], t, 1);
  t.polygonEnd();
}
function IF(r, t) {
  r && P3.hasOwnProperty(r.type) ? P3[r.type](r, t) : Yg(r, t);
}
h0();
h0();
function s_(r) {
  return [Kx(r[1], r[0]), ou(r[2])];
}
function jx(r) {
  var t = r[0], e = r[1], n = bn(e);
  return [n * bn(t), n * In(t), In(e)];
}
function Ch(r, t) {
  return r[0] * t[0] + r[1] * t[1] + r[2] * t[2];
}
function Xg(r, t) {
  return [r[1] * t[2] - r[2] * t[1], r[2] * t[0] - r[0] * t[2], r[0] * t[1] - r[1] * t[0]];
}
function em(r, t) {
  r[0] += t[0], r[1] += t[1], r[2] += t[2];
}
function Mh(r, t) {
  return [r[0] * t, r[1] * t, r[2] * t];
}
function o_(r) {
  var t = cc(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
  r[0] /= t, r[1] /= t, r[2] /= t;
}
h0();
function c6(r, t) {
  function e(n, i) {
    return n = r(n, i), t(n[0], n[1]);
  }
  return r.invert && t.invert && (e.invert = function(n, i) {
    return n = t.invert(n, i), n && r.invert(n[0], n[1]);
  }), e;
}
function a_(r, t) {
  return [r > Se ? r - No : r < -Se ? r + No : r, t];
}
a_.invert = a_;
function wF(r, t, e) {
  return (r %= No) ? t || e ? c6(R3(r), A3(t, e)) : R3(r) : t || e ? A3(t, e) : a_;
}
function O3(r) {
  return function(t, e) {
    return t += r, [t > Se ? t - No : t < -Se ? t + No : t, e];
  };
}
function R3(r) {
  var t = O3(r);
  return t.invert = O3(-r), t;
}
function A3(r, t) {
  var e = bn(r), n = In(r), i = bn(t), s = In(t);
  function o(a, u) {
    var x = bn(u), c = bn(a) * x, f = In(a) * x, l = In(u), h = l * e + c * n;
    return [
      Kx(f * i - h * s, c * e - l * n),
      ou(h * i + f * s)
    ];
  }
  return o.invert = function(a, u) {
    var x = bn(u), c = bn(a) * x, f = In(a) * x, l = In(u), h = l * i - f * s;
    return [
      Kx(f * i + l * s, c * e + h * n),
      ou(h * e - c * n)
    ];
  }, o;
}
function EF(r, t, e, n, i, s) {
  if (e) {
    var o = bn(t), a = In(t), u = n * e;
    i == null ? (i = t + n * No, s = t - u / 2) : (i = T3(o, i), s = T3(o, s), (n > 0 ? i < s : i > s) && (i += n * No));
    for (var x, c = i; n > 0 ? c > s : c < s; c -= u)
      x = s_([o, -a * bn(c), -a * In(c)]), r.point(x[0], x[1]);
  }
}
function T3(r, t) {
  t = jx(t), t[0] -= r, o_(t);
  var e = x6(-t[1]);
  return ((-t[2] < 0 ? -e : e) + No - Ke) % No;
}
function f6() {
  var r = [], t;
  return {
    point: function(e, n) {
      t.push([e, n]);
    },
    lineStart: function() {
      r.push(t = []);
    },
    lineEnd: Gc,
    rejoin: function() {
      r.length > 1 && r.push(r.pop().concat(r.shift()));
    },
    result: function() {
      var e = r;
      return r = [], t = null, e;
    }
  };
}
function SF(r, t, e, n, i, s) {
  var o = r[0], a = r[1], u = t[0], x = t[1], c = 0, f = 1, l = u - o, h = x - a, p;
  if (p = e - o, !(!l && p > 0)) {
    if (p /= l, l < 0) {
      if (p < c) return;
      p < f && (f = p);
    } else if (l > 0) {
      if (p > f) return;
      p > c && (c = p);
    }
    if (p = i - o, !(!l && p < 0)) {
      if (p /= l, l < 0) {
        if (p > f) return;
        p > c && (c = p);
      } else if (l > 0) {
        if (p < c) return;
        p < f && (f = p);
      }
      if (p = n - a, !(!h && p > 0)) {
        if (p /= h, h < 0) {
          if (p < c) return;
          p < f && (f = p);
        } else if (h > 0) {
          if (p > f) return;
          p > c && (c = p);
        }
        if (p = s - a, !(!h && p < 0)) {
          if (p /= h, h < 0) {
            if (p > f) return;
            p > c && (c = p);
          } else if (h > 0) {
            if (p < c) return;
            p < f && (f = p);
          }
          return c > 0 && (r[0] = o + c * l, r[1] = a + c * h), f < 1 && (t[0] = o + f * l, t[1] = a + f * h), !0;
        }
      }
    }
  }
}
function Wh(r, t) {
  return mr(r[0] - t[0]) < Ke && mr(r[1] - t[1]) < Ke;
}
function Ph(r, t, e, n) {
  this.x = r, this.z = t, this.o = e, this.e = n, this.v = !1, this.n = this.p = null;
}
function l6(r, t, e, n, i) {
  var s = [], o = [], a, u;
  if (r.forEach(function(p) {
    if (!((y = p.length - 1) <= 0)) {
      var y, v = p[0], m = p[y], d;
      if (Wh(v, m)) {
        for (i.lineStart(), a = 0; a < y; ++a) i.point((v = p[a])[0], v[1]);
        i.lineEnd();
        return;
      }
      s.push(d = new Ph(v, p, null, !0)), o.push(d.o = new Ph(v, null, d, !1)), s.push(d = new Ph(m, p, null, !1)), o.push(d.o = new Ph(m, null, d, !0));
    }
  }), !!s.length) {
    for (o.sort(t), D3(s), D3(o), a = 0, u = o.length; a < u; ++a)
      o[a].e = e = !e;
    for (var x = s[0], c, f; ; ) {
      for (var l = x, h = !0; l.v; ) if ((l = l.n) === x) return;
      c = l.z, i.lineStart();
      do {
        if (l.v = l.o.v = !0, l.e) {
          if (h)
            for (a = 0, u = c.length; a < u; ++a) i.point((f = c[a])[0], f[1]);
          else
            n(l.x, l.n.x, 1, i);
          l = l.n;
        } else {
          if (h)
            for (c = l.p.z, a = c.length - 1; a >= 0; --a) i.point((f = c[a])[0], f[1]);
          else
            n(l.x, l.p.x, -1, i);
          l = l.p;
        }
        l = l.o, c = l.z, h = !h;
      } while (!l.v);
      i.lineEnd();
    }
  }
}
function D3(r) {
  if (t = r.length) {
    for (var t, e = 0, n = r[0], i; ++e < t; )
      n.n = i = r[e], i.p = n, n = i;
    n.n = i = r[0], i.p = n;
  }
}
function h6(r, t) {
  return r < t ? -1 : r > t ? 1 : r >= t ? 0 : NaN;
}
function CF(r) {
  return r.length === 1 && (r = MF(r)), {
    left: function(t, e, n, i) {
      for (n == null && (n = 0), i == null && (i = t.length); n < i; ) {
        var s = n + i >>> 1;
        r(t[s], e) < 0 ? n = s + 1 : i = s;
      }
      return n;
    },
    right: function(t, e, n, i) {
      for (n == null && (n = 0), i == null && (i = t.length); n < i; ) {
        var s = n + i >>> 1;
        r(t[s], e) > 0 ? i = s : n = s + 1;
      }
      return n;
    }
  };
}
function MF(r) {
  return function(t, e) {
    return h6(r(t), e);
  };
}
CF(h6);
function p6(r) {
  for (var t = r.length, e, n = -1, i = 0, s, o; ++n < t; ) i += r[n].length;
  for (s = new Array(i); --t >= 0; )
    for (o = r[t], e = o.length; --e >= 0; )
      s[--i] = o[e];
  return s;
}
var Yc = 1e9, Lh = -Yc;
function PF(r, t, e, n) {
  function i(x, c) {
    return r <= x && x <= e && t <= c && c <= n;
  }
  function s(x, c, f, l) {
    var h = 0, p = 0;
    if (x == null || (h = o(x, f)) !== (p = o(c, f)) || u(x, c) < 0 ^ f > 0)
      do
        l.point(h === 0 || h === 3 ? r : e, h > 1 ? n : t);
      while ((h = (h + f + 4) % 4) !== p);
    else
      l.point(c[0], c[1]);
  }
  function o(x, c) {
    return mr(x[0] - r) < Ke ? c > 0 ? 0 : 3 : mr(x[0] - e) < Ke ? c > 0 ? 2 : 1 : mr(x[1] - t) < Ke ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2;
  }
  function a(x, c) {
    return u(x.x, c.x);
  }
  function u(x, c) {
    var f = o(x, 1), l = o(c, 1);
    return f !== l ? f - l : f === 0 ? c[1] - x[1] : f === 1 ? x[0] - c[0] : f === 2 ? x[1] - c[1] : c[0] - x[0];
  }
  return function(x) {
    var c = x, f = f6(), l, h, p, y, v, m, d, g, _, b, w, E = {
      point: S,
      lineStart: N,
      lineEnd: P,
      polygonStart: L,
      polygonEnd: M
    };
    function S(k, D) {
      i(k, D) && c.point(k, D);
    }
    function I() {
      for (var k = 0, D = 0, F = h.length; D < F; ++D)
        for (var X = h[D], W = 1, U = X.length, q = X[0], V, tt, $ = q[0], B = q[1]; W < U; ++W)
          V = $, tt = B, q = X[W], $ = q[0], B = q[1], tt <= n ? B > n && ($ - V) * (n - tt) > (B - tt) * (r - V) && ++k : B <= n && ($ - V) * (n - tt) < (B - tt) * (r - V) && --k;
      return k;
    }
    function L() {
      c = f, l = [], h = [], w = !0;
    }
    function M() {
      var k = I(), D = w && k, F = (l = p6(l)).length;
      (D || F) && (x.polygonStart(), D && (x.lineStart(), s(null, null, 1, x), x.lineEnd()), F && l6(l, a, k, s, x), x.polygonEnd()), c = x, l = h = p = null;
    }
    function N() {
      E.point = O, h && h.push(p = []), b = !0, _ = !1, d = g = NaN;
    }
    function P() {
      l && (O(y, v), m && _ && f.rejoin(), l.push(f.result())), E.point = S, _ && c.lineEnd();
    }
    function O(k, D) {
      var F = i(k, D);
      if (h && p.push([k, D]), b)
        y = k, v = D, m = F, b = !1, F && (c.lineStart(), c.point(k, D));
      else if (F && _) c.point(k, D);
      else {
        var X = [d = Math.max(Lh, Math.min(Yc, d)), g = Math.max(Lh, Math.min(Yc, g))], W = [k = Math.max(Lh, Math.min(Yc, k)), D = Math.max(Lh, Math.min(Yc, D))];
        SF(X, W, r, t, e, n) ? (_ || (c.lineStart(), c.point(X[0], X[1])), c.point(W[0], W[1]), F || c.lineEnd(), w = !1) : F && (c.lineStart(), c.point(k, D), w = !1);
      }
      d = k, g = D, _ = F;
    }
    return E;
  };
}
var nm = h0();
function LF(r, t) {
  var e = t[0], n = t[1], i = [In(e), -bn(e), 0], s = 0, o = 0;
  nm.reset();
  for (var a = 0, u = r.length; a < u; ++a)
    if (c = (x = r[a]).length)
      for (var x, c, f = x[c - 1], l = f[0], h = f[1] / 2 + M3, p = In(h), y = bn(h), v = 0; v < c; ++v, l = d, p = _, y = b, f = m) {
        var m = x[v], d = m[0], g = m[1] / 2 + M3, _ = In(g), b = bn(g), w = d - l, E = w >= 0 ? 1 : -1, S = E * w, I = S > Se, L = p * _;
        if (nm.add(Kx(L * E * In(S), y * b + L * bn(S))), s += I ? w + E * No : w, I ^ l >= e ^ d >= e) {
          var M = Xg(jx(f), jx(m));
          o_(M);
          var N = Xg(i, M);
          o_(N);
          var P = (I ^ w >= 0 ? -1 : 1) * ou(N[2]);
          (n > P || n === P && (M[0] || M[1])) && (o += I ^ w >= 0 ? 1 : -1);
        }
      }
  return (s < -Ke || s < Ke && nm < -Ke) ^ o & 1;
}
h0();
function F3(r) {
  return r;
}
h0();
h0();
var Qx = 1 / 0, qg = Qx, Nl = -Qx, zg = Nl, k3 = {
  point: NF,
  lineStart: Gc,
  lineEnd: Gc,
  polygonStart: Gc,
  polygonEnd: Gc,
  result: function() {
    var r = [[Qx, qg], [Nl, zg]];
    return Nl = zg = -(qg = Qx = 1 / 0), r;
  }
};
function NF(r, t) {
  r < Qx && (Qx = r), r > Nl && (Nl = r), t < qg && (qg = t), t > zg && (zg = t);
}
h0();
function d6(r, t, e, n) {
  return function(i, s) {
    var o = t(s), a = i.invert(n[0], n[1]), u = f6(), x = t(u), c = !1, f, l, h, p = {
      point: y,
      lineStart: m,
      lineEnd: d,
      polygonStart: function() {
        p.point = g, p.lineStart = _, p.lineEnd = b, l = [], f = [];
      },
      polygonEnd: function() {
        p.point = y, p.lineStart = m, p.lineEnd = d, l = p6(l);
        var w = LF(f, a);
        l.length ? (c || (s.polygonStart(), c = !0), l6(l, RF, w, e, s)) : w && (c || (s.polygonStart(), c = !0), s.lineStart(), e(null, null, 1, s), s.lineEnd()), c && (s.polygonEnd(), c = !1), l = f = null;
      },
      sphere: function() {
        s.polygonStart(), s.lineStart(), e(null, null, 1, s), s.lineEnd(), s.polygonEnd();
      }
    };
    function y(w, E) {
      var S = i(w, E);
      r(w = S[0], E = S[1]) && s.point(w, E);
    }
    function v(w, E) {
      var S = i(w, E);
      o.point(S[0], S[1]);
    }
    function m() {
      p.point = v, o.lineStart();
    }
    function d() {
      p.point = y, o.lineEnd();
    }
    function g(w, E) {
      h.push([w, E]);
      var S = i(w, E);
      x.point(S[0], S[1]);
    }
    function _() {
      x.lineStart(), h = [];
    }
    function b() {
      g(h[0][0], h[0][1]), x.lineEnd();
      var w = x.clean(), E = u.result(), S, I = E.length, L, M, N;
      if (h.pop(), f.push(h), h = null, !!I) {
        if (w & 1) {
          if (M = E[0], (L = M.length - 1) > 0) {
            for (c || (s.polygonStart(), c = !0), s.lineStart(), S = 0; S < L; ++S) s.point((N = M[S])[0], N[1]);
            s.lineEnd();
          }
          return;
        }
        I > 1 && w & 2 && E.push(E.pop().concat(E.shift())), l.push(E.filter(OF));
      }
    }
    return p;
  };
}
function OF(r) {
  return r.length > 1;
}
function RF(r, t) {
  return ((r = r.x)[0] < 0 ? r[1] - vo - Ke : vo - r[1]) - ((t = t.x)[0] < 0 ? t[1] - vo - Ke : vo - t[1]);
}
const B3 = d6(
  function() {
    return !0;
  },
  AF,
  DF,
  [-Se, -vo]
);
function AF(r) {
  var t = NaN, e = NaN, n = NaN, i;
  return {
    lineStart: function() {
      r.lineStart(), i = 1;
    },
    point: function(s, o) {
      var a = s > 0 ? Se : -Se, u = mr(s - t);
      mr(u - Se) < Ke ? (r.point(t, e = (e + o) / 2 > 0 ? vo : -vo), r.point(n, e), r.lineEnd(), r.lineStart(), r.point(a, e), r.point(s, e), i = 0) : n !== a && u >= Se && (mr(t - n) < Ke && (t -= n * Ke), mr(s - a) < Ke && (s -= a * Ke), e = TF(t, e, s, o), r.point(n, e), r.lineEnd(), r.lineStart(), r.point(a, e), i = 0), r.point(t = s, e = o), n = a;
    },
    lineEnd: function() {
      r.lineEnd(), t = e = NaN;
    },
    clean: function() {
      return 2 - i;
    }
  };
}
function TF(r, t, e, n) {
  var i, s, o = In(r - e);
  return mr(o) > Ke ? bF((In(t) * (s = bn(n)) * In(e) - In(n) * (i = bn(t)) * In(r)) / (i * s * o)) : (t + n) / 2;
}
function DF(r, t, e, n) {
  var i;
  if (r == null)
    i = e * vo, n.point(-Se, i), n.point(0, i), n.point(Se, i), n.point(Se, 0), n.point(Se, -i), n.point(0, -i), n.point(-Se, -i), n.point(-Se, 0), n.point(-Se, i);
  else if (mr(r[0] - t[0]) > Ke) {
    var s = r[0] < t[0] ? Se : -Se;
    i = e * s / 2, n.point(-s, i), n.point(0, i), n.point(s, i);
  } else
    n.point(t[0], t[1]);
}
function FF(r, t) {
  var e = bn(r), n = e > 0, i = mr(e) > Ke;
  function s(c, f, l, h) {
    EF(h, r, t, l, c, f);
  }
  function o(c, f) {
    return bn(c) * bn(f) > e;
  }
  function a(c) {
    var f, l, h, p, y;
    return {
      lineStart: function() {
        p = h = !1, y = 1;
      },
      point: function(v, m) {
        var d = [v, m], g, _ = o(v, m), b = n ? _ ? 0 : x(v, m) : _ ? x(v + (v < 0 ? Se : -Se), m) : 0;
        if (!f && (p = h = _) && c.lineStart(), _ !== h && (g = u(f, d), (!g || Wh(f, g) || Wh(d, g)) && (d[0] += Ke, d[1] += Ke, _ = o(d[0], d[1]))), _ !== h)
          y = 0, _ ? (c.lineStart(), g = u(d, f), c.point(g[0], g[1])) : (g = u(f, d), c.point(g[0], g[1]), c.lineEnd()), f = g;
        else if (i && f && n ^ _) {
          var w;
          !(b & l) && (w = u(d, f, !0)) && (y = 0, n ? (c.lineStart(), c.point(w[0][0], w[0][1]), c.point(w[1][0], w[1][1]), c.lineEnd()) : (c.point(w[1][0], w[1][1]), c.lineEnd(), c.lineStart(), c.point(w[0][0], w[0][1])));
        }
        _ && (!f || !Wh(f, d)) && c.point(d[0], d[1]), f = d, h = _, l = b;
      },
      lineEnd: function() {
        h && c.lineEnd(), f = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return y | (p && h) << 1;
      }
    };
  }
  function u(c, f, l) {
    var h = jx(c), p = jx(f), y = [1, 0, 0], v = Xg(h, p), m = Ch(v, v), d = v[0], g = m - d * d;
    if (!g) return !l && c;
    var _ = e * m / g, b = -e * d / g, w = Xg(y, v), E = Mh(y, _), S = Mh(v, b);
    em(E, S);
    var I = w, L = Ch(E, I), M = Ch(I, I), N = L * L - M * (Ch(E, E) - 1);
    if (!(N < 0)) {
      var P = cc(N), O = Mh(I, (-L - P) / M);
      if (em(O, E), O = s_(O), !l) return O;
      var k = c[0], D = f[0], F = c[1], X = f[1], W;
      D < k && (W = k, k = D, D = W);
      var U = D - k, q = mr(U - Se) < Ke, V = q || U < Ke;
      if (!q && X < F && (W = F, F = X, X = W), V ? q ? F + X > 0 ^ O[1] < (mr(O[0] - k) < Ke ? F : X) : F <= O[1] && O[1] <= X : U > Se ^ (k <= O[0] && O[0] <= D)) {
        var tt = Mh(I, (-L + P) / M);
        return em(tt, E), [O, s_(tt)];
      }
    }
  }
  function x(c, f) {
    var l = n ? r : Se - r, h = 0;
    return c < -l ? h |= 1 : c > l && (h |= 2), f < -l ? h |= 4 : f > l && (h |= 8), h;
  }
  return d6(o, a, s, n ? [0, -r] : [-Se, r - Se]);
}
function g6(r) {
  return function(t) {
    var e = new u_();
    for (var n in r) e[n] = r[n];
    return e.stream = t, e;
  };
}
function u_() {
}
u_.prototype = {
  constructor: u_,
  point: function(r, t) {
    this.stream.point(r, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function y6(r, t, e) {
  var n = t[1][0] - t[0][0], i = t[1][1] - t[0][1], s = r.clipExtent && r.clipExtent();
  r.scale(150).translate([0, 0]), s != null && r.clipExtent(null), IF(e, r.stream(k3));
  var o = k3.result(), a = Math.min(n / (o[1][0] - o[0][0]), i / (o[1][1] - o[0][1])), u = +t[0][0] + (n - a * (o[1][0] + o[0][0])) / 2, x = +t[0][1] + (i - a * (o[1][1] + o[0][1])) / 2;
  return s != null && r.clipExtent(s), r.scale(a * 150).translate([u, x]);
}
function kF(r, t, e) {
  return y6(r, [[0, 0], t], e);
}
var G3 = 16, BF = bn(30 * as);
function Y3(r, t) {
  return +t ? YF(r, t) : GF(r);
}
function GF(r) {
  return g6({
    point: function(t, e) {
      t = r(t, e), this.stream.point(t[0], t[1]);
    }
  });
}
function YF(r, t) {
  function e(n, i, s, o, a, u, x, c, f, l, h, p, y, v) {
    var m = x - n, d = c - i, g = m * m + d * d;
    if (g > 4 * t && y--) {
      var _ = o + l, b = a + h, w = u + p, E = cc(_ * _ + b * b + w * w), S = ou(w /= E), I = mr(mr(w) - 1) < Ke || mr(s - f) < Ke ? (s + f) / 2 : Kx(b, _), L = r(I, S), M = L[0], N = L[1], P = M - n, O = N - i, k = d * P - m * O;
      (k * k / g > t || mr((m * P + d * O) / g - 0.5) > 0.3 || o * l + a * h + u * p < BF) && (e(n, i, s, o, a, u, M, N, I, _ /= E, b /= E, w, y, v), v.point(M, N), e(M, N, I, _, b, w, x, c, f, l, h, p, y, v));
    }
  }
  return function(n) {
    var i, s, o, a, u, x, c, f, l, h, p, y, v = {
      point: m,
      lineStart: d,
      lineEnd: _,
      polygonStart: function() {
        n.polygonStart(), v.lineStart = b;
      },
      polygonEnd: function() {
        n.polygonEnd(), v.lineStart = d;
      }
    };
    function m(S, I) {
      S = r(S, I), n.point(S[0], S[1]);
    }
    function d() {
      f = NaN, v.point = g, n.lineStart();
    }
    function g(S, I) {
      var L = jx([S, I]), M = r(S, I);
      e(f, l, c, h, p, y, f = M[0], l = M[1], c = S, h = L[0], p = L[1], y = L[2], G3, n), n.point(f, l);
    }
    function _() {
      v.point = m, n.lineEnd();
    }
    function b() {
      d(), v.point = w, v.lineEnd = E;
    }
    function w(S, I) {
      g(i = S, I), s = f, o = l, a = h, u = p, x = y, v.point = g;
    }
    function E() {
      e(f, l, c, h, p, y, s, o, i, a, u, x, G3, n), v.lineEnd = _, _();
    }
    return v;
  };
}
var XF = g6({
  point: function(r, t) {
    this.stream.point(r * as, t * as);
  }
});
function qF(r) {
  return zF(function() {
    return r;
  })();
}
function zF(r) {
  var t, e = 150, n = 480, i = 250, s, o, a = 0, u = 0, x = 0, c = 0, f = 0, l, h, p = null, y = B3, v = null, m, d, g, _ = F3, b = 0.5, w = Y3(M, b), E, S;
  function I(O) {
    return O = h(O[0] * as, O[1] * as), [O[0] * e + s, o - O[1] * e];
  }
  function L(O) {
    return O = h.invert((O[0] - s) / e, (o - O[1]) / e), O && [O[0] * Aa, O[1] * Aa];
  }
  function M(O, k) {
    return O = t(O, k), [O[0] * e + s, o - O[1] * e];
  }
  I.stream = function(O) {
    return E && S === O ? E : E = XF(y(l, w(_(S = O))));
  }, I.clipAngle = function(O) {
    return arguments.length ? (y = +O ? FF(p = O * as, 6 * as) : (p = null, B3), P()) : p * Aa;
  }, I.clipExtent = function(O) {
    return arguments.length ? (_ = O == null ? (v = m = d = g = null, F3) : PF(v = +O[0][0], m = +O[0][1], d = +O[1][0], g = +O[1][1]), P()) : v == null ? null : [[v, m], [d, g]];
  }, I.scale = function(O) {
    return arguments.length ? (e = +O, N()) : e;
  }, I.translate = function(O) {
    return arguments.length ? (n = +O[0], i = +O[1], N()) : [n, i];
  }, I.center = function(O) {
    return arguments.length ? (a = O[0] % 360 * as, u = O[1] % 360 * as, N()) : [a * Aa, u * Aa];
  }, I.rotate = function(O) {
    return arguments.length ? (x = O[0] % 360 * as, c = O[1] % 360 * as, f = O.length > 2 ? O[2] % 360 * as : 0, N()) : [x * Aa, c * Aa, f * Aa];
  }, I.precision = function(O) {
    return arguments.length ? (w = Y3(M, b = O * O), P()) : cc(b);
  }, I.fitExtent = function(O, k) {
    return y6(I, O, k);
  }, I.fitSize = function(O, k) {
    return kF(I, O, k);
  };
  function N() {
    h = c6(l = wF(x, c, f), t);
    var O = t(a, u);
    return s = n - O[0] * e, o = i + O[1] * e, P();
  }
  function P() {
    return E = S = null, I;
  }
  return function() {
    return t = r.apply(this, arguments), I.invert = t.invert && L, N();
  };
}
function v6(r) {
  return function(t, e) {
    var n = bn(t), i = bn(e), s = r(n * i);
    return [
      s * i * In(t),
      s * In(e)
    ];
  };
}
function m6(r) {
  return function(t, e) {
    var n = cc(t * t + e * e), i = r(n), s = In(i), o = bn(i);
    return [
      Kx(t * s, n * o),
      ou(n && e * s / n)
    ];
  };
}
var UF = v6(function(r) {
  return cc(2 / (1 + r));
});
UF.invert = m6(function(r) {
  return 2 * ou(r / 2);
});
var _6 = v6(function(r) {
  return (r = x6(r)) && r / In(r);
});
_6.invert = m6(function(r) {
  return r;
});
function VF() {
  return qF(_6).scale(79.4188).clipAngle(180 - 1e-3);
}
function X3(r, t) {
  return [r, t];
}
X3.invert = X3;
function WF(r, t, e) {
  e = e || {};
  var n = e.units || "kilometers", i = e.steps || 8;
  if (!r) throw new Error("geojson is required");
  if (typeof e != "object") throw new Error("options must be an object");
  if (typeof i != "number") throw new Error("steps must be an number");
  if (t === void 0) throw new Error("radius is required");
  if (i <= 0) throw new Error("steps must be greater than 0");
  var s = [];
  switch (r.type) {
    case "GeometryCollection":
      return Pi(r, function(o) {
        var a = Hh(o, t, n, i);
        a && s.push(a);
      }), ht(s);
    case "FeatureCollection":
      return he(r, function(o) {
        var a = Hh(o, t, n, i);
        a && he(a, function(u) {
          u && s.push(u);
        });
      }), ht(s);
  }
  return Hh(r, t, n, i);
}
function Hh(r, t, e, n) {
  var i = r.properties || {}, s = r.type === "Feature" ? r.geometry : r;
  if (s.type === "GeometryCollection") {
    var o = [];
    return Pi(r, function(y) {
      var v = Hh(y, t, e, n);
      v && o.push(v);
    }), ht(o);
  }
  var a = HF(s), u = {
    type: s.type,
    coordinates: I6(s.coordinates, a)
  }, x = new J2(), c = x.read(u), f = Px(X0(t, e), "meters"), l = zn.bufferOp(c, f, n), h = new VS();
  if (l = h.write(l), !b6(l.coordinates)) {
    var p = {
      type: l.type,
      coordinates: w6(l.coordinates, a)
    };
    return Tn(p, i);
  }
}
function b6(r) {
  return Array.isArray(r[0]) ? b6(r[0]) : isNaN(r[0]);
}
function I6(r, t) {
  return typeof r[0] != "object" ? t(r) : r.map(function(e) {
    return I6(e, t);
  });
}
function w6(r, t) {
  return typeof r[0] != "object" ? t.invert(r) : r.map(function(e) {
    return w6(e, t);
  });
}
function HF(r) {
  var t = Py(r).geometry.coordinates, e = [-t[0], -t[1]];
  return VF().rotate(e).scale(Xn);
}
function JF(r, t, e) {
  e === void 0 && (e = {});
  var n = ke(r), i = ke(t), s = ia.union(n.coordinates, i.coordinates);
  return s.length === 0 ? null : s.length === 1 ? Nt(s[0], e.properties) : Mi(s, e.properties);
}
function Ol(r, t, e) {
  e === void 0 && (e = {});
  var n = ke(r), i = ke(t), s = ia.intersection(n.coordinates, i.coordinates);
  return s.length === 0 ? null : s.length === 1 ? Nt(s[0], e.properties) : Mi(s, e.properties);
}
function ZF(r, t) {
  if (t = t || {}, !we(t)) throw new Error("options is invalid");
  var e = t.propertyName;
  Ia(r, "Polygon", "dissolve");
  var n = [];
  if (t.propertyName) {
    var i = {};
    he(r, function(u) {
      Object.prototype.hasOwnProperty.call(
        i,
        u.properties[e]
      ) || (i[u.properties[e]] = []), i[u.properties[e]].push(u);
    });
    for (var s = Object.keys(i), o = 0; o < s.length; o++) {
      var a = Mi(
        ia.union.apply(
          null,
          i[s[o]].map(function(u) {
            return u.geometry.coordinates;
          })
        )
      );
      a.properties[e] = s[o], n.push(a);
    }
  } else
    return Um(
      Mi(
        ia.union.apply(
          null,
          r.features.map(function(u) {
            return u.geometry.coordinates;
          })
        )
      )
    );
  return Um(ht(n));
}
function E6(r, t, e) {
  e === void 0 && (e = {});
  var n = JSON.stringify(e.properties || {}), i = r[0], s = r[1], o = r[2], a = r[3], u = (s + a) / 2, x = (i + o) / 2, c = t * 2 / Ie([i, u], [o, u], e), f = c * (o - i), l = t * 2 / Ie([x, s], [x, a], e), h = l * (a - s), p = f / 2, y = p * 2, v = Math.sqrt(3) / 2 * h, m = o - i, d = a - s, g = 3 / 4 * y, _ = v, b = (m - y) / (y - p / 2), w = Math.floor(b), E = (w * g - p / 2 - m) / 2 - p / 2 + g / 2, S = Math.floor((d - v) / v), I = (d - S * v) / 2, L = S * v - d > v / 2;
  L && (I -= v / 4);
  for (var M = [], N = [], P = 0; P < 6; P++) {
    var O = 2 * Math.PI / 6 * P;
    M.push(Math.cos(O)), N.push(Math.sin(O));
  }
  for (var k = [], D = 0; D <= w; D++)
    for (var F = 0; F <= S; F++) {
      var X = D % 2 === 1;
      if (!(F === 0 && X) && !(F === 0 && L)) {
        var W = D * g + i - E, U = F * _ + s + I;
        if (X && (U -= v / 2), e.triangles === !0)
          jF([W, U], f / 2, h / 2, JSON.parse(n), M, N).forEach(function(V) {
            e.mask ? Ol(e.mask, V) && k.push(V) : k.push(V);
          });
        else {
          var q = KF([W, U], f / 2, h / 2, JSON.parse(n), M, N);
          e.mask ? Ol(e.mask, q) && k.push(q) : k.push(q);
        }
      }
    }
  return ht(k);
}
function KF(r, t, e, n, i, s) {
  for (var o = [], a = 0; a < 6; a++) {
    var u = r[0] + t * i[a], x = r[1] + e * s[a];
    o.push([u, x]);
  }
  return o.push(o[0].slice()), Nt([o], n);
}
function jF(r, t, e, n, i, s) {
  for (var o = [], a = 0; a < 6; a++) {
    var u = [];
    u.push(r), u.push([r[0] + t * i[a], r[1] + e * s[a]]), u.push([
      r[0] + t * i[(a + 1) % 6],
      r[1] + e * s[(a + 1) % 6]
    ]), u.push(r), o.push(Nt([u], n));
  }
  return o;
}
function QF(r, t) {
  var e = tk(t), n = null;
  return r.type === "FeatureCollection" ? n = $F(r) : n = S6(
    ia.union(r.geometry.coordinates)
  ), n.geometry.coordinates.forEach(function(i) {
    e.geometry.coordinates.push(i[0]);
  }), e;
}
function $F(r) {
  var t = r.features.length === 2 ? ia.union(
    r.features[0].geometry.coordinates,
    r.features[1].geometry.coordinates
  ) : ia.union.apply(
    ia,
    r.features.map(function(e) {
      return e.geometry.coordinates;
    })
  );
  return S6(t);
}
function S6(r) {
  return Mi(r);
}
function tk(r) {
  var t = [
    [
      [180, 90],
      [-180, 90],
      [-180, -90],
      [180, -90],
      [180, 90]
    ]
  ], e = r && r.geometry.coordinates || t;
  return Nt(e);
}
function ek(r, t, e, n) {
  n === void 0 && (n = {});
  for (var i = [], s = r[0], o = r[1], a = r[2], u = r[3], x = t / Ie([s, o], [a, o], n), c = x * (a - s), f = e / Ie([s, o], [s, u], n), l = f * (u - o), h = a - s, p = u - o, y = Math.floor(h / c), v = Math.floor(p / l), m = (h - y * c) / 2, d = (p - v * l) / 2, g = s + m, _ = 0; _ < y; _++) {
    for (var b = o + d, w = 0; w < v; w++) {
      var E = Nt([
        [
          [g, b],
          [g, b + l],
          [g + c, b + l],
          [g + c, b],
          [g, b]
        ]
      ], n.properties);
      n.mask ? cS(n.mask, E) && i.push(E) : i.push(E), b += l;
    }
    g += c;
  }
  return ht(i);
}
function C6(r, t, e) {
  return e === void 0 && (e = {}), ek(r, t, t, e);
}
function M6(r, t, e) {
  e === void 0 && (e = {});
  for (var n = [], i = t / Ie([r[0], r[1]], [r[2], r[1]], e), s = i * (r[2] - r[0]), o = t / Ie([r[0], r[1]], [r[0], r[3]], e), a = o * (r[3] - r[1]), u = 0, x = r[0]; x <= r[2]; ) {
    for (var c = 0, f = r[1]; f <= r[3]; ) {
      var l = null, h = null;
      u % 2 === 0 && c % 2 === 0 ? (l = Nt([
        [
          [x, f],
          [x, f + a],
          [x + s, f],
          [x, f]
        ]
      ], e.properties), h = Nt([
        [
          [x, f + a],
          [x + s, f + a],
          [x + s, f],
          [x, f + a]
        ]
      ], e.properties)) : u % 2 === 0 && c % 2 === 1 ? (l = Nt([
        [
          [x, f],
          [x + s, f + a],
          [x + s, f],
          [x, f]
        ]
      ], e.properties), h = Nt([
        [
          [x, f],
          [x, f + a],
          [x + s, f + a],
          [x, f]
        ]
      ], e.properties)) : c % 2 === 0 && u % 2 === 1 ? (l = Nt([
        [
          [x, f],
          [x, f + a],
          [x + s, f + a],
          [x, f]
        ]
      ], e.properties), h = Nt([
        [
          [x, f],
          [x + s, f + a],
          [x + s, f],
          [x, f]
        ]
      ], e.properties)) : c % 2 === 1 && u % 2 === 1 && (l = Nt([
        [
          [x, f],
          [x, f + a],
          [x + s, f],
          [x, f]
        ]
      ], e.properties), h = Nt([
        [
          [x, f + a],
          [x + s, f + a],
          [x + s, f],
          [x, f + a]
        ]
      ], e.properties)), e.mask ? (Ol(e.mask, l) && n.push(l), Ol(e.mask, h) && n.push(h)) : (n.push(l), n.push(h)), f += a, c++;
    }
    u++, x += s;
  }
  return ht(n);
}
function nk(r, t, e) {
  if (e = e || {}, typeof e != "object") throw new Error("options is invalid");
  var n = e.gridType, i = e.property, s = e.weight;
  if (!r) throw new Error("points is required");
  if (Ia(r, "Point", "input must contain Points"), !t) throw new Error("cellSize is required");
  if (s !== void 0 && typeof s != "number")
    throw new Error("weight must be a number");
  i = i || "elevation", n = n || "square", s = s || 1;
  var o = Cn(r), a;
  switch (n) {
    case "point":
    case "points":
      a = vE(o, t, e);
      break;
    case "square":
    case "squares":
      a = C6(o, t, e);
      break;
    case "hex":
    case "hexes":
      a = E6(o, t, e);
      break;
    case "triangle":
    case "triangles":
      a = M6(o, t, e);
      break;
    default:
      throw new Error("invalid gridType");
  }
  var u = [];
  return he(a, function(x) {
    var c = 0, f = 0;
    he(r, function(h) {
      var p = n === "point" ? x : Ka(x), y = Ie(p, h, e), v;
      if (i !== void 0 && (v = h.properties[i]), v === void 0 && (v = h.geometry.coordinates[2]), v === void 0) throw new Error("zValue is missing");
      y === 0 && (c = v);
      var m = 1 / Math.pow(y, s);
      f += m, c += m * v;
    });
    var l = br(x);
    l.properties[i] = c / f, u.push(l);
  }), ht(u);
}
const rk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  along: $L,
  angle: pD,
  applyFilter: zy,
  area: p2,
  areaFactors: Ig,
  bbox: Cn,
  bboxClip: NN,
  bboxPolygon: n2,
  bearing: fa,
  bearingToAngle: q0,
  bearingToAzimuth: q0,
  bezier: O5,
  bezierSpline: O5,
  booleanClockwise: Pg,
  booleanContains: uT,
  booleanCrosses: yT,
  booleanDisjoint: sS,
  booleanEqual: wT,
  booleanIntersects: cS,
  booleanOverlap: IT,
  booleanParallel: YT,
  booleanPointInPolygon: Fe,
  booleanPointOnLine: bi,
  booleanWithin: dE,
  buffer: WF,
  center: Py,
  centerMean: F2,
  centerMedian: lD,
  centerOfMass: Vw,
  centroid: Ka,
  circle: r2,
  cleanCoords: U0,
  clone: br,
  clusterEach: k2,
  clusterReduce: AS,
  clusters: PD,
  clustersDbscan: LT,
  clustersKmeans: GT,
  collect: vP,
  collectionOf: Ia,
  combine: DP,
  concave: cP,
  containsNumber: J_,
  convertArea: _w,
  convertDistance: z0,
  convertLength: z0,
  convex: Aw,
  coordAll: Lx,
  coordEach: hn,
  coordReduce: X_,
  createBins: B2,
  degrees2radians: Un,
  degreesToRadians: Un,
  destination: Eo,
  difference: rF,
  dissolve: ZF,
  distance: Ie,
  distanceToDegrees: wg,
  distanceToRadians: X0,
  distanceWeight: wS,
  earthRadius: Xn,
  ellipse: bS,
  envelope: zw,
  explode: Ly,
  factors: Sy,
  feature: Tn,
  featureCollection: ht,
  featureEach: he,
  featureOf: il,
  featureReduce: z_,
  filterProperties: TS,
  findPoint: Cw,
  findSegment: Sw,
  flatten: Um,
  flattenEach: sr,
  flattenReduce: Ew,
  flip: mP,
  geojsonType: Mw,
  geomEach: Pi,
  geomReduce: U_,
  geometry: dw,
  geometryCollection: Y_,
  getCluster: RS,
  getCoord: Ae,
  getCoords: gt,
  getGeom: ke,
  getType: oi,
  greatCircle: EN,
  helpers: ZC,
  hexGrid: E6,
  inside: Fe,
  interpolate: nk,
  intersect: Ol,
  invariant: jC,
  isNumber: Wn,
  isObject: we,
  isobands: TA,
  isolines: fM,
  kinks: ZL,
  length: zm,
  lengthToDegrees: wg,
  lengthToRadians: X0,
  lineArc: wE,
  lineChunk: fN,
  lineDistance: zm,
  lineEach: W_,
  lineIntersect: wa,
  lineOffset: rS,
  lineOverlap: tS,
  lineReduce: H_,
  lineSegment: W0,
  lineSlice: tN,
  lineSliceAlong: pE,
  lineSplit: SN,
  lineString: ge,
  lineStringToPolygon: j5,
  lineStrings: vw,
  lineToPolygon: j5,
  mask: QF,
  meta: KC,
  midpoint: TP,
  moranIndex: mD,
  multiLineString: c0,
  multiPoint: Gl,
  multiPolygon: Mi,
  nearest: Eg,
  nearestPoint: Eg,
  nearestPointOnLine: Ko,
  nearestPointToLine: WL,
  planepoint: JL,
  point: Pt,
  pointGrid: vE,
  pointOnFeature: k5,
  pointOnLine: Ko,
  pointOnSurface: k5,
  pointToLineDistance: hE,
  points: gw,
  pointsWithinPolygon: Dm,
  polygon: Nt,
  polygonSmooth: dD,
  polygonTangents: qR,
  polygonToLine: fl,
  polygonToLineString: fl,
  polygonize: nT,
  polygons: yw,
  projection: ID,
  propEach: q_,
  propReduce: ww,
  propertiesContainsFilter: G2,
  radians2degrees: Za,
  radiansToDegrees: Za,
  radiansToDistance: Px,
  radiansToLength: Px,
  random: MD,
  randomLineString: NS,
  randomPoint: PS,
  randomPolygon: LS,
  randomPosition: Hl,
  rewind: VR,
  rhumbBearing: H0,
  rhumbDestination: Ox,
  rhumbDistance: ky,
  round: mw,
  sample: OP,
  sector: YR,
  segmentEach: Zo,
  segmentReduce: V_,
  shortestPath: zT,
  simplify: EP,
  square: Uw,
  squareGrid: C6,
  standardDeviationalEllipse: hD,
  tag: NP,
  tesselate: $P,
  tin: Tw,
  toMercator: SS,
  toWgs84: CS,
  transformRotate: eS,
  transformScale: nS,
  transformTranslate: qA,
  triangleGrid: M6,
  truncate: mE,
  union: JF,
  unitsFactors: pw,
  unkinkPolygon: wN,
  validateBBox: bw,
  validateId: Iw,
  voronoi: fD,
  within: Dm
}, Symbol.toStringTag, { value: "Module" }));
(function(r, t) {
  const e = au, n = r();
  for (; ; )
    try {
      if (-parseInt(e(304)) / 1 * (-parseInt(e(296)) / 2) + parseInt(e(288)) / 3 + parseInt(e(321)) / 4 * (-parseInt(e(305)) / 5) + parseInt(e(290)) / 6 * (parseInt(e(315)) / 7) + parseInt(e(291)) / 8 * (parseInt(e(309)) / 9) + -parseInt(e(287)) / 10 + -parseInt(e(310)) / 11 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Ug, 700056);
function au(r, t) {
  const e = Ug();
  return au = function(n, i) {
    return n = n - 285, e[n];
  }, au(r, t);
}
function q3(r, t, e, n) {
  const i = au;
  r[i(301)] = e, r[i(320)](), r.lineWidth = n, r[i(286)](t[0][0], t[0][1]);
  for (let s = 1; s < t[i(297)]; s++)
    r[i(292)](t[s][0], t[s][1]);
  r[i(293)]();
}
function ik(r, t, e, n) {
  const i = au;
  r[i(299)] = n, r[i(320)](), r.moveTo(t[0][0], t[0][1]);
  for (let s = 1; s < t.length; s++)
    r[i(292)](t[s][0], t[s][1]);
  for (let s = e[i(297)] - 1; s >= 0; s--)
    r[i(292)](e[s][0], e[s][1]);
  r.closePath(), r[i(314)]();
}
function sk(r, t, e) {
  const n = au;
  let i = e[n(317)][n(293)][n(302)].color || n(306), s = e.Style.fill[n(294)][n(311)] || "rgba(0,0,255,1)", o = e.Style.stroke.Stroke[n(295)] || 2, a = e[n(317)][n(293)].Stroke.parallelDistance || 5;
  const u = ge(t), x = rS(u, a, { units: "degrees" }), c = rk[n(312)](u, -a, { units: n(285) });
  let f = x[n(307)][n(308)], l = c[n(307)][n(308)];
  return f[n(313)](l[l[n(297)] - 1]), f[n(289)](l[0]), ik(r, x[n(307)][n(308)], c[n(307)][n(308)], i), q3(r, x[n(307)].coordinates, s, o), q3(r, c[n(307)].coordinates, s, o), { start: t[t[n(297)] - 2], end: t[t[n(297)] - 1], angle: Math[n(300)](t[t.length - 1][1] - t[t[n(297)] - 2][1], t[t[n(297)] - 1][0] - t[t.length - 2][0]) };
}
function ok(r, t, e, n, i) {
  const s = au;
  let o = i[s(317)][s(293)][s(302)][s(295)] || 15, a = i[s(317)].stroke.Stroke[s(316)] || 30, u = i[s(317)][s(293)][s(302)][s(311)] || s(306), x = i.Style.fill[s(294)][s(311)] || "rgba(0,0,255,1)";
  const c = o, f = t + a * Math[s(318)](n), l = e + a * Math[s(303)](n), h = c * Math.cos(n + Math.PI / 2), p = c * Math[s(303)](n + Math.PI / 2), y = t - h, v = e - p, m = t + h, d = e + p;
  r[s(301)] = x, r.fillStyle = u, r[s(298)] = 2, r[s(320)](), r[s(286)](f, l), r[s(292)](y, v), r.lineTo(t, e), r[s(292)](m, d), r[s(319)](), r[s(314)](), r.stroke();
}
function Ug() {
  const r = ["522704MgQJjC", "degrees", "moveTo", "5014340xHaoIT", "3414987YFRKgk", "unshift", "2389074VSabsl", "1430024DbtrAC", "lineTo", "stroke", "Fill", "width", "20RLMWVX", "length", "lineWidth", "fillStyle", "atan2", "strokeStyle", "Stroke", "sin", "122751jBGNkx", "15rRrfgr", "rgba(0,0,255,1)", "geometry", "coordinates", "27LQEBma", "27534287HEKmEA", "color", "lineOffset", "push", "fill", "21zMmBuA", "height", "Style", "cos", "closePath", "beginPath"];
  return Ug = function() {
    return r;
  }, Ug();
}
(function(r, t) {
  const e = Vg, n = r();
  for (; ; )
    try {
      if (-parseInt(e(430)) / 1 + -parseInt(e(427)) / 2 * (parseInt(e(435)) / 3) + -parseInt(e(420)) / 4 * (-parseInt(e(426)) / 5) + -parseInt(e(433)) / 6 + parseInt(e(425)) / 7 * (-parseInt(e(431)) / 8) + -parseInt(e(423)) / 9 + parseInt(e(424)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Wg, 701586);
function Vg(r, t) {
  const e = Wg();
  return Vg = function(n, i) {
    return n = n - 420, e[n];
  }, Vg(r, t);
}
function Wg() {
  const r = ["arrowStyle", "7790520YZtknE", "ParallelLines", "9hlMlpp", "8nOArBo", "length", "lineStyle", "9511074QXeUdS", "37862740Igpqfk", "7FAcMYj", "1120235mjhWcm", "182916LrBcIa", "context", "rgba(0,0,255,1)", "71283BmtJQw", "6655352LYvCMH"];
  return Wg = function() {
    return r;
  }, Wg();
}
function ak(r) {
  const t = Vg;
  Is(r[t(422)]);
  let e = { glyph: t(434), lineStyle: { Style: { stroke: { Stroke: { color: t(429), width: 1, parallelDistance: 3 } }, fill: { Fill: { color: "rgba(0,0,255,1)" } } } }, arrowStyle: { Style: { stroke: { Stroke: { color: t(429), width: 15, height: 30 } }, fill: { Fill: { color: "rgba(0,0,255,1)" } } } } };
  const n = Object.assign({}, e, r);
  return [new En({ renderer: (s, o) => {
    const a = t, u = o[a(428)], { start: x, end: c, angle: f } = sk(u, s, n[a(422)]);
    ok(u, s[s.length - 1][0], s[s[a(421)] - 1][1], f, n[a(432)]);
  } })];
}
var Ec = Jg;
(function(r, t) {
  for (var e = Jg, n = r(); ; )
    try {
      var i = parseInt(e(246)) / 1 * (parseInt(e(245)) / 2) + -parseInt(e(247)) / 3 + -parseInt(e(249)) / 4 + parseInt(e(256)) / 5 * (parseInt(e(248)) / 6) + -parseInt(e(254)) / 7 * (-parseInt(e(251)) / 8) + -parseInt(e(255)) / 9 * (parseInt(e(244)) / 10) + parseInt(e(250)) / 11;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Hg, 218839);
function Hg() {
  var r = ["getCme_LINES_51", "getCme_LINES_41", "getCme_FrostLineStyle", "10AiTQep", "2KtoFhx", "333613nwqOMd", "736305GsumTQ", "678Ekrznm", "239188GyrsIu", "3612774KBgEFP", "254152XhzYRG", "getCme_LINES_SYMBOL2", "getCme_LINES_19", "21eYlHvA", "2733138fesFJN", "3115yskmgk"];
  return Hg = function() {
    return r;
  }, Hg();
}
function Jg(r, t) {
  var e = Hg();
  return Jg = function(n, i) {
    n = n - 244;
    var s = e[n];
    return s;
  }, Jg(r, t);
}
var uk = class {
  constructor(t) {
  }
  [Ec(259)](t) {
    return UC(t);
  }
  [Ec(252)](t) {
    return h5(t);
  }
  getCme_LINES_18(t) {
    return h5(t);
  }
  [Ec(253)](t) {
    return WC(t);
  }
  [Ec(258)](t) {
    return HC(t);
  }
  [Ec(257)](t) {
    return JC(t);
  }
  getCme_ParallelLines(t, e) {
    return ak(t);
  }
  getCme_Style(t) {
    return Is(t);
  }
};
function Zg(r, t) {
  var e = Kg();
  return Zg = function(n, i) {
    n = n - 453;
    var s = e[n];
    return s;
  }, Zg(r, t);
}
var xk = Zg;
(function(r, t) {
  for (var e = Zg, n = r(); ; )
    try {
      var i = parseInt(e(461)) / 1 + -parseInt(e(460)) / 2 + parseInt(e(458)) / 3 + parseInt(e(455)) / 4 + parseInt(e(453)) / 5 + parseInt(e(459)) / 6 + parseInt(e(457)) / 7 * (-parseInt(e(454)) / 8);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(Kg, 589260);
function Kg() {
  var r = ["63194TrXnDS", "975886oJDHiK", "1787510NJTfHJ", "6310888HfxuGI", "2270328wecHId", "getCme_Style", "21TOSWdL", "1649247vyIEJC", "3220326ByXnNC"];
  return Kg = function() {
    return r;
  }, Kg();
}
var ck = class {
  constructor(t) {
  }
  [xk(456)](t) {
    return Is(t);
  }
};
function jg() {
  var r = ["canvas", "beginPath", "canvas_", "lineTo", "8761494GdCapI", "repeat", "createPattern", "tile", "push", "scale", "535764dwOeIj", "1557GKDFfZ", "pattern", "length", "textBaseline", "offset", "center", "abs", "10hIdYto", "stroke", "clone", "px Arial", "63109111aSJEDM", "number", "sin", "height", "5jMCLuo", "moveTo", "lineWidth", "width", "globalAlpha", "dot", "strokeStyle", "square", "angle", "getImage", "fill", "strokeWidth", "load", "circle", "14ZxLWbn", "image", "addPattern", "fillRect", "121zMQeaH", "circles", "middle", "restore", "concat", "1673440hEhxMx", "cross", "color", "getPattern_", "getContext", "font", "fillText", "4836nunjLb", "lineCap", "hatch", "drawImage", "7063668lBVlFT", "2zQlGFU", "getColor", "lines", "char", "spacing", "translate", "opacity", "1225934jDbDcw", "#000", "patterns", "cos", "setColor", "red", "fillStyle", "size", "clearRect", "round"];
  return jg = function() {
    return r;
  }, jg();
}
function Rl(r, t) {
  var e = jg();
  return Rl = function(n, i) {
    n = n - 406;
    var s = e[n];
    return s;
  }, Rl(r, t);
}
var b0 = Rl;
(function(r, t) {
  for (var e = Rl, n = r(); ; )
    try {
      var i = parseInt(e(425)) / 1 * (-parseInt(e(432)) / 2) + -parseInt(e(453)) / 3 * (parseInt(e(420)) / 4) + parseInt(e(468)) / 5 * (-parseInt(e(446)) / 6) + -parseInt(e(482)) / 7 * (parseInt(e(413)) / 8) + parseInt(e(424)) / 9 * (-parseInt(e(460)) / 10) + -parseInt(e(408)) / 11 * (-parseInt(e(452)) / 12) + parseInt(e(464)) / 13;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(jg, 828798);
var ex = class extends Hr {
  constructor(t) {
    var e = Rl;
    super(), t = t || {};
    var n, i = this[e(444)] = document.createElement(e(442)), s = Number(t[e(451)]) > 0 ? Number(t[e(451)]) : 1, o = s * Tb || Tb, a = i[e(417)]("2d");
    if (t.image) {
      t[e(483)][e(480)]();
      var u, x = t[e(483)][e(477)]();
      if (x[e(471)]) i.width = Math[e(441)](x[e(471)] * o), i[e(467)] = Math.round(x[e(467)] * o), a[e(472)] = typeof t[e(431)] == e(465) ? t[e(431)] : 1, a[e(423)](x, 0, 0, x[e(471)], x[e(467)], 0, 0, i.width, i[e(467)]), n = a[e(448)](i, e(447));
      else {
        var c = this;
        n = [0, 0, 0, 0], x.onload = function() {
          var g = e;
          i[g(471)] = Math[g(441)](x[g(471)] * o), i[g(467)] = Math[g(441)](x[g(467)] * o), a[g(472)] = typeof t[g(431)] == g(465) ? t[g(431)] : 1, a[g(423)](x, 0, 0, x.width, x[g(467)], 0, 0, i[g(471)], i.height), n = a[g(448)](i, "repeat"), c[g(436)](n);
        };
      }
    } else {
      var f = this[e(416)](t);
      if (i[e(471)] = Math[e(441)](f[e(471)] * o), i.height = Math.round(f[e(467)] * o), a[e(443)](), t[e(478)] && (a[e(438)] = Jo(t.fill[e(426)]()), a[e(407)](0, 0, i[e(471)], i[e(467)])), a[e(451)](o, o), a[e(421)] = e(441), a[e(470)] = f[e(461)] || 1, a[e(438)] = Jo(t[e(415)] || e(433)), a[e(474)] = Jo(t[e(415)] || "#000"), f[e(409)]) for (u = 0; u < f[e(409)][e(455)]; u++) {
        var l = f[e(409)][u];
        a[e(443)](), a.arc(l[0], l[1], l[2], 0, 2 * Math.PI), f[e(478)] && a[e(478)](), f[e(461)] && a[e(461)]();
      }
      if (f[e(447)] || (f[e(447)] = [[0, 0]]), f[e(428)] && (a[e(418)] = f[e(418)] || f.width + e(463), a.textAlign = e(458), a[e(456)] = e(410), f[e(476)] ? (a[e(419)](f[e(428)], f[e(471)] / 4, f.height / 4), a.fillText(f[e(428)], 5 * f[e(471)] / 4, 5 * f[e(467)] / 4), a[e(419)](f[e(428)], f[e(471)] / 4, 5 * f.height / 4), a[e(419)](f[e(428)], 5 * f[e(471)] / 4, f[e(467)] / 4), a[e(419)](f[e(428)], 3 * f[e(471)] / 4, 3 * f.height / 4), a[e(419)](f.char, -f[e(471)] / 4, -f[e(467)] / 4), a[e(419)](f[e(428)], 3 * f[e(471)] / 4, -f[e(467)] / 4), a[e(419)](f[e(428)], -f[e(471)] / 4, 3 * f.height / 4)) : a[e(419)](f[e(428)], f[e(471)] / 2, f[e(467)] / 2)), f[e(427)])
        for (u = 0; u < f[e(427)].length; u++) for (var h = 0; h < f.repeat[e(455)]; h++) {
          var p = f[e(427)][u];
          a.beginPath(), a[e(469)](p[0] + f[e(447)][h][0], p[1] + f[e(447)][h][1]);
          for (var y = 2; y < p[e(455)]; y += 2)
            a[e(445)](p[y] + f[e(447)][h][0], p[y + 1] + f[e(447)][h][1]);
          f[e(478)] && a[e(478)](), f[e(461)] && a[e(461)](), a.save(), a[e(474)] = e(437), a[e(479)] = 0.1, a[e(411)]();
        }
      if (n = a[e(448)](i, "repeat"), t[e(457)]) {
        var v = t.offset;
        if (typeof v == e(465) && (v = [v, v]), v instanceof Array) {
          var m = Math[e(441)](v[0] * o), d = Math[e(441)](v[1] * o);
          a[e(451)](1 / o, 1 / o), a[e(440)](0, 0, i[e(471)], i[e(467)]), a[e(430)](m, d), a[e(438)] = n, a[e(407)](-m, -d, i[e(471)], i[e(467)]), n = a[e(448)](i, e(447));
        }
      }
    }
    this[e(436)](n);
  }
  static [b0(406)](t, e) {
    var n = b0;
    e || (e = {}), ex[n(434)][t || e.char] = { width: e.width || e[n(439)] || 10, height: e.height || e[n(439)] || 10, font: e[n(418)], char: e.char, circles: e.circles, lines: e[n(427)], repeat: e.repeat, stroke: e[n(461)], angle: e[n(476)], fill: e[n(478)] };
  }
  clone() {
    var t = b0, e = super[t(462)]();
    return e.canvas_ = this[t(444)], e;
  }
  [b0(477)]() {
    var t = b0;
    return this[t(444)];
  }
  [b0(416)](t) {
    var e = b0, n = ex[e(434)][t[e(454)]] || ex[e(434)][e(473)], i = Math[e(441)](t[e(429)]) || 10, s;
    switch (t[e(454)]) {
      case e(473):
      case "circle": {
        s = t.size === 0 ? 0 : t[e(439)] / 2 || 2, t.angle ? (i = n[e(471)] = n[e(467)] = Math.round(i * 1.4), n[e(409)] = [[i / 4, i / 4, s], [3 * i / 4, 3 * i / 4, s]], t[e(454)] == e(481) && (n.circles = n[e(409)][e(412)]([[i / 4 + i, i / 4, s], [i / 4, i / 4 + i, s], [3 * i / 4 - i, 3 * i / 4, s], [3 * i / 4, 3 * i / 4 - i, s], [i / 4 + i, i / 4 + i, s], [3 * i / 4 - i, 3 * i / 4 - i, s]]))) : (n[e(471)] = n.height = i, n.circles = [[i / 2, i / 2, s]], t[e(454)] == e(481) && (n[e(409)] = n[e(409)].concat([[i / 2 + i, i / 2, s], [i / 2 - i, i / 2, s], [i / 2, i / 2 + i, s], [i / 2, i / 2 - i, s], [i / 2 + i, i / 2 + i, s], [i / 2 + i, i / 2 - i, s], [i / 2 - i, i / 2 + i, s], [i / 2 - i, i / 2 - i, s]])));
        break;
      }
      case e(449):
      case e(475): {
        s = t[e(439)] === 0 ? 0 : t[e(439)] / 2 || 2, t[e(476)] ? (n[e(471)] = n[e(467)] = i, n[e(427)] = [[i / 2 - s, i / 2, i / 2, i / 2 - s, i / 2 + s, i / 2, i / 2, i / 2 + s, i / 2 - s, i / 2]]) : (n[e(471)] = n[e(467)] = i, n[e(427)] = [[i / 2 - s, i / 2 - s, i / 2 + s, i / 2 - s, i / 2 + s, i / 2 + s, i / 2 - s, i / 2 + s, i / 2 - s, i / 2 - s]]), t[e(454)] == e(475) && (n.repeat = [[0, 0], [0, i], [i, 0], [0, -i], [-i, 0], [-i, -i], [i, i], [-i, i], [i, -i]]);
        break;
      }
      case "cross":
        t[e(476)] && (t.angle = 45);
      case e(422): {
        var o = Math.round(((t[e(476)] || 0) - 90) % 360);
        o > 180 && (o -= 360), o *= Math.PI / 180;
        var a = Math[e(435)](o), u = Math[e(466)](o);
        if (Math[e(459)](u) < 1e-4) n[e(471)] = n[e(467)] = i, n.lines = [[0, 0.5, i, 0.5]], n[e(447)] = [[0, 0], [0, i]];
        else if (Math[e(459)](a) < 1e-4) n.width = n[e(467)] = i, n[e(427)] = [[0.5, 0, 0.5, i]], n[e(447)] = [[0, 0], [i, 0]], t[e(454)] == e(414) && (n.lines[e(450)]([0, 0.5, i, 0.5]), n[e(447)][e(450)]([0, i]));
        else {
          var x = n[e(471)] = Math[e(441)](Math[e(459)](i / u)) || 1, c = n[e(467)] = Math[e(441)](Math[e(459)](i / a)) || 1;
          t[e(454)] == e(414) ? (n[e(427)] = [[-x, -c, 2 * x, 2 * c], [2 * x, -c, -x, 2 * c]], n[e(447)] = [[0, 0]]) : a * u > 0 ? (n.lines = [[-x, -c, 2 * x, 2 * c]], n[e(447)] = [[0, 0], [x, 0], [0, c]]) : (n[e(427)] = [[2 * x, -c, -x, 2 * c]], n[e(447)] = [[0, 0], [-x, 0], [0, c]]);
        }
        n[e(461)] = t[e(439)] === 0 ? 0 : t[e(439)] || 4;
        break;
      }
    }
    return n;
  }
};
ex.patterns = { hatch: { width: 5, height: 5, lines: [[0, 2.5, 5, 2.5]], stroke: 1 }, cross: { width: 7, height: 7, lines: [[0, 3, 10, 3], [3, 0, 3, 10]], stroke: 1 }, dot: { width: 8, height: 8, circles: [[5, 5, 2]], stroke: !1, fill: !0 }, circle: { width: 10, height: 10, circles: [[5, 5, 2]], stroke: 1, fill: !1 }, square: { width: 10, height: 10, lines: [[3, 3, 3, 8, 8, 8, 8, 3, 3, 3]], stroke: 1, fill: !1 }, tile: { width: 10, height: 10, lines: [[3, 3, 3, 8, 8, 8, 8, 3, 3, 3]], fill: !0 }, woven: { width: 12, height: 12, lines: [[3, 3, 9, 9], [0, 12, 3, 9], [9, 3, 12, 0], [-1, 1, 1, -1], [13, 11, 11, 13]], stroke: 1 }, crosses: { width: 8, height: 8, lines: [[2, 2, 6, 6], [2, 6, 6, 2]], stroke: 1 }, caps: { width: 8, height: 8, lines: [[2, 6, 4, 2, 6, 6]], stroke: 1 }, nylon: { width: 20, height: 20, lines: [[1, 6, 1, 1, 6, 1], [6, 11, 11, 11, 11, 6], [11, 16, 11, 21, 16, 21], [16, 11, 21, 11, 21, 16]], repeat: [[0, 0], [-20, 0], [0, -20]], stroke: 1 }, hexagon: { width: 20, height: 12, lines: [[0, 10, 4, 4, 10, 4, 14, 10, 10, 16, 4, 16, 0, 10]], stroke: 1, repeat: [[0, 0], [10, 6], [10, -6], [-10, -6]] }, cemetry: { width: 15, height: 19, lines: [[0, 3.5, 7, 3.5], [3.5, 0, 3.5, 10]], stroke: 1, repeat: [[0, 0], [7, 9]] }, sand: { width: 20, height: 20, circles: [[1, 2, 1], [9, 3, 1], [2, 16, 1], [7, 8, 1], [6, 14, 1], [4, 19, 1], [14, 2, 1], [12, 10, 1], [14, 18, 1], [18, 8, 1], [18, 14, 1]], fill: 1 }, conglomerate: { width: 60, height: 40, circles: [[2, 4, 1], [17, 3, 1], [26, 18, 1], [12, 17, 1], [5, 17, 2], [28, 11, 2]], lines: [[7, 5, 6, 7, 9, 9, 11, 8, 11, 6, 9, 5, 7, 5], [16, 10, 15, 13, 16, 14, 19, 15, 21, 13, 22, 9, 20, 8, 19, 8, 16, 10], [24, 6, 26, 7, 27, 5, 26, 4, 24, 4, 24, 6]], repeat: [[30, 0], [-15, 20], [15, 20], [45, 20]], stroke: 1 }, conglomerate2: { width: 60, height: 40, circles: [[2, 4, 1], [17, 3, 1], [26, 18, 1], [12, 17, 1], [5, 17, 2], [28, 11, 2]], lines: [[7, 5, 6, 7, 9, 9, 11, 8, 11, 6, 9, 5, 7, 5], [16, 10, 15, 13, 16, 14, 19, 15, 21, 13, 22, 9, 20, 8, 19, 8, 16, 10], [24, 6, 26, 7, 27, 5, 26, 4, 24, 4, 24, 6]], repeat: [[30, 0], [-15, 20], [15, 20], [45, 20]], fill: 1 }, gravel: { width: 15, height: 10, circles: [[4, 2, 1], [5, 9, 1], [1, 7, 1]], lines: [[7, 5, 6, 6, 7, 7, 8, 7, 9, 7, 10, 5, 9, 4, 7, 5], [11, 2, 14, 4, 14, 1, 12, 1, 11, 2]], stroke: 1 }, brick: { width: 18, height: 16, lines: [[0, 1, 18, 1], [0, 10, 18, 10], [6, 1, 6, 10], [12, 10, 12, 18], [12, 0, 12, 1]], stroke: 1 }, dolomite: { width: 20, height: 16, lines: [[0, 1, 20, 1], [0, 9, 20, 9], [1, 9, 6, 1], [11, 9, 14, 16], [14, 0, 14.4, 1]], stroke: 1 }, coal: { width: 20, height: 16, lines: [[1, 5, 7, 1, 7, 7], [11, 10, 12, 5, 18, 9], [5, 10, 2, 15, 9, 15], [15, 16, 15, 13, 20, 16], [15, 0, 15, 2, 20, 0]], fill: 1 }, breccia: { width: 20, height: 16, lines: [[1, 5, 7, 1, 7, 7, 1, 5], [11, 10, 12, 5, 18, 9, 11, 10], [5, 10, 2, 15, 9, 15, 5, 10], [15, 16, 15, 13, 22, 18], [15, 0, 15, 2, 20, 0]], stroke: 1 }, clay: { width: 20, height: 20, lines: [[0, 0, 3, 11, 0, 20], [11, 0, 10, 3, 13, 13, 11, 20], [0, 0, 10, 3, 20, 0], [0, 12, 3, 11, 13, 13, 20, 12]], stroke: 1 }, flooded: { width: 15, height: 10, lines: [[0, 1, 10, 1], [0, 6, 5, 6], [10, 6, 15, 6]], stroke: 1 }, chaos: { width: 40, height: 40, lines: [[40, 2, 40, 0, 38, 0, 40, 2], [4, 0, 3, 2, 2, 5, 0, 0, 0, 3, 2, 7, 5, 6, 7, 7, 8, 10, 9, 12, 9, 13, 9, 14, 8, 14, 6, 15, 2, 15, 0, 20, 0, 22, 2, 20, 5, 19, 8, 15, 10, 14, 11, 12.25, 10, 12, 10, 10, 12, 9, 13, 7, 12, 6, 13, 4, 16, 7, 17, 4, 20, 0, 18, 0, 15, 3, 14, 2, 14, 0, 12, 1, 11, 0, 10, 1, 11, 4, 10, 7, 9, 8, 8, 5, 6, 4, 5, 3, 5, 1, 5, 0, 4, 0], [7, 1, 7, 3, 8, 3, 8, 2, 7, 1], [4, 3, 5, 5, 4, 5, 4, 3], [34, 5, 33, 7, 38, 10, 38, 8, 36, 5, 34, 5], [27, 0, 23, 2, 21, 8, 30, 0, 27, 0], [25, 8, 26, 12, 26, 16, 22.71875, 15.375, 20, 13, 18, 15, 17, 18, 13, 22, 17, 21, 19, 22, 21, 20, 19, 18, 22, 17, 30, 25, 26, 26, 24, 28, 21.75, 33.34375, 20, 36, 18, 40, 20, 40, 24, 37, 25, 32, 27, 31, 26, 38, 27, 37, 30, 32, 32, 35, 36, 37, 38, 40, 38, 39, 40, 40, 37, 36, 34, 32, 37, 31, 36, 29, 33, 27, 34, 24, 39, 21, 40, 21, 40, 16, 37, 20, 31, 22, 32, 25, 27, 20, 29, 15, 30, 20, 32, 20, 34, 18, 33, 12, 31, 11, 29, 14, 26, 9, 25, 8], [39, 24, 37, 26, 40, 28, 39, 24], [13, 15, 9, 19, 14, 18, 13, 15], [18, 23, 14, 27, 16, 27, 17, 25, 20, 26, 18, 23], [6, 24, 2, 26, 1, 28, 2, 30, 5, 28, 12, 30, 16, 32, 18, 30, 15, 30, 12, 28, 9, 25, 7, 27, 6, 24], [29, 27, 32, 28, 33, 31, 30, 29, 27, 28, 29, 27], [5, 35, 1, 33, 3, 36, 13, 38, 15, 35, 10, 36, 5, 35]], fill: 1 }, grass: { width: 27, height: 22, lines: [[0, 10.5, 13, 10.5], [2.5, 10, 1.5, 7], [4.5, 10, 4.5, 5, 3.5, 4], [7, 10, 7.5, 6, 8.5, 3], [10, 10, 11, 6]], repeat: [[0, 0], [14, 10]], stroke: 1 }, swamp: { width: 24, height: 23, lines: [[0, 10.5, 9.5, 10.5], [2.5, 10, 2.5, 7], [4.5, 10, 4.5, 4], [6.5, 10, 6.5, 6], [3, 12.5, 7, 12.5]], repeat: [[0, 0], [14, 10]], stroke: 1 }, reed: { width: 26, height: 23, lines: [[2.5, 10, 2, 7], [4.5, 10, 4.2, 4], [6.5, 10, 6.8, 4], [8.5, 10, 9, 6], [3.7, 4, 3.7, 2.5], [4.7, 4, 4.7, 2.5], [6.3, 4, 6.3, 2.5], [7.3, 4, 7.3, 2.5]], circles: [[4.2, 2.5, 0.5], [18.2, 12.5, 0.5], [6.8, 2.5, 0.5], [20.8, 12.5, 0.5], [9, 6, 0.5], [23, 16, 0.5]], repeat: [[0, 0], [14, 10]], stroke: 1 }, wave: { width: 10, height: 8, lines: [[0, 0, 5, 4, 10, 0]], stroke: 1 }, vine: { width: 13, height: 13, lines: [[3, 0, 3, 6], [9, 7, 9, 13]], stroke: 1 }, forest: { width: 55, height: 30, circles: [[7, 7, 3.5], [20, 20, 1.5], [42, 22, 3.5], [35, 5, 1.5]], stroke: 1 }, forest2: { width: 55, height: 30, circles: [[7, 7, 3.5], [20, 20, 1.5], [42, 22, 3.5], [35, 5, 1.5]], fill: 1, stroke: 1 }, scrub: { width: 26, height: 20, lines: [[1, 4, 4, 8, 6, 4]], circles: [[20, 13, 1.5]], stroke: 1 }, tree: { width: 30, height: 30, lines: [[7.78, 10.61, 4.95, 10.61, 4.95, 7.78, 3.54, 7.78, 2.12, 6.36, 0.71, 6.36, 0, 4.24, 0.71, 2.12, 4.24, 0, 7.78, 0.71, 9.19, 3.54, 7.78, 4.95, 7.07, 7.07, 4.95, 7.78]], repeat: [[3, 1], [18, 16]], stroke: 1 }, tree2: { width: 30, height: 30, lines: [[7.78, 10.61, 4.95, 10.61, 4.95, 7.78, 3.54, 7.78, 2.12, 6.36, 0.71, 6.36, 0, 4.24, 0.71, 2.12, 4.24, 0, 7.78, 0.71, 9.19, 3.54, 7.78, 4.95, 7.07, 7.07, 4.95, 7.78, 4.95, 10.61, 7.78, 10.61]], repeat: [[3, 1], [18, 16]], fill: 1, stroke: 1 }, pine: { width: 30, height: 30, lines: [[5.66, 11.31, 2.83, 11.31, 2.83, 8.49, 0, 8.49, 2.83, 0, 5.66, 8.49, 2.83, 8.49]], repeat: [[3, 1], [18, 16]], stroke: 1 }, pine2: { width: 30, height: 30, lines: [[5.66, 11.31, 2.83, 11.31, 2.83, 8.49, 0, 8.49, 2.83, 0, 5.66, 8.49, 2.83, 8.49, 2.83, 11.31, 5.66, 11.31]], repeat: [[3, 1], [18, 16]], fill: 1, stroke: 1 }, mixtree: { width: 30, height: 30, lines: [[7.78, 10.61, 4.95, 10.61, 4.95, 7.78, 3.54, 7.78, 2.12, 6.36, 0.71, 6.36, 0, 4.24, 0.71, 2.12, 4.24, 0, 7.78, 0.71, 9.19, 3.54, 7.78, 4.95, 7.07, 7.07, 4.95, 7.78, 4.95, 10.61, 7.78, 10.61], [23.66, 27.31, 20.83, 27.31, 20.83, 24.49, 18, 24.49, 20.83, 16, 23.66, 24.49, 20.83, 24.49, 20.83, 27.31, 23.66, 27.31]], repeat: [[3, 1]], stroke: 1 }, mixtree2: { width: 30, height: 30, lines: [[7.78, 10.61, 4.95, 10.61, 4.95, 7.78, 3.54, 7.78, 2.12, 6.36, 0.71, 6.36, 0, 4.24, 0.71, 2.12, 4.24, 0, 7.78, 0.71, 9.19, 3.54, 7.78, 4.95, 7.07, 7.07, 4.95, 7.78, 4.95, 10.61, 7.78, 10.61], [23.66, 27.31, 20.83, 27.31, 20.83, 24.49, 18, 24.49, 20.83, 16, 23.66, 24.49, 20.83, 24.49, 20.83, 27.31, 23.66, 27.31]], repeat: [[3, 1]], fill: 1, stroke: 1 }, pines: { width: 22, height: 20, lines: [[1, 4, 3.5, 1, 6, 4], [1, 8, 3.5, 5, 6, 8], [3.5, 1, 3.5, 11], [12, 14.5, 14.5, 14, 17, 14.5], [12, 18, 17, 18], [14.5, 12, 14.5, 18]], repeat: [[2, 1]], stroke: 1 }, rock: { width: 20, height: 20, lines: [[1, 0, 1, 9], [4, 0, 4, 9], [7, 0, 7, 9], [10, 1, 19, 1], [10, 4, 19, 4], [10, 7, 19, 7], [0, 11, 9, 11], [0, 14, 9, 14], [0, 17, 9, 17], [12, 10, 12, 19], [15, 10, 15, 19], [18, 10, 18, 19]], repeat: [[0.5, 0.5]], stroke: 1 }, rocks: { width: 20, height: 20, lines: [[5, 0, 3, 0, 5, 4, 4, 6, 0, 3, 0, 5, 3, 6, 5, 9, 3.75, 10, 2.5, 10, 0, 9, 0, 10, 4, 11, 5, 14, 4, 15, 0, 13, 0, 13, 0, 13, 0, 14, 0, 14, 5, 16, 5, 18, 3, 19, 0, 19, -0.25, 19.9375, 5, 20, 10, 19, 10, 20, 11, 20, 12, 19, 14, 20, 15, 20, 17, 19, 20, 20, 20, 19, 19, 16, 20, 15, 20, 11, 20, 10, 19, 8, 20, 5, 20, 0, 19, 0, 20, 2, 19, 4, 17, 4, 16, 3, 15, 0, 14, 0, 15, 4, 11, 5, 10, 4, 11, 0, 10, 0, 9, 4, 6, 5, 5, 0], [18, 5, 19, 6, 18, 10, 16, 10, 14, 9, 16, 5, 18, 5], [5, 6, 9, 5, 10, 6, 10, 9, 6, 10, 5, 6], [14, 5, 14, 8, 13, 9, 12, 9, 11, 7, 12, 5, 14, 5], [5, 11, 8, 10, 9, 11, 10, 14, 6, 15, 6, 15, 5, 11], [13, 10, 14, 11, 15, 14, 15, 14, 15, 14, 11, 15, 10, 11, 11, 10, 13, 10], [15, 12, 16, 11, 19, 11, 19, 15, 16, 14, 16, 14, 15, 12], [6, 16, 9, 15, 10, 18, 5, 19, 6, 16], [10, 16, 14, 16, 14, 18, 13, 19, 11, 18, 10, 16], [15, 15, 18, 16, 18, 18, 16, 19, 15, 18, 15, 15]], stroke: 1 } };
function Qg(r, t) {
  const e = $g();
  return Qg = function(n, i) {
    return n = n - 238, e[n];
  }, Qg(r, t);
}
(function(r, t) {
  const e = Qg, n = r();
  for (; ; )
    try {
      if (parseInt(e(248)) / 1 + -parseInt(e(239)) / 2 * (parseInt(e(246)) / 3) + parseInt(e(243)) / 4 * (parseInt(e(244)) / 5) + parseInt(e(238)) / 6 * (-parseInt(e(241)) / 7) + -parseInt(e(251)) / 8 + -parseInt(e(247)) / 9 + parseInt(e(250)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})($g, 390325);
function $g() {
  const r = ["fill", "179636efrWMo", "55lCexoY", "color", "1813827CqRyeV", "1377864gLugGO", "371960VZclzj", "offset", "9871620qLvqLB", "2547768iIGEtx", "size", "angle", "ratio", "spacing", "pattern", "2319720QKwnJk", "2hqKdfg", "scale", "7GRCMxo"];
  return $g = function() {
    return r;
  }, $g();
}
function fk(r) {
  const t = Qg;
  return new En({ fill: new ex({ pattern: r[t(256)], ratio: r[t(254)] || 1, color: r[t(245)], offset: r[t(249)] || 0, scale: r[t(240)] || 1, fill: new Hr({ color: r[t(242)] }), size: r[t(252)], spacing: r[t(255)], angle: r[t(253)] }) });
}
function ty(r, t) {
  const e = ey();
  return ty = function(n, i) {
    return n = n - 303, e[n];
  }, ty(r, t);
}
(function(r, t) {
  const e = ty, n = r();
  for (; ; )
    try {
      if (parseInt(e(304)) / 1 * (parseInt(e(311)) / 2) + -parseInt(e(310)) / 3 * (-parseInt(e(318)) / 4) + parseInt(e(305)) / 5 * (parseInt(e(324)) / 6) + parseInt(e(303)) / 7 * (parseInt(e(321)) / 8) + parseInt(e(319)) / 9 + parseInt(e(316)) / 10 * (-parseInt(e(320)) / 11) + parseInt(e(315)) / 12 * (-parseInt(e(317)) / 13) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ey, 788018);
function ey() {
  const r = ["spacing", "offset", "pattern", "angle", "3taOLwI", "70TyknWQ", "color", "size", "ratio", "42564660YeeEyV", "890OjfXVX", "13rVjmKG", "4157536ZqEGdc", "12871035KXWYgL", "11748AFCnXj", "1269096VZHWvs", "scale", "fill", "6pWewem", "35UcgQvL", "26948AeAsjm", "1121305CJITIH"];
  return ey = function() {
    return r;
  }, ey();
}
function lk(r) {
  const t = ty;
  return new En({ fill: new ex({ pattern: r[t(308)], ratio: r[t(314)] || 1, color: r[t(312)], offset: r[t(307)] || 0, scale: r[t(322)] || 1, fill: new Hr({ color: r[t(323)] }), size: r[t(313)], spacing: r[t(306)], angle: r[t(309)] }) });
}
const rm = ry;
(function(r, t) {
  const e = ry, n = r();
  for (; ; )
    try {
      if (-parseInt(e(131)) / 1 * (-parseInt(e(135)) / 2) + -parseInt(e(123)) / 3 * (parseInt(e(133)) / 4) + parseInt(e(128)) / 5 * (-parseInt(e(124)) / 6) + -parseInt(e(129)) / 7 * (-parseInt(e(136)) / 8) + -parseInt(e(132)) / 9 * (-parseInt(e(130)) / 10) + -parseInt(e(122)) / 11 + -parseInt(e(121)) / 12 * (-parseInt(e(134)) / 13) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ny, 191765);
function ny() {
  const r = ["getCme_FILLAREA_1101_2_4", "getCme_Style", "getCme_FILLAREA_1101_2_5", "360geAbtr", "1371433SczrEG", "190MTfyuf", "13Qgiixt", "118737RbTmPT", "461424EjFtEr", "3913RGWkMp", "21936GpdFEp", "8ZsYffQ", "10596FVPLrm", "3283984IUlvSp", "9JdezER", "1548NUDjpe"];
  return ny = function() {
    return r;
  }, ny();
}
function ry(r, t) {
  const e = ny();
  return ry = function(n, i) {
    return n = n - 121, e[n];
  }, ry(r, t);
}
var hk = class {
  constructor(t) {
  }
  [rm(126)](t) {
    return Is(t);
  }
  [rm(127)](t) {
    return fk(t);
  }
  [rm(125)](t) {
    return lk(t);
  }
}, pk = sy;
(function(r, t) {
  for (var e = sy, n = r(); ; )
    try {
      var i = parseInt(e(340)) / 1 * (parseInt(e(349)) / 2) + parseInt(e(346)) / 3 + parseInt(e(343)) / 4 + parseInt(e(350)) / 5 * (parseInt(e(348)) / 6) + parseInt(e(345)) / 7 + -parseInt(e(351)) / 8 * (-parseInt(e(342)) / 9) + -parseInt(e(347)) / 10 * (parseInt(e(344)) / 11);
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(iy, 159249);
function iy() {
  var r = ["10ykrPHC", "16hAecQa", "39gffqzM", "getCme_Style", "309006ynfUwZ", "119912jynLLX", "11fZRVKn", "1051127FnJJQF", "107652zIyrMH", "3321440eSXIYq", "82374pWPgJK", "9192fOgpNl"];
  return iy = function() {
    return r;
  }, iy();
}
function sy(r, t) {
  var e = iy();
  return sy = function(n, i) {
    n = n - 340;
    var s = e[n];
    return s;
  }, sy(r, t);
}
var dk = class {
  constructor(t) {
  }
  [pk(341)](t) {
    return Is(t);
  }
};
function oy(r, t) {
  var e = ay();
  return oy = function(n, i) {
    n = n - 450;
    var s = e[n];
    return s;
  }, oy(r, t);
}
(function(r, t) {
  for (var e = oy, n = r(); ; )
    try {
      var i = parseInt(e(453)) / 1 + -parseInt(e(450)) / 2 * (parseInt(e(454)) / 3) + -parseInt(e(459)) / 4 + -parseInt(e(452)) / 5 * (-parseInt(e(456)) / 6) + parseInt(e(461)) / 7 * (-parseInt(e(457)) / 8) + -parseInt(e(462)) / 9 * (parseInt(e(458)) / 10) + parseInt(e(460)) / 11;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(ay, 395805);
class gk extends Oo {
  constructor(t, e, n) {
    var i = oy;
    super(t), this[i(455)] = e, this[i(451)] = n !== void 0 ? n : null;
  }
}
function ay() {
  var r = ["1929712jzlBio", "11777997tlteRL", "511tOvZuv", "45UOxdsJ", "52JwJKXK", "frameState", "774590RjAflU", "620107cFjUjK", "77556qwgHsK", "map", "18LTRrXE", "58528vacsBS", "142270mYpAGf"];
  return ay = function() {
    return r;
  }, ay();
}
var Uo = $x;
function uy() {
  var r = ["6EZYusy", "getEventPixel", "pixel_", "8XgoyhU", "818274VGKXXm", "1417244nElnFm", "activePointers", "stopPropagation", "coordinate", "350mBsJGQ", "9036800xLfCVO", "dragging", "map", "4299001EVUCZg", "4700934ftyaem", "originalEvent", "coordinate_", "3365480qGUcVx", "pixel", "3303OiFlKZ", "getCoordinateFromPixel", "preventDefault"];
  return uy = function() {
    return r;
  }, uy();
}
(function(r, t) {
  for (var e = $x, n = r(); ; )
    try {
      var i = parseInt(e(154)) / 1 * (parseInt(e(144)) / 2) + -parseInt(e(139)) / 3 + parseInt(e(140)) / 4 + -parseInt(e(152)) / 5 * (parseInt(e(135)) / 6) + -parseInt(e(148)) / 7 + -parseInt(e(138)) / 8 * (-parseInt(e(149)) / 9) + parseInt(e(145)) / 10;
      if (i === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(uy, 798345);
class yk extends gk {
  constructor(t, e, n, i, s, o) {
    var a = $x;
    super(t, e, s), this[a(150)] = n, this.pixel_ = null, this[a(151)] = null, this[a(146)] = i !== void 0 ? i : !1, this[a(141)] = o;
  }
  get pixel() {
    var t = $x;
    return !this.pixel_ && (this.pixel_ = this[t(147)][t(136)](this[t(150)])), this[t(137)];
  }
  set [Uo(153)](t) {
    var e = Uo;
    this[e(137)] = t;
  }
  get [Uo(143)]() {
    var t = Uo;
    return !this[t(151)] && (this[t(151)] = this[t(147)][t(155)](this[t(153)])), this[t(151)];
  }
  set [Uo(143)](t) {
    var e = Uo;
    this[e(151)] = t;
  }
  [Uo(156)]() {
    var t = Uo;
    super[t(156)](), t(156) in this[t(150)] && this.originalEvent.preventDefault();
  }
  stopPropagation() {
    var t = Uo;
    super[t(142)](), t(142) in this[t(150)] && this[t(150)][t(142)]();
  }
}
function $x(r, t) {
  var e = uy();
  return $x = function(n, i) {
    n = n - 135;
    var s = e[n];
    return s;
  }, $x(r, t);
}
function vk() {
  let r = new vy();
  return new Bl({
    // 设置图层名称为eidtSource
    layerName: "eidtSource",
    //必填值，而且是唯一值
    // 设置图层源为source.value
    source: r,
    // 设置图层样式
    style: new En({
      // 设置填充样式
      fill: new Hr({
        // 设置填充颜色为蓝色
        color: "rgba(0, 0, 255, 0.2)"
      }),
      // 设置描边样式
      stroke: new ys({
        // 设置描边颜色为红色
        color: "#ff0000",
        // 设置描边宽度为2
        width: 2
      }),
      // 设置图片样式
      image: new x0({
        // 设置图片半径为7
        radius: 7,
        // 设置图片填充颜色为黄色
        fill: new Hr({
          color: "#ffcc33"
        })
      })
    })
  });
}
function mk(r, t, e, n) {
  var i = r - e, s = t - n;
  return Math.atan2(i, s);
}
let Bs = {
  SYMBOLS_70: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_69: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_1601: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_1611: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_373: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_61: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_60: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_63: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_62: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_26: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_64: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_221: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_55: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_25: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_47: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_231: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_28: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_27: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_23: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_65: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_24: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_22: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_21: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_66: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_51: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_50: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_52: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_32: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_31: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_201: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_44: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_46: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_211: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_45: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_102: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          // "form": "",
          radius: 20,
          rotation: 0
          // "displacement": [
          //     0,
          //     0
          // ],
          // "color": "#ff0000",
          // "fill": {
          //     "Fill": {
          //         "color": "rgba(0,255,0,1)"
          //     }
          // },
          // "stroke": {
          //     "Stroke": {
          //         "color": "rgba(255,255,0,1)",
          //         "width": 1
          //     }
          // }
        }
        // "fill": {
        //     "Fill": {
        //         "color": "rgba(0,255,0,1)"
        //     }
        // },
        // "stroke": {
        //     "Stroke": {
        //         "color": "rgba(255,255,0,1)",
        //         "width": 1
        //     }
        // }
      }
    }
  },
  SYMBOLS_101: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_40: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_43: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_34: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_35: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_41: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_33: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_36: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_39: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_103: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_42: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_161: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_160: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_29: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_30: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_151: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_155: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_153: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_154: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_156: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_152: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_150: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_37: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_371: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_162: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_163: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  },
  SYMBOLS_372: {
    Style: {
      image: {
        cme_style_FontSymbol: {
          glyph: "",
          form: "",
          radius: 20,
          rotation: 0,
          displacement: [
            0,
            0
          ],
          color: "#ff0000",
          fill: {
            Fill: {
              color: "rgba(0,255,0,1)"
            }
          },
          stroke: {
            Stroke: {
              color: "rgba(255,255,0,1)",
              width: 1
            }
          }
        },
        fill: {
          Fill: {
            color: "rgba(0,255,0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "rgba(255,255,0,1)",
            width: 1
          }
        }
      }
    }
  }
}, z3 = {
  linesym_width: "width"
  // linesym_width
  // "stroke": {
  //     "Stroke": {
  //     //   "color": "red",
  //       "width": "linesym_width",
  //     //   "lineDash": [
  //     //     5,
  //     //     10,
  //     //     25
  //     //   ]
  //     }
  //   } 
}, Nh = {
  linesym_width: "width"
}, U3 = {
  // "linesym_width": "width",
  fillarea_color: "fillColor",
  fillarea_backcolor: "fill",
  fillarea_gradient_angle: "angle"
}, V3 = {
  // "linesym_width": "width",
  // "nsymbol_code": 48,
  // "nsymbol_charLen": 5,
  nsymbol_char: "text",
  nsymbol_angle: "rotation",
  //"0",
  // "nsymbol_fontLen": "10",
  nsymbol_fontName: "font",
  //simhei.ttf",
  // "nsymbol_fontSize": "16",
  // "nsymbol_fontType": "1",
  nsymbol_color: "color"
  //  [
  //   255,
  //   0,
  //   124,
  //   255
  // ]
  // "nsymbol_code": 48,
  // "nsymbol_charLen": 5,
  // "nsymbol_char": "STNRY",
  // "nsymbol_angle": "0",
  // "nsymbol_fontLen": "10",
  // "nsymbol_fontName": "simhei.ttf",
  // "nsymbol_fontSize": "16",
  // "nsymbol_fontType": "1",
  // "nsymbol_color": [
  //   255,
  //   0,
  //   124,
  //   255
  // ]
};
function mo(r, t, e) {
  return _k(r, (n, i) => {
    for (let s in t)
      if (t.hasOwnProperty(s) && t[s] == n && e.getProperties()[s])
        return e.getProperties()[s];
    return i;
  }), r;
}
function _k(r, t) {
  function e(i) {
    return i && typeof i == "object" && !Array.isArray(i);
  }
  function n(i) {
    for (const s in i)
      if (i.hasOwnProperty(s)) {
        const o = i[s];
        e(o) ? n(o) : i[s] = t(s, o);
      }
  }
  n(r);
}
class bk {
  constructor() {
  }
  getCommonStyle(t) {
    return {
      Style: {
        image: {
          cme_style_FontSymbol: {
            // font: 'sans-serif',
            glyph: t,
            //符号的名称
            form: "",
            //外边框的样式
            /**form 对应的边框类型
                         *  circle  poi  bubble  marker  coma
                         shield  blazon  bookmark  hexagon  diamond  triangle  sign
                         ban  lozenge  square
                         * */
            //  fontStyle:"italic", //
            /**fontStyle 对应的类型
             *   unset
             *  bold
             *  italic
             * bold italic//样式
             */
            radius: 20,
            //大小
            //  rotation: 2,//Number($("#rotation").val())*Math.PI/180,//旋转角度
            //这个和offsetY  offsetX二选一，都是偏移量的参数，根据自己的需要去配置
            displacement: [0, 0],
            //像素位置偏移量  包含 x  y两个方向
            //  offsetY: 10,
            //  offsetX: 10,
            color: "#ff0000",
            //符号的颜色
            /**
             * 以下是字体符号的背景色和边框颜色
             *  其中fill是背景颜色  stroke是边框颜色，具体的可以查看ol的样式
             */
            fill: {
              Fill: {
                //符号背景色
                color: "rgba(0,255,0,1)"
              }
            },
            stroke: {
              Stroke: {
                color: "rgba(255,255,0,1)",
                width: 1
              }
            },
            /**
             * 以下是form背景色和边框颜色
             * 其中fill是背景颜色  stroke是边框颜色，具体的可以查看ol的样式
             */
            fill: {
              Fill: {
                //符号背景色
                color: "rgba(255,255,0,0)"
              }
            },
            stroke: {
              Stroke: {
                color: "rgba(0,0,255,0)",
                width: 1
              }
            }
          }
        }
      }
    };
  }
  getStyle(t, e = null) {
    if (Bs[t])
      return Bs[t].Style.image.cme_style_FontSymbol.glyph = t, e != null && (Bs[t] = mo(Bs[t], Nh, e)), Bs[t];
    {
      let n = this.getCommonStyle(t);
      return e != null && (n = mo(n, Nh, e)), n;
    }
  }
  /**
   * 获取指定字形的风格。 风羽图的样式
   *
   * @param {string} theGlyph - 要获取风格的字形。
   * @return {object} 给定字形的风格对象。
   */
  getWindyStyle(t, e, n) {
    debugger;
    if (Bs[t])
      return Bs[t].Style.image.cme_style_FontSymbol.glyph = t, Bs[t].Style.image.cme_style_FontSymbol.rotation = e, n != null && (Bs[t] = mo(Bs[t], Nh, n)), Bs[t];
    {
      let i = this.getCommonStyle(t);
      return n != null && (i = mo(i, Nh, n)), i;
    }
  }
}
class P6 {
  constructor() {
    this.commonPoint = new bk(), this.cme_Point = new ck();
  }
  /**
   * 将给定的字体样式添加到字体图形中，并返回更新后的字体符号。
   *
   * @param {Object} fontStyle - 要添加的字体样式。它应该有一个 'font' 属性和一个 'glyphs' 属性。
   * @return {Object} 添加字体样式后更新的字体符号。
   */
  getFontGraph(t) {
    cs.addDefs(
      t.font,
      t.glyphs
    );
    var e = cs.defs.glyphs;
    return console.log("glyph"), console.log(JSON.stringify(e)), cs;
  }
  /**
   * 根据给定的字体样式，将其添加到字体图形中，并返回更新后的字体符号。  主要是绘制风向杆的功能
   *
   * @param {Object} fontStyle - 要添加的字体样式。它应该包含 'font' 和 'glyphs' 属性。
   * @return {Object} 添加字体样式后更新的字体符号。
   */
  setWindStyle(t, e) {
    let n = t.getGeometry().getCoordinates();
    const i = mk(
      n[0][0],
      n[0][1],
      n[1][0],
      n[1][1]
    );
    let s = this.commonPoint.getWindyStyle(e, i, t);
    t.setProperties({
      customStyle: s
    });
    let o = this.getwindyStyleByJSON(s), a = new An({
      geometry: new tr([n[0][0], n[0][1]])
      // 设置点的经纬度坐标
    });
    return a.setStyle(o), a;
  }
  /**
   * 根据提供的样式JSON获取样式。
   *
   * @param {Object} styleJSON - 包含样式信息的样式JSON对象。
   * @return {Array} 根据提供的样式JSON获取的样式数组。
   */
  getwindyStyleByJSON(t) {
    console.log("styleJSON"), console.log(JSON.stringify(t));
    debugger;
    var e = [];
    let n = this.cme_Point.getCme_Style(t);
    return console.log(n), e.push(n), e;
  }
  /**
   * 设置给定字形的样式  通用的格式
   *
   * @param {Object} styleJSON - 样式JSON对象，样式的详细信息可以查看ol-json-style的文档
   * @return {Array} 返回样式数组，因为fontSymbol可能使用多个样式，所以返回的是一个数组，里面包含样式对象
   */
  setStyle(t, e) {
    let n = this.commonPoint.getStyle(e);
    t.setProperties({
      customStyle: n
    });
    var i = [];
    let s = this.cme_Point.getCme_Style(n);
    i.push(s), t.setStyle(i);
  }
}
const at = Al;
(function(r, t) {
  const e = Al, n = r();
  for (; ; )
    try {
      if (-parseInt(e(223)) / 1 * (-parseInt(e(273)) / 2) + parseInt(e(293)) / 3 * (parseInt(e(300)) / 4) + parseInt(e(208)) / 5 * (parseInt(e(173)) / 6) + parseInt(e(158)) / 7 + -parseInt(e(194)) / 8 + parseInt(e(306)) / 9 + -parseInt(e(188)) / 10 === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(xy, 594738);
function xy() {
  const r = ["trace", "DRAWSTART", "condition", "finishCondition", "getLinearRing", "stopClick_", "snapTolerance_", "originalEvent", "finishDrawing", "style", "77694QdiEuT", "setFlatCoordinates", "setGeometry", "source_", "createOrUpdateSketchPoint_", "updateSketchFeatures_", "sketchLineCoords_", "map", "Polygon", "feature", "sketchFeature_", "freehandCondition", "downPx_", "overlay_", "toggleTraceState_", "21606770adKJjJ", "getLayout", "abortDrawing", "getFlatCoordinates", "once", "targetIndex", "5312816tTlQHz", "geometryFunction_", "createOrUpdateCustomSketchLine_", "getPointerCount", "DBLCLICK", "geometryLayout", "drawabort", "minPoints_", "geometryName_", "getSource", "sketchPoint_", "getOverlay", "Circle", "removeLastPoint", "255MHMfqN", "traceSource_", "endIndex", "deactivateTrace_", "MultiPoint", "extend", "POINTERMOVE", "Point", "POINTERDRAG", "freehand", "round", "getProjection", "startPx", "pointerType", "updateTrace_", "9KGgGJj", "finishCondition_", "shouldHandle_", "mouse", "getGeometry", "LineString", "setMap", "minPoints", "setCoordinates", "type_", "sketchCoords_", "clickTolerance", "getType", "transform", "type", "features_", "freehand_", "ring", "removeLastPoints_", "slice", "floor", "startIndex", "pointerType_", "handleDownEvent", "geometryFunction", "clear", "coordinates", "pixel", "addFeature", "setTrace", "wrapX", "sqrt", "stopDown", "mode_", "splice", "drawend", "geometryLayout_", "getActive", "preventDefault", "traceCondition_", "stopClick", "getPixelFromCoordinate", "features", "ceil", "active", "downTimeout_", "MultiLineString", "POINTERDOWN", "length", "traceState_", "128788AyIlvm", "abortDrawing_", "finishCoordinate_", "handleEvent", "frameState", "lastDragTime_", "targets", "addOrRemoveTracedCoordinates_", "setCenterAndRadius", "setGeometryName", "getCoordinates", "removeTracedCoordinates_", "getGeometries", "dispatchEvent", "addToDrawing_", "push", "startDrawing_", "getView", "condition_", "MultiPolygon", "508743KKptMN", "dragVertexDelay", "getCoordinateFromPixel", "addTracedCoordinates_", "maxPoints", "getMap", "updateState_", "20ovofyL", "addChangeListener", "along", "CONTEXTMENU", "atFinish_", "traceSource", "5443839xbhBtz", "appendCoordinates", "coordinate", "now", "pop", "source", "handlePointerMove_", "squaredClickTolerance_", "5087572sWpQDc", "freehandCondition_", "ACTIVE", "dragVertexDelay_", "sketchLine_"];
  return xy = function() {
    return r;
  }, xy();
}
const Oh = { DRAWSTART: "drawstart", DRAWEND: at(258), DRAWABORT: at(200) };
class Rh extends Oo {
  constructor(t, e) {
    const n = at;
    super(t), this[n(182)] = e;
  }
}
function Ik(r, t) {
  const e = at, n = [];
  for (let i = 0; i < t[e(271)]; ++i) {
    const s = t[i], o = s[e(227)]();
    L6(r, o, n);
  }
  return n;
}
function Ah(r, t) {
  return $o(r[0], r[1], t[0], t[1]);
}
function Hu(r, t) {
  const e = at, n = r[e(271)];
  return t < 0 ? r[t + n] : t >= n ? r[t - n] : r[t];
}
function Th(r, t, e) {
  const n = at;
  let i, s;
  t < e ? (i = t, s = e) : (i = e, s = t);
  const o = Math.ceil(i), a = Math[n(243)](s);
  if (o > a) {
    const x = Ju(r, i), c = Ju(r, s);
    return Ah(x, c);
  }
  let u = 0;
  if (i < o) {
    const x = Ju(r, i), c = Hu(r, o);
    u += Ah(x, c);
  }
  if (a < s) {
    const x = Hu(r, a), c = Ju(r, s);
    u += Ah(x, c);
  }
  for (let x = o; x < a - 1; ++x) {
    const c = Hu(r, x), f = Hu(r, x + 1);
    u += Ah(c, f);
  }
  return u;
}
function L6(r, t, e) {
  const n = at;
  if (t instanceof Ku) {
    Dh(r, t[n(283)](), !1, e);
    return;
  }
  if (t instanceof M4) {
    const i = t.getCoordinates();
    for (let s = 0, o = i[n(271)]; s < o; ++s)
      Dh(r, i[s], !1, e);
    return;
  }
  if (t instanceof F0) {
    const i = t[n(283)]();
    for (let s = 0, o = i.length; s < o; ++s)
      Dh(r, i[s], !0, e);
    return;
  }
  if (t instanceof T4) {
    const i = t[n(283)]();
    for (let s = 0, o = i[n(271)]; s < o; ++s) {
      const a = i[s];
      for (let u = 0, x = a[n(271)]; u < x; ++u)
        Dh(r, a[u], !0, e);
    }
    return;
  }
  if (t instanceof U8) {
    const i = t[n(285)]();
    for (let s = 0; s < i[n(271)]; ++s)
      L6(r, i[s], e);
    return;
  }
}
const im = { index: -1, endIndex: NaN };
function wk(r, t, e, n) {
  const i = at, s = r[0], o = r[1];
  let a = 1 / 0, u = -1, x = NaN;
  for (let l = 0; l < t[i(279)][i(271)]; ++l) {
    const h = t[i(279)][l], p = h[i(249)];
    let y = 1 / 0, v;
    for (let m = 0; m < p[i(271)] - 1; ++m) {
      const d = p[m], g = p[m + 1], _ = N6(s, o, d, g);
      _.squaredDistance < y && (y = _.squaredDistance, v = m + _[i(302)]);
    }
    y < a && (a = y, h[i(240)] && t[i(193)] === l && (h[i(210)] > h[i(244)] ? v < h[i(244)] && (v += p[i(271)]) : h[i(210)] < h[i(244)] && v > h[i(244)] && (v -= p.length)), x = v, u = l);
  }
  const c = t.targets[u];
  let f = c[i(240)];
  if (t.targetIndex === u && f) {
    const l = Ju(c[i(249)], x), h = e.getPixelFromCoordinate(l);
    A1(h, t[i(220)]) > n && (f = !1);
  }
  if (f) {
    const l = c[i(249)], h = l[i(271)], p = c.startIndex, y = x;
    if (p < y) {
      const v = Th(l, p, y);
      Th(l, p, y - h) < v && (x -= h);
    } else {
      const v = Th(l, p, y);
      Th(l, p, y + h) < v && (x += h);
    }
  }
  return im.index = u, im[i(210)] = x, im;
}
function Dh(r, t, e, n) {
  const i = at, s = r[0], o = r[1];
  for (let a = 0, u = t[i(271)] - 1; a < u; ++a) {
    const x = t[a], c = t[a + 1], f = N6(s, o, x, c);
    if (f.squaredDistance === 0) {
      const l = a + f[i(302)];
      n[i(288)]({ coordinates: t, ring: e, startIndex: l, endIndex: l });
      return;
    }
  }
}
const sm = { along: 0, squaredDistance: 0 };
function N6(r, t, e, n) {
  const i = at, s = e[0], o = e[1], a = n[0], u = n[1], x = a - s, c = u - o;
  let f = 0, l = s, h = o;
  return (x !== 0 || c !== 0) && (f = Tr(((r - s) * x + (t - o) * c) / (x * x + c * c), 0, 1), l += x * f, h += c * f), sm[i(302)] = f, sm.squaredDistance = h4($o(r, t, l, h), 10), sm;
}
function Ju(r, t) {
  const e = at, n = r[e(271)];
  let i = Math[e(243)](t);
  const s = t - i;
  i >= n ? i -= n : i < 0 && (i += n);
  let o = i + 1;
  o >= n && (o -= n);
  const a = r[i], u = a[0], x = a[1], c = r[o], f = c[0] - u, l = c[1] - x;
  return [u + f * s, x + l * s];
}
function Al(r, t) {
  const e = xy();
  return Al = function(n, i) {
    return n = n - 155, e[n];
  }, Al(r, t);
}
class W3 extends Iy {
  constructor(t) {
    const e = at, n = t;
    !n[e(255)] && (n[e(255)] = x_), super(n), this.on, this[e(192)], this.un, this.shouldHandle_ = !1, this[e(185)] = null, this[e(268)], this[e(278)], this.pointerType_, this.freehand_ = !1, this[e(176)] = t[e(155)] ? t[e(155)] : null, this[e(238)] = t.features ? t[e(265)] : null, this[e(169)] = t.snapTolerance ? t.snapTolerance : 12, this[e(232)] = t[e(237)], this[e(256)] = Sk(this[e(232)]), this[e(168)] = !!t[e(263)], this.minPoints_ = t.minPoints ? t[e(230)] : this[e(256)] === e(181) ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : t[e(297)] ? t[e(297)] : 1 / 0, this.finishCondition_ = t.finishCondition ? t[e(166)] : ix, this[e(259)] = t[e(199)] ? t[e(199)] : "XY";
    let i = t[e(247)];
    if (!i) {
      const s = this.mode_;
      if (s === "Circle") i = (o, a, u) => {
        const x = e, c = a || new m4([NaN, NaN]), f = cn(o[0]), l = ta(f, cn(o[o[x(271)] - 1]));
        return c[x(281)](f, Math[x(254)](l), this[x(259)]), c;
      };
      else {
        let o;
        s === "Point" ? o = tr : s === "LineString" ? o = Ku : s === e(181) && (o = F0), i = (a, u, x) => {
          const c = e;
          return u ? s === c(181) ? a[0][c(271)] ? u[c(231)]([a[0].concat([a[0][0]])], this[c(259)]) : u[c(231)]([], this.geometryLayout_) : u[c(231)](a, this[c(259)]) : u = new o(a, this[c(259)]), u;
        };
      }
    }
    this[e(195)] = i, this[e(161)] = t[e(294)] !== void 0 ? t.dragVertexDelay : 500, this[e(275)] = null, this[e(183)] = null, this.sketchPoint_ = null, this[e(233)] = null, this[e(162)] = null, this[e(179)] = null, this[e(157)] = t[e(234)] ? t[e(234)] * t.clickTolerance : 36, this[e(186)] = new Bl({ source: new vy({ useSpatialIndex: !1, wrapX: t[e(253)] ? t[e(253)] : !1 }), style: t[e(172)] ? t[e(172)] : Ek(), updateWhileInteracting: !0 }), this[e(202)] = t.geometryName, this[e(291)] = t.condition ? t[e(165)] : gC, this[e(159)], t[e(217)] ? this[e(159)] = Rm : this.freehandCondition_ = t[e(184)] ? t[e(184)] : k_, this[e(262)], this[e(252)](t[e(163)] || !1), this[e(272)] = { active: !1 }, this[e(209)] = t[e(305)] || t[e(155)] || null, this[e(301)](am[e(160)], this[e(299)]);
  }
  [at(252)](t) {
    const e = at;
    let n;
    t ? t === !0 ? n = Rm : n = t : n = Am, this[e(262)] = n;
  }
  [at(229)](t) {
    const e = at;
    super[e(229)](t), this[e(299)]();
  }
  [at(205)]() {
    return this[at(186)];
  }
  [at(276)](t) {
    const e = at;
    t[e(170)][e(237)] === rr[e(303)] && t[e(170)][e(261)](), this[e(239)] = this[e(256)] !== e(215) && this.freehandCondition_(t);
    let n = t[e(237)] === Or.POINTERMOVE, i = !0;
    return !this[e(239)] && this.lastDragTime_ && t[e(237)] === Or[e(216)] && (Date[e(309)]() - this[e(278)] >= this.dragVertexDelay_ ? (this[e(185)] = t[e(250)], this[e(225)] = !this[e(239)], n = !0) : this[e(278)] = void 0, this[e(225)] && this.downTimeout_ !== void 0 && (clearTimeout(this[e(268)]), this[e(268)] = void 0)), this[e(239)] && t[e(237)] === Or[e(216)] && this[e(183)] !== null ? (this[e(287)](t[e(308)]), i = !1) : this[e(239)] && t[e(237)] === Or[e(270)] ? i = !1 : n && this[e(197)]() < 2 ? (i = t[e(237)] === Or[e(214)], i && this[e(239)] ? (this[e(156)](t), this[e(225)] && t[e(170)][e(261)]()) : (t.originalEvent[e(221)] === e(226) || t[e(237)] === Or.POINTERDRAG && this[e(268)] === void 0) && this.handlePointerMove_(t)) : t[e(237)] === Or[e(198)] && (i = !1), super[e(276)](t) && i;
  }
  [at(246)](t) {
    const e = at;
    return this[e(225)] = !this.freehand_, this[e(239)] ? (this[e(185)] = t[e(250)], !this[e(275)] && this.startDrawing_(t[e(308)]), !0) : this[e(291)](t) ? (this.lastDragTime_ = Date[e(309)](), this[e(268)] = setTimeout(() => {
      const n = e;
      this[n(156)](new yk(Or.POINTERMOVE, t[n(180)], t[n(170)], !1, t[n(277)]));
    }, this[e(161)]), this[e(185)] = t[e(250)], !0) : (this.lastDragTime_ = void 0, !1);
  }
  deactivateTrace_() {
    const t = at;
    this[t(272)] = { active: !1 };
  }
  [at(187)](t) {
    const e = at;
    if (!this[e(209)] || !this[e(262)](t)) return;
    if (this[e(272)][e(267)]) {
      this[e(211)]();
      return;
    }
    const n = this[e(298)](), i = n[e(295)]([t[e(250)][0] - this[e(169)], t.pixel[1] + this[e(169)]]), s = n[e(295)]([t[e(250)][0] + this[e(169)], t[e(250)][1] - this[e(169)]]), o = di([i, s]), a = this[e(209)].getFeaturesInExtent(o);
    if (a[e(271)] === 0) return;
    const u = Ik(t[e(308)], a);
    u[e(271)] && (this[e(272)] = { active: !0, startPx: t[e(250)].slice(), targets: u, targetIndex: -1 });
  }
  [at(280)](t, e) {
    const n = at, i = t[n(244)] <= t[n(210)], s = t[n(244)] <= e;
    i === s ? i && e > t[n(210)] || !i && e < t[n(210)] ? this.addTracedCoordinates_(t, t[n(210)], e) : (i && e < t[n(210)] || !i && e > t[n(210)]) && this[n(284)](e, t.endIndex) : (this[n(284)](t[n(244)], t[n(210)]), this[n(296)](t, t[n(244)], e));
  }
  [at(284)](t, e) {
    const n = at;
    if (t === e) return;
    let i = 0;
    if (t < e) {
      const s = Math[n(266)](t);
      let o = Math[n(243)](e);
      o === e && (o -= 1), i = o - s + 1;
    } else {
      const s = Math.floor(t);
      let o = Math.ceil(e);
      o === e && (o += 1), i = s - o + 1;
    }
    i > 0 && this[n(241)](i);
  }
  [at(296)](t, e, n) {
    const i = at;
    if (e === n) return;
    const s = [];
    if (e < n) {
      const o = Math.ceil(e);
      let a = Math[i(243)](n);
      a === n && (a -= 1);
      for (let u = o; u <= a; ++u)
        s[i(288)](Hu(t.coordinates, u));
    } else {
      const o = Math[i(243)](e);
      let a = Math[i(266)](n);
      a === n && (a += 1);
      for (let u = o; u >= a; --u)
        s.push(Hu(t[i(249)], u));
    }
    s[i(271)] && this[i(307)](s);
  }
  [at(222)](t) {
    const e = at, n = this[e(272)];
    if (!n[e(267)] || n[e(193)] === -1 && A1(n.startPx, t[e(250)]) < this[e(169)])
      return;
    const i = wk(t[e(308)], n, this[e(298)](), this[e(169)]);
    if (n[e(193)] !== i.index) {
      if (n[e(193)] !== -1) {
        const x = n[e(279)][n[e(193)]];
        this[e(284)](x[e(244)], x[e(210)]);
      }
      const u = n[e(279)][i.index];
      this[e(296)](u, u[e(244)], i[e(210)]);
    } else {
      const u = n[e(279)][n[e(193)]];
      this.addOrRemoveTracedCoordinates_(u, i[e(210)]);
    }
    n[e(193)] = i.index;
    const s = n[e(279)][n[e(193)]];
    s[e(210)] = i[e(210)];
    const o = Ju(s[e(249)], s[e(210)]), a = this[e(298)]().getPixelFromCoordinate(o);
    t[e(308)] = o, t[e(250)] = [Math[e(218)](a[0]), Math[e(218)](a[1])];
  }
  handleUpEvent(t) {
    const e = at;
    let n = !0;
    if (this[e(197)]() === 0) {
      this[e(268)] && (clearTimeout(this[e(268)]), this.downTimeout_ = void 0), this[e(156)](t);
      const i = this[e(272)][e(267)];
      if (this[e(187)](t), this[e(225)]) {
        const s = !this.finishCoordinate_;
        s && this[e(289)](t[e(308)]), !s && this.freehand_ ? this[e(171)]() : !this[e(239)] && (!s || this[e(256)] === e(215)) && (this[e(304)](t[e(250)], i) ? this[e(224)](t) && this.finishDrawing() : this[e(287)](t[e(308)])), n = !1;
      } else this.freehand_ && this[e(190)]();
    }
    return !n && this[e(168)] && t[e(261)](), n;
  }
  [at(156)](t) {
    const e = at;
    if (this[e(245)] = t[e(170)].pointerType, this[e(185)] && (!this[e(239)] && this[e(225)] || this[e(239)] && !this.shouldHandle_)) {
      const n = this[e(185)], i = t[e(250)], s = n[0] - i[0], o = n[1] - i[1], a = s * s + o * o;
      if (this.shouldHandle_ = this.freehand_ ? a > this[e(157)] : a <= this[e(157)], !this[e(225)]) return;
    }
    if (!this[e(275)]) {
      this[e(177)](t[e(308)].slice());
      return;
    }
    this[e(222)](t), this.modifyDrawing_(t.coordinate);
  }
  [at(304)](t, e) {
    const n = at;
    let i = !1;
    if (this[n(183)]) {
      let s = !1, o = [this.finishCoordinate_];
      const a = this[n(256)];
      if (a === n(215)) i = !0;
      else if (a === "Circle") i = this[n(233)][n(271)] === 2;
      else if (a === n(228)) s = !e && this[n(233)][n(271)] > this[n(201)];
      else if (a === n(181)) {
        const u = this[n(233)];
        s = u[0][n(271)] > this[n(201)], o = [u[0][0], u[0][u[0].length - 2]], e ? o = [u[0][0]] : o = [u[0][0], u[0][u[0].length - 2]];
      }
      if (s) {
        const u = this[n(298)]();
        for (let x = 0, c = o[n(271)]; x < c; x++) {
          const f = o[x], l = u[n(264)](f), h = t[0] - l[0], p = t[1] - l[1], y = this[n(239)] ? 1 : this[n(169)];
          if (i = Math[n(254)](h * h + p * p) <= y, i) {
            this[n(275)] = f;
            break;
          }
        }
      }
    }
    return i;
  }
  createOrUpdateSketchPoint_(t) {
    const e = at;
    this[e(204)] ? this[e(204)][e(227)]()[e(231)](t) : (this[e(204)] = new An(new tr(t)), this[e(178)]());
  }
  [at(196)](t) {
    const e = at;
    !this[e(162)] && (this[e(162)] = new An());
    const n = t[e(167)](0);
    let i = this[e(162)][e(227)]();
    i ? (i[e(174)](n.getLayout(), n[e(191)]()), i.changed()) : (i = new Ku(n[e(191)](), n[e(189)]()), this[e(162)][e(175)](i));
  }
  [at(289)](t) {
    const e = at, n = this[e(298)]()[e(290)]()[e(219)](), i = Y1(this[e(259)]);
    for (; t.length < i; )
      t[e(288)](0);
    this[e(275)] = t, this[e(256)] === e(215) ? this[e(233)] = t[e(242)]() : this[e(256)] === e(181) ? (this[e(233)] = [[t[e(242)](), t[e(242)]()]], this[e(179)] = this.sketchCoords_[0]) : this[e(233)] = [t[e(242)](), t[e(242)]()], this[e(179)] && (this[e(162)] = new An(new Ku(this[e(179)])));
    const s = this.geometryFunction_(this[e(233)], void 0, n);
    this[e(183)] = new An(), this[e(202)] && this[e(183)][e(282)](this[e(202)]), this[e(183)].setGeometry(s), this[e(178)](), this[e(286)](new Rh(Oh[e(164)], this[e(183)]));
  }
  modifyDrawing_(t) {
    const e = at, n = this[e(298)](), i = this.sketchFeature_.getGeometry(), s = n[e(290)]()[e(219)](), o = Y1(this.geometryLayout_);
    let a, u;
    for (; t.length < o; )
      t[e(288)](0);
    this[e(256)] === e(215) ? u = this[e(233)] : this[e(256)] === e(181) ? (a = this[e(233)][0], u = a[a[e(271)] - 1], this.atFinish_(n[e(264)](t)) && (t = this[e(275)].slice())) : (a = this.sketchCoords_, u = a[a[e(271)] - 1]), u[0] = t[0], u[1] = t[1], this[e(195)](this.sketchCoords_, i, s), this[e(204)] && this.sketchPoint_[e(227)]().setCoordinates(t), i[e(235)]() === e(181) && this[e(256)] !== e(181) ? this[e(196)](i) : this[e(179)] && this.sketchLine_[e(227)]()[e(231)](this.sketchLineCoords_), this[e(178)]();
  }
  addToDrawing_(t) {
    const e = at, n = this.sketchFeature_[e(227)](), i = this[e(298)]()[e(290)]()[e(219)]();
    let s, o;
    const a = this[e(256)];
    return a === e(228) || a === e(206) ? (this[e(275)] = t[e(242)](), o = this[e(233)], o[e(271)] >= this.maxPoints_ && (this.freehand_ ? o[e(310)]() : s = !0), o.push(t[e(242)]()), this.geometryFunction_(o, n, i)) : a === "Polygon" && (o = this[e(233)][0], o.length >= this.maxPoints_ && (this[e(239)] ? o[e(310)]() : s = !0), o.push(t[e(242)]()), s && (this[e(275)] = o[0]), this[e(195)](this[e(233)], n, i)), this[e(177)](t[e(242)]()), this[e(178)](), s ? this[e(171)]() : this[e(183)];
  }
  [at(241)](t) {
    const e = at;
    if (!this.sketchFeature_) return;
    const n = this[e(183)].getGeometry(), i = this[e(298)]().getView()[e(219)](), s = this[e(256)];
    for (let o = 0; o < t; ++o) {
      let a;
      if (s === "LineString" || s === e(206)) {
        if (a = this[e(233)], a[e(257)](-2, 1), a[e(271)] >= 2) {
          this[e(275)] = a[a.length - 2][e(242)]();
          const u = this[e(275)][e(242)]();
          a[a.length - 1] = u, this[e(177)](u);
        }
        this[e(195)](a, n, i), n[e(235)]() === e(181) && this[e(162)] && this[e(196)](n);
      } else if (s === "Polygon") {
        a = this[e(233)][0], a.splice(-2, 1);
        const u = this.sketchLine_[e(227)]();
        if (a.length >= 2) {
          const x = a[a[e(271)] - 2][e(242)]();
          a[a[e(271)] - 1] = x, this[e(177)](x);
        }
        u[e(231)](a), this[e(195)](this[e(233)], n, i);
      }
      if (a.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this[e(178)]();
  }
  [at(207)]() {
    this.removeLastPoints_(1);
  }
  [at(171)]() {
    const t = at, e = this[t(274)]();
    if (!e) return null;
    let n = this[t(233)];
    const i = e[t(227)](), s = this[t(298)]().getView().getProjection();
    return this[t(256)] === "LineString" ? (n[t(310)](), this[t(195)](n, i, s)) : this[t(256)] === t(181) && (n[0].pop(), this.geometryFunction_(n, i, s), n = i[t(283)]()), this.type_ === t(212) ? e[t(175)](new L4([n])) : this[t(232)] === t(269) ? e[t(175)](new M4([n])) : this.type_ === t(292) && e[t(175)](new T4([n])), this[t(286)](new Rh(Oh.DRAWEND, e)), this[t(238)] && this[t(238)][t(288)](e), this[t(176)] && this[t(176)][t(251)](e), e;
  }
  abortDrawing_() {
    const t = at;
    this[t(275)] = null;
    const e = this[t(183)];
    return this.sketchFeature_ = null, this[t(204)] = null, this[t(162)] = null, this.overlay_[t(203)]()[t(248)](!0), this[t(211)](), e;
  }
  [at(190)]() {
    const t = at, e = this[t(274)]();
    e && this[t(286)](new Rh(Oh.DRAWABORT, e));
  }
  [at(307)](t) {
    const e = at, n = this[e(256)], i = !this.sketchFeature_;
    i && this.startDrawing_(t[0]);
    let s;
    if (n === e(228) || n === "Circle") s = this[e(233)];
    else if (n === "Polygon") s = this[e(233)] && this.sketchCoords_[e(271)] ? this[e(233)][0] : [];
    else return;
    i && s.shift(), s[e(310)]();
    for (let a = 0; a < t[e(271)]; a++)
      this[e(287)](t[a]);
    const o = t[t[e(271)] - 1];
    this[e(183)] = this.addToDrawing_(o), this.modifyDrawing_(o);
  }
  [at(213)](t) {
    const e = at, n = t[e(227)](), i = n;
    this[e(183)] = t, this[e(233)] = i[e(283)]();
    const s = this[e(233)][this[e(233)].length - 1];
    this[e(275)] = s[e(242)](), this[e(233)][e(288)](s.slice()), this[e(204)] = new An(new tr(s)), this.updateSketchFeatures_(), this[e(286)](new Rh(Oh[e(164)], this[e(183)]));
  }
  updateSketchFeatures_() {
    const t = at, e = [];
    this[t(183)] && e[t(288)](this.sketchFeature_), this.sketchLine_ && e[t(288)](this[t(162)]), this[t(204)] && e[t(288)](this[t(204)]);
    const n = this[t(186)][t(203)]();
    n[t(248)](!0), n.addFeatures(e);
  }
  [at(299)]() {
    const t = at, e = this.getMap(), n = this[t(260)]();
    (!e || !n) && this.abortDrawing(), this.overlay_.setMap(n ? e : null);
  }
}
function Ek() {
  const r = R_();
  return function(t, e) {
    const n = Al;
    return r[t[n(227)]()[n(235)]()];
  };
}
function Sk(r) {
  const t = at;
  switch (r) {
    case t(215):
    case t(212):
      return "Point";
    case t(228):
    case t(269):
      return "LineString";
    case t(181):
    case t(292):
      return t(181);
    case "Circle":
      return t(206);
    default:
      throw new Error("Invalid type: " + r);
  }
}
const vn = tc;
(function(r, t) {
  const e = tc, n = r();
  for (; ; )
    try {
      if (-parseInt(e(310)) / 1 + -parseInt(e(261)) / 2 * (-parseInt(e(300)) / 3) + parseInt(e(278)) / 4 + -parseInt(e(258)) / 5 + parseInt(e(329)) / 6 + parseInt(e(257)) / 7 + -parseInt(e(323)) / 8 * (parseInt(e(312)) / 9) === t) break;
      n.push(n.shift());
    } catch {
      n.push(n.shift());
    }
})(cy, 635959);
function tc(r, t) {
  const e = cy();
  return tc = function(n, i) {
    return n = n - 251, e[n];
  }, tc(r, t);
}
function cy() {
  const r = ["16nhMYAq", "features_", "push", "mapBrowserEvent", "getType", "getGeometry", "1501566fgRnFG", "getAllLayers", "includes", "getStyle", "filter", "features", "extend", "style", "6577116QOYBor", "3503020WQHPUL", "setMap", "once", "1068622JDzDyY", "layers", "removeFeature_", "ADD", "GeometryCollection", "getSource", "hitTolerance", "indexOf", "forEachFeatureAtPixel", "getLayer", "restorePreviousStyle_", "setHitTolerance", "Polygon", "setStyle", "addEventListener", "deselected", "addCondition", "2239080ylkCrc", "map", "featureLayerAssociation_", "function", "addFeature_", "removeEventListener", "getMap", "hitTolerance_", "addFeatureLayerAssociation_", "removeCondition", "layerFilter_", "getArray", "style_", "addCondition_", "boundAddFeature_", "multi", "element", "filter_", "boundRemoveFeature_", "getInteractions", "forEach", "length", "3kfTXCF", "multi_", "splice", "find", "bind", "getLength", "condition", "toggleCondition", "removeCondition_", "selected", "709985OmORec", "applySelectedStyle_", "1068219XmywJH", "pixel", "getFeatures", "SELECT", "removeFeatureLayerAssociation_", "REMOVE", "LineString", "handleEvent", "remove", "condition_", "toggleCondition_"];
  return cy = function() {
    return r;
  }, cy();
}
const Ck = { SELECT: "select" };
class Mk extends Oo {
  constructor(t, e, n, i) {
    const s = tc;
    super(t), this[s(309)] = e, this[s(276)] = n, this[s(326)] = i;
  }
}
const Fh = {};
class rb extends hy {
  constructor(t) {
    const e = tc;
    super(), this.on, this[e(260)], this.un, t = t || {}, this[e(292)] = this.addFeature_[e(304)](this), this.boundRemoveFeature_ = this[e(263)][e(304)](this), this.condition_ = t[e(306)] ? t[e(306)] : nw, this[e(291)] = t[e(277)] ? t[e(277)] : Am, this[e(308)] = t[e(287)] ? t[e(287)] : Am, this[e(322)] = t[e(307)] ? t[e(307)] : k_, this[e(301)] = t[e(293)] ? t[e(293)] : !1, this.filter_ = t[e(253)] ? t[e(253)] : ix, this.hitTolerance_ = t[e(267)] ? t[e(267)] : 0, this.style_ = t[e(256)] !== void 0 ? t[e(256)] : Pk(), this[e(324)] = t[e(254)] || new aa();
    let n;
    if (t[e(262)])
      if (typeof t[e(262)] === e(281)) n = t[e(262)];
      else {
        const i = t[e(262)];
        n = function(s) {
          return i.includes(s);
        };
      }
    else n = ix;
    this.layerFilter_ = n, this[e(280)] = {};
  }
  [vn(286)](t, e) {
    const n = vn;
    this[n(280)][ve(t)] = e;
  }
  [vn(314)]() {
    return this[vn(324)];
  }
  getHitTolerance() {
    return this[vn(285)];
  }
  [vn(270)](t) {
    return this[vn(280)][ve(t)];
  }
  [vn(272)](t) {
    const e = vn;
    this[e(285)] = t;
  }
  [vn(259)](t) {
    const e = vn;
    this[e(284)]() && this[e(290)] && this[e(324)][e(298)](this.restorePreviousStyle_[e(304)](this)), super.setMap(t), t ? (this.features_[e(275)](_i[e(264)], this[e(292)]), this[e(324)].addEventListener(_i[e(317)], this[e(296)]), this.style_ && this.features_[e(298)](this.applySelectedStyle_[e(304)](this))) : (this[e(324)][e(283)](_i[e(264)], this.boundAddFeature_), this[e(324)][e(283)](_i[e(317)], this[e(296)]));
  }
  [vn(282)](t) {
    const e = vn, n = t[e(294)];
    if (this[e(290)] && this[e(311)](n), !this[e(270)](n)) {
      const i = this.getMap()[e(330)]()[e(303)](function(s) {
        const o = e;
        if (s instanceof Bl && s[o(266)]() && s.getSource().hasFeature(n)) return s;
      });
      i && this[e(286)](n, i);
    }
  }
  removeFeature_(t) {
    const e = vn;
    this[e(290)] && this.restorePreviousStyle_(t[e(294)]);
  }
  [vn(252)]() {
    return this.style_;
  }
  [vn(311)](t) {
    const e = vn, n = ve(t);
    !(n in Fh) && (Fh[n] = t[e(252)]()), t[e(274)](this.style_);
  }
  [vn(271)](t) {
    const e = vn, n = this[e(284)]()[e(297)]()[e(289)]();
    for (let s = n[e(299)] - 1; s >= 0; --s) {
      const o = n[s];
      if (o !== this && o instanceof rb && o[e(252)]() && o[e(314)]().getArray().lastIndexOf(t) !== -1) {
        t[e(274)](o[e(252)]());
        return;
      }
    }
    const i = ve(t);
    t[e(274)](Fh[i]), delete Fh[i];
  }
  [vn(316)](t) {
    delete this.featureLayerAssociation_[ve(t)];
  }
  [vn(319)](t) {
    const e = vn;
    if (!this[e(321)](t)) return !0;
    const n = this[e(291)](t), i = this.removeCondition_(t), s = this[e(322)](t), o = !n && !i && !s, a = t[e(279)], u = this[e(314)](), x = [], c = [];
    if (o) {
      ly(this.featureLayerAssociation_), a[e(269)](t[e(313)], (f, l) => {
        const h = e;
        if (!(!(f instanceof An) || !this[h(295)](f, l)))
          return this[h(286)](f, l), c[h(325)](f), !this[h(301)];
      }, { layerFilter: this[e(288)], hitTolerance: this[e(285)] });
      for (let f = u[e(305)]() - 1; f >= 0; --f) {
        const l = u.item(f), h = c[e(268)](l);
        h > -1 ? c[e(302)](h, 1) : (u.remove(l), x[e(325)](l));
      }
      c[e(299)] !== 0 && u[e(255)](c);
    } else {
      a[e(269)](t[e(313)], (f, l) => {
        const h = e;
        if (!(!(f instanceof An) || !this.filter_(f, l)))
          return (n || s) && !u[h(289)]()[h(251)](f) ? (this[h(286)](f, l), c[h(325)](f)) : (i || s) && u[h(289)]()[h(251)](f) && (x[h(325)](f), this[h(316)](f)), !this[h(301)];
      }, { layerFilter: this[e(288)], hitTolerance: this[e(285)] });
      for (let f = x[e(299)] - 1; f >= 0; --f)
        u[e(320)](x[f]);
      u.extend(c);
    }
    return (c[e(299)] > 0 || x[e(299)] > 0) && this.dispatchEvent(new Mk(Ck[e(315)], c, x, t)), !0;
  }
}
function Pk() {
  const r = vn, t = R_();
  return ds(t[r(273)], t.LineString), ds(t[r(265)], t[r(318)]), function(e) {
    const n = r;
    return e[n(328)]() ? t[e[n(328)]()[n(327)]()] : null;
  };
}
let H3 = {
  lines: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
    }
  },
  LINES_18: {
    //冷锋
    glyph: "LINES_18",
    //根据这个名字查找对应的样式
    lineStyle: {
      Style: {
        stroke: {
          //线条的样式
          Stroke: {
            color: "rgb(0,0,255)",
            //颜色 也可以是rgba
            width: 2
            //线条的宽度
          }
        }
      }
    },
    options: {
      angle: Math.PI / 4,
      //0.7853981633974483,//弧度  默认值 Math.PI / 4,
      sqrt_2: 1.414,
      //square 默认值 建议不修改
      color: "rgb(255,0,0)",
      radius: 10,
      //绘制的半圆的半径
      distance: 60,
      //绘制图形的间隔 贴合线的半圆的距离间隔
      coefficient: 0.8
      //曲线的系数  值越小，越接近真实绘制的曲线，值越大，曲率越大
    }
  },
  LINES_19: {
    //暖锋
    glyph: "LINES_19",
    //根据这个名字查找对应的样式
    lineStyle: {
      Style: {
        stroke: {
          //线条的样式
          Stroke: {
            color: "rgba(0,0,255,1)",
            //颜色 也可以是rgba
            width: 2
            //线条的宽度
          }
        }
      }
    },
    options: {
      color: "rgba(0,0,255,1)",
      radius: 10,
      //绘制的半圆的半径
      distance: 60,
      //绘制图形的间隔 贴合线的半圆的距离间隔
      coefficient: 0.8
      //曲线的系数  值越小，越接近真实绘制的曲线，值越大，曲率越大
    }
  },
  LINES_41: {
    //  //静止锋
    glyph: "LINES_41",
    //根据这个名字查找对应的样式
    lineStyle: {
      Style: {
        stroke: {
          //线条的样式
          Stroke: {
            color: "rgb(0,0,255)",
            //颜色 也可以是rgba
            width: 2
            //线条的宽度
          }
        }
      }
    },
    options: {
      angle: Math.PI / 4,
      //0.7853981633974483,//弧度  默认值 Math.PI / 4,
      sqrt_2: 1.414,
      //square 默认值 建议不修改
      color: "rgb(255,0,0)",
      radius: 10,
      //绘制的半圆的半径
      distance: 60,
      //绘制图形的间隔 贴合线的半圆的距离间隔
      coefficient: 0.8
      //曲线的系数  值越小，越接近真实绘制的曲线，值越大，曲率越大
    }
  },
  LINES_51: {
    //锢囚锋
    glyph: "LINES_51",
    //根据这个名字查找对应的样式
    lineStyle: {
      Style: {
        stroke: {
          //线条的样式
          Stroke: {
            color: "rgb(0,0,255)",
            //颜色 也可以是rgba
            width: 2
            //线条的宽度
          }
        }
      }
    },
    options: {
      angle: Math.PI / 4,
      //0.7853981633974483,//弧度  默认值 Math.PI / 4,
      sqrt_2: 1.414,
      //square 默认值 建议不修改
      color: "rgb(255,0,0)",
      radius: 10,
      //绘制的半圆的半径
      distance: 60,
      //绘制图形的间隔 贴合线的半圆的距离间隔
      coefficient: 0.8
      //曲线的系数  值越小，越接近真实绘制的曲线，值越大，曲率越大
    }
  },
  LINESYMBOLS_1218: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_1219: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_1102: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  REGION_8: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  REGION_32: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  REGION_1: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  REGION_4: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  REGION_2: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  REGION_16: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINES_39: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
    }
  },
  // "LINES_39": {
  //   "Style": {
  //     "stroke": {
  //       "Stroke": {
  //         "color": "red",
  //         "width": 5,
  //         "lineDash": [
  //           5,
  //           10,
  //           25
  //         ]
  //       }
  //     },
  //     // "text": {
  //     //   "Text": {
  //     //     "text": "Sample Text",
  //     //     "font": "12px Calibri,sans-serif",
  //     //     "fill": {
  //     //       "Fill": {
  //     //         "color": "#ff0000ff"
  //     //       }
  //     //     },
  //     //     "stroke": {
  //     //       "Stroke": {
  //     //         "color": "#ffffff",
  //     //         "width": 2
  //     //       }
  //     //     },
  //     //     "offsetX": 0,
  //     //     "offsetY": 0,
  //     //     "textAlign": "center",
  //     //     "placement": "point",
  //     //     "textBaseline": "middle",
  //     //     "scale": 2,
  //     //     "maxAngle": 0.7853981633974483,
  //     //     "overflow": "truncate",
  //     //     "rotation": 0
  //     //   }
  //     // }
  //   }
  // },
  LINES_21: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINES_31: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINES_38: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_0: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_1110: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_1111: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_1113: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_1112: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_1115: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_1114: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  },
  LINESYMBOLS_1116: {
    Style: {
      stroke: {
        Stroke: {
          color: "red",
          width: 5,
          lineDash: [
            5,
            10,
            25
          ]
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "center",
      //     "placement": "point",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "maxAngle": 0.7853981633974483,
      //     "overflow": "truncate",
      //     "rotation": 0
      //   }
      // }
    }
  }
};
class Lk {
  constructor() {
  }
  getCommonStyle(t) {
    return {
      Style: {
        stroke: {
          Stroke: {
            color: "red",
            width: 5
            //  "lineDash": [
            //    5,
            //    10,
            //    25
            //  ]
          }
        }
      }
    };
  }
  getStyle(t, e = null) {
    if (H3[t]) {
      let n = H3[t];
      return e != null && (n = mo(n, z3, e)), n.glyph = t, n;
    } else {
      let n = this.getCommonStyle(t);
      return e != null && (n = mo(n, z3, e)), n;
    }
  }
}
const Nk = {
  Circle: x0,
  Fill: Hr,
  Icon: rc,
  Image: nc,
  IconImage: N_,
  RegularShape: _o,
  Stroke: ys,
  Style: En,
  Text: Dl
  // cme_style_FontSymbol
};
function fy(r) {
  if (!r || typeof r != "object")
    return r;
  const t = {};
  for (const e of Object.keys(r)) {
    const n = Nk[e];
    if (n)
      return new n(fy(r[e]));
    Array.isArray(r[e]) ? t[e] = r[e] : t[e] = fy(r[e]);
  }
  return t;
}
class Ok {
  constructor() {
    this.commonLine = new Lk(), this.cme_polyline = new uk();
  }
  /**
   * 设置给定特征在给定分辨率下的样式。
   *
   * @param {Object} feature - 要设置样式的特征。
   * @param {number} resolution - 地图的分辨率。
   * @return {Object} 特征的样式对象。
   */
  // setStyle(feature, resolution) {
  setStyle(t, e) {
    let n = this.commonLine.getStyle(e, t);
    this.coefficient = 0.2, this.distance = 100;
    let i = this.getCommonLineStyle(n);
    t.setProperties({
      customStyle: n
    });
    let o = t.getGeometry().getCoordinates();
    t.setProperties({
      geo: o
    }), t.setStyle(i), this.setFeature(t, this.coefficient, this.distance);
  }
  setFeature(t, e, n) {
    t.getProperties().geo, t.getProperties().geo != null;
  }
  getCommonLineStyle(t) {
    debugger;
    console.log("getCommonLineStyle", t);
    let n = "getCme_" + t.glyph;
    console.log("styleFunc1-------------名称", n);
    let i;
    debugger;
    return this.cme_polyline[n] ? i = this.cme_polyline[n](t) : (console.log("没有找到对应的样式"), i = fy({
      Style: t.Style
    })), i;
  }
}
let J3 = {
  FILLAREA_1101_1_0: {
    Style: {
      fill: {
        Fill: {
          color: "rgba(40,113,62,1)"
        }
      },
      stroke: {
        Stroke: {
          color: "rgba(0,0,0,0)",
          width: 1
        }
      }
      // "text": {
      //   "Text": {
      //     "text": "Sample Text111\r\n1111111111111",
      //     "font": "12px Calibri,sans-serif",
      //     "fill": {
      //       "Fill": {
      //         "color": "#ff0000ff"
      //       }
      //     },
      //     "stroke": {
      //       "Stroke": {
      //         "color": "#ffffff",
      //         "width": 2
      //       }
      //     },
      //     "offsetX": 0,
      //     "offsetY": 0,
      //     "textAlign": "left",
      //     "placement": "polygon",
      //     "textBaseline": "middle",
      //     "scale": 2,
      //     "overflow": "false",
      //     "rotation": 0
      //   }
      // }
    }
  },
  FILLAREA_1101_2_5: {
    pattern: "hatch",
    //这个是默认值，不能改动，主要是方便以后做扩展
    color: "rgba(255,255,0,1)",
    // 线条的颜色
    offset: 0,
    //偏移量 目前不起作用
    scale: 1,
    //整体的放大系数
    fill: "rgba(40,113,62,1)",
    //背景色
    size: 3,
    //线条的宽度
    spacing: 15,
    //线条的间隔
    angle: 45
    // 旋转的角度
  },
  FILLAREA_1101_2_4: {
    pattern: "hatch",
    //这个是默认值，不能改动，主要是方便以后做扩展
    color: "rgba(171,37,36,1)",
    // 线条的颜色
    offset: 0,
    //偏移量 目前不起作用
    scale: 1,
    //整体的放大系数
    fill: "rgba(40,113,62,1)",
    //背景色
    size: 3,
    //线条的宽度
    spacing: 15,
    //线条的间隔
    angle: 90
    // 旋转的角度
  },
  FILLAREA_1101_0_0: {
    Style: {
      fill: {
        Fill: {
          color: "rgba(0, 0, 0,0)"
        }
      },
      stroke: {
        Stroke: {
          color: "rgba(40,113,62,1)",
          width: 5
        }
      }
    }
  },
  FILLAREA_1101_0_X: {
    Style: {
      fill: {
        Fill: {
          color: "rgba(255, 0, 0,1)"
        }
      },
      stroke: {
        Stroke: {
          color: "#ffcc33",
          width: 2
        }
      },
      text: {
        Text: {
          text: `Sample Text111\r
1111111111111`,
          font: "12px Calibri,sans-serif",
          fill: {
            Fill: {
              color: "#ff0000ff"
            }
          },
          stroke: {
            Stroke: {
              color: "#ffffff",
              width: 2
            }
          },
          offsetX: 0,
          offsetY: 0,
          textAlign: "left",
          placement: "polygon",
          textBaseline: "middle",
          scale: 2,
          overflow: "false",
          rotation: 0
        }
      }
    }
  }
};
class Rk {
  constructor() {
  }
  getCommonStyle(t) {
    return {
      // glyph: theGlyph, //that.geoStyleName,
      Style: {
        fill: {
          Fill: {
            color: "rgba(255, 0, 0,1)"
          }
        },
        stroke: {
          Stroke: {
            color: "#ffcc33",
            width: 2
          }
        }
        // "text": {
        //   "Text": {
        //     text: 'Sample Text111\r\n1111111111111',
        //       font: '12px Calibri,sans-serif',
        //     fill: {
        //       Fill: {
        //         color: "#ff0000ff"
        //       }
        //     },
        //     stroke: {
        //       Stroke: {
        //         color: "#ffffff",
        //         width: 2
        //       }
        //     },
        //       // 设置文本偏移量
        //       offsetX: 0,
        //       offsetY: 0,
        //       textAlign: 'left',
        //       // 将文本放置在多边形的中心
        //       placement: 'polygon',
        //       // 保持文本水平
        //       textBaseline: 'middle',
        //       // 随地图缩放
        //       scale: true,
        //       // 文本的最大角度
        //       // maxAngle: 0.7853981633974483,
        //       // 文本溢出时的处理方式
        //       overflow: 'false',
        //       // 文本旋转角度
        //       rotation: 0,
        //       scale: 2
        //   }
        // }
      }
    };
  }
  getStyle(t, e = null) {
    debugger;
    if (J3[t]) {
      let n = J3[t];
      return e != null && (n = mo(n, U3, e)), n.glyph = t, n;
    } else {
      let n = this.getCommonStyle(t);
      return e != null && (n = mo(n, U3, e)), n;
    }
  }
}
class Ak {
  constructor() {
    this.commonPolygon = new Rk(), this.cme_polygon = new hk();
  }
  setStyle(t, e) {
    let n = this.commonPolygon.getStyle(e, t), i = this.getCommonStyle(n);
    t.setProperties({
      customStyle: n
    });
    let o = t.getGeometry().getCoordinates();
    t.setProperties({
      geo: o
    }), t.setStyle(i);
  }
  /**
   * 设置给定特征在给定分辨率下的样式。
   *
   * @param {Object} feature - 要设置样式的特征。
   * @param {number} resolution - 地图的分辨率。
   * @return {Object} 特征的样式对象。
   */
  // setStyle(feature, resolution) {
  getCommonStyle(t) {
    let n = "getCme_" + t.glyph;
    console.log("styleFunc1  ", n);
    let i;
    return this.cme_polygon[n] ? i = this.cme_polygon[n](t) : (console.log("没有找到对应的样式"), console.log(t), i = fy({
      Style: t.Style
    })), i;
  }
}
let om = {
  symbol_jiantou: {
    Style: {
      text: {
        Text: {
          text: "自定义的名字",
          textAlign: null,
          textBaseline: null,
          font: null,
          fill: {
            Fill: {
              color: "#ff0000ff"
            }
          },
          stroke: {
            Stroke: {
              color: "#ffffff",
              width: 2
            }
          },
          offsetX: 0,
          offsetY: 0,
          placement: "Point",
          maxAngle: 0.7853981633974483,
          overflow: null,
          rotation: 0,
          scale: 5
        }
      }
    }
  }
};
class Tk {
  constructor() {
  }
  getCommonStyle(t) {
    return {
      Style: {
        text: {
          Text: {
            text: t.toString(),
            // textAlign: null,
            // textBaseline: null,
            // font: null,
            fill: {
              Fill: {
                color: "#ff0000"
              }
            },
            stroke: {
              Stroke: {
                color: "#ffffff",
                width: 2
              }
            },
            offsetX: 0,
            offsetY: 0,
            // placement: "Point",
            // maxAngle: 0.7853981633974483,
            // // overflow: null,
            rotation: 0
            // scale: 5
          }
        }
      }
    };
  }
  getStyle(t, e = null) {
    debugger;
    if (om[t])
      return om[t].Style.image.cme_style_FontSymbol.glyph = t, e != null ? mo(om[t], V3, e) : fontStyleJSON[t];
    {
      let n = this.getCommonStyle(t);
      return e != null ? mo(n, V3, e) : n;
    }
  }
}
class Dk {
  constructor() {
    this.commonText = new Tk(), this.cme_text = new dk();
  }
  setStyle(t, e, n = 0) {
    debugger;
    let i = this.commonText.getStyle(e, t);
    i.Style.text.Text.rotation = n, console.log("styleJSON.Style.text.Text.rotation " + i.Style.text.Text.rotation), t.setProperties({
      customStyle: i
    });
    let s = this.getStyle(i);
    t.setStyle(s);
  }
  /**
   * 设置给定特征在给定分辨率下的样式。
   *
   * @param {Object} feature - 要设置样式的特征。
   * @param {number} resolution - 地图的分辨率。
   * @return {Object} 特征的样式对象。
   */
  // setStyle(feature, resolution) {
  getStyle(t) {
    let n = "getCme_" + t.glyph, i;
    return this.cme_text[n] ? i = this.cme_text[n](t) : i = this.cme_text.getCme_Style(t), i;
  }
}
class Fk {
  constructor() {
    this.FontSymbolStyle = new P6(), this.polylineStyle = new Ok(), this.polygonStyle = new Ak(), this.textStyle = new Dk();
  }
  /**
   * 为要素添加风向标样式。
   *
   * @param {Object} feature - 要添加样式的要素。
   * @param {string} geoStyleName - 地理样式的名称。
   * @param {Object} layer - 要添加要素的图层。
   */
  addWindBarbStyleToFeature(t, e, n) {
    let i = this.FontSymbolStyle.setWindStyle(t, e);
    n.getSource().addFeature(i);
  }
  /**
   * 为点要素添加样式
   * @param {Object} feature - 要素对象
   * @param {string} geoStyleName - 样式名称
   */
  addPointStyleToFeature(t, e) {
    this.FontSymbolStyle.setStyle(t, e);
  }
  /**
   * 为线要素添加线样式。
   *
   * @param {Object} feature - 要添加样式的要素。
   * @param {string} geoStyleName - 要应用的样式名称。
   */
  addLineStyleToFeature(t, e) {
    this.polylineStyle.setStyle(t, e);
  }
  /**
   * 根据给定的geoStyleName将多边形样式添加到特征中。
   *
   * @param {Object} feature - 要将多边形样式添加到的特征。
   * @param {string} geoStyleName - 要应用的geo样式的名称。
   * @return {void} 此函数不返回任何内容。
   */
  addPolygonStyleToFeature(t, e) {
    this.polygonStyle.setStyle(t, e);
  }
  /**
   * 为点要素添加样式
   * @param {Object} feature - 要素对象
   * @param {string} geoStyleName - 样式名称
   */
  addTextStyleToFeature(t, e) {
    this.textStyle.setStyle(t, e);
  }
  addTextStyleToFeaturePolygon(t, e) {
    debugger;
    this.textStyle.setStyle(t.midFeature, e, t.angle);
  }
}
class kk {
  constructor(t) {
    this.map = t, this.styleToMicaps = new Fk(), this.draw = null, this.geoStyleName = null, this.tempLayer = vk(), this.layer = null, this.mapEvent = null;
  }
  /**
  +     * 负责添加具有指定类型、图层和地理样式名称的绘制交互操作。
  +     *
  +     * @param {type} type - 绘制交互操作的类型。
  +     * @param {type} layer - 绘制交互操作的图层。
       * @param {type} geoStyleName - 绘制交互操作的地理样式名称。
       * @return {type} 未定义
       */
  addDraw(t, e, n) {
    this.layer = e, this.geoStyleName = n;
    let i = [
      "SYMBOLSS_36",
      "SYMBOLS_101",
      "SYMBOLS_103",
      "SYMBOLS_35",
      "SYMBOLS_33",
      "SYMBOLS_102",
      "SYMBOLS_39",
      "SYMBOLS_41",
      "SYMBOLS_43",
      "SYMBOLS_34",
      "SYMBOLS_40"
    ];
    i.indexOf(n) >= 0 ? this.draw = new W3({
      interactionType: "CME_draw",
      //设定对应的类型
      source: this.tempLayer.getSource(),
      // source,
      type: "LineString",
      // var type = 'LineString';
      maxPoints: 2
      // 设绘制风羽图
    }) : this.draw = new W3({
      interactionType: "CME_draw",
      source: e.getSource(),
      // source,
      type: t
    });
    let s = this;
    this.draw.set("interactionType", "CME_draw"), this.draw.setActive(!0), this.map.addInteraction(this.draw), this.draw.on("drawend", function(o) {
      if (s.geoStyleName) {
        let a = s.geoStyleName.split("_")[0];
        switch (o.feature.getGeometry().getType()) {
          case "Point":
            a == "NOTES" ? s.styleToMicaps.addTextStyleToFeature(o.feature, s.geoStyleName) : s.styleToMicaps.addPointStyleToFeature(o.feature, s.geoStyleName);
            break;
          case "LineString":
            i.indexOf(n) >= 0 ? (s.styleToMicaps.addWindBarbStyleToFeature(
              o.feature,
              s.geoStyleName,
              e
            ), e.getSource().removeFeature(o.feature)) : s.styleToMicaps.addLineStyleToFeature(o.feature, s.geoStyleName);
            break;
          case "Polygon":
            debugger;
            console.log("that.geoStyleName", s.geoStyleName), s.styleToMicaps.addPolygonStyleToFeature(o.feature, s.geoStyleName);
            break;
          default:
            featureType = "未知";
        }
      }
    });
  }
  getFeaturebyPointFeature(t) {
    const e = t.getGeometry();
    e.getType();
    let n, i;
    const s = e.getCoordinates(), o = s[0], a = o.length - 1;
    n = o[a], i = o[a === 0 ? o.length - 1 : a - 1];
    const u = [
      (n[0] + i[0]) / 2,
      // 中间点的 X 坐标
      (n[1] + i[1]) / 2
      // 中间点的 Y 坐标
    ];
    let x = 0;
    this.isClockwise(s) > 0 ? x = this.bearing(i, n) : x = this.bearing(i, n), console.log("角度:", x), x = x * (Math.PI / 180), console.log("弧度:", x), console.log("随机点:", n), console.log("前一个点:", i), console.log("中间点:", u), console.log("弧度:", x), new An({
      geometry: new tr(n)
    });
    const c = new An({
      geometry: new tr(u)
    });
    return this.layer.getSource().addFeature(c), { midFeature: c, angle: x };
  }
  //判断是逆时针还是顺时针
  isClockwise(t) {
    let e = 0;
    for (let n = 0; n < t.length; n++) {
      let i = (n + 1) % t.length;
      e += (t[i][0] - t[n][0]) * (t[i][1] + t[n][1]);
    }
    return e > 0;
  }
  bearing(t, e) {
    var n = t[0] * Math.PI / 180, i = t[1] * Math.PI / 180, s = e[0] * Math.PI / 180, o = e[1] * Math.PI / 180, a = o - i, u = Math.sin(a) * Math.cos(s), x = Math.cos(n) * Math.sin(s) - Math.sin(n) * Math.cos(s) * Math.cos(a), c = Math.atan2(u, x) * 180 / Math.PI;
    return (c + 360) % 360;
  }
  // getFeaturebyPointFeature(feature) {
  //   // 假设已经有一个 Feature 对象
  //   // const feature = yourFeature; // 替换为你的 Feature 对象
  //   // 获取几何数据
  //   const geometry = feature.getGeometry();
  //   // 获取几何类型
  //   const geomType = geometry.getType();
  //   // 初始化一个随机点
  //   let randomPoint;
  //   // 根据几何类型处理坐标数据
  //   if (geomType === 'Polygon') {
  //     // 获取多边形的外部环坐标
  //     const coordinates = geometry.getCoordinates();
  //     const exteriorRing = coordinates[0]; // 假设是二维坐标数组
  //     // 生成一个随机索引
  //     const randomIndex = Math.floor(Math.random() * exteriorRing.length);
  //     // 获取随机点
  //     randomPoint = exteriorRing[randomIndex];
  //   } else if (geomType === 'LineString') {
  //     // 获取线的坐标
  //     const coordinates = geometry.getCoordinates();
  //     // 生成一个随机索引
  //     const randomIndex = Math.floor(Math.random() * coordinates.length);
  //     // 获取随机点
  //     randomPoint = coordinates[randomIndex];
  //   } else if (geomType === 'Point') {
  //     // 如果是点，直接使用点的坐标
  //     randomPoint = geometry.getCoordinates();
  //   }
  //   // 创建一个新的 Feature，使用生成的随机点
  //   const newFeature = new Feature({
  //     geometry: new Point(randomPoint)
  //   });
  //   // 打印新 Feature
  //   console.log('新的随机点 Feature:', newFeature);
  //   this.layer.getSource().addFeature(newFeature);
  //   return newFeature;
  //   // 你可以将新 Feature 添加到现有的向量图层中
  //   // vectorLayer.getSource().addFeature(newFeature);
  // };
}
class sB {
  constructor(t, e) {
    this.map = t, this.layer = null, this.interactions = {}, this.featureSelect = null, this.SelectFunction = null, this.transform = null, this.select = null, this.modify = null, this.undoredo = null, this.copyPaste = null, this.geoStyleName = null, this.commonDraw = new kk(this.map);
  }
  convertIconFont() {
    const t = NC;
    let e = {}, n = t.font_family, i = t.css_prefix_text, s = t.glyphs;
    for (let u = 0; u < s.length; u++) {
      let x = s[u];
      e[i + x.font_class] = {
        font: n,
        code: x.unicode_decimal,
        name: x.name,
        search: i + x.font_class
      };
    }
    let o = {
      font: {
        font: n,
        copyright: ""
      },
      glyphs: e
    };
    return new P6().getFontGraph(o), o;
  }
  /**
  // 以下是开始交互的方法，通过传入地图对象和图层对象，开启交互操作
  // 通过这个方法，可以开启滑动操作，用于对图层进行平移、旋转、缩放操作
  // 通过传入的图层对象，可以获取到图层的数据源信息，并且可以进行撤销、重做操作
  // 这个方法返回值为void，没有返回值
  // 参数列表：layer, 类型为Object，用于传入图层对象
  // 参数说明：layer, 用于传入图层对象，通过这个对象可以获取到图层的数据源信息，并且可以进行撤销、重做操作
  // 调用方法示例：
  // let ctrl = new interactionsControl(this.map, layer);
  // ctrl.startInteraction(layer);
   */
  startInteraction(t) {
    this.layer = t, this.addUndoRedo(), this.map.addInteraction(new wC({
      source: this.layer.getSource(),
      interactionType: "CME_snap",
      //名字，依CME开头，后续好扩展，比如遍历删除的交互的控件根据CME开头编写
      pixelTolerance: 5
    }));
  }
  ////////////////////////////////////////////////撤销 重做
  /**
   * 添加撤销重做功能
   * 这个函数用于给地图对象添加撤销重做的功能，通过给地图对象添加一个撤销重做对象，
   * 可以通过这个对象来进行撤销和重做操作，并且可以设置撤销和重做按钮的状态
   */
  addUndoRedo() {
    this.undoredo = new f9({
      layer: this.layer,
      interactionType: "CME_undoredo"
    }), this.map.addInteraction(this.undoredo);
  }
  /**
   * 撤销按钮的功能函数
   * 用于撤销上一步的操作，根据之前的操作记录来撤销之前的绘制要素
   * 注意：该功能依赖于撤销重做功能，需要先添加撤销重做功能
   * 该功能需要一个用于绘图的通用对象（CommonDraw），用于获取之前绘制过的要素，并根据记录来撤销要素
   * 所以该功能依赖于该对象
   * 因此，在使用该功能之前，需要先实例化一个用于绘图的通用对象（CommonDraw）
   */
  UndoClickFunction() {
    this.undoredo.undo();
  }
  /**
  * 重做按钮点击时的功能函数
  * 用于重做上一步操作，根据之前的操作记录来重新绘制要素
  * 注意：该功能需要一个用于绘图的通用对象（CommonDraw）
  * 该对象用于获取之前绘制过的要素，并根据记录来重新绘制要素
  * 所以该功能依赖于该对象
  * 因此，在使用该功能之前，需要先实例化一个用于绘图的通用对象（CommonDraw）
  */
  RedoClickFunction() {
    debugger;
    this.undoredo.redo();
  }
  //////////////////////////////////////////////////////////////复制 剪切 粘贴
  /**
   * 复制功能函数
   * 用于将要素复制到剪贴板中
   *
   * @param {Object} options - 复制选项
   * @param {boolean} options.silent - 是
   */
  CopyPasterClickFunctionC() {
    this.copyPaste.copy({ silent: !1 });
  }
  /**
   * 剪切功能函数
   * 用户剪切要素
   *
   * @param {Object} options - 剪切选项
   * @param {boolean} options.silent - 是
   */
  CopyPasterClickFunctionX() {
    this.copyPaste.copy({ cut: !0, silent: !1 });
  }
  /**
   * 粘贴功能函数
   * 用于将要素粘贴到
   */
  CopyPasterClickFunctionV() {
    this.copyPaste.paste({ silent: !1 });
  }
  //////////////修改要素//////////////////////////////////////////////////////////
  /**
   * 添加修改要素的交互功能
   * 通过该功能，可以对要素进行修改
   * 包括修改点、线、面的坐标、样式等信息
   * 注意：该交互功能需要一个绘图的通用对象（CommonDraw），
   *      并且需要向该对象传入一个用于绘图的源（source）
   *      通过该源，才能够获取到绘制的要素，用于后续的修改操作
   */
  addModify() {
    let t = {
      source: this.layer.getSource(),
      interactionType: "CME_modify"
    };
    this.modify = new _C(t), this.map.addInteraction(this.modify);
  }
  ////////////////////////////////////////////////选择要素//////////////////////////////////////////////////////////
  // 添加选择要素的功能
  // 注释：
  // 用户可以通过鼠标点击地图上的要素来选择要素，并且可以撤销或者重做选择要素的操作。
  addSelect() {
    this.select = new rb({
      interactionType: "CME_select",
      hitTolerance: 30
    }), this.select.set("interactionType", "CME_select"), this.map.addInteraction(this.select);
    let t = this;
    this.SelectFunction = this.select.on("select", function(e) {
      if (t.select) {
        var n = e.target.getFeatures();
        n.forEach(function(i) {
          t.featureSelect = i;
        });
      }
    });
  }
  /**
   * 重置所有交互事件，用于清除之前的绘制和选择
   *
   * @description
   * 清除绘制点、线、面等micaps的样式
   * 清除选中的事件方法
   *
   */
  resetInteractions() {
    this.geoStyleName = null, this.select && this.SelectFunction && this.select.un("select", this.SelectFunction);
  }
  ///////////////////////////////////旋转  移动
  /**
   * 添加旋转和移动功能
   * 注释：
   * 旋转和移动，通常和其他的交互功能一起使用，比如绘制、修改、变形等
   * 一般用于在已有的要素上进行旋转和移动操作
   *
   * @example
   * // 添加旋转和移动功能
   * this.addTransform();
   * （继续添加其他交互功能，如绘制、修改、变形等）
   */
  addTransform() {
    let t = {
      enableRotatedTransform: !1,
      interactionType: "CME_transform",
      addCondition: k_,
      hitTolerance: 2,
      pointRadius: function(e) {
        var n = e.get("radius") || 10;
        return [n, n];
      }
    };
    this.transform = new pC(t), this.map.addInteraction(this.transform), this.addCopyPase();
  }
  /**
   * 添加复制粘贴交互功能到地图上。 必须在transform交互功能上添加,否则不起作用
   *
   * @return {void}
   */
  addCopyPase() {
    this.copyPaste = new h9({
      destination: this.layer.getSource(),
      interactionType: "CME_copypase",
      features: this.transform.getFeatures()
    }, this.transform), this.map.addInteraction(this.copyPaste);
  }
  /*
  * 清除所有交互事件
  * 注释：
  *   此方法用于在模型清除时，清除所有自定义交互事件
  */
  activeModelClean() {
    this.resetInteractions();
    let t = this.map.getInteractions().getArray(), e = t.length;
    for (let n = e - 1; n >= 0; n--)
      t[n].getProperties().interactionType && (t[n].getProperties().interactionType.includes("CME_undoredo") || t[n].getProperties().interactionType.includes("CME_") && this.map.removeInteraction(t[n]));
    this.transform = null, this.copyPaste = null, this.select = null, this.modify = null;
  }
  ////////////////////////////////////////绘制点 线  面
  /**
   * 激活绘制点、线、面的功能
   * 删除之前的自定义的交互事件
   * 根据type参数判断激活哪个功能，目前只有修改和变形两个功能
   * 修改功能：添加点、线、面的修改交互事件
   * 变形功能：添加点、线、面的变形交互事件
   *
   * @param {string} type - 交互类型，目前只有两个修改和变形
   */
  activeModel(t) {
    switch (this.activeModelClean(), t) {
      case "modify":
        this.addModify();
        break;
      case "transform":
        this.addTransform();
        break;
      case "select":
        this.addSelect();
        break;
      case "delete":
        this.deleteFeature();
      case "Point":
        this.commonDraw.addDraw(t, this.layer, this.geoStyleName);
      case "LineString":
        this.commonDraw.addDraw(t, this.layer, this.geoStyleName);
      case "Polygon":
        this.commonDraw.addDraw(t, this.layer, this.geoStyleName);
        break;
    }
  }
  /**
   * 激活模型
   * 清空之前的激活的操作，并根据传入的模型类型激活相应的操作
   * 如果传入的模型类型为 "modify"、"transform"、"select"、"delete" 之一，则会清空之前的操作
   * 如果传入的模型类型为 "Point"、"LineString"、"Polygon" 之一，则会根据传入的模型类型和样式名称执行绘制操作
   *
   * @param {string} type - 模型类型，可以为 "modify"、"transform"、"select"、"delete"、"Point"、"LineString"、"Polygon" 之一
   * @param {string} geoName - 样式名称，当传入的模型类型为 "Point"、"LineString"、"Polygon" 时必须传入样式名称
   */
  activePointModel(t, e) {
    this.activeModelClean(), this.geoStyleName = e, this.commonDraw.addDraw(t, this.layer, this.geoStyleName);
  }
  /**
   * 删除特征
   * 如果选中的特征为空，则提示选中的feature为空
   * 否则从图层中移除选中的特征，并将选中的特征设置为null
   */
  deleteFeature() {
    this.featureSelect == null ? alert("选中的feature为空") : (this.layer.getSource().removeFeature(this.featureSelect), this.featureSelect = null);
  }
  /*
   * 清除所有的交互事件，用于清除之前的绘制
   */
  cleanIneractions() {
    this.resetInteractions();
    let t = this.map.getInteractions().getArray(), e = t.length;
    for (let n = e - 1; n >= 0; n--)
      t[n].getProperties().interactionType && t[n].getProperties().interactionType.includes("CME_") && this.map.removeInteraction(t[n]);
    this.transform = null, this.select = null, this.modify = null, this.undoredo = null, this.copyPaste = null, this.draw = null;
  }
}
function Bk() {
  if (!document.currentScript) return;
  const t = document.currentScript.src.replace(/\/([^\/]+$)/gi, "/style.css");
  document.write(`<link rel="stylesheet" href="${t}"/>`);
}
Bk();
export {
  sB as interactionsControl
};
